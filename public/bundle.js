/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	__webpack_require__(4);
	module.exports = __webpack_require__(6);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(2)(__webpack_require__(3))

/***/ },
/* 2 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	module.exports = function(src) {
		if (typeof execScript === "function")
			execScript(src);
		else
			eval.call(null, src);
	}

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = "\"use strict\";\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*! jQuery v2.2.4 | (c) jQuery Foundation | jquery.org/license */\n!function (a, b) {\n  \"object\" == (typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) && \"object\" == _typeof(module.exports) ? module.exports = a.document ? b(a, !0) : function (a) {\n    if (!a.document) throw new Error(\"jQuery requires a window with a document\");return b(a);\n  } : b(a);\n}(\"undefined\" != typeof window ? window : undefined, function (a, b) {\n  var c = [],\n      d = a.document,\n      e = c.slice,\n      f = c.concat,\n      g = c.push,\n      h = c.indexOf,\n      i = {},\n      j = i.toString,\n      k = i.hasOwnProperty,\n      l = {},\n      m = \"2.2.4\",\n      n = function n(a, b) {\n    return new n.fn.init(a, b);\n  },\n      o = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n      p = /^-ms-/,\n      q = /-([\\da-z])/gi,\n      r = function r(a, b) {\n    return b.toUpperCase();\n  };n.fn = n.prototype = { jquery: m, constructor: n, selector: \"\", length: 0, toArray: function toArray() {\n      return e.call(this);\n    }, get: function get(a) {\n      return null != a ? 0 > a ? this[a + this.length] : this[a] : e.call(this);\n    }, pushStack: function pushStack(a) {\n      var b = n.merge(this.constructor(), a);return b.prevObject = this, b.context = this.context, b;\n    }, each: function each(a) {\n      return n.each(this, a);\n    }, map: function map(a) {\n      return this.pushStack(n.map(this, function (b, c) {\n        return a.call(b, c, b);\n      }));\n    }, slice: function slice() {\n      return this.pushStack(e.apply(this, arguments));\n    }, first: function first() {\n      return this.eq(0);\n    }, last: function last() {\n      return this.eq(-1);\n    }, eq: function eq(a) {\n      var b = this.length,\n          c = +a + (0 > a ? b : 0);return this.pushStack(c >= 0 && b > c ? [this[c]] : []);\n    }, end: function end() {\n      return this.prevObject || this.constructor();\n    }, push: g, sort: c.sort, splice: c.splice }, n.extend = n.fn.extend = function () {\n    var a,\n        b,\n        c,\n        d,\n        e,\n        f,\n        g = arguments[0] || {},\n        h = 1,\n        i = arguments.length,\n        j = !1;for (\"boolean\" == typeof g && (j = g, g = arguments[h] || {}, h++), \"object\" == (typeof g === \"undefined\" ? \"undefined\" : _typeof(g)) || n.isFunction(g) || (g = {}), h === i && (g = this, h--); i > h; h++) {\n      if (null != (a = arguments[h])) for (b in a) {\n        c = g[b], d = a[b], g !== d && (j && d && (n.isPlainObject(d) || (e = n.isArray(d))) ? (e ? (e = !1, f = c && n.isArray(c) ? c : []) : f = c && n.isPlainObject(c) ? c : {}, g[b] = n.extend(j, f, d)) : void 0 !== d && (g[b] = d));\n      }\n    }return g;\n  }, n.extend({ expando: \"jQuery\" + (m + Math.random()).replace(/\\D/g, \"\"), isReady: !0, error: function error(a) {\n      throw new Error(a);\n    }, noop: function noop() {}, isFunction: function isFunction(a) {\n      return \"function\" === n.type(a);\n    }, isArray: Array.isArray, isWindow: function isWindow(a) {\n      return null != a && a === a.window;\n    }, isNumeric: function isNumeric(a) {\n      var b = a && a.toString();return !n.isArray(a) && b - parseFloat(b) + 1 >= 0;\n    }, isPlainObject: function isPlainObject(a) {\n      var b;if (\"object\" !== n.type(a) || a.nodeType || n.isWindow(a)) return !1;if (a.constructor && !k.call(a, \"constructor\") && !k.call(a.constructor.prototype || {}, \"isPrototypeOf\")) return !1;for (b in a) {}return void 0 === b || k.call(a, b);\n    }, isEmptyObject: function isEmptyObject(a) {\n      var b;for (b in a) {\n        return !1;\n      }return !0;\n    }, type: function type(a) {\n      return null == a ? a + \"\" : \"object\" == (typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) || \"function\" == typeof a ? i[j.call(a)] || \"object\" : typeof a === \"undefined\" ? \"undefined\" : _typeof(a);\n    }, globalEval: function globalEval(a) {\n      var b,\n          c = eval;a = n.trim(a), a && (1 === a.indexOf(\"use strict\") ? (b = d.createElement(\"script\"), b.text = a, d.head.appendChild(b).parentNode.removeChild(b)) : c(a));\n    }, camelCase: function camelCase(a) {\n      return a.replace(p, \"ms-\").replace(q, r);\n    }, nodeName: function nodeName(a, b) {\n      return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase();\n    }, each: function each(a, b) {\n      var c,\n          d = 0;if (s(a)) {\n        for (c = a.length; c > d; d++) {\n          if (b.call(a[d], d, a[d]) === !1) break;\n        }\n      } else for (d in a) {\n        if (b.call(a[d], d, a[d]) === !1) break;\n      }return a;\n    }, trim: function trim(a) {\n      return null == a ? \"\" : (a + \"\").replace(o, \"\");\n    }, makeArray: function makeArray(a, b) {\n      var c = b || [];return null != a && (s(Object(a)) ? n.merge(c, \"string\" == typeof a ? [a] : a) : g.call(c, a)), c;\n    }, inArray: function inArray(a, b, c) {\n      return null == b ? -1 : h.call(b, a, c);\n    }, merge: function merge(a, b) {\n      for (var c = +b.length, d = 0, e = a.length; c > d; d++) {\n        a[e++] = b[d];\n      }return a.length = e, a;\n    }, grep: function grep(a, b, c) {\n      for (var d, e = [], f = 0, g = a.length, h = !c; g > f; f++) {\n        d = !b(a[f], f), d !== h && e.push(a[f]);\n      }return e;\n    }, map: function map(a, b, c) {\n      var d,\n          e,\n          g = 0,\n          h = [];if (s(a)) for (d = a.length; d > g; g++) {\n        e = b(a[g], g, c), null != e && h.push(e);\n      } else for (g in a) {\n        e = b(a[g], g, c), null != e && h.push(e);\n      }return f.apply([], h);\n    }, guid: 1, proxy: function proxy(a, b) {\n      var c, d, f;return \"string\" == typeof b && (c = a[b], b = a, a = c), n.isFunction(a) ? (d = e.call(arguments, 2), f = function f() {\n        return a.apply(b || this, d.concat(e.call(arguments)));\n      }, f.guid = a.guid = a.guid || n.guid++, f) : void 0;\n    }, now: Date.now, support: l }), \"function\" == typeof Symbol && (n.fn[Symbol.iterator] = c[Symbol.iterator]), n.each(\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \"), function (a, b) {\n    i[\"[object \" + b + \"]\"] = b.toLowerCase();\n  });function s(a) {\n    var b = !!a && \"length\" in a && a.length,\n        c = n.type(a);return \"function\" === c || n.isWindow(a) ? !1 : \"array\" === c || 0 === b || \"number\" == typeof b && b > 0 && b - 1 in a;\n  }var t = function (a) {\n    var b,\n        c,\n        d,\n        e,\n        f,\n        g,\n        h,\n        i,\n        j,\n        k,\n        l,\n        m,\n        n,\n        o,\n        p,\n        q,\n        r,\n        s,\n        t,\n        u = \"sizzle\" + 1 * new Date(),\n        v = a.document,\n        w = 0,\n        x = 0,\n        y = ga(),\n        z = ga(),\n        A = ga(),\n        B = function B(a, b) {\n      return a === b && (l = !0), 0;\n    },\n        C = 1 << 31,\n        D = {}.hasOwnProperty,\n        E = [],\n        F = E.pop,\n        G = E.push,\n        H = E.push,\n        I = E.slice,\n        J = function J(a, b) {\n      for (var c = 0, d = a.length; d > c; c++) {\n        if (a[c] === b) return c;\n      }return -1;\n    },\n        K = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n        L = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n        M = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n        N = \"\\\\[\" + L + \"*(\" + M + \")(?:\" + L + \"*([*^$|!~]?=)\" + L + \"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + M + \"))|)\" + L + \"*\\\\]\",\n        O = \":(\" + M + \")(?:\\\\((('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + N + \")*)|.*)\\\\)|)\",\n        P = new RegExp(L + \"+\", \"g\"),\n        Q = new RegExp(\"^\" + L + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + L + \"+$\", \"g\"),\n        R = new RegExp(\"^\" + L + \"*,\" + L + \"*\"),\n        S = new RegExp(\"^\" + L + \"*([>+~]|\" + L + \")\" + L + \"*\"),\n        T = new RegExp(\"=\" + L + \"*([^\\\\]'\\\"]*?)\" + L + \"*\\\\]\", \"g\"),\n        U = new RegExp(O),\n        V = new RegExp(\"^\" + M + \"$\"),\n        W = { ID: new RegExp(\"^#(\" + M + \")\"), CLASS: new RegExp(\"^\\\\.(\" + M + \")\"), TAG: new RegExp(\"^(\" + M + \"|[*])\"), ATTR: new RegExp(\"^\" + N), PSEUDO: new RegExp(\"^\" + O), CHILD: new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + L + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + L + \"*(?:([+-]|)\" + L + \"*(\\\\d+)|))\" + L + \"*\\\\)|)\", \"i\"), bool: new RegExp(\"^(?:\" + K + \")$\", \"i\"), needsContext: new RegExp(\"^\" + L + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + L + \"*((?:-\\\\d)?\\\\d*)\" + L + \"*\\\\)|)(?=[^-]|$)\", \"i\") },\n        X = /^(?:input|select|textarea|button)$/i,\n        Y = /^h\\d$/i,\n        Z = /^[^{]+\\{\\s*\\[native \\w/,\n        $ = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n        _ = /[+~]/,\n        aa = /'|\\\\/g,\n        ba = new RegExp(\"\\\\\\\\([\\\\da-f]{1,6}\" + L + \"?|(\" + L + \")|.)\", \"ig\"),\n        ca = function ca(a, b, c) {\n      var d = \"0x\" + b - 65536;return d !== d || c ? b : 0 > d ? String.fromCharCode(d + 65536) : String.fromCharCode(d >> 10 | 55296, 1023 & d | 56320);\n    },\n        da = function da() {\n      m();\n    };try {\n      H.apply(E = I.call(v.childNodes), v.childNodes), E[v.childNodes.length].nodeType;\n    } catch (ea) {\n      H = { apply: E.length ? function (a, b) {\n          G.apply(a, I.call(b));\n        } : function (a, b) {\n          var c = a.length,\n              d = 0;while (a[c++] = b[d++]) {}a.length = c - 1;\n        } };\n    }function fa(a, b, d, e) {\n      var f,\n          h,\n          j,\n          k,\n          l,\n          o,\n          r,\n          s,\n          w = b && b.ownerDocument,\n          x = b ? b.nodeType : 9;if (d = d || [], \"string\" != typeof a || !a || 1 !== x && 9 !== x && 11 !== x) return d;if (!e && ((b ? b.ownerDocument || b : v) !== n && m(b), b = b || n, p)) {\n        if (11 !== x && (o = $.exec(a))) if (f = o[1]) {\n          if (9 === x) {\n            if (!(j = b.getElementById(f))) return d;if (j.id === f) return d.push(j), d;\n          } else if (w && (j = w.getElementById(f)) && t(b, j) && j.id === f) return d.push(j), d;\n        } else {\n          if (o[2]) return H.apply(d, b.getElementsByTagName(a)), d;if ((f = o[3]) && c.getElementsByClassName && b.getElementsByClassName) return H.apply(d, b.getElementsByClassName(f)), d;\n        }if (c.qsa && !A[a + \" \"] && (!q || !q.test(a))) {\n          if (1 !== x) w = b, s = a;else if (\"object\" !== b.nodeName.toLowerCase()) {\n            (k = b.getAttribute(\"id\")) ? k = k.replace(aa, \"\\\\$&\") : b.setAttribute(\"id\", k = u), r = g(a), h = r.length, l = V.test(k) ? \"#\" + k : \"[id='\" + k + \"']\";while (h--) {\n              r[h] = l + \" \" + qa(r[h]);\n            }s = r.join(\",\"), w = _.test(a) && oa(b.parentNode) || b;\n          }if (s) try {\n            return H.apply(d, w.querySelectorAll(s)), d;\n          } catch (y) {} finally {\n            k === u && b.removeAttribute(\"id\");\n          }\n        }\n      }return i(a.replace(Q, \"$1\"), b, d, e);\n    }function ga() {\n      var a = [];function b(c, e) {\n        return a.push(c + \" \") > d.cacheLength && delete b[a.shift()], b[c + \" \"] = e;\n      }return b;\n    }function ha(a) {\n      return a[u] = !0, a;\n    }function ia(a) {\n      var b = n.createElement(\"div\");try {\n        return !!a(b);\n      } catch (c) {\n        return !1;\n      } finally {\n        b.parentNode && b.parentNode.removeChild(b), b = null;\n      }\n    }function ja(a, b) {\n      var c = a.split(\"|\"),\n          e = c.length;while (e--) {\n        d.attrHandle[c[e]] = b;\n      }\n    }function ka(a, b) {\n      var c = b && a,\n          d = c && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || C) - (~a.sourceIndex || C);if (d) return d;if (c) while (c = c.nextSibling) {\n        if (c === b) return -1;\n      }return a ? 1 : -1;\n    }function la(a) {\n      return function (b) {\n        var c = b.nodeName.toLowerCase();return \"input\" === c && b.type === a;\n      };\n    }function ma(a) {\n      return function (b) {\n        var c = b.nodeName.toLowerCase();return (\"input\" === c || \"button\" === c) && b.type === a;\n      };\n    }function na(a) {\n      return ha(function (b) {\n        return b = +b, ha(function (c, d) {\n          var e,\n              f = a([], c.length, b),\n              g = f.length;while (g--) {\n            c[e = f[g]] && (c[e] = !(d[e] = c[e]));\n          }\n        });\n      });\n    }function oa(a) {\n      return a && \"undefined\" != typeof a.getElementsByTagName && a;\n    }c = fa.support = {}, f = fa.isXML = function (a) {\n      var b = a && (a.ownerDocument || a).documentElement;return b ? \"HTML\" !== b.nodeName : !1;\n    }, m = fa.setDocument = function (a) {\n      var b,\n          e,\n          g = a ? a.ownerDocument || a : v;return g !== n && 9 === g.nodeType && g.documentElement ? (n = g, o = n.documentElement, p = !f(n), (e = n.defaultView) && e.top !== e && (e.addEventListener ? e.addEventListener(\"unload\", da, !1) : e.attachEvent && e.attachEvent(\"onunload\", da)), c.attributes = ia(function (a) {\n        return a.className = \"i\", !a.getAttribute(\"className\");\n      }), c.getElementsByTagName = ia(function (a) {\n        return a.appendChild(n.createComment(\"\")), !a.getElementsByTagName(\"*\").length;\n      }), c.getElementsByClassName = Z.test(n.getElementsByClassName), c.getById = ia(function (a) {\n        return o.appendChild(a).id = u, !n.getElementsByName || !n.getElementsByName(u).length;\n      }), c.getById ? (d.find.ID = function (a, b) {\n        if (\"undefined\" != typeof b.getElementById && p) {\n          var c = b.getElementById(a);return c ? [c] : [];\n        }\n      }, d.filter.ID = function (a) {\n        var b = a.replace(ba, ca);return function (a) {\n          return a.getAttribute(\"id\") === b;\n        };\n      }) : (delete d.find.ID, d.filter.ID = function (a) {\n        var b = a.replace(ba, ca);return function (a) {\n          var c = \"undefined\" != typeof a.getAttributeNode && a.getAttributeNode(\"id\");return c && c.value === b;\n        };\n      }), d.find.TAG = c.getElementsByTagName ? function (a, b) {\n        return \"undefined\" != typeof b.getElementsByTagName ? b.getElementsByTagName(a) : c.qsa ? b.querySelectorAll(a) : void 0;\n      } : function (a, b) {\n        var c,\n            d = [],\n            e = 0,\n            f = b.getElementsByTagName(a);if (\"*\" === a) {\n          while (c = f[e++]) {\n            1 === c.nodeType && d.push(c);\n          }return d;\n        }return f;\n      }, d.find.CLASS = c.getElementsByClassName && function (a, b) {\n        return \"undefined\" != typeof b.getElementsByClassName && p ? b.getElementsByClassName(a) : void 0;\n      }, r = [], q = [], (c.qsa = Z.test(n.querySelectorAll)) && (ia(function (a) {\n        o.appendChild(a).innerHTML = \"<a id='\" + u + \"'></a><select id='\" + u + \"-\\r\\\\' msallowcapture=''><option selected=''></option></select>\", a.querySelectorAll(\"[msallowcapture^='']\").length && q.push(\"[*^$]=\" + L + \"*(?:''|\\\"\\\")\"), a.querySelectorAll(\"[selected]\").length || q.push(\"\\\\[\" + L + \"*(?:value|\" + K + \")\"), a.querySelectorAll(\"[id~=\" + u + \"-]\").length || q.push(\"~=\"), a.querySelectorAll(\":checked\").length || q.push(\":checked\"), a.querySelectorAll(\"a#\" + u + \"+*\").length || q.push(\".#.+[+~]\");\n      }), ia(function (a) {\n        var b = n.createElement(\"input\");b.setAttribute(\"type\", \"hidden\"), a.appendChild(b).setAttribute(\"name\", \"D\"), a.querySelectorAll(\"[name=d]\").length && q.push(\"name\" + L + \"*[*^$|!~]?=\"), a.querySelectorAll(\":enabled\").length || q.push(\":enabled\", \":disabled\"), a.querySelectorAll(\"*,:x\"), q.push(\",.*:\");\n      })), (c.matchesSelector = Z.test(s = o.matches || o.webkitMatchesSelector || o.mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector)) && ia(function (a) {\n        c.disconnectedMatch = s.call(a, \"div\"), s.call(a, \"[s!='']:x\"), r.push(\"!=\", O);\n      }), q = q.length && new RegExp(q.join(\"|\")), r = r.length && new RegExp(r.join(\"|\")), b = Z.test(o.compareDocumentPosition), t = b || Z.test(o.contains) ? function (a, b) {\n        var c = 9 === a.nodeType ? a.documentElement : a,\n            d = b && b.parentNode;return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(d)));\n      } : function (a, b) {\n        if (b) while (b = b.parentNode) {\n          if (b === a) return !0;\n        }return !1;\n      }, B = b ? function (a, b) {\n        if (a === b) return l = !0, 0;var d = !a.compareDocumentPosition - !b.compareDocumentPosition;return d ? d : (d = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 1 & d || !c.sortDetached && b.compareDocumentPosition(a) === d ? a === n || a.ownerDocument === v && t(v, a) ? -1 : b === n || b.ownerDocument === v && t(v, b) ? 1 : k ? J(k, a) - J(k, b) : 0 : 4 & d ? -1 : 1);\n      } : function (a, b) {\n        if (a === b) return l = !0, 0;var c,\n            d = 0,\n            e = a.parentNode,\n            f = b.parentNode,\n            g = [a],\n            h = [b];if (!e || !f) return a === n ? -1 : b === n ? 1 : e ? -1 : f ? 1 : k ? J(k, a) - J(k, b) : 0;if (e === f) return ka(a, b);c = a;while (c = c.parentNode) {\n          g.unshift(c);\n        }c = b;while (c = c.parentNode) {\n          h.unshift(c);\n        }while (g[d] === h[d]) {\n          d++;\n        }return d ? ka(g[d], h[d]) : g[d] === v ? -1 : h[d] === v ? 1 : 0;\n      }, n) : n;\n    }, fa.matches = function (a, b) {\n      return fa(a, null, null, b);\n    }, fa.matchesSelector = function (a, b) {\n      if ((a.ownerDocument || a) !== n && m(a), b = b.replace(T, \"='$1']\"), c.matchesSelector && p && !A[b + \" \"] && (!r || !r.test(b)) && (!q || !q.test(b))) try {\n        var d = s.call(a, b);if (d || c.disconnectedMatch || a.document && 11 !== a.document.nodeType) return d;\n      } catch (e) {}return fa(b, n, null, [a]).length > 0;\n    }, fa.contains = function (a, b) {\n      return (a.ownerDocument || a) !== n && m(a), t(a, b);\n    }, fa.attr = function (a, b) {\n      (a.ownerDocument || a) !== n && m(a);var e = d.attrHandle[b.toLowerCase()],\n          f = e && D.call(d.attrHandle, b.toLowerCase()) ? e(a, b, !p) : void 0;return void 0 !== f ? f : c.attributes || !p ? a.getAttribute(b) : (f = a.getAttributeNode(b)) && f.specified ? f.value : null;\n    }, fa.error = function (a) {\n      throw new Error(\"Syntax error, unrecognized expression: \" + a);\n    }, fa.uniqueSort = function (a) {\n      var b,\n          d = [],\n          e = 0,\n          f = 0;if (l = !c.detectDuplicates, k = !c.sortStable && a.slice(0), a.sort(B), l) {\n        while (b = a[f++]) {\n          b === a[f] && (e = d.push(f));\n        }while (e--) {\n          a.splice(d[e], 1);\n        }\n      }return k = null, a;\n    }, e = fa.getText = function (a) {\n      var b,\n          c = \"\",\n          d = 0,\n          f = a.nodeType;if (f) {\n        if (1 === f || 9 === f || 11 === f) {\n          if (\"string\" == typeof a.textContent) return a.textContent;for (a = a.firstChild; a; a = a.nextSibling) {\n            c += e(a);\n          }\n        } else if (3 === f || 4 === f) return a.nodeValue;\n      } else while (b = a[d++]) {\n        c += e(b);\n      }return c;\n    }, d = fa.selectors = { cacheLength: 50, createPseudo: ha, match: W, attrHandle: {}, find: {}, relative: { \">\": { dir: \"parentNode\", first: !0 }, \" \": { dir: \"parentNode\" }, \"+\": { dir: \"previousSibling\", first: !0 }, \"~\": { dir: \"previousSibling\" } }, preFilter: { ATTR: function ATTR(a) {\n          return a[1] = a[1].replace(ba, ca), a[3] = (a[3] || a[4] || a[5] || \"\").replace(ba, ca), \"~=\" === a[2] && (a[3] = \" \" + a[3] + \" \"), a.slice(0, 4);\n        }, CHILD: function CHILD(a) {\n          return a[1] = a[1].toLowerCase(), \"nth\" === a[1].slice(0, 3) ? (a[3] || fa.error(a[0]), a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * (\"even\" === a[3] || \"odd\" === a[3])), a[5] = +(a[7] + a[8] || \"odd\" === a[3])) : a[3] && fa.error(a[0]), a;\n        }, PSEUDO: function PSEUDO(a) {\n          var b,\n              c = !a[6] && a[2];return W.CHILD.test(a[0]) ? null : (a[3] ? a[2] = a[4] || a[5] || \"\" : c && U.test(c) && (b = g(c, !0)) && (b = c.indexOf(\")\", c.length - b) - c.length) && (a[0] = a[0].slice(0, b), a[2] = c.slice(0, b)), a.slice(0, 3));\n        } }, filter: { TAG: function TAG(a) {\n          var b = a.replace(ba, ca).toLowerCase();return \"*\" === a ? function () {\n            return !0;\n          } : function (a) {\n            return a.nodeName && a.nodeName.toLowerCase() === b;\n          };\n        }, CLASS: function CLASS(a) {\n          var b = y[a + \" \"];return b || (b = new RegExp(\"(^|\" + L + \")\" + a + \"(\" + L + \"|$)\")) && y(a, function (a) {\n            return b.test(\"string\" == typeof a.className && a.className || \"undefined\" != typeof a.getAttribute && a.getAttribute(\"class\") || \"\");\n          });\n        }, ATTR: function ATTR(a, b, c) {\n          return function (d) {\n            var e = fa.attr(d, a);return null == e ? \"!=\" === b : b ? (e += \"\", \"=\" === b ? e === c : \"!=\" === b ? e !== c : \"^=\" === b ? c && 0 === e.indexOf(c) : \"*=\" === b ? c && e.indexOf(c) > -1 : \"$=\" === b ? c && e.slice(-c.length) === c : \"~=\" === b ? (\" \" + e.replace(P, \" \") + \" \").indexOf(c) > -1 : \"|=\" === b ? e === c || e.slice(0, c.length + 1) === c + \"-\" : !1) : !0;\n          };\n        }, CHILD: function CHILD(a, b, c, d, e) {\n          var f = \"nth\" !== a.slice(0, 3),\n              g = \"last\" !== a.slice(-4),\n              h = \"of-type\" === b;return 1 === d && 0 === e ? function (a) {\n            return !!a.parentNode;\n          } : function (b, c, i) {\n            var j,\n                k,\n                l,\n                m,\n                n,\n                o,\n                p = f !== g ? \"nextSibling\" : \"previousSibling\",\n                q = b.parentNode,\n                r = h && b.nodeName.toLowerCase(),\n                s = !i && !h,\n                t = !1;if (q) {\n              if (f) {\n                while (p) {\n                  m = b;while (m = m[p]) {\n                    if (h ? m.nodeName.toLowerCase() === r : 1 === m.nodeType) return !1;\n                  }o = p = \"only\" === a && !o && \"nextSibling\";\n                }return !0;\n              }if (o = [g ? q.firstChild : q.lastChild], g && s) {\n                m = q, l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), j = k[a] || [], n = j[0] === w && j[1], t = n && j[2], m = n && q.childNodes[n];while (m = ++n && m && m[p] || (t = n = 0) || o.pop()) {\n                  if (1 === m.nodeType && ++t && m === b) {\n                    k[a] = [w, n, t];break;\n                  }\n                }\n              } else if (s && (m = b, l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), j = k[a] || [], n = j[0] === w && j[1], t = n), t === !1) while (m = ++n && m && m[p] || (t = n = 0) || o.pop()) {\n                if ((h ? m.nodeName.toLowerCase() === r : 1 === m.nodeType) && ++t && (s && (l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), k[a] = [w, t]), m === b)) break;\n              }return t -= e, t === d || t % d === 0 && t / d >= 0;\n            }\n          };\n        }, PSEUDO: function PSEUDO(a, b) {\n          var c,\n              e = d.pseudos[a] || d.setFilters[a.toLowerCase()] || fa.error(\"unsupported pseudo: \" + a);return e[u] ? e(b) : e.length > 1 ? (c = [a, a, \"\", b], d.setFilters.hasOwnProperty(a.toLowerCase()) ? ha(function (a, c) {\n            var d,\n                f = e(a, b),\n                g = f.length;while (g--) {\n              d = J(a, f[g]), a[d] = !(c[d] = f[g]);\n            }\n          }) : function (a) {\n            return e(a, 0, c);\n          }) : e;\n        } }, pseudos: { not: ha(function (a) {\n          var b = [],\n              c = [],\n              d = h(a.replace(Q, \"$1\"));return d[u] ? ha(function (a, b, c, e) {\n            var f,\n                g = d(a, null, e, []),\n                h = a.length;while (h--) {\n              (f = g[h]) && (a[h] = !(b[h] = f));\n            }\n          }) : function (a, e, f) {\n            return b[0] = a, d(b, null, f, c), b[0] = null, !c.pop();\n          };\n        }), has: ha(function (a) {\n          return function (b) {\n            return fa(a, b).length > 0;\n          };\n        }), contains: ha(function (a) {\n          return a = a.replace(ba, ca), function (b) {\n            return (b.textContent || b.innerText || e(b)).indexOf(a) > -1;\n          };\n        }), lang: ha(function (a) {\n          return V.test(a || \"\") || fa.error(\"unsupported lang: \" + a), a = a.replace(ba, ca).toLowerCase(), function (b) {\n            var c;do {\n              if (c = p ? b.lang : b.getAttribute(\"xml:lang\") || b.getAttribute(\"lang\")) return c = c.toLowerCase(), c === a || 0 === c.indexOf(a + \"-\");\n            } while ((b = b.parentNode) && 1 === b.nodeType);return !1;\n          };\n        }), target: function target(b) {\n          var c = a.location && a.location.hash;return c && c.slice(1) === b.id;\n        }, root: function root(a) {\n          return a === o;\n        }, focus: function focus(a) {\n          return a === n.activeElement && (!n.hasFocus || n.hasFocus()) && !!(a.type || a.href || ~a.tabIndex);\n        }, enabled: function enabled(a) {\n          return a.disabled === !1;\n        }, disabled: function disabled(a) {\n          return a.disabled === !0;\n        }, checked: function checked(a) {\n          var b = a.nodeName.toLowerCase();return \"input\" === b && !!a.checked || \"option\" === b && !!a.selected;\n        }, selected: function selected(a) {\n          return a.parentNode && a.parentNode.selectedIndex, a.selected === !0;\n        }, empty: function empty(a) {\n          for (a = a.firstChild; a; a = a.nextSibling) {\n            if (a.nodeType < 6) return !1;\n          }return !0;\n        }, parent: function parent(a) {\n          return !d.pseudos.empty(a);\n        }, header: function header(a) {\n          return Y.test(a.nodeName);\n        }, input: function input(a) {\n          return X.test(a.nodeName);\n        }, button: function button(a) {\n          var b = a.nodeName.toLowerCase();return \"input\" === b && \"button\" === a.type || \"button\" === b;\n        }, text: function text(a) {\n          var b;return \"input\" === a.nodeName.toLowerCase() && \"text\" === a.type && (null == (b = a.getAttribute(\"type\")) || \"text\" === b.toLowerCase());\n        }, first: na(function () {\n          return [0];\n        }), last: na(function (a, b) {\n          return [b - 1];\n        }), eq: na(function (a, b, c) {\n          return [0 > c ? c + b : c];\n        }), even: na(function (a, b) {\n          for (var c = 0; b > c; c += 2) {\n            a.push(c);\n          }return a;\n        }), odd: na(function (a, b) {\n          for (var c = 1; b > c; c += 2) {\n            a.push(c);\n          }return a;\n        }), lt: na(function (a, b, c) {\n          for (var d = 0 > c ? c + b : c; --d >= 0;) {\n            a.push(d);\n          }return a;\n        }), gt: na(function (a, b, c) {\n          for (var d = 0 > c ? c + b : c; ++d < b;) {\n            a.push(d);\n          }return a;\n        }) } }, d.pseudos.nth = d.pseudos.eq;for (b in { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 }) {\n      d.pseudos[b] = la(b);\n    }for (b in { submit: !0, reset: !0 }) {\n      d.pseudos[b] = ma(b);\n    }function pa() {}pa.prototype = d.filters = d.pseudos, d.setFilters = new pa(), g = fa.tokenize = function (a, b) {\n      var c,\n          e,\n          f,\n          g,\n          h,\n          i,\n          j,\n          k = z[a + \" \"];if (k) return b ? 0 : k.slice(0);h = a, i = [], j = d.preFilter;while (h) {\n        c && !(e = R.exec(h)) || (e && (h = h.slice(e[0].length) || h), i.push(f = [])), c = !1, (e = S.exec(h)) && (c = e.shift(), f.push({ value: c, type: e[0].replace(Q, \" \") }), h = h.slice(c.length));for (g in d.filter) {\n          !(e = W[g].exec(h)) || j[g] && !(e = j[g](e)) || (c = e.shift(), f.push({ value: c, type: g, matches: e }), h = h.slice(c.length));\n        }if (!c) break;\n      }return b ? h.length : h ? fa.error(a) : z(a, i).slice(0);\n    };function qa(a) {\n      for (var b = 0, c = a.length, d = \"\"; c > b; b++) {\n        d += a[b].value;\n      }return d;\n    }function ra(a, b, c) {\n      var d = b.dir,\n          e = c && \"parentNode\" === d,\n          f = x++;return b.first ? function (b, c, f) {\n        while (b = b[d]) {\n          if (1 === b.nodeType || e) return a(b, c, f);\n        }\n      } : function (b, c, g) {\n        var h,\n            i,\n            j,\n            k = [w, f];if (g) {\n          while (b = b[d]) {\n            if ((1 === b.nodeType || e) && a(b, c, g)) return !0;\n          }\n        } else while (b = b[d]) {\n          if (1 === b.nodeType || e) {\n            if (j = b[u] || (b[u] = {}), i = j[b.uniqueID] || (j[b.uniqueID] = {}), (h = i[d]) && h[0] === w && h[1] === f) return k[2] = h[2];if (i[d] = k, k[2] = a(b, c, g)) return !0;\n          }\n        }\n      };\n    }function sa(a) {\n      return a.length > 1 ? function (b, c, d) {\n        var e = a.length;while (e--) {\n          if (!a[e](b, c, d)) return !1;\n        }return !0;\n      } : a[0];\n    }function ta(a, b, c) {\n      for (var d = 0, e = b.length; e > d; d++) {\n        fa(a, b[d], c);\n      }return c;\n    }function ua(a, b, c, d, e) {\n      for (var f, g = [], h = 0, i = a.length, j = null != b; i > h; h++) {\n        (f = a[h]) && (c && !c(f, d, e) || (g.push(f), j && b.push(h)));\n      }return g;\n    }function va(a, b, c, d, e, f) {\n      return d && !d[u] && (d = va(d)), e && !e[u] && (e = va(e, f)), ha(function (f, g, h, i) {\n        var j,\n            k,\n            l,\n            m = [],\n            n = [],\n            o = g.length,\n            p = f || ta(b || \"*\", h.nodeType ? [h] : h, []),\n            q = !a || !f && b ? p : ua(p, m, a, h, i),\n            r = c ? e || (f ? a : o || d) ? [] : g : q;if (c && c(q, r, h, i), d) {\n          j = ua(r, n), d(j, [], h, i), k = j.length;while (k--) {\n            (l = j[k]) && (r[n[k]] = !(q[n[k]] = l));\n          }\n        }if (f) {\n          if (e || a) {\n            if (e) {\n              j = [], k = r.length;while (k--) {\n                (l = r[k]) && j.push(q[k] = l);\n              }e(null, r = [], j, i);\n            }k = r.length;while (k--) {\n              (l = r[k]) && (j = e ? J(f, l) : m[k]) > -1 && (f[j] = !(g[j] = l));\n            }\n          }\n        } else r = ua(r === g ? r.splice(o, r.length) : r), e ? e(null, g, r, i) : H.apply(g, r);\n      });\n    }function wa(a) {\n      for (var b, c, e, f = a.length, g = d.relative[a[0].type], h = g || d.relative[\" \"], i = g ? 1 : 0, k = ra(function (a) {\n        return a === b;\n      }, h, !0), l = ra(function (a) {\n        return J(b, a) > -1;\n      }, h, !0), m = [function (a, c, d) {\n        var e = !g && (d || c !== j) || ((b = c).nodeType ? k(a, c, d) : l(a, c, d));return b = null, e;\n      }]; f > i; i++) {\n        if (c = d.relative[a[i].type]) m = [ra(sa(m), c)];else {\n          if (c = d.filter[a[i].type].apply(null, a[i].matches), c[u]) {\n            for (e = ++i; f > e; e++) {\n              if (d.relative[a[e].type]) break;\n            }return va(i > 1 && sa(m), i > 1 && qa(a.slice(0, i - 1).concat({ value: \" \" === a[i - 2].type ? \"*\" : \"\" })).replace(Q, \"$1\"), c, e > i && wa(a.slice(i, e)), f > e && wa(a = a.slice(e)), f > e && qa(a));\n          }m.push(c);\n        }\n      }return sa(m);\n    }function xa(a, b) {\n      var c = b.length > 0,\n          e = a.length > 0,\n          f = function f(_f, g, h, i, k) {\n        var l,\n            o,\n            q,\n            r = 0,\n            s = \"0\",\n            t = _f && [],\n            u = [],\n            v = j,\n            x = _f || e && d.find.TAG(\"*\", k),\n            y = w += null == v ? 1 : Math.random() || .1,\n            z = x.length;for (k && (j = g === n || g || k); s !== z && null != (l = x[s]); s++) {\n          if (e && l) {\n            o = 0, g || l.ownerDocument === n || (m(l), h = !p);while (q = a[o++]) {\n              if (q(l, g || n, h)) {\n                i.push(l);break;\n              }\n            }k && (w = y);\n          }c && ((l = !q && l) && r--, _f && t.push(l));\n        }if (r += s, c && s !== r) {\n          o = 0;while (q = b[o++]) {\n            q(t, u, g, h);\n          }if (_f) {\n            if (r > 0) while (s--) {\n              t[s] || u[s] || (u[s] = F.call(i));\n            }u = ua(u);\n          }H.apply(i, u), k && !_f && u.length > 0 && r + b.length > 1 && fa.uniqueSort(i);\n        }return k && (w = y, j = v), t;\n      };return c ? ha(f) : f;\n    }return h = fa.compile = function (a, b) {\n      var c,\n          d = [],\n          e = [],\n          f = A[a + \" \"];if (!f) {\n        b || (b = g(a)), c = b.length;while (c--) {\n          f = wa(b[c]), f[u] ? d.push(f) : e.push(f);\n        }f = A(a, xa(e, d)), f.selector = a;\n      }return f;\n    }, i = fa.select = function (a, b, e, f) {\n      var i,\n          j,\n          k,\n          l,\n          m,\n          n = \"function\" == typeof a && a,\n          o = !f && g(a = n.selector || a);if (e = e || [], 1 === o.length) {\n        if (j = o[0] = o[0].slice(0), j.length > 2 && \"ID\" === (k = j[0]).type && c.getById && 9 === b.nodeType && p && d.relative[j[1].type]) {\n          if (b = (d.find.ID(k.matches[0].replace(ba, ca), b) || [])[0], !b) return e;n && (b = b.parentNode), a = a.slice(j.shift().value.length);\n        }i = W.needsContext.test(a) ? 0 : j.length;while (i--) {\n          if (k = j[i], d.relative[l = k.type]) break;if ((m = d.find[l]) && (f = m(k.matches[0].replace(ba, ca), _.test(j[0].type) && oa(b.parentNode) || b))) {\n            if (j.splice(i, 1), a = f.length && qa(j), !a) return H.apply(e, f), e;break;\n          }\n        }\n      }return (n || h(a, o))(f, b, !p, e, !b || _.test(a) && oa(b.parentNode) || b), e;\n    }, c.sortStable = u.split(\"\").sort(B).join(\"\") === u, c.detectDuplicates = !!l, m(), c.sortDetached = ia(function (a) {\n      return 1 & a.compareDocumentPosition(n.createElement(\"div\"));\n    }), ia(function (a) {\n      return a.innerHTML = \"<a href='#'></a>\", \"#\" === a.firstChild.getAttribute(\"href\");\n    }) || ja(\"type|href|height|width\", function (a, b, c) {\n      return c ? void 0 : a.getAttribute(b, \"type\" === b.toLowerCase() ? 1 : 2);\n    }), c.attributes && ia(function (a) {\n      return a.innerHTML = \"<input/>\", a.firstChild.setAttribute(\"value\", \"\"), \"\" === a.firstChild.getAttribute(\"value\");\n    }) || ja(\"value\", function (a, b, c) {\n      return c || \"input\" !== a.nodeName.toLowerCase() ? void 0 : a.defaultValue;\n    }), ia(function (a) {\n      return null == a.getAttribute(\"disabled\");\n    }) || ja(K, function (a, b, c) {\n      var d;return c ? void 0 : a[b] === !0 ? b.toLowerCase() : (d = a.getAttributeNode(b)) && d.specified ? d.value : null;\n    }), fa;\n  }(a);n.find = t, n.expr = t.selectors, n.expr[\":\"] = n.expr.pseudos, n.uniqueSort = n.unique = t.uniqueSort, n.text = t.getText, n.isXMLDoc = t.isXML, n.contains = t.contains;var u = function u(a, b, c) {\n    var d = [],\n        e = void 0 !== c;while ((a = a[b]) && 9 !== a.nodeType) {\n      if (1 === a.nodeType) {\n        if (e && n(a).is(c)) break;d.push(a);\n      }\n    }return d;\n  },\n      v = function v(a, b) {\n    for (var c = []; a; a = a.nextSibling) {\n      1 === a.nodeType && a !== b && c.push(a);\n    }return c;\n  },\n      w = n.expr.match.needsContext,\n      x = /^<([\\w-]+)\\s*\\/?>(?:<\\/\\1>|)$/,\n      y = /^.[^:#\\[\\.,]*$/;function z(a, b, c) {\n    if (n.isFunction(b)) return n.grep(a, function (a, d) {\n      return !!b.call(a, d, a) !== c;\n    });if (b.nodeType) return n.grep(a, function (a) {\n      return a === b !== c;\n    });if (\"string\" == typeof b) {\n      if (y.test(b)) return n.filter(b, a, c);b = n.filter(b, a);\n    }return n.grep(a, function (a) {\n      return h.call(b, a) > -1 !== c;\n    });\n  }n.filter = function (a, b, c) {\n    var d = b[0];return c && (a = \":not(\" + a + \")\"), 1 === b.length && 1 === d.nodeType ? n.find.matchesSelector(d, a) ? [d] : [] : n.find.matches(a, n.grep(b, function (a) {\n      return 1 === a.nodeType;\n    }));\n  }, n.fn.extend({ find: function find(a) {\n      var b,\n          c = this.length,\n          d = [],\n          e = this;if (\"string\" != typeof a) return this.pushStack(n(a).filter(function () {\n        for (b = 0; c > b; b++) {\n          if (n.contains(e[b], this)) return !0;\n        }\n      }));for (b = 0; c > b; b++) {\n        n.find(a, e[b], d);\n      }return d = this.pushStack(c > 1 ? n.unique(d) : d), d.selector = this.selector ? this.selector + \" \" + a : a, d;\n    }, filter: function filter(a) {\n      return this.pushStack(z(this, a || [], !1));\n    }, not: function not(a) {\n      return this.pushStack(z(this, a || [], !0));\n    }, is: function is(a) {\n      return !!z(this, \"string\" == typeof a && w.test(a) ? n(a) : a || [], !1).length;\n    } });var A,\n      B = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n      C = n.fn.init = function (a, b, c) {\n    var e, f;if (!a) return this;if (c = c || A, \"string\" == typeof a) {\n      if (e = \"<\" === a[0] && \">\" === a[a.length - 1] && a.length >= 3 ? [null, a, null] : B.exec(a), !e || !e[1] && b) return !b || b.jquery ? (b || c).find(a) : this.constructor(b).find(a);if (e[1]) {\n        if (b = b instanceof n ? b[0] : b, n.merge(this, n.parseHTML(e[1], b && b.nodeType ? b.ownerDocument || b : d, !0)), x.test(e[1]) && n.isPlainObject(b)) for (e in b) {\n          n.isFunction(this[e]) ? this[e](b[e]) : this.attr(e, b[e]);\n        }return this;\n      }return f = d.getElementById(e[2]), f && f.parentNode && (this.length = 1, this[0] = f), this.context = d, this.selector = a, this;\n    }return a.nodeType ? (this.context = this[0] = a, this.length = 1, this) : n.isFunction(a) ? void 0 !== c.ready ? c.ready(a) : a(n) : (void 0 !== a.selector && (this.selector = a.selector, this.context = a.context), n.makeArray(a, this));\n  };C.prototype = n.fn, A = n(d);var D = /^(?:parents|prev(?:Until|All))/,\n      E = { children: !0, contents: !0, next: !0, prev: !0 };n.fn.extend({ has: function has(a) {\n      var b = n(a, this),\n          c = b.length;return this.filter(function () {\n        for (var a = 0; c > a; a++) {\n          if (n.contains(this, b[a])) return !0;\n        }\n      });\n    }, closest: function closest(a, b) {\n      for (var c, d = 0, e = this.length, f = [], g = w.test(a) || \"string\" != typeof a ? n(a, b || this.context) : 0; e > d; d++) {\n        for (c = this[d]; c && c !== b; c = c.parentNode) {\n          if (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && n.find.matchesSelector(c, a))) {\n            f.push(c);break;\n          }\n        }\n      }return this.pushStack(f.length > 1 ? n.uniqueSort(f) : f);\n    }, index: function index(a) {\n      return a ? \"string\" == typeof a ? h.call(n(a), this[0]) : h.call(this, a.jquery ? a[0] : a) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;\n    }, add: function add(a, b) {\n      return this.pushStack(n.uniqueSort(n.merge(this.get(), n(a, b))));\n    }, addBack: function addBack(a) {\n      return this.add(null == a ? this.prevObject : this.prevObject.filter(a));\n    } });function F(a, b) {\n    while ((a = a[b]) && 1 !== a.nodeType) {}return a;\n  }n.each({ parent: function parent(a) {\n      var b = a.parentNode;return b && 11 !== b.nodeType ? b : null;\n    }, parents: function parents(a) {\n      return u(a, \"parentNode\");\n    }, parentsUntil: function parentsUntil(a, b, c) {\n      return u(a, \"parentNode\", c);\n    }, next: function next(a) {\n      return F(a, \"nextSibling\");\n    }, prev: function prev(a) {\n      return F(a, \"previousSibling\");\n    }, nextAll: function nextAll(a) {\n      return u(a, \"nextSibling\");\n    }, prevAll: function prevAll(a) {\n      return u(a, \"previousSibling\");\n    }, nextUntil: function nextUntil(a, b, c) {\n      return u(a, \"nextSibling\", c);\n    }, prevUntil: function prevUntil(a, b, c) {\n      return u(a, \"previousSibling\", c);\n    }, siblings: function siblings(a) {\n      return v((a.parentNode || {}).firstChild, a);\n    }, children: function children(a) {\n      return v(a.firstChild);\n    }, contents: function contents(a) {\n      return a.contentDocument || n.merge([], a.childNodes);\n    } }, function (a, b) {\n    n.fn[a] = function (c, d) {\n      var e = n.map(this, b, c);return \"Until\" !== a.slice(-5) && (d = c), d && \"string\" == typeof d && (e = n.filter(d, e)), this.length > 1 && (E[a] || n.uniqueSort(e), D.test(a) && e.reverse()), this.pushStack(e);\n    };\n  });var G = /\\S+/g;function H(a) {\n    var b = {};return n.each(a.match(G) || [], function (a, c) {\n      b[c] = !0;\n    }), b;\n  }n.Callbacks = function (a) {\n    a = \"string\" == typeof a ? H(a) : n.extend({}, a);var b,\n        c,\n        d,\n        e,\n        f = [],\n        g = [],\n        h = -1,\n        i = function i() {\n      for (e = a.once, d = b = !0; g.length; h = -1) {\n        c = g.shift();while (++h < f.length) {\n          f[h].apply(c[0], c[1]) === !1 && a.stopOnFalse && (h = f.length, c = !1);\n        }\n      }a.memory || (c = !1), b = !1, e && (f = c ? [] : \"\");\n    },\n        j = { add: function add() {\n        return f && (c && !b && (h = f.length - 1, g.push(c)), function d(b) {\n          n.each(b, function (b, c) {\n            n.isFunction(c) ? a.unique && j.has(c) || f.push(c) : c && c.length && \"string\" !== n.type(c) && d(c);\n          });\n        }(arguments), c && !b && i()), this;\n      }, remove: function remove() {\n        return n.each(arguments, function (a, b) {\n          var c;while ((c = n.inArray(b, f, c)) > -1) {\n            f.splice(c, 1), h >= c && h--;\n          }\n        }), this;\n      }, has: function has(a) {\n        return a ? n.inArray(a, f) > -1 : f.length > 0;\n      }, empty: function empty() {\n        return f && (f = []), this;\n      }, disable: function disable() {\n        return e = g = [], f = c = \"\", this;\n      }, disabled: function disabled() {\n        return !f;\n      }, lock: function lock() {\n        return e = g = [], c || (f = c = \"\"), this;\n      }, locked: function locked() {\n        return !!e;\n      }, fireWith: function fireWith(a, c) {\n        return e || (c = c || [], c = [a, c.slice ? c.slice() : c], g.push(c), b || i()), this;\n      }, fire: function fire() {\n        return j.fireWith(this, arguments), this;\n      }, fired: function fired() {\n        return !!d;\n      } };return j;\n  }, n.extend({ Deferred: function Deferred(a) {\n      var b = [[\"resolve\", \"done\", n.Callbacks(\"once memory\"), \"resolved\"], [\"reject\", \"fail\", n.Callbacks(\"once memory\"), \"rejected\"], [\"notify\", \"progress\", n.Callbacks(\"memory\")]],\n          c = \"pending\",\n          d = { state: function state() {\n          return c;\n        }, always: function always() {\n          return e.done(arguments).fail(arguments), this;\n        }, then: function then() {\n          var a = arguments;return n.Deferred(function (c) {\n            n.each(b, function (b, f) {\n              var g = n.isFunction(a[b]) && a[b];e[f[1]](function () {\n                var a = g && g.apply(this, arguments);a && n.isFunction(a.promise) ? a.promise().progress(c.notify).done(c.resolve).fail(c.reject) : c[f[0] + \"With\"](this === d ? c.promise() : this, g ? [a] : arguments);\n              });\n            }), a = null;\n          }).promise();\n        }, promise: function promise(a) {\n          return null != a ? n.extend(a, d) : d;\n        } },\n          e = {};return d.pipe = d.then, n.each(b, function (a, f) {\n        var g = f[2],\n            h = f[3];d[f[1]] = g.add, h && g.add(function () {\n          c = h;\n        }, b[1 ^ a][2].disable, b[2][2].lock), e[f[0]] = function () {\n          return e[f[0] + \"With\"](this === e ? d : this, arguments), this;\n        }, e[f[0] + \"With\"] = g.fireWith;\n      }), d.promise(e), a && a.call(e, e), e;\n    }, when: function when(a) {\n      var b = 0,\n          c = e.call(arguments),\n          d = c.length,\n          f = 1 !== d || a && n.isFunction(a.promise) ? d : 0,\n          g = 1 === f ? a : n.Deferred(),\n          h = function h(a, b, c) {\n        return function (d) {\n          b[a] = this, c[a] = arguments.length > 1 ? e.call(arguments) : d, c === i ? g.notifyWith(b, c) : --f || g.resolveWith(b, c);\n        };\n      },\n          i,\n          j,\n          k;if (d > 1) for (i = new Array(d), j = new Array(d), k = new Array(d); d > b; b++) {\n        c[b] && n.isFunction(c[b].promise) ? c[b].promise().progress(h(b, j, i)).done(h(b, k, c)).fail(g.reject) : --f;\n      }return f || g.resolveWith(k, c), g.promise();\n    } });var I;n.fn.ready = function (a) {\n    return n.ready.promise().done(a), this;\n  }, n.extend({ isReady: !1, readyWait: 1, holdReady: function holdReady(a) {\n      a ? n.readyWait++ : n.ready(!0);\n    }, ready: function ready(a) {\n      (a === !0 ? --n.readyWait : n.isReady) || (n.isReady = !0, a !== !0 && --n.readyWait > 0 || (I.resolveWith(d, [n]), n.fn.triggerHandler && (n(d).triggerHandler(\"ready\"), n(d).off(\"ready\"))));\n    } });function J() {\n    d.removeEventListener(\"DOMContentLoaded\", J), a.removeEventListener(\"load\", J), n.ready();\n  }n.ready.promise = function (b) {\n    return I || (I = n.Deferred(), \"complete\" === d.readyState || \"loading\" !== d.readyState && !d.documentElement.doScroll ? a.setTimeout(n.ready) : (d.addEventListener(\"DOMContentLoaded\", J), a.addEventListener(\"load\", J))), I.promise(b);\n  }, n.ready.promise();var K = function K(a, b, c, d, e, f, g) {\n    var h = 0,\n        i = a.length,\n        j = null == c;if (\"object\" === n.type(c)) {\n      e = !0;for (h in c) {\n        K(a, b, h, c[h], !0, f, g);\n      }\n    } else if (void 0 !== d && (e = !0, n.isFunction(d) || (g = !0), j && (g ? (b.call(a, d), b = null) : (j = b, b = function b(a, _b, c) {\n      return j.call(n(a), c);\n    })), b)) for (; i > h; h++) {\n      b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));\n    }return e ? a : j ? b.call(a) : i ? b(a[0], c) : f;\n  },\n      L = function L(a) {\n    return 1 === a.nodeType || 9 === a.nodeType || !+a.nodeType;\n  };function M() {\n    this.expando = n.expando + M.uid++;\n  }M.uid = 1, M.prototype = { register: function register(a, b) {\n      var c = b || {};return a.nodeType ? a[this.expando] = c : Object.defineProperty(a, this.expando, { value: c, writable: !0, configurable: !0 }), a[this.expando];\n    }, cache: function cache(a) {\n      if (!L(a)) return {};var b = a[this.expando];return b || (b = {}, L(a) && (a.nodeType ? a[this.expando] = b : Object.defineProperty(a, this.expando, { value: b, configurable: !0 }))), b;\n    }, set: function set(a, b, c) {\n      var d,\n          e = this.cache(a);if (\"string\" == typeof b) e[b] = c;else for (d in b) {\n        e[d] = b[d];\n      }return e;\n    }, get: function get(a, b) {\n      return void 0 === b ? this.cache(a) : a[this.expando] && a[this.expando][b];\n    }, access: function access(a, b, c) {\n      var d;return void 0 === b || b && \"string\" == typeof b && void 0 === c ? (d = this.get(a, b), void 0 !== d ? d : this.get(a, n.camelCase(b))) : (this.set(a, b, c), void 0 !== c ? c : b);\n    }, remove: function remove(a, b) {\n      var c,\n          d,\n          e,\n          f = a[this.expando];if (void 0 !== f) {\n        if (void 0 === b) this.register(a);else {\n          n.isArray(b) ? d = b.concat(b.map(n.camelCase)) : (e = n.camelCase(b), b in f ? d = [b, e] : (d = e, d = d in f ? [d] : d.match(G) || [])), c = d.length;while (c--) {\n            delete f[d[c]];\n          }\n        }(void 0 === b || n.isEmptyObject(f)) && (a.nodeType ? a[this.expando] = void 0 : delete a[this.expando]);\n      }\n    }, hasData: function hasData(a) {\n      var b = a[this.expando];return void 0 !== b && !n.isEmptyObject(b);\n    } };var N = new M(),\n      O = new M(),\n      P = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n      Q = /[A-Z]/g;function R(a, b, c) {\n    var d;if (void 0 === c && 1 === a.nodeType) if (d = \"data-\" + b.replace(Q, \"-$&\").toLowerCase(), c = a.getAttribute(d), \"string\" == typeof c) {\n      try {\n        c = \"true\" === c ? !0 : \"false\" === c ? !1 : \"null\" === c ? null : +c + \"\" === c ? +c : P.test(c) ? n.parseJSON(c) : c;\n      } catch (e) {}O.set(a, b, c);\n    } else c = void 0;return c;\n  }n.extend({ hasData: function hasData(a) {\n      return O.hasData(a) || N.hasData(a);\n    }, data: function data(a, b, c) {\n      return O.access(a, b, c);\n    }, removeData: function removeData(a, b) {\n      O.remove(a, b);\n    }, _data: function _data(a, b, c) {\n      return N.access(a, b, c);\n    }, _removeData: function _removeData(a, b) {\n      N.remove(a, b);\n    } }), n.fn.extend({ data: function data(a, b) {\n      var c,\n          d,\n          e,\n          f = this[0],\n          g = f && f.attributes;if (void 0 === a) {\n        if (this.length && (e = O.get(f), 1 === f.nodeType && !N.get(f, \"hasDataAttrs\"))) {\n          c = g.length;while (c--) {\n            g[c] && (d = g[c].name, 0 === d.indexOf(\"data-\") && (d = n.camelCase(d.slice(5)), R(f, d, e[d])));\n          }N.set(f, \"hasDataAttrs\", !0);\n        }return e;\n      }return \"object\" == (typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) ? this.each(function () {\n        O.set(this, a);\n      }) : K(this, function (b) {\n        var c, d;if (f && void 0 === b) {\n          if (c = O.get(f, a) || O.get(f, a.replace(Q, \"-$&\").toLowerCase()), void 0 !== c) return c;if (d = n.camelCase(a), c = O.get(f, d), void 0 !== c) return c;if (c = R(f, d, void 0), void 0 !== c) return c;\n        } else d = n.camelCase(a), this.each(function () {\n          var c = O.get(this, d);O.set(this, d, b), a.indexOf(\"-\") > -1 && void 0 !== c && O.set(this, a, b);\n        });\n      }, null, b, arguments.length > 1, null, !0);\n    }, removeData: function removeData(a) {\n      return this.each(function () {\n        O.remove(this, a);\n      });\n    } }), n.extend({ queue: function queue(a, b, c) {\n      var d;return a ? (b = (b || \"fx\") + \"queue\", d = N.get(a, b), c && (!d || n.isArray(c) ? d = N.access(a, b, n.makeArray(c)) : d.push(c)), d || []) : void 0;\n    }, dequeue: function dequeue(a, b) {\n      b = b || \"fx\";var c = n.queue(a, b),\n          d = c.length,\n          e = c.shift(),\n          f = n._queueHooks(a, b),\n          g = function g() {\n        n.dequeue(a, b);\n      };\"inprogress\" === e && (e = c.shift(), d--), e && (\"fx\" === b && c.unshift(\"inprogress\"), delete f.stop, e.call(a, g, f)), !d && f && f.empty.fire();\n    }, _queueHooks: function _queueHooks(a, b) {\n      var c = b + \"queueHooks\";return N.get(a, c) || N.access(a, c, { empty: n.Callbacks(\"once memory\").add(function () {\n          N.remove(a, [b + \"queue\", c]);\n        }) });\n    } }), n.fn.extend({ queue: function queue(a, b) {\n      var c = 2;return \"string\" != typeof a && (b = a, a = \"fx\", c--), arguments.length < c ? n.queue(this[0], a) : void 0 === b ? this : this.each(function () {\n        var c = n.queue(this, a, b);n._queueHooks(this, a), \"fx\" === a && \"inprogress\" !== c[0] && n.dequeue(this, a);\n      });\n    }, dequeue: function dequeue(a) {\n      return this.each(function () {\n        n.dequeue(this, a);\n      });\n    }, clearQueue: function clearQueue(a) {\n      return this.queue(a || \"fx\", []);\n    }, promise: function promise(a, b) {\n      var c,\n          d = 1,\n          e = n.Deferred(),\n          f = this,\n          g = this.length,\n          h = function h() {\n        --d || e.resolveWith(f, [f]);\n      };\"string\" != typeof a && (b = a, a = void 0), a = a || \"fx\";while (g--) {\n        c = N.get(f[g], a + \"queueHooks\"), c && c.empty && (d++, c.empty.add(h));\n      }return h(), e.promise(b);\n    } });var S = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,\n      T = new RegExp(\"^(?:([+-])=|)(\" + S + \")([a-z%]*)$\", \"i\"),\n      U = [\"Top\", \"Right\", \"Bottom\", \"Left\"],\n      V = function V(a, b) {\n    return a = b || a, \"none\" === n.css(a, \"display\") || !n.contains(a.ownerDocument, a);\n  };function W(a, b, c, d) {\n    var e,\n        f = 1,\n        g = 20,\n        h = d ? function () {\n      return d.cur();\n    } : function () {\n      return n.css(a, b, \"\");\n    },\n        i = h(),\n        j = c && c[3] || (n.cssNumber[b] ? \"\" : \"px\"),\n        k = (n.cssNumber[b] || \"px\" !== j && +i) && T.exec(n.css(a, b));if (k && k[3] !== j) {\n      j = j || k[3], c = c || [], k = +i || 1;do {\n        f = f || \".5\", k /= f, n.style(a, b, k + j);\n      } while (f !== (f = h() / i) && 1 !== f && --g);\n    }return c && (k = +k || +i || 0, e = c[1] ? k + (c[1] + 1) * c[2] : +c[2], d && (d.unit = j, d.start = k, d.end = e)), e;\n  }var X = /^(?:checkbox|radio)$/i,\n      Y = /<([\\w:-]+)/,\n      Z = /^$|\\/(?:java|ecma)script/i,\n      $ = { option: [1, \"<select multiple='multiple'>\", \"</select>\"], thead: [1, \"<table>\", \"</table>\"], col: [2, \"<table><colgroup>\", \"</colgroup></table>\"], tr: [2, \"<table><tbody>\", \"</tbody></table>\"], td: [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"], _default: [0, \"\", \"\"] };$.optgroup = $.option, $.tbody = $.tfoot = $.colgroup = $.caption = $.thead, $.th = $.td;function _(a, b) {\n    var c = \"undefined\" != typeof a.getElementsByTagName ? a.getElementsByTagName(b || \"*\") : \"undefined\" != typeof a.querySelectorAll ? a.querySelectorAll(b || \"*\") : [];return void 0 === b || b && n.nodeName(a, b) ? n.merge([a], c) : c;\n  }function aa(a, b) {\n    for (var c = 0, d = a.length; d > c; c++) {\n      N.set(a[c], \"globalEval\", !b || N.get(b[c], \"globalEval\"));\n    }\n  }var ba = /<|&#?\\w+;/;function ca(a, b, c, d, e) {\n    for (var f, g, h, i, j, k, l = b.createDocumentFragment(), m = [], o = 0, p = a.length; p > o; o++) {\n      if (f = a[o], f || 0 === f) if (\"object\" === n.type(f)) n.merge(m, f.nodeType ? [f] : f);else if (ba.test(f)) {\n        g = g || l.appendChild(b.createElement(\"div\")), h = (Y.exec(f) || [\"\", \"\"])[1].toLowerCase(), i = $[h] || $._default, g.innerHTML = i[1] + n.htmlPrefilter(f) + i[2], k = i[0];while (k--) {\n          g = g.lastChild;\n        }n.merge(m, g.childNodes), g = l.firstChild, g.textContent = \"\";\n      } else m.push(b.createTextNode(f));\n    }l.textContent = \"\", o = 0;while (f = m[o++]) {\n      if (d && n.inArray(f, d) > -1) e && e.push(f);else if (j = n.contains(f.ownerDocument, f), g = _(l.appendChild(f), \"script\"), j && aa(g), c) {\n        k = 0;while (f = g[k++]) {\n          Z.test(f.type || \"\") && c.push(f);\n        }\n      }\n    }return l;\n  }!function () {\n    var a = d.createDocumentFragment(),\n        b = a.appendChild(d.createElement(\"div\")),\n        c = d.createElement(\"input\");c.setAttribute(\"type\", \"radio\"), c.setAttribute(\"checked\", \"checked\"), c.setAttribute(\"name\", \"t\"), b.appendChild(c), l.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, b.innerHTML = \"<textarea>x</textarea>\", l.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue;\n  }();var da = /^key/,\n      ea = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n      fa = /^([^.]*)(?:\\.(.+)|)/;function ga() {\n    return !0;\n  }function ha() {\n    return !1;\n  }function ia() {\n    try {\n      return d.activeElement;\n    } catch (a) {}\n  }function ja(a, b, c, d, e, f) {\n    var g, h;if (\"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b))) {\n      \"string\" != typeof c && (d = d || c, c = void 0);for (h in b) {\n        ja(a, h, c, d, b[h], f);\n      }return a;\n    }if (null == d && null == e ? (e = c, d = c = void 0) : null == e && (\"string\" == typeof c ? (e = d, d = void 0) : (e = d, d = c, c = void 0)), e === !1) e = ha;else if (!e) return a;return 1 === f && (g = e, e = function e(a) {\n      return n().off(a), g.apply(this, arguments);\n    }, e.guid = g.guid || (g.guid = n.guid++)), a.each(function () {\n      n.event.add(this, b, e, d, c);\n    });\n  }n.event = { global: {}, add: function add(a, b, c, d, e) {\n      var f,\n          g,\n          h,\n          i,\n          j,\n          k,\n          l,\n          m,\n          o,\n          p,\n          q,\n          r = N.get(a);if (r) {\n        c.handler && (f = c, c = f.handler, e = f.selector), c.guid || (c.guid = n.guid++), (i = r.events) || (i = r.events = {}), (g = r.handle) || (g = r.handle = function (b) {\n          return \"undefined\" != typeof n && n.event.triggered !== b.type ? n.event.dispatch.apply(a, arguments) : void 0;\n        }), b = (b || \"\").match(G) || [\"\"], j = b.length;while (j--) {\n          h = fa.exec(b[j]) || [], o = q = h[1], p = (h[2] || \"\").split(\".\").sort(), o && (l = n.event.special[o] || {}, o = (e ? l.delegateType : l.bindType) || o, l = n.event.special[o] || {}, k = n.extend({ type: o, origType: q, data: d, handler: c, guid: c.guid, selector: e, needsContext: e && n.expr.match.needsContext.test(e), namespace: p.join(\".\") }, f), (m = i[o]) || (m = i[o] = [], m.delegateCount = 0, l.setup && l.setup.call(a, d, p, g) !== !1 || a.addEventListener && a.addEventListener(o, g)), l.add && (l.add.call(a, k), k.handler.guid || (k.handler.guid = c.guid)), e ? m.splice(m.delegateCount++, 0, k) : m.push(k), n.event.global[o] = !0);\n        }\n      }\n    }, remove: function remove(a, b, c, d, e) {\n      var f,\n          g,\n          h,\n          i,\n          j,\n          k,\n          l,\n          m,\n          o,\n          p,\n          q,\n          r = N.hasData(a) && N.get(a);if (r && (i = r.events)) {\n        b = (b || \"\").match(G) || [\"\"], j = b.length;while (j--) {\n          if (h = fa.exec(b[j]) || [], o = q = h[1], p = (h[2] || \"\").split(\".\").sort(), o) {\n            l = n.event.special[o] || {}, o = (d ? l.delegateType : l.bindType) || o, m = i[o] || [], h = h[2] && new RegExp(\"(^|\\\\.)\" + p.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\"), g = f = m.length;while (f--) {\n              k = m[f], !e && q !== k.origType || c && c.guid !== k.guid || h && !h.test(k.namespace) || d && d !== k.selector && (\"**\" !== d || !k.selector) || (m.splice(f, 1), k.selector && m.delegateCount--, l.remove && l.remove.call(a, k));\n            }g && !m.length && (l.teardown && l.teardown.call(a, p, r.handle) !== !1 || n.removeEvent(a, o, r.handle), delete i[o]);\n          } else for (o in i) {\n            n.event.remove(a, o + b[j], c, d, !0);\n          }\n        }n.isEmptyObject(i) && N.remove(a, \"handle events\");\n      }\n    }, dispatch: function dispatch(a) {\n      a = n.event.fix(a);var b,\n          c,\n          d,\n          f,\n          g,\n          h = [],\n          i = e.call(arguments),\n          j = (N.get(this, \"events\") || {})[a.type] || [],\n          k = n.event.special[a.type] || {};if (i[0] = a, a.delegateTarget = this, !k.preDispatch || k.preDispatch.call(this, a) !== !1) {\n        h = n.event.handlers.call(this, a, j), b = 0;while ((f = h[b++]) && !a.isPropagationStopped()) {\n          a.currentTarget = f.elem, c = 0;while ((g = f.handlers[c++]) && !a.isImmediatePropagationStopped()) {\n            a.rnamespace && !a.rnamespace.test(g.namespace) || (a.handleObj = g, a.data = g.data, d = ((n.event.special[g.origType] || {}).handle || g.handler).apply(f.elem, i), void 0 !== d && (a.result = d) === !1 && (a.preventDefault(), a.stopPropagation()));\n          }\n        }return k.postDispatch && k.postDispatch.call(this, a), a.result;\n      }\n    }, handlers: function handlers(a, b) {\n      var c,\n          d,\n          e,\n          f,\n          g = [],\n          h = b.delegateCount,\n          i = a.target;if (h && i.nodeType && (\"click\" !== a.type || isNaN(a.button) || a.button < 1)) for (; i !== this; i = i.parentNode || this) {\n        if (1 === i.nodeType && (i.disabled !== !0 || \"click\" !== a.type)) {\n          for (d = [], c = 0; h > c; c++) {\n            f = b[c], e = f.selector + \" \", void 0 === d[e] && (d[e] = f.needsContext ? n(e, this).index(i) > -1 : n.find(e, this, null, [i]).length), d[e] && d.push(f);\n          }d.length && g.push({ elem: i, handlers: d });\n        }\n      }return h < b.length && g.push({ elem: this, handlers: b.slice(h) }), g;\n    }, props: \"altKey bubbles cancelable ctrlKey currentTarget detail eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"), fixHooks: {}, keyHooks: { props: \"char charCode key keyCode\".split(\" \"), filter: function filter(a, b) {\n        return null == a.which && (a.which = null != b.charCode ? b.charCode : b.keyCode), a;\n      } }, mouseHooks: { props: \"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"), filter: function filter(a, b) {\n        var c,\n            e,\n            f,\n            g = b.button;return null == a.pageX && null != b.clientX && (c = a.target.ownerDocument || d, e = c.documentElement, f = c.body, a.pageX = b.clientX + (e && e.scrollLeft || f && f.scrollLeft || 0) - (e && e.clientLeft || f && f.clientLeft || 0), a.pageY = b.clientY + (e && e.scrollTop || f && f.scrollTop || 0) - (e && e.clientTop || f && f.clientTop || 0)), a.which || void 0 === g || (a.which = 1 & g ? 1 : 2 & g ? 3 : 4 & g ? 2 : 0), a;\n      } }, fix: function fix(a) {\n      if (a[n.expando]) return a;var b,\n          c,\n          e,\n          f = a.type,\n          g = a,\n          h = this.fixHooks[f];h || (this.fixHooks[f] = h = ea.test(f) ? this.mouseHooks : da.test(f) ? this.keyHooks : {}), e = h.props ? this.props.concat(h.props) : this.props, a = new n.Event(g), b = e.length;while (b--) {\n        c = e[b], a[c] = g[c];\n      }return a.target || (a.target = d), 3 === a.target.nodeType && (a.target = a.target.parentNode), h.filter ? h.filter(a, g) : a;\n    }, special: { load: { noBubble: !0 }, focus: { trigger: function trigger() {\n          return this !== ia() && this.focus ? (this.focus(), !1) : void 0;\n        }, delegateType: \"focusin\" }, blur: { trigger: function trigger() {\n          return this === ia() && this.blur ? (this.blur(), !1) : void 0;\n        }, delegateType: \"focusout\" }, click: { trigger: function trigger() {\n          return \"checkbox\" === this.type && this.click && n.nodeName(this, \"input\") ? (this.click(), !1) : void 0;\n        }, _default: function _default(a) {\n          return n.nodeName(a.target, \"a\");\n        } }, beforeunload: { postDispatch: function postDispatch(a) {\n          void 0 !== a.result && a.originalEvent && (a.originalEvent.returnValue = a.result);\n        } } } }, n.removeEvent = function (a, b, c) {\n    a.removeEventListener && a.removeEventListener(b, c);\n  }, n.Event = function (a, b) {\n    return this instanceof n.Event ? (a && a.type ? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue === !1 ? ga : ha) : this.type = a, b && n.extend(this, b), this.timeStamp = a && a.timeStamp || n.now(), void (this[n.expando] = !0)) : new n.Event(a, b);\n  }, n.Event.prototype = { constructor: n.Event, isDefaultPrevented: ha, isPropagationStopped: ha, isImmediatePropagationStopped: ha, isSimulated: !1, preventDefault: function preventDefault() {\n      var a = this.originalEvent;this.isDefaultPrevented = ga, a && !this.isSimulated && a.preventDefault();\n    }, stopPropagation: function stopPropagation() {\n      var a = this.originalEvent;this.isPropagationStopped = ga, a && !this.isSimulated && a.stopPropagation();\n    }, stopImmediatePropagation: function stopImmediatePropagation() {\n      var a = this.originalEvent;this.isImmediatePropagationStopped = ga, a && !this.isSimulated && a.stopImmediatePropagation(), this.stopPropagation();\n    } }, n.each({ mouseenter: \"mouseover\", mouseleave: \"mouseout\", pointerenter: \"pointerover\", pointerleave: \"pointerout\" }, function (a, b) {\n    n.event.special[a] = { delegateType: b, bindType: b, handle: function handle(a) {\n        var c,\n            d = this,\n            e = a.relatedTarget,\n            f = a.handleObj;return e && (e === d || n.contains(d, e)) || (a.type = f.origType, c = f.handler.apply(this, arguments), a.type = b), c;\n      } };\n  }), n.fn.extend({ on: function on(a, b, c, d) {\n      return ja(this, a, b, c, d);\n    }, one: function one(a, b, c, d) {\n      return ja(this, a, b, c, d, 1);\n    }, off: function off(a, b, c) {\n      var d, e;if (a && a.preventDefault && a.handleObj) return d = a.handleObj, n(a.delegateTarget).off(d.namespace ? d.origType + \".\" + d.namespace : d.origType, d.selector, d.handler), this;if (\"object\" == (typeof a === \"undefined\" ? \"undefined\" : _typeof(a))) {\n        for (e in a) {\n          this.off(e, b, a[e]);\n        }return this;\n      }return b !== !1 && \"function\" != typeof b || (c = b, b = void 0), c === !1 && (c = ha), this.each(function () {\n        n.event.remove(this, a, c, b);\n      });\n    } });var ka = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:-]+)[^>]*)\\/>/gi,\n      la = /<script|<style|<link/i,\n      ma = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n      na = /^true\\/(.*)/,\n      oa = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;function pa(a, b) {\n    return n.nodeName(a, \"table\") && n.nodeName(11 !== b.nodeType ? b : b.firstChild, \"tr\") ? a.getElementsByTagName(\"tbody\")[0] || a.appendChild(a.ownerDocument.createElement(\"tbody\")) : a;\n  }function qa(a) {\n    return a.type = (null !== a.getAttribute(\"type\")) + \"/\" + a.type, a;\n  }function ra(a) {\n    var b = na.exec(a.type);return b ? a.type = b[1] : a.removeAttribute(\"type\"), a;\n  }function sa(a, b) {\n    var c, d, e, f, g, h, i, j;if (1 === b.nodeType) {\n      if (N.hasData(a) && (f = N.access(a), g = N.set(b, f), j = f.events)) {\n        delete g.handle, g.events = {};for (e in j) {\n          for (c = 0, d = j[e].length; d > c; c++) {\n            n.event.add(b, e, j[e][c]);\n          }\n        }\n      }O.hasData(a) && (h = O.access(a), i = n.extend({}, h), O.set(b, i));\n    }\n  }function ta(a, b) {\n    var c = b.nodeName.toLowerCase();\"input\" === c && X.test(a.type) ? b.checked = a.checked : \"input\" !== c && \"textarea\" !== c || (b.defaultValue = a.defaultValue);\n  }function ua(a, b, c, d) {\n    b = f.apply([], b);var e,\n        g,\n        h,\n        i,\n        j,\n        k,\n        m = 0,\n        o = a.length,\n        p = o - 1,\n        q = b[0],\n        r = n.isFunction(q);if (r || o > 1 && \"string\" == typeof q && !l.checkClone && ma.test(q)) return a.each(function (e) {\n      var f = a.eq(e);r && (b[0] = q.call(this, e, f.html())), ua(f, b, c, d);\n    });if (o && (e = ca(b, a[0].ownerDocument, !1, a, d), g = e.firstChild, 1 === e.childNodes.length && (e = g), g || d)) {\n      for (h = n.map(_(e, \"script\"), qa), i = h.length; o > m; m++) {\n        j = e, m !== p && (j = n.clone(j, !0, !0), i && n.merge(h, _(j, \"script\"))), c.call(a[m], j, m);\n      }if (i) for (k = h[h.length - 1].ownerDocument, n.map(h, ra), m = 0; i > m; m++) {\n        j = h[m], Z.test(j.type || \"\") && !N.access(j, \"globalEval\") && n.contains(k, j) && (j.src ? n._evalUrl && n._evalUrl(j.src) : n.globalEval(j.textContent.replace(oa, \"\")));\n      }\n    }return a;\n  }function va(a, b, c) {\n    for (var d, e = b ? n.filter(b, a) : a, f = 0; null != (d = e[f]); f++) {\n      c || 1 !== d.nodeType || n.cleanData(_(d)), d.parentNode && (c && n.contains(d.ownerDocument, d) && aa(_(d, \"script\")), d.parentNode.removeChild(d));\n    }return a;\n  }n.extend({ htmlPrefilter: function htmlPrefilter(a) {\n      return a.replace(ka, \"<$1></$2>\");\n    }, clone: function clone(a, b, c) {\n      var d,\n          e,\n          f,\n          g,\n          h = a.cloneNode(!0),\n          i = n.contains(a.ownerDocument, a);if (!(l.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || n.isXMLDoc(a))) for (g = _(h), f = _(a), d = 0, e = f.length; e > d; d++) {\n        ta(f[d], g[d]);\n      }if (b) if (c) for (f = f || _(a), g = g || _(h), d = 0, e = f.length; e > d; d++) {\n        sa(f[d], g[d]);\n      } else sa(a, h);return g = _(h, \"script\"), g.length > 0 && aa(g, !i && _(a, \"script\")), h;\n    }, cleanData: function cleanData(a) {\n      for (var b, c, d, e = n.event.special, f = 0; void 0 !== (c = a[f]); f++) {\n        if (L(c)) {\n          if (b = c[N.expando]) {\n            if (b.events) for (d in b.events) {\n              e[d] ? n.event.remove(c, d) : n.removeEvent(c, d, b.handle);\n            }c[N.expando] = void 0;\n          }c[O.expando] && (c[O.expando] = void 0);\n        }\n      }\n    } }), n.fn.extend({ domManip: ua, detach: function detach(a) {\n      return va(this, a, !0);\n    }, remove: function remove(a) {\n      return va(this, a);\n    }, text: function text(a) {\n      return K(this, function (a) {\n        return void 0 === a ? n.text(this) : this.empty().each(function () {\n          1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = a);\n        });\n      }, null, a, arguments.length);\n    }, append: function append() {\n      return ua(this, arguments, function (a) {\n        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {\n          var b = pa(this, a);b.appendChild(a);\n        }\n      });\n    }, prepend: function prepend() {\n      return ua(this, arguments, function (a) {\n        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {\n          var b = pa(this, a);b.insertBefore(a, b.firstChild);\n        }\n      });\n    }, before: function before() {\n      return ua(this, arguments, function (a) {\n        this.parentNode && this.parentNode.insertBefore(a, this);\n      });\n    }, after: function after() {\n      return ua(this, arguments, function (a) {\n        this.parentNode && this.parentNode.insertBefore(a, this.nextSibling);\n      });\n    }, empty: function empty() {\n      for (var a, b = 0; null != (a = this[b]); b++) {\n        1 === a.nodeType && (n.cleanData(_(a, !1)), a.textContent = \"\");\n      }return this;\n    }, clone: function clone(a, b) {\n      return a = null == a ? !1 : a, b = null == b ? a : b, this.map(function () {\n        return n.clone(this, a, b);\n      });\n    }, html: function html(a) {\n      return K(this, function (a) {\n        var b = this[0] || {},\n            c = 0,\n            d = this.length;if (void 0 === a && 1 === b.nodeType) return b.innerHTML;if (\"string\" == typeof a && !la.test(a) && !$[(Y.exec(a) || [\"\", \"\"])[1].toLowerCase()]) {\n          a = n.htmlPrefilter(a);try {\n            for (; d > c; c++) {\n              b = this[c] || {}, 1 === b.nodeType && (n.cleanData(_(b, !1)), b.innerHTML = a);\n            }b = 0;\n          } catch (e) {}\n        }b && this.empty().append(a);\n      }, null, a, arguments.length);\n    }, replaceWith: function replaceWith() {\n      var a = [];return ua(this, arguments, function (b) {\n        var c = this.parentNode;n.inArray(this, a) < 0 && (n.cleanData(_(this)), c && c.replaceChild(b, this));\n      }, a);\n    } }), n.each({ appendTo: \"append\", prependTo: \"prepend\", insertBefore: \"before\", insertAfter: \"after\", replaceAll: \"replaceWith\" }, function (a, b) {\n    n.fn[a] = function (a) {\n      for (var c, d = [], e = n(a), f = e.length - 1, h = 0; f >= h; h++) {\n        c = h === f ? this : this.clone(!0), n(e[h])[b](c), g.apply(d, c.get());\n      }return this.pushStack(d);\n    };\n  });var wa,\n      xa = { HTML: \"block\", BODY: \"block\" };function ya(a, b) {\n    var c = n(b.createElement(a)).appendTo(b.body),\n        d = n.css(c[0], \"display\");return c.detach(), d;\n  }function za(a) {\n    var b = d,\n        c = xa[a];return c || (c = ya(a, b), \"none\" !== c && c || (wa = (wa || n(\"<iframe frameborder='0' width='0' height='0'/>\")).appendTo(b.documentElement), b = wa[0].contentDocument, b.write(), b.close(), c = ya(a, b), wa.detach()), xa[a] = c), c;\n  }var Aa = /^margin/,\n      Ba = new RegExp(\"^(\" + S + \")(?!px)[a-z%]+$\", \"i\"),\n      Ca = function Ca(b) {\n    var c = b.ownerDocument.defaultView;return c && c.opener || (c = a), c.getComputedStyle(b);\n  },\n      Da = function Da(a, b, c, d) {\n    var e,\n        f,\n        g = {};for (f in b) {\n      g[f] = a.style[f], a.style[f] = b[f];\n    }e = c.apply(a, d || []);for (f in b) {\n      a.style[f] = g[f];\n    }return e;\n  },\n      Ea = d.documentElement;!function () {\n    var b,\n        c,\n        e,\n        f,\n        g = d.createElement(\"div\"),\n        h = d.createElement(\"div\");if (h.style) {\n      (function () {\n        var i = function i() {\n          h.style.cssText = \"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%\", h.innerHTML = \"\", Ea.appendChild(g);var d = a.getComputedStyle(h);b = \"1%\" !== d.top, f = \"2px\" === d.marginLeft, c = \"4px\" === d.width, h.style.marginRight = \"50%\", e = \"4px\" === d.marginRight, Ea.removeChild(g);\n        };\n\n        h.style.backgroundClip = \"content-box\", h.cloneNode(!0).style.backgroundClip = \"\", l.clearCloneStyle = \"content-box\" === h.style.backgroundClip, g.style.cssText = \"border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute\", g.appendChild(h);n.extend(l, { pixelPosition: function pixelPosition() {\n            return i(), b;\n          }, boxSizingReliable: function boxSizingReliable() {\n            return null == c && i(), c;\n          }, pixelMarginRight: function pixelMarginRight() {\n            return null == c && i(), e;\n          }, reliableMarginLeft: function reliableMarginLeft() {\n            return null == c && i(), f;\n          }, reliableMarginRight: function reliableMarginRight() {\n            var b,\n                c = h.appendChild(d.createElement(\"div\"));return c.style.cssText = h.style.cssText = \"-webkit-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0\", c.style.marginRight = c.style.width = \"0\", h.style.width = \"1px\", Ea.appendChild(g), b = !parseFloat(a.getComputedStyle(c).marginRight), Ea.removeChild(g), h.removeChild(c), b;\n          } });\n      })();\n    }\n  }();function Fa(a, b, c) {\n    var d,\n        e,\n        f,\n        g,\n        h = a.style;return c = c || Ca(a), g = c ? c.getPropertyValue(b) || c[b] : void 0, \"\" !== g && void 0 !== g || n.contains(a.ownerDocument, a) || (g = n.style(a, b)), c && !l.pixelMarginRight() && Ba.test(g) && Aa.test(b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f), void 0 !== g ? g + \"\" : g;\n  }function Ga(a, b) {\n    return { get: function get() {\n        return a() ? void delete this.get : (this.get = b).apply(this, arguments);\n      } };\n  }var Ha = /^(none|table(?!-c[ea]).+)/,\n      Ia = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n      Ja = { letterSpacing: \"0\", fontWeight: \"400\" },\n      Ka = [\"Webkit\", \"O\", \"Moz\", \"ms\"],\n      La = d.createElement(\"div\").style;function Ma(a) {\n    if (a in La) return a;var b = a[0].toUpperCase() + a.slice(1),\n        c = Ka.length;while (c--) {\n      if (a = Ka[c] + b, a in La) return a;\n    }\n  }function Na(a, b, c) {\n    var d = T.exec(b);return d ? Math.max(0, d[2] - (c || 0)) + (d[3] || \"px\") : b;\n  }function Oa(a, b, c, d, e) {\n    for (var f = c === (d ? \"border\" : \"content\") ? 4 : \"width\" === b ? 1 : 0, g = 0; 4 > f; f += 2) {\n      \"margin\" === c && (g += n.css(a, c + U[f], !0, e)), d ? (\"content\" === c && (g -= n.css(a, \"padding\" + U[f], !0, e)), \"margin\" !== c && (g -= n.css(a, \"border\" + U[f] + \"Width\", !0, e))) : (g += n.css(a, \"padding\" + U[f], !0, e), \"padding\" !== c && (g += n.css(a, \"border\" + U[f] + \"Width\", !0, e)));\n    }return g;\n  }function Pa(a, b, c) {\n    var d = !0,\n        e = \"width\" === b ? a.offsetWidth : a.offsetHeight,\n        f = Ca(a),\n        g = \"border-box\" === n.css(a, \"boxSizing\", !1, f);if (0 >= e || null == e) {\n      if (e = Fa(a, b, f), (0 > e || null == e) && (e = a.style[b]), Ba.test(e)) return e;d = g && (l.boxSizingReliable() || e === a.style[b]), e = parseFloat(e) || 0;\n    }return e + Oa(a, b, c || (g ? \"border\" : \"content\"), d, f) + \"px\";\n  }function Qa(a, b) {\n    for (var c, d, e, f = [], g = 0, h = a.length; h > g; g++) {\n      d = a[g], d.style && (f[g] = N.get(d, \"olddisplay\"), c = d.style.display, b ? (f[g] || \"none\" !== c || (d.style.display = \"\"), \"\" === d.style.display && V(d) && (f[g] = N.access(d, \"olddisplay\", za(d.nodeName)))) : (e = V(d), \"none\" === c && e || N.set(d, \"olddisplay\", e ? c : n.css(d, \"display\"))));\n    }for (g = 0; h > g; g++) {\n      d = a[g], d.style && (b && \"none\" !== d.style.display && \"\" !== d.style.display || (d.style.display = b ? f[g] || \"\" : \"none\"));\n    }return a;\n  }n.extend({ cssHooks: { opacity: { get: function get(a, b) {\n          if (b) {\n            var c = Fa(a, \"opacity\");return \"\" === c ? \"1\" : c;\n          }\n        } } }, cssNumber: { animationIterationCount: !0, columnCount: !0, fillOpacity: !0, flexGrow: !0, flexShrink: !0, fontWeight: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0 }, cssProps: { \"float\": \"cssFloat\" }, style: function style(a, b, c, d) {\n      if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {\n        var e,\n            f,\n            g,\n            h = n.camelCase(b),\n            i = a.style;return b = n.cssProps[h] || (n.cssProps[h] = Ma(h) || h), g = n.cssHooks[b] || n.cssHooks[h], void 0 === c ? g && \"get\" in g && void 0 !== (e = g.get(a, !1, d)) ? e : i[b] : (f = typeof c === \"undefined\" ? \"undefined\" : _typeof(c), \"string\" === f && (e = T.exec(c)) && e[1] && (c = W(a, b, e), f = \"number\"), null != c && c === c && (\"number\" === f && (c += e && e[3] || (n.cssNumber[h] ? \"\" : \"px\")), l.clearCloneStyle || \"\" !== c || 0 !== b.indexOf(\"background\") || (i[b] = \"inherit\"), g && \"set\" in g && void 0 === (c = g.set(a, c, d)) || (i[b] = c)), void 0);\n      }\n    }, css: function css(a, b, c, d) {\n      var e,\n          f,\n          g,\n          h = n.camelCase(b);return b = n.cssProps[h] || (n.cssProps[h] = Ma(h) || h), g = n.cssHooks[b] || n.cssHooks[h], g && \"get\" in g && (e = g.get(a, !0, c)), void 0 === e && (e = Fa(a, b, d)), \"normal\" === e && b in Ja && (e = Ja[b]), \"\" === c || c ? (f = parseFloat(e), c === !0 || isFinite(f) ? f || 0 : e) : e;\n    } }), n.each([\"height\", \"width\"], function (a, b) {\n    n.cssHooks[b] = { get: function get(a, c, d) {\n        return c ? Ha.test(n.css(a, \"display\")) && 0 === a.offsetWidth ? Da(a, Ia, function () {\n          return Pa(a, b, d);\n        }) : Pa(a, b, d) : void 0;\n      }, set: function set(a, c, d) {\n        var e,\n            f = d && Ca(a),\n            g = d && Oa(a, b, d, \"border-box\" === n.css(a, \"boxSizing\", !1, f), f);return g && (e = T.exec(c)) && \"px\" !== (e[3] || \"px\") && (a.style[b] = c, c = n.css(a, b)), Na(a, c, g);\n      } };\n  }), n.cssHooks.marginLeft = Ga(l.reliableMarginLeft, function (a, b) {\n    return b ? (parseFloat(Fa(a, \"marginLeft\")) || a.getBoundingClientRect().left - Da(a, { marginLeft: 0 }, function () {\n      return a.getBoundingClientRect().left;\n    })) + \"px\" : void 0;\n  }), n.cssHooks.marginRight = Ga(l.reliableMarginRight, function (a, b) {\n    return b ? Da(a, { display: \"inline-block\" }, Fa, [a, \"marginRight\"]) : void 0;\n  }), n.each({ margin: \"\", padding: \"\", border: \"Width\" }, function (a, b) {\n    n.cssHooks[a + b] = { expand: function expand(c) {\n        for (var d = 0, e = {}, f = \"string\" == typeof c ? c.split(\" \") : [c]; 4 > d; d++) {\n          e[a + U[d] + b] = f[d] || f[d - 2] || f[0];\n        }return e;\n      } }, Aa.test(a) || (n.cssHooks[a + b].set = Na);\n  }), n.fn.extend({ css: function css(a, b) {\n      return K(this, function (a, b, c) {\n        var d,\n            e,\n            f = {},\n            g = 0;if (n.isArray(b)) {\n          for (d = Ca(a), e = b.length; e > g; g++) {\n            f[b[g]] = n.css(a, b[g], !1, d);\n          }return f;\n        }return void 0 !== c ? n.style(a, b, c) : n.css(a, b);\n      }, a, b, arguments.length > 1);\n    }, show: function show() {\n      return Qa(this, !0);\n    }, hide: function hide() {\n      return Qa(this);\n    }, toggle: function toggle(a) {\n      return \"boolean\" == typeof a ? a ? this.show() : this.hide() : this.each(function () {\n        V(this) ? n(this).show() : n(this).hide();\n      });\n    } });function Ra(a, b, c, d, e) {\n    return new Ra.prototype.init(a, b, c, d, e);\n  }n.Tween = Ra, Ra.prototype = { constructor: Ra, init: function init(a, b, c, d, e, f) {\n      this.elem = a, this.prop = c, this.easing = e || n.easing._default, this.options = b, this.start = this.now = this.cur(), this.end = d, this.unit = f || (n.cssNumber[c] ? \"\" : \"px\");\n    }, cur: function cur() {\n      var a = Ra.propHooks[this.prop];return a && a.get ? a.get(this) : Ra.propHooks._default.get(this);\n    }, run: function run(a) {\n      var b,\n          c = Ra.propHooks[this.prop];return this.options.duration ? this.pos = b = n.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : this.pos = b = a, this.now = (this.end - this.start) * b + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), c && c.set ? c.set(this) : Ra.propHooks._default.set(this), this;\n    } }, Ra.prototype.init.prototype = Ra.prototype, Ra.propHooks = { _default: { get: function get(a) {\n        var b;return 1 !== a.elem.nodeType || null != a.elem[a.prop] && null == a.elem.style[a.prop] ? a.elem[a.prop] : (b = n.css(a.elem, a.prop, \"\"), b && \"auto\" !== b ? b : 0);\n      }, set: function set(a) {\n        n.fx.step[a.prop] ? n.fx.step[a.prop](a) : 1 !== a.elem.nodeType || null == a.elem.style[n.cssProps[a.prop]] && !n.cssHooks[a.prop] ? a.elem[a.prop] = a.now : n.style(a.elem, a.prop, a.now + a.unit);\n      } } }, Ra.propHooks.scrollTop = Ra.propHooks.scrollLeft = { set: function set(a) {\n      a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now);\n    } }, n.easing = { linear: function linear(a) {\n      return a;\n    }, swing: function swing(a) {\n      return .5 - Math.cos(a * Math.PI) / 2;\n    }, _default: \"swing\" }, n.fx = Ra.prototype.init, n.fx.step = {};var Sa,\n      Ta,\n      Ua = /^(?:toggle|show|hide)$/,\n      Va = /queueHooks$/;function Wa() {\n    return a.setTimeout(function () {\n      Sa = void 0;\n    }), Sa = n.now();\n  }function Xa(a, b) {\n    var c,\n        d = 0,\n        e = { height: a };for (b = b ? 1 : 0; 4 > d; d += 2 - b) {\n      c = U[d], e[\"margin\" + c] = e[\"padding\" + c] = a;\n    }return b && (e.opacity = e.width = a), e;\n  }function Ya(a, b, c) {\n    for (var d, e = (_a.tweeners[b] || []).concat(_a.tweeners[\"*\"]), f = 0, g = e.length; g > f; f++) {\n      if (d = e[f].call(c, b, a)) return d;\n    }\n  }function Za(a, b, c) {\n    var d,\n        e,\n        f,\n        g,\n        h,\n        i,\n        j,\n        k,\n        l = this,\n        m = {},\n        o = a.style,\n        p = a.nodeType && V(a),\n        q = N.get(a, \"fxshow\");c.queue || (h = n._queueHooks(a, \"fx\"), null == h.unqueued && (h.unqueued = 0, i = h.empty.fire, h.empty.fire = function () {\n      h.unqueued || i();\n    }), h.unqueued++, l.always(function () {\n      l.always(function () {\n        h.unqueued--, n.queue(a, \"fx\").length || h.empty.fire();\n      });\n    })), 1 === a.nodeType && (\"height\" in b || \"width\" in b) && (c.overflow = [o.overflow, o.overflowX, o.overflowY], j = n.css(a, \"display\"), k = \"none\" === j ? N.get(a, \"olddisplay\") || za(a.nodeName) : j, \"inline\" === k && \"none\" === n.css(a, \"float\") && (o.display = \"inline-block\")), c.overflow && (o.overflow = \"hidden\", l.always(function () {\n      o.overflow = c.overflow[0], o.overflowX = c.overflow[1], o.overflowY = c.overflow[2];\n    }));for (d in b) {\n      if (e = b[d], Ua.exec(e)) {\n        if (delete b[d], f = f || \"toggle\" === e, e === (p ? \"hide\" : \"show\")) {\n          if (\"show\" !== e || !q || void 0 === q[d]) continue;p = !0;\n        }m[d] = q && q[d] || n.style(a, d);\n      } else j = void 0;\n    }if (n.isEmptyObject(m)) \"inline\" === (\"none\" === j ? za(a.nodeName) : j) && (o.display = j);else {\n      q ? \"hidden\" in q && (p = q.hidden) : q = N.access(a, \"fxshow\", {}), f && (q.hidden = !p), p ? n(a).show() : l.done(function () {\n        n(a).hide();\n      }), l.done(function () {\n        var b;N.remove(a, \"fxshow\");for (b in m) {\n          n.style(a, b, m[b]);\n        }\n      });for (d in m) {\n        g = Ya(p ? q[d] : 0, d, l), d in q || (q[d] = g.start, p && (g.end = g.start, g.start = \"width\" === d || \"height\" === d ? 1 : 0));\n      }\n    }\n  }function $a(a, b) {\n    var c, d, e, f, g;for (c in a) {\n      if (d = n.camelCase(c), e = b[d], f = a[c], n.isArray(f) && (e = f[1], f = a[c] = f[0]), c !== d && (a[d] = f, delete a[c]), g = n.cssHooks[d], g && \"expand\" in g) {\n        f = g.expand(f), delete a[d];for (c in f) {\n          c in a || (a[c] = f[c], b[c] = e);\n        }\n      } else b[d] = e;\n    }\n  }function _a(a, b, c) {\n    var d,\n        e,\n        f = 0,\n        g = _a.prefilters.length,\n        h = n.Deferred().always(function () {\n      delete i.elem;\n    }),\n        i = function i() {\n      if (e) return !1;for (var b = Sa || Wa(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.tweens.length; i > g; g++) {\n        j.tweens[g].run(f);\n      }return h.notifyWith(a, [j, f, c]), 1 > f && i ? c : (h.resolveWith(a, [j]), !1);\n    },\n        j = h.promise({ elem: a, props: n.extend({}, b), opts: n.extend(!0, { specialEasing: {}, easing: n.easing._default }, c), originalProperties: b, originalOptions: c, startTime: Sa || Wa(), duration: c.duration, tweens: [], createTween: function createTween(b, c) {\n        var d = n.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing);return j.tweens.push(d), d;\n      }, stop: function stop(b) {\n        var c = 0,\n            d = b ? j.tweens.length : 0;if (e) return this;for (e = !0; d > c; c++) {\n          j.tweens[c].run(1);\n        }return b ? (h.notifyWith(a, [j, 1, 0]), h.resolveWith(a, [j, b])) : h.rejectWith(a, [j, b]), this;\n      } }),\n        k = j.props;for ($a(k, j.opts.specialEasing); g > f; f++) {\n      if (d = _a.prefilters[f].call(j, a, k, j.opts)) return n.isFunction(d.stop) && (n._queueHooks(j.elem, j.opts.queue).stop = n.proxy(d.stop, d)), d;\n    }return n.map(k, Ya, j), n.isFunction(j.opts.start) && j.opts.start.call(a, j), n.fx.timer(n.extend(i, { elem: a, anim: j, queue: j.opts.queue })), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always);\n  }n.Animation = n.extend(_a, { tweeners: { \"*\": [function (a, b) {\n        var c = this.createTween(a, b);return W(c.elem, a, T.exec(b), c), c;\n      }] }, tweener: function tweener(a, b) {\n      n.isFunction(a) ? (b = a, a = [\"*\"]) : a = a.match(G);for (var c, d = 0, e = a.length; e > d; d++) {\n        c = a[d], _a.tweeners[c] = _a.tweeners[c] || [], _a.tweeners[c].unshift(b);\n      }\n    }, prefilters: [Za], prefilter: function prefilter(a, b) {\n      b ? _a.prefilters.unshift(a) : _a.prefilters.push(a);\n    } }), n.speed = function (a, b, c) {\n    var d = a && \"object\" == (typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) ? n.extend({}, a) : { complete: c || !c && b || n.isFunction(a) && a, duration: a, easing: c && b || b && !n.isFunction(b) && b };return d.duration = n.fx.off ? 0 : \"number\" == typeof d.duration ? d.duration : d.duration in n.fx.speeds ? n.fx.speeds[d.duration] : n.fx.speeds._default, null != d.queue && d.queue !== !0 || (d.queue = \"fx\"), d.old = d.complete, d.complete = function () {\n      n.isFunction(d.old) && d.old.call(this), d.queue && n.dequeue(this, d.queue);\n    }, d;\n  }, n.fn.extend({ fadeTo: function fadeTo(a, b, c, d) {\n      return this.filter(V).css(\"opacity\", 0).show().end().animate({ opacity: b }, a, c, d);\n    }, animate: function animate(a, b, c, d) {\n      var e = n.isEmptyObject(a),\n          f = n.speed(b, c, d),\n          g = function g() {\n        var b = _a(this, n.extend({}, a), f);(e || N.get(this, \"finish\")) && b.stop(!0);\n      };return g.finish = g, e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g);\n    }, stop: function stop(a, b, c) {\n      var d = function d(a) {\n        var b = a.stop;delete a.stop, b(c);\n      };return \"string\" != typeof a && (c = b, b = a, a = void 0), b && a !== !1 && this.queue(a || \"fx\", []), this.each(function () {\n        var b = !0,\n            e = null != a && a + \"queueHooks\",\n            f = n.timers,\n            g = N.get(this);if (e) g[e] && g[e].stop && d(g[e]);else for (e in g) {\n          g[e] && g[e].stop && Va.test(e) && d(g[e]);\n        }for (e = f.length; e--;) {\n          f[e].elem !== this || null != a && f[e].queue !== a || (f[e].anim.stop(c), b = !1, f.splice(e, 1));\n        }!b && c || n.dequeue(this, a);\n      });\n    }, finish: function finish(a) {\n      return a !== !1 && (a = a || \"fx\"), this.each(function () {\n        var b,\n            c = N.get(this),\n            d = c[a + \"queue\"],\n            e = c[a + \"queueHooks\"],\n            f = n.timers,\n            g = d ? d.length : 0;for (c.finish = !0, n.queue(this, a, []), e && e.stop && e.stop.call(this, !0), b = f.length; b--;) {\n          f[b].elem === this && f[b].queue === a && (f[b].anim.stop(!0), f.splice(b, 1));\n        }for (b = 0; g > b; b++) {\n          d[b] && d[b].finish && d[b].finish.call(this);\n        }delete c.finish;\n      });\n    } }), n.each([\"toggle\", \"show\", \"hide\"], function (a, b) {\n    var c = n.fn[b];n.fn[b] = function (a, d, e) {\n      return null == a || \"boolean\" == typeof a ? c.apply(this, arguments) : this.animate(Xa(b, !0), a, d, e);\n    };\n  }), n.each({ slideDown: Xa(\"show\"), slideUp: Xa(\"hide\"), slideToggle: Xa(\"toggle\"), fadeIn: { opacity: \"show\" }, fadeOut: { opacity: \"hide\" }, fadeToggle: { opacity: \"toggle\" } }, function (a, b) {\n    n.fn[a] = function (a, c, d) {\n      return this.animate(b, a, c, d);\n    };\n  }), n.timers = [], n.fx.tick = function () {\n    var a,\n        b = 0,\n        c = n.timers;for (Sa = n.now(); b < c.length; b++) {\n      a = c[b], a() || c[b] !== a || c.splice(b--, 1);\n    }c.length || n.fx.stop(), Sa = void 0;\n  }, n.fx.timer = function (a) {\n    n.timers.push(a), a() ? n.fx.start() : n.timers.pop();\n  }, n.fx.interval = 13, n.fx.start = function () {\n    Ta || (Ta = a.setInterval(n.fx.tick, n.fx.interval));\n  }, n.fx.stop = function () {\n    a.clearInterval(Ta), Ta = null;\n  }, n.fx.speeds = { slow: 600, fast: 200, _default: 400 }, n.fn.delay = function (b, c) {\n    return b = n.fx ? n.fx.speeds[b] || b : b, c = c || \"fx\", this.queue(c, function (c, d) {\n      var e = a.setTimeout(c, b);d.stop = function () {\n        a.clearTimeout(e);\n      };\n    });\n  }, function () {\n    var a = d.createElement(\"input\"),\n        b = d.createElement(\"select\"),\n        c = b.appendChild(d.createElement(\"option\"));a.type = \"checkbox\", l.checkOn = \"\" !== a.value, l.optSelected = c.selected, b.disabled = !0, l.optDisabled = !c.disabled, a = d.createElement(\"input\"), a.value = \"t\", a.type = \"radio\", l.radioValue = \"t\" === a.value;\n  }();var ab,\n      bb = n.expr.attrHandle;n.fn.extend({ attr: function attr(a, b) {\n      return K(this, n.attr, a, b, arguments.length > 1);\n    }, removeAttr: function removeAttr(a) {\n      return this.each(function () {\n        n.removeAttr(this, a);\n      });\n    } }), n.extend({ attr: function attr(a, b, c) {\n      var d,\n          e,\n          f = a.nodeType;if (3 !== f && 8 !== f && 2 !== f) return \"undefined\" == typeof a.getAttribute ? n.prop(a, b, c) : (1 === f && n.isXMLDoc(a) || (b = b.toLowerCase(), e = n.attrHooks[b] || (n.expr.match.bool.test(b) ? ab : void 0)), void 0 !== c ? null === c ? void n.removeAttr(a, b) : e && \"set\" in e && void 0 !== (d = e.set(a, c, b)) ? d : (a.setAttribute(b, c + \"\"), c) : e && \"get\" in e && null !== (d = e.get(a, b)) ? d : (d = n.find.attr(a, b), null == d ? void 0 : d));\n    }, attrHooks: { type: { set: function set(a, b) {\n          if (!l.radioValue && \"radio\" === b && n.nodeName(a, \"input\")) {\n            var c = a.value;return a.setAttribute(\"type\", b), c && (a.value = c), b;\n          }\n        } } }, removeAttr: function removeAttr(a, b) {\n      var c,\n          d,\n          e = 0,\n          f = b && b.match(G);if (f && 1 === a.nodeType) while (c = f[e++]) {\n        d = n.propFix[c] || c, n.expr.match.bool.test(c) && (a[d] = !1), a.removeAttribute(c);\n      }\n    } }), ab = { set: function set(a, b, c) {\n      return b === !1 ? n.removeAttr(a, c) : a.setAttribute(c, c), c;\n    } }, n.each(n.expr.match.bool.source.match(/\\w+/g), function (a, b) {\n    var c = bb[b] || n.find.attr;bb[b] = function (a, b, d) {\n      var e, f;return d || (f = bb[b], bb[b] = e, e = null != c(a, b, d) ? b.toLowerCase() : null, bb[b] = f), e;\n    };\n  });var cb = /^(?:input|select|textarea|button)$/i,\n      db = /^(?:a|area)$/i;n.fn.extend({ prop: function prop(a, b) {\n      return K(this, n.prop, a, b, arguments.length > 1);\n    }, removeProp: function removeProp(a) {\n      return this.each(function () {\n        delete this[n.propFix[a] || a];\n      });\n    } }), n.extend({ prop: function prop(a, b, c) {\n      var d,\n          e,\n          f = a.nodeType;if (3 !== f && 8 !== f && 2 !== f) return 1 === f && n.isXMLDoc(a) || (b = n.propFix[b] || b, e = n.propHooks[b]), void 0 !== c ? e && \"set\" in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && \"get\" in e && null !== (d = e.get(a, b)) ? d : a[b];\n    }, propHooks: { tabIndex: { get: function get(a) {\n          var b = n.find.attr(a, \"tabindex\");return b ? parseInt(b, 10) : cb.test(a.nodeName) || db.test(a.nodeName) && a.href ? 0 : -1;\n        } } }, propFix: { \"for\": \"htmlFor\", \"class\": \"className\" } }), l.optSelected || (n.propHooks.selected = { get: function get(a) {\n      var b = a.parentNode;return b && b.parentNode && b.parentNode.selectedIndex, null;\n    }, set: function set(a) {\n      var b = a.parentNode;b && (b.selectedIndex, b.parentNode && b.parentNode.selectedIndex);\n    } }), n.each([\"tabIndex\", \"readOnly\", \"maxLength\", \"cellSpacing\", \"cellPadding\", \"rowSpan\", \"colSpan\", \"useMap\", \"frameBorder\", \"contentEditable\"], function () {\n    n.propFix[this.toLowerCase()] = this;\n  });var eb = /[\\t\\r\\n\\f]/g;function fb(a) {\n    return a.getAttribute && a.getAttribute(\"class\") || \"\";\n  }n.fn.extend({ addClass: function addClass(a) {\n      var b,\n          c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          i = 0;if (n.isFunction(a)) return this.each(function (b) {\n        n(this).addClass(a.call(this, b, fb(this)));\n      });if (\"string\" == typeof a && a) {\n        b = a.match(G) || [];while (c = this[i++]) {\n          if (e = fb(c), d = 1 === c.nodeType && (\" \" + e + \" \").replace(eb, \" \")) {\n            g = 0;while (f = b[g++]) {\n              d.indexOf(\" \" + f + \" \") < 0 && (d += f + \" \");\n            }h = n.trim(d), e !== h && c.setAttribute(\"class\", h);\n          }\n        }\n      }return this;\n    }, removeClass: function removeClass(a) {\n      var b,\n          c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          i = 0;if (n.isFunction(a)) return this.each(function (b) {\n        n(this).removeClass(a.call(this, b, fb(this)));\n      });if (!arguments.length) return this.attr(\"class\", \"\");if (\"string\" == typeof a && a) {\n        b = a.match(G) || [];while (c = this[i++]) {\n          if (e = fb(c), d = 1 === c.nodeType && (\" \" + e + \" \").replace(eb, \" \")) {\n            g = 0;while (f = b[g++]) {\n              while (d.indexOf(\" \" + f + \" \") > -1) {\n                d = d.replace(\" \" + f + \" \", \" \");\n              }\n            }h = n.trim(d), e !== h && c.setAttribute(\"class\", h);\n          }\n        }\n      }return this;\n    }, toggleClass: function toggleClass(a, b) {\n      var c = typeof a === \"undefined\" ? \"undefined\" : _typeof(a);return \"boolean\" == typeof b && \"string\" === c ? b ? this.addClass(a) : this.removeClass(a) : n.isFunction(a) ? this.each(function (c) {\n        n(this).toggleClass(a.call(this, c, fb(this), b), b);\n      }) : this.each(function () {\n        var b, d, e, f;if (\"string\" === c) {\n          d = 0, e = n(this), f = a.match(G) || [];while (b = f[d++]) {\n            e.hasClass(b) ? e.removeClass(b) : e.addClass(b);\n          }\n        } else void 0 !== a && \"boolean\" !== c || (b = fb(this), b && N.set(this, \"__className__\", b), this.setAttribute && this.setAttribute(\"class\", b || a === !1 ? \"\" : N.get(this, \"__className__\") || \"\"));\n      });\n    }, hasClass: function hasClass(a) {\n      var b,\n          c,\n          d = 0;b = \" \" + a + \" \";while (c = this[d++]) {\n        if (1 === c.nodeType && (\" \" + fb(c) + \" \").replace(eb, \" \").indexOf(b) > -1) return !0;\n      }return !1;\n    } });var gb = /\\r/g,\n      hb = /[\\x20\\t\\r\\n\\f]+/g;n.fn.extend({ val: function val(a) {\n      var b,\n          c,\n          d,\n          e = this[0];{\n        if (arguments.length) return d = n.isFunction(a), this.each(function (c) {\n          var e;1 === this.nodeType && (e = d ? a.call(this, c, n(this).val()) : a, null == e ? e = \"\" : \"number\" == typeof e ? e += \"\" : n.isArray(e) && (e = n.map(e, function (a) {\n            return null == a ? \"\" : a + \"\";\n          })), b = n.valHooks[this.type] || n.valHooks[this.nodeName.toLowerCase()], b && \"set\" in b && void 0 !== b.set(this, e, \"value\") || (this.value = e));\n        });if (e) return b = n.valHooks[e.type] || n.valHooks[e.nodeName.toLowerCase()], b && \"get\" in b && void 0 !== (c = b.get(e, \"value\")) ? c : (c = e.value, \"string\" == typeof c ? c.replace(gb, \"\") : null == c ? \"\" : c);\n      }\n    } }), n.extend({ valHooks: { option: { get: function get(a) {\n          var b = n.find.attr(a, \"value\");return null != b ? b : n.trim(n.text(a)).replace(hb, \" \");\n        } }, select: { get: function get(a) {\n          for (var b, c, d = a.options, e = a.selectedIndex, f = \"select-one\" === a.type || 0 > e, g = f ? null : [], h = f ? e + 1 : d.length, i = 0 > e ? h : f ? e : 0; h > i; i++) {\n            if (c = d[i], (c.selected || i === e) && (l.optDisabled ? !c.disabled : null === c.getAttribute(\"disabled\")) && (!c.parentNode.disabled || !n.nodeName(c.parentNode, \"optgroup\"))) {\n              if (b = n(c).val(), f) return b;g.push(b);\n            }\n          }return g;\n        }, set: function set(a, b) {\n          var c,\n              d,\n              e = a.options,\n              f = n.makeArray(b),\n              g = e.length;while (g--) {\n            d = e[g], (d.selected = n.inArray(n.valHooks.option.get(d), f) > -1) && (c = !0);\n          }return c || (a.selectedIndex = -1), f;\n        } } } }), n.each([\"radio\", \"checkbox\"], function () {\n    n.valHooks[this] = { set: function set(a, b) {\n        return n.isArray(b) ? a.checked = n.inArray(n(a).val(), b) > -1 : void 0;\n      } }, l.checkOn || (n.valHooks[this].get = function (a) {\n      return null === a.getAttribute(\"value\") ? \"on\" : a.value;\n    });\n  });var ib = /^(?:focusinfocus|focusoutblur)$/;n.extend(n.event, { trigger: function trigger(b, c, e, f) {\n      var g,\n          h,\n          i,\n          j,\n          l,\n          m,\n          o,\n          p = [e || d],\n          q = k.call(b, \"type\") ? b.type : b,\n          r = k.call(b, \"namespace\") ? b.namespace.split(\".\") : [];if (h = i = e = e || d, 3 !== e.nodeType && 8 !== e.nodeType && !ib.test(q + n.event.triggered) && (q.indexOf(\".\") > -1 && (r = q.split(\".\"), q = r.shift(), r.sort()), l = q.indexOf(\":\") < 0 && \"on\" + q, b = b[n.expando] ? b : new n.Event(q, \"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) && b), b.isTrigger = f ? 2 : 3, b.namespace = r.join(\".\"), b.rnamespace = b.namespace ? new RegExp(\"(^|\\\\.)\" + r.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\") : null, b.result = void 0, b.target || (b.target = e), c = null == c ? [b] : n.makeArray(c, [b]), o = n.event.special[q] || {}, f || !o.trigger || o.trigger.apply(e, c) !== !1)) {\n        if (!f && !o.noBubble && !n.isWindow(e)) {\n          for (j = o.delegateType || q, ib.test(j + q) || (h = h.parentNode); h; h = h.parentNode) {\n            p.push(h), i = h;\n          }i === (e.ownerDocument || d) && p.push(i.defaultView || i.parentWindow || a);\n        }g = 0;while ((h = p[g++]) && !b.isPropagationStopped()) {\n          b.type = g > 1 ? j : o.bindType || q, m = (N.get(h, \"events\") || {})[b.type] && N.get(h, \"handle\"), m && m.apply(h, c), m = l && h[l], m && m.apply && L(h) && (b.result = m.apply(h, c), b.result === !1 && b.preventDefault());\n        }return b.type = q, f || b.isDefaultPrevented() || o._default && o._default.apply(p.pop(), c) !== !1 || !L(e) || l && n.isFunction(e[q]) && !n.isWindow(e) && (i = e[l], i && (e[l] = null), n.event.triggered = q, e[q](), n.event.triggered = void 0, i && (e[l] = i)), b.result;\n      }\n    }, simulate: function simulate(a, b, c) {\n      var d = n.extend(new n.Event(), c, { type: a, isSimulated: !0 });n.event.trigger(d, null, b);\n    } }), n.fn.extend({ trigger: function trigger(a, b) {\n      return this.each(function () {\n        n.event.trigger(a, b, this);\n      });\n    }, triggerHandler: function triggerHandler(a, b) {\n      var c = this[0];return c ? n.event.trigger(a, b, c, !0) : void 0;\n    } }), n.each(\"blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu\".split(\" \"), function (a, b) {\n    n.fn[b] = function (a, c) {\n      return arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b);\n    };\n  }), n.fn.extend({ hover: function hover(a, b) {\n      return this.mouseenter(a).mouseleave(b || a);\n    } }), l.focusin = \"onfocusin\" in a, l.focusin || n.each({ focus: \"focusin\", blur: \"focusout\" }, function (a, b) {\n    var c = function c(a) {\n      n.event.simulate(b, a.target, n.event.fix(a));\n    };n.event.special[b] = { setup: function setup() {\n        var d = this.ownerDocument || this,\n            e = N.access(d, b);e || d.addEventListener(a, c, !0), N.access(d, b, (e || 0) + 1);\n      }, teardown: function teardown() {\n        var d = this.ownerDocument || this,\n            e = N.access(d, b) - 1;e ? N.access(d, b, e) : (d.removeEventListener(a, c, !0), N.remove(d, b));\n      } };\n  });var jb = a.location,\n      kb = n.now(),\n      lb = /\\?/;n.parseJSON = function (a) {\n    return JSON.parse(a + \"\");\n  }, n.parseXML = function (b) {\n    var c;if (!b || \"string\" != typeof b) return null;try {\n      c = new a.DOMParser().parseFromString(b, \"text/xml\");\n    } catch (d) {\n      c = void 0;\n    }return c && !c.getElementsByTagName(\"parsererror\").length || n.error(\"Invalid XML: \" + b), c;\n  };var mb = /#.*$/,\n      nb = /([?&])_=[^&]*/,\n      ob = /^(.*?):[ \\t]*([^\\r\\n]*)$/gm,\n      pb = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n      qb = /^(?:GET|HEAD)$/,\n      rb = /^\\/\\//,\n      sb = {},\n      tb = {},\n      ub = \"*/\".concat(\"*\"),\n      vb = d.createElement(\"a\");vb.href = jb.href;function wb(a) {\n    return function (b, c) {\n      \"string\" != typeof b && (c = b, b = \"*\");var d,\n          e = 0,\n          f = b.toLowerCase().match(G) || [];if (n.isFunction(c)) while (d = f[e++]) {\n        \"+\" === d[0] ? (d = d.slice(1) || \"*\", (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c);\n      }\n    };\n  }function xb(a, b, c, d) {\n    var e = {},\n        f = a === tb;function g(h) {\n      var i;return e[h] = !0, n.each(a[h] || [], function (a, h) {\n        var j = h(b, c, d);return \"string\" != typeof j || f || e[j] ? f ? !(i = j) : void 0 : (b.dataTypes.unshift(j), g(j), !1);\n      }), i;\n    }return g(b.dataTypes[0]) || !e[\"*\"] && g(\"*\");\n  }function yb(a, b) {\n    var c,\n        d,\n        e = n.ajaxSettings.flatOptions || {};for (c in b) {\n      void 0 !== b[c] && ((e[c] ? a : d || (d = {}))[c] = b[c]);\n    }return d && n.extend(!0, a, d), a;\n  }function zb(a, b, c) {\n    var d,\n        e,\n        f,\n        g,\n        h = a.contents,\n        i = a.dataTypes;while (\"*\" === i[0]) {\n      i.shift(), void 0 === d && (d = a.mimeType || b.getResponseHeader(\"Content-Type\"));\n    }if (d) for (e in h) {\n      if (h[e] && h[e].test(d)) {\n        i.unshift(e);break;\n      }\n    }if (i[0] in c) f = i[0];else {\n      for (e in c) {\n        if (!i[0] || a.converters[e + \" \" + i[0]]) {\n          f = e;break;\n        }g || (g = e);\n      }f = f || g;\n    }return f ? (f !== i[0] && i.unshift(f), c[f]) : void 0;\n  }function Ab(a, b, c, d) {\n    var e,\n        f,\n        g,\n        h,\n        i,\n        j = {},\n        k = a.dataTypes.slice();if (k[1]) for (g in a.converters) {\n      j[g.toLowerCase()] = a.converters[g];\n    }f = k.shift();while (f) {\n      if (a.responseFields[f] && (c[a.responseFields[f]] = b), !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), i = f, f = k.shift()) if (\"*\" === f) f = i;else if (\"*\" !== i && i !== f) {\n        if (g = j[i + \" \" + f] || j[\"* \" + f], !g) for (e in j) {\n          if (h = e.split(\" \"), h[1] === f && (g = j[i + \" \" + h[0]] || j[\"* \" + h[0]])) {\n            g === !0 ? g = j[e] : j[e] !== !0 && (f = h[0], k.unshift(h[1]));break;\n          }\n        }if (g !== !0) if (g && a[\"throws\"]) b = g(b);else try {\n          b = g(b);\n        } catch (l) {\n          return { state: \"parsererror\", error: g ? l : \"No conversion from \" + i + \" to \" + f };\n        }\n      }\n    }return { state: \"success\", data: b };\n  }n.extend({ active: 0, lastModified: {}, etag: {}, ajaxSettings: { url: jb.href, type: \"GET\", isLocal: pb.test(jb.protocol), global: !0, processData: !0, async: !0, contentType: \"application/x-www-form-urlencoded; charset=UTF-8\", accepts: { \"*\": ub, text: \"text/plain\", html: \"text/html\", xml: \"application/xml, text/xml\", json: \"application/json, text/javascript\" }, contents: { xml: /\\bxml\\b/, html: /\\bhtml/, json: /\\bjson\\b/ }, responseFields: { xml: \"responseXML\", text: \"responseText\", json: \"responseJSON\" }, converters: { \"* text\": String, \"text html\": !0, \"text json\": n.parseJSON, \"text xml\": n.parseXML }, flatOptions: { url: !0, context: !0 } }, ajaxSetup: function ajaxSetup(a, b) {\n      return b ? yb(yb(a, n.ajaxSettings), b) : yb(n.ajaxSettings, a);\n    }, ajaxPrefilter: wb(sb), ajaxTransport: wb(tb), ajax: function ajax(b, c) {\n      \"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) && (c = b, b = void 0), c = c || {};var e,\n          f,\n          g,\n          h,\n          i,\n          j,\n          k,\n          l,\n          m = n.ajaxSetup({}, c),\n          o = m.context || m,\n          p = m.context && (o.nodeType || o.jquery) ? n(o) : n.event,\n          q = n.Deferred(),\n          r = n.Callbacks(\"once memory\"),\n          s = m.statusCode || {},\n          t = {},\n          u = {},\n          v = 0,\n          w = \"canceled\",\n          x = { readyState: 0, getResponseHeader: function getResponseHeader(a) {\n          var b;if (2 === v) {\n            if (!h) {\n              h = {};while (b = ob.exec(g)) {\n                h[b[1].toLowerCase()] = b[2];\n              }\n            }b = h[a.toLowerCase()];\n          }return null == b ? null : b;\n        }, getAllResponseHeaders: function getAllResponseHeaders() {\n          return 2 === v ? g : null;\n        }, setRequestHeader: function setRequestHeader(a, b) {\n          var c = a.toLowerCase();return v || (a = u[c] = u[c] || a, t[a] = b), this;\n        }, overrideMimeType: function overrideMimeType(a) {\n          return v || (m.mimeType = a), this;\n        }, statusCode: function statusCode(a) {\n          var b;if (a) if (2 > v) for (b in a) {\n            s[b] = [s[b], a[b]];\n          } else x.always(a[x.status]);return this;\n        }, abort: function abort(a) {\n          var b = a || w;return e && e.abort(b), z(0, b), this;\n        } };if (q.promise(x).complete = r.add, x.success = x.done, x.error = x.fail, m.url = ((b || m.url || jb.href) + \"\").replace(mb, \"\").replace(rb, jb.protocol + \"//\"), m.type = c.method || c.type || m.method || m.type, m.dataTypes = n.trim(m.dataType || \"*\").toLowerCase().match(G) || [\"\"], null == m.crossDomain) {\n        j = d.createElement(\"a\");try {\n          j.href = m.url, j.href = j.href, m.crossDomain = vb.protocol + \"//\" + vb.host != j.protocol + \"//\" + j.host;\n        } catch (y) {\n          m.crossDomain = !0;\n        }\n      }if (m.data && m.processData && \"string\" != typeof m.data && (m.data = n.param(m.data, m.traditional)), xb(sb, m, c, x), 2 === v) return x;k = n.event && m.global, k && 0 === n.active++ && n.event.trigger(\"ajaxStart\"), m.type = m.type.toUpperCase(), m.hasContent = !qb.test(m.type), f = m.url, m.hasContent || (m.data && (f = m.url += (lb.test(f) ? \"&\" : \"?\") + m.data, delete m.data), m.cache === !1 && (m.url = nb.test(f) ? f.replace(nb, \"$1_=\" + kb++) : f + (lb.test(f) ? \"&\" : \"?\") + \"_=\" + kb++)), m.ifModified && (n.lastModified[f] && x.setRequestHeader(\"If-Modified-Since\", n.lastModified[f]), n.etag[f] && x.setRequestHeader(\"If-None-Match\", n.etag[f])), (m.data && m.hasContent && m.contentType !== !1 || c.contentType) && x.setRequestHeader(\"Content-Type\", m.contentType), x.setRequestHeader(\"Accept\", m.dataTypes[0] && m.accepts[m.dataTypes[0]] ? m.accepts[m.dataTypes[0]] + (\"*\" !== m.dataTypes[0] ? \", \" + ub + \"; q=0.01\" : \"\") : m.accepts[\"*\"]);for (l in m.headers) {\n        x.setRequestHeader(l, m.headers[l]);\n      }if (m.beforeSend && (m.beforeSend.call(o, x, m) === !1 || 2 === v)) return x.abort();w = \"abort\";for (l in { success: 1, error: 1, complete: 1 }) {\n        x[l](m[l]);\n      }if (e = xb(tb, m, c, x)) {\n        if (x.readyState = 1, k && p.trigger(\"ajaxSend\", [x, m]), 2 === v) return x;m.async && m.timeout > 0 && (i = a.setTimeout(function () {\n          x.abort(\"timeout\");\n        }, m.timeout));try {\n          v = 1, e.send(t, z);\n        } catch (y) {\n          if (!(2 > v)) throw y;z(-1, y);\n        }\n      } else z(-1, \"No Transport\");function z(b, c, d, h) {\n        var j,\n            l,\n            t,\n            u,\n            w,\n            y = c;2 !== v && (v = 2, i && a.clearTimeout(i), e = void 0, g = h || \"\", x.readyState = b > 0 ? 4 : 0, j = b >= 200 && 300 > b || 304 === b, d && (u = zb(m, x, d)), u = Ab(m, u, x, j), j ? (m.ifModified && (w = x.getResponseHeader(\"Last-Modified\"), w && (n.lastModified[f] = w), w = x.getResponseHeader(\"etag\"), w && (n.etag[f] = w)), 204 === b || \"HEAD\" === m.type ? y = \"nocontent\" : 304 === b ? y = \"notmodified\" : (y = u.state, l = u.data, t = u.error, j = !t)) : (t = y, !b && y || (y = \"error\", 0 > b && (b = 0))), x.status = b, x.statusText = (c || y) + \"\", j ? q.resolveWith(o, [l, y, x]) : q.rejectWith(o, [x, y, t]), x.statusCode(s), s = void 0, k && p.trigger(j ? \"ajaxSuccess\" : \"ajaxError\", [x, m, j ? l : t]), r.fireWith(o, [x, y]), k && (p.trigger(\"ajaxComplete\", [x, m]), --n.active || n.event.trigger(\"ajaxStop\")));\n      }return x;\n    }, getJSON: function getJSON(a, b, c) {\n      return n.get(a, b, c, \"json\");\n    }, getScript: function getScript(a, b) {\n      return n.get(a, void 0, b, \"script\");\n    } }), n.each([\"get\", \"post\"], function (a, b) {\n    n[b] = function (a, c, d, e) {\n      return n.isFunction(c) && (e = e || d, d = c, c = void 0), n.ajax(n.extend({ url: a, type: b, dataType: e, data: c, success: d }, n.isPlainObject(a) && a));\n    };\n  }), n._evalUrl = function (a) {\n    return n.ajax({ url: a, type: \"GET\", dataType: \"script\", async: !1, global: !1, \"throws\": !0 });\n  }, n.fn.extend({ wrapAll: function wrapAll(a) {\n      var b;return n.isFunction(a) ? this.each(function (b) {\n        n(this).wrapAll(a.call(this, b));\n      }) : (this[0] && (b = n(a, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && b.insertBefore(this[0]), b.map(function () {\n        var a = this;while (a.firstElementChild) {\n          a = a.firstElementChild;\n        }return a;\n      }).append(this)), this);\n    }, wrapInner: function wrapInner(a) {\n      return n.isFunction(a) ? this.each(function (b) {\n        n(this).wrapInner(a.call(this, b));\n      }) : this.each(function () {\n        var b = n(this),\n            c = b.contents();c.length ? c.wrapAll(a) : b.append(a);\n      });\n    }, wrap: function wrap(a) {\n      var b = n.isFunction(a);return this.each(function (c) {\n        n(this).wrapAll(b ? a.call(this, c) : a);\n      });\n    }, unwrap: function unwrap() {\n      return this.parent().each(function () {\n        n.nodeName(this, \"body\") || n(this).replaceWith(this.childNodes);\n      }).end();\n    } }), n.expr.filters.hidden = function (a) {\n    return !n.expr.filters.visible(a);\n  }, n.expr.filters.visible = function (a) {\n    return a.offsetWidth > 0 || a.offsetHeight > 0 || a.getClientRects().length > 0;\n  };var Bb = /%20/g,\n      Cb = /\\[\\]$/,\n      Db = /\\r?\\n/g,\n      Eb = /^(?:submit|button|image|reset|file)$/i,\n      Fb = /^(?:input|select|textarea|keygen)/i;function Gb(a, b, c, d) {\n    var e;if (n.isArray(b)) n.each(b, function (b, e) {\n      c || Cb.test(a) ? d(a, e) : Gb(a + \"[\" + (\"object\" == (typeof e === \"undefined\" ? \"undefined\" : _typeof(e)) && null != e ? b : \"\") + \"]\", e, c, d);\n    });else if (c || \"object\" !== n.type(b)) d(a, b);else for (e in b) {\n      Gb(a + \"[\" + e + \"]\", b[e], c, d);\n    }\n  }n.param = function (a, b) {\n    var c,\n        d = [],\n        e = function e(a, b) {\n      b = n.isFunction(b) ? b() : null == b ? \"\" : b, d[d.length] = encodeURIComponent(a) + \"=\" + encodeURIComponent(b);\n    };if (void 0 === b && (b = n.ajaxSettings && n.ajaxSettings.traditional), n.isArray(a) || a.jquery && !n.isPlainObject(a)) n.each(a, function () {\n      e(this.name, this.value);\n    });else for (c in a) {\n      Gb(c, a[c], b, e);\n    }return d.join(\"&\").replace(Bb, \"+\");\n  }, n.fn.extend({ serialize: function serialize() {\n      return n.param(this.serializeArray());\n    }, serializeArray: function serializeArray() {\n      return this.map(function () {\n        var a = n.prop(this, \"elements\");return a ? n.makeArray(a) : this;\n      }).filter(function () {\n        var a = this.type;return this.name && !n(this).is(\":disabled\") && Fb.test(this.nodeName) && !Eb.test(a) && (this.checked || !X.test(a));\n      }).map(function (a, b) {\n        var c = n(this).val();return null == c ? null : n.isArray(c) ? n.map(c, function (a) {\n          return { name: b.name, value: a.replace(Db, \"\\r\\n\") };\n        }) : { name: b.name, value: c.replace(Db, \"\\r\\n\") };\n      }).get();\n    } }), n.ajaxSettings.xhr = function () {\n    try {\n      return new a.XMLHttpRequest();\n    } catch (b) {}\n  };var Hb = { 0: 200, 1223: 204 },\n      Ib = n.ajaxSettings.xhr();l.cors = !!Ib && \"withCredentials\" in Ib, l.ajax = Ib = !!Ib, n.ajaxTransport(function (b) {\n    var _c, d;return l.cors || Ib && !b.crossDomain ? { send: function send(e, f) {\n        var g,\n            h = b.xhr();if (h.open(b.type, b.url, b.async, b.username, b.password), b.xhrFields) for (g in b.xhrFields) {\n          h[g] = b.xhrFields[g];\n        }b.mimeType && h.overrideMimeType && h.overrideMimeType(b.mimeType), b.crossDomain || e[\"X-Requested-With\"] || (e[\"X-Requested-With\"] = \"XMLHttpRequest\");for (g in e) {\n          h.setRequestHeader(g, e[g]);\n        }_c = function c(a) {\n          return function () {\n            _c && (_c = d = h.onload = h.onerror = h.onabort = h.onreadystatechange = null, \"abort\" === a ? h.abort() : \"error\" === a ? \"number\" != typeof h.status ? f(0, \"error\") : f(h.status, h.statusText) : f(Hb[h.status] || h.status, h.statusText, \"text\" !== (h.responseType || \"text\") || \"string\" != typeof h.responseText ? { binary: h.response } : { text: h.responseText }, h.getAllResponseHeaders()));\n          };\n        }, h.onload = _c(), d = h.onerror = _c(\"error\"), void 0 !== h.onabort ? h.onabort = d : h.onreadystatechange = function () {\n          4 === h.readyState && a.setTimeout(function () {\n            _c && d();\n          });\n        }, _c = _c(\"abort\");try {\n          h.send(b.hasContent && b.data || null);\n        } catch (i) {\n          if (_c) throw i;\n        }\n      }, abort: function abort() {\n        _c && _c();\n      } } : void 0;\n  }), n.ajaxSetup({ accepts: { script: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\" }, contents: { script: /\\b(?:java|ecma)script\\b/ }, converters: { \"text script\": function textScript(a) {\n        return n.globalEval(a), a;\n      } } }), n.ajaxPrefilter(\"script\", function (a) {\n    void 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = \"GET\");\n  }), n.ajaxTransport(\"script\", function (a) {\n    if (a.crossDomain) {\n      var b, _c2;return { send: function send(e, f) {\n          b = n(\"<script>\").prop({ charset: a.scriptCharset, src: a.url }).on(\"load error\", _c2 = function c(a) {\n            b.remove(), _c2 = null, a && f(\"error\" === a.type ? 404 : 200, a.type);\n          }), d.head.appendChild(b[0]);\n        }, abort: function abort() {\n          _c2 && _c2();\n        } };\n    }\n  });var Jb = [],\n      Kb = /(=)\\?(?=&|$)|\\?\\?/;n.ajaxSetup({ jsonp: \"callback\", jsonpCallback: function jsonpCallback() {\n      var a = Jb.pop() || n.expando + \"_\" + kb++;return this[a] = !0, a;\n    } }), n.ajaxPrefilter(\"json jsonp\", function (b, c, d) {\n    var e,\n        f,\n        g,\n        h = b.jsonp !== !1 && (Kb.test(b.url) ? \"url\" : \"string\" == typeof b.data && 0 === (b.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") && Kb.test(b.data) && \"data\");return h || \"jsonp\" === b.dataTypes[0] ? (e = b.jsonpCallback = n.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, h ? b[h] = b[h].replace(Kb, \"$1\" + e) : b.jsonp !== !1 && (b.url += (lb.test(b.url) ? \"&\" : \"?\") + b.jsonp + \"=\" + e), b.converters[\"script json\"] = function () {\n      return g || n.error(e + \" was not called\"), g[0];\n    }, b.dataTypes[0] = \"json\", f = a[e], a[e] = function () {\n      g = arguments;\n    }, d.always(function () {\n      void 0 === f ? n(a).removeProp(e) : a[e] = f, b[e] && (b.jsonpCallback = c.jsonpCallback, Jb.push(e)), g && n.isFunction(f) && f(g[0]), g = f = void 0;\n    }), \"script\") : void 0;\n  }), n.parseHTML = function (a, b, c) {\n    if (!a || \"string\" != typeof a) return null;\"boolean\" == typeof b && (c = b, b = !1), b = b || d;var e = x.exec(a),\n        f = !c && [];return e ? [b.createElement(e[1])] : (e = ca([a], b, f), f && f.length && n(f).remove(), n.merge([], e.childNodes));\n  };var Lb = n.fn.load;n.fn.load = function (a, b, c) {\n    if (\"string\" != typeof a && Lb) return Lb.apply(this, arguments);var d,\n        e,\n        f,\n        g = this,\n        h = a.indexOf(\" \");return h > -1 && (d = n.trim(a.slice(h)), a = a.slice(0, h)), n.isFunction(b) ? (c = b, b = void 0) : b && \"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) && (e = \"POST\"), g.length > 0 && n.ajax({ url: a, type: e || \"GET\", dataType: \"html\", data: b }).done(function (a) {\n      f = arguments, g.html(d ? n(\"<div>\").append(n.parseHTML(a)).find(d) : a);\n    }).always(c && function (a, b) {\n      g.each(function () {\n        c.apply(this, f || [a.responseText, b, a]);\n      });\n    }), this;\n  }, n.each([\"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\"], function (a, b) {\n    n.fn[b] = function (a) {\n      return this.on(b, a);\n    };\n  }), n.expr.filters.animated = function (a) {\n    return n.grep(n.timers, function (b) {\n      return a === b.elem;\n    }).length;\n  };function Mb(a) {\n    return n.isWindow(a) ? a : 9 === a.nodeType && a.defaultView;\n  }n.offset = { setOffset: function setOffset(a, b, c) {\n      var d,\n          e,\n          f,\n          g,\n          h,\n          i,\n          j,\n          k = n.css(a, \"position\"),\n          l = n(a),\n          m = {};\"static\" === k && (a.style.position = \"relative\"), h = l.offset(), f = n.css(a, \"top\"), i = n.css(a, \"left\"), j = (\"absolute\" === k || \"fixed\" === k) && (f + i).indexOf(\"auto\") > -1, j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0), n.isFunction(b) && (b = b.call(a, c, n.extend({}, h))), null != b.top && (m.top = b.top - h.top + g), null != b.left && (m.left = b.left - h.left + e), \"using\" in b ? b.using.call(a, m) : l.css(m);\n    } }, n.fn.extend({ offset: function offset(a) {\n      if (arguments.length) return void 0 === a ? this : this.each(function (b) {\n        n.offset.setOffset(this, a, b);\n      });var b,\n          c,\n          d = this[0],\n          e = { top: 0, left: 0 },\n          f = d && d.ownerDocument;if (f) return b = f.documentElement, n.contains(b, d) ? (e = d.getBoundingClientRect(), c = Mb(f), { top: e.top + c.pageYOffset - b.clientTop, left: e.left + c.pageXOffset - b.clientLeft }) : e;\n    }, position: function position() {\n      if (this[0]) {\n        var a,\n            b,\n            c = this[0],\n            d = { top: 0, left: 0 };return \"fixed\" === n.css(c, \"position\") ? b = c.getBoundingClientRect() : (a = this.offsetParent(), b = this.offset(), n.nodeName(a[0], \"html\") || (d = a.offset()), d.top += n.css(a[0], \"borderTopWidth\", !0), d.left += n.css(a[0], \"borderLeftWidth\", !0)), { top: b.top - d.top - n.css(c, \"marginTop\", !0), left: b.left - d.left - n.css(c, \"marginLeft\", !0) };\n      }\n    }, offsetParent: function offsetParent() {\n      return this.map(function () {\n        var a = this.offsetParent;while (a && \"static\" === n.css(a, \"position\")) {\n          a = a.offsetParent;\n        }return a || Ea;\n      });\n    } }), n.each({ scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function (a, b) {\n    var c = \"pageYOffset\" === b;n.fn[a] = function (d) {\n      return K(this, function (a, d, e) {\n        var f = Mb(a);return void 0 === e ? f ? f[b] : a[d] : void (f ? f.scrollTo(c ? f.pageXOffset : e, c ? e : f.pageYOffset) : a[d] = e);\n      }, a, d, arguments.length);\n    };\n  }), n.each([\"top\", \"left\"], function (a, b) {\n    n.cssHooks[b] = Ga(l.pixelPosition, function (a, c) {\n      return c ? (c = Fa(a, b), Ba.test(c) ? n(a).position()[b] + \"px\" : c) : void 0;\n    });\n  }), n.each({ Height: \"height\", Width: \"width\" }, function (a, b) {\n    n.each({ padding: \"inner\" + a, content: b, \"\": \"outer\" + a }, function (c, d) {\n      n.fn[d] = function (d, e) {\n        var f = arguments.length && (c || \"boolean\" != typeof d),\n            g = c || (d === !0 || e === !0 ? \"margin\" : \"border\");return K(this, function (b, c, d) {\n          var e;return n.isWindow(b) ? b.document.documentElement[\"client\" + a] : 9 === b.nodeType ? (e = b.documentElement, Math.max(b.body[\"scroll\" + a], e[\"scroll\" + a], b.body[\"offset\" + a], e[\"offset\" + a], e[\"client\" + a])) : void 0 === d ? n.css(b, c, g) : n.style(b, c, d, g);\n        }, b, f ? d : void 0, f, null);\n      };\n    });\n  }), n.fn.extend({ bind: function bind(a, b, c) {\n      return this.on(a, null, b, c);\n    }, unbind: function unbind(a, b) {\n      return this.off(a, null, b);\n    }, delegate: function delegate(a, b, c, d) {\n      return this.on(b, a, c, d);\n    }, undelegate: function undelegate(a, b, c) {\n      return 1 === arguments.length ? this.off(a, \"**\") : this.off(b, a || \"**\", c);\n    }, size: function size() {\n      return this.length;\n    } }), n.fn.andSelf = n.fn.addBack, \"function\" == typeof define && define.amd && define(\"jquery\", [], function () {\n    return n;\n  });var Nb = a.jQuery,\n      Ob = a.$;return n.noConflict = function (b) {\n    return a.$ === n && (a.$ = Ob), b && a.jQuery === n && (a.jQuery = Nb), n;\n  }, b || (a.jQuery = a.$ = n), n;\n});"

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(2)(__webpack_require__(5))

/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = "\"use strict\";var _typeof=typeof Symbol===\"function\"&&typeof Symbol.iterator===\"symbol\"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol===\"function\"&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj;};function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}!function(t){\"use strict\";function e(t){if(void 0===Function.prototype.name){var e=/function\\s([^(]{1,})\\(/,i=e.exec(t.toString());return i&&i.length>1?i[1].trim():\"\";}return void 0===t.prototype?t.constructor.name:t.prototype.constructor.name;}function i(t){return /true/.test(t)?!0:/false/.test(t)?!1:isNaN(1*t)?t:parseFloat(t);}function n(t){return t.replace(/([a-z])([A-Z])/g,\"$1-$2\").toLowerCase();}var s=\"6.2.3\",o={version:s,_plugins:{},_uuids:[],rtl:function rtl(){return\"rtl\"===t(\"html\").attr(\"dir\");},plugin:function plugin(t,i){var s=i||e(t),o=n(s);this._plugins[o]=this[s]=t;},registerPlugin:function registerPlugin(t,i){var s=i?n(i):e(t.constructor).toLowerCase();t.uuid=this.GetYoDigits(6,s),t.$element.attr(\"data-\"+s)||t.$element.attr(\"data-\"+s,t.uuid),t.$element.data(\"zfPlugin\")||t.$element.data(\"zfPlugin\",t),t.$element.trigger(\"init.zf.\"+s),this._uuids.push(t.uuid);},unregisterPlugin:function unregisterPlugin(t){var i=n(e(t.$element.data(\"zfPlugin\").constructor));this._uuids.splice(this._uuids.indexOf(t.uuid),1),t.$element.removeAttr(\"data-\"+i).removeData(\"zfPlugin\").trigger(\"destroyed.zf.\"+i);for(var s in t){t[s]=null;}},reInit:function reInit(e){var i=e instanceof t;try{if(i)e.each(function(){t(this).data(\"zfPlugin\")._init();});else{var s=typeof e===\"undefined\"?\"undefined\":_typeof(e),o=this,a={object:function object(e){e.forEach(function(e){e=n(e),t(\"[data-\"+e+\"]\").foundation(\"_init\");});},string:function string(){e=n(e),t(\"[data-\"+e+\"]\").foundation(\"_init\");},undefined:function undefined(){this.object(Object.keys(o._plugins));}};a[s](e);}}catch(r){console.error(r);}finally{return e;}},GetYoDigits:function GetYoDigits(t,e){return t=t||6,Math.round(Math.pow(36,t+1)-Math.random()*Math.pow(36,t)).toString(36).slice(1)+(e?\"-\"+e:\"\");},reflow:function reflow(e,n){\"undefined\"==typeof n?n=Object.keys(this._plugins):\"string\"==typeof n&&(n=[n]);var s=this;t.each(n,function(n,o){var a=s._plugins[o],r=t(e).find(\"[data-\"+o+\"]\").addBack(\"[data-\"+o+\"]\");r.each(function(){var e=t(this),n={};if(e.data(\"zfPlugin\"))return void console.warn(\"Tried to initialize \"+o+\" on an element that already has a Foundation plugin.\");if(e.attr(\"data-options\")){e.attr(\"data-options\").split(\";\").forEach(function(t,e){var s=t.split(\":\").map(function(t){return t.trim();});s[0]&&(n[s[0]]=i(s[1]));});}try{e.data(\"zfPlugin\",new a(t(this),n));}catch(s){console.error(s);}finally{return;}});});},getFnName:e,transitionend:function transitionend(t){var e,i={transition:\"transitionend\",WebkitTransition:\"webkitTransitionEnd\",MozTransition:\"transitionend\",OTransition:\"otransitionend\"},n=document.createElement(\"div\");for(var s in i){\"undefined\"!=typeof n.style[s]&&(e=i[s]);}return e?e:(e=setTimeout(function(){t.triggerHandler(\"transitionend\",[t]);},1),\"transitionend\");}};o.util={throttle:function throttle(t,e){var i=null;return function(){var n=this,s=arguments;null===i&&(i=setTimeout(function(){t.apply(n,s),i=null;},e));};}};var a=function a(i){var n=typeof i===\"undefined\"?\"undefined\":_typeof(i),s=t(\"meta.foundation-mq\"),a=t(\".no-js\");if(s.length||t('<meta class=\"foundation-mq\">').appendTo(document.head),a.length&&a.removeClass(\"no-js\"),\"undefined\"===n)o.MediaQuery._init(),o.reflow(this);else{if(\"string\"!==n)throw new TypeError(\"We're sorry, \"+n+\" is not a valid parameter. You must use a string representing the method you wish to invoke.\");var r=Array.prototype.slice.call(arguments,1),l=this.data(\"zfPlugin\");if(void 0===l||void 0===l[i])throw new ReferenceError(\"We're sorry, '\"+i+\"' is not an available method for \"+(l?e(l):\"this element\")+\".\");1===this.length?l[i].apply(l,r):this.each(function(e,n){l[i].apply(t(n).data(\"zfPlugin\"),r);});}return this;};window.Foundation=o,t.fn.foundation=a,function(){Date.now&&window.Date.now||(window.Date.now=Date.now=function(){return new Date().getTime();});for(var t=[\"webkit\",\"moz\"],e=0;e<t.length&&!window.requestAnimationFrame;++e){var i=t[e];window.requestAnimationFrame=window[i+\"RequestAnimationFrame\"],window.cancelAnimationFrame=window[i+\"CancelAnimationFrame\"]||window[i+\"CancelRequestAnimationFrame\"];}if(/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent)||!window.requestAnimationFrame||!window.cancelAnimationFrame){var n=0;window.requestAnimationFrame=function(t){var e=Date.now(),i=Math.max(n+16,e);return setTimeout(function(){t(n=i);},i-e);},window.cancelAnimationFrame=clearTimeout;}window.performance&&window.performance.now||(window.performance={start:Date.now(),now:function now(){return Date.now()-this.start;}});}(),Function.prototype.bind||(Function.prototype.bind=function(t){if(\"function\"!=typeof this)throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\");var e=Array.prototype.slice.call(arguments,1),i=this,n=function n(){},s=function s(){return i.apply(this instanceof n?this:t,e.concat(Array.prototype.slice.call(arguments)));};return this.prototype&&(n.prototype=this.prototype),s.prototype=new n(),s;});}(jQuery),!function(t){function e(t,e,n,s){var o,a,r,l,u=i(t);if(e){var d=i(e);a=u.offset.top+u.height<=d.height+d.offset.top,o=u.offset.top>=d.offset.top,r=u.offset.left>=d.offset.left,l=u.offset.left+u.width<=d.width+d.offset.left;}else a=u.offset.top+u.height<=u.windowDims.height+u.windowDims.offset.top,o=u.offset.top>=u.windowDims.offset.top,r=u.offset.left>=u.windowDims.offset.left,l=u.offset.left+u.width<=u.windowDims.width;var h=[a,o,r,l];return n?r===l==!0:s?o===a==!0:-1===h.indexOf(!1);}function i(t,e){if(t=t.length?t[0]:t,t===window||t===document)throw new Error(\"I'm sorry, Dave. I'm afraid I can't do that.\");var i=t.getBoundingClientRect(),n=t.parentNode.getBoundingClientRect(),s=document.body.getBoundingClientRect(),o=window.pageYOffset,a=window.pageXOffset;return{width:i.width,height:i.height,offset:{top:i.top+o,left:i.left+a},parentDims:{width:n.width,height:n.height,offset:{top:n.top+o,left:n.left+a}},windowDims:{width:s.width,height:s.height,offset:{top:o,left:a}}};}function n(t,e,n,s,o,a){var r=i(t),l=e?i(e):null;switch(n){case\"top\":return{left:Foundation.rtl()?l.offset.left-r.width+l.width:l.offset.left,top:l.offset.top-(r.height+s)};case\"left\":return{left:l.offset.left-(r.width+o),top:l.offset.top};case\"right\":return{left:l.offset.left+l.width+o,top:l.offset.top};case\"center top\":return{left:l.offset.left+l.width/2-r.width/2,top:l.offset.top-(r.height+s)};case\"center bottom\":return{left:a?o:l.offset.left+l.width/2-r.width/2,top:l.offset.top+l.height+s};case\"center left\":return{left:l.offset.left-(r.width+o),top:l.offset.top+l.height/2-r.height/2};case\"center right\":return{left:l.offset.left+l.width+o+1,top:l.offset.top+l.height/2-r.height/2};case\"center\":return{left:r.windowDims.offset.left+r.windowDims.width/2-r.width/2,top:r.windowDims.offset.top+r.windowDims.height/2-r.height/2};case\"reveal\":return{left:(r.windowDims.width-r.width)/2,top:r.windowDims.offset.top+s};case\"reveal full\":return{left:r.windowDims.offset.left,top:r.windowDims.offset.top};case\"left bottom\":return{left:l.offset.left-(r.width+o),top:l.offset.top+l.height};case\"right bottom\":return{left:l.offset.left+l.width+o-r.width,top:l.offset.top+l.height};default:return{left:Foundation.rtl()?l.offset.left-r.width+l.width:l.offset.left,top:l.offset.top+l.height+s};}}Foundation.Box={ImNotTouchingYou:e,GetDimensions:i,GetOffsets:n};}(jQuery),!function(t){function e(t){var e={};for(var i in t){e[t[i]]=t[i];}return e;}var i={9:\"TAB\",13:\"ENTER\",27:\"ESCAPE\",32:\"SPACE\",37:\"ARROW_LEFT\",38:\"ARROW_UP\",39:\"ARROW_RIGHT\",40:\"ARROW_DOWN\"},n={},s={keys:e(i),parseKey:function parseKey(t){var e=i[t.which||t.keyCode]||String.fromCharCode(t.which).toUpperCase();return t.shiftKey&&(e=\"SHIFT_\"+e),t.ctrlKey&&(e=\"CTRL_\"+e),t.altKey&&(e=\"ALT_\"+e),e;},handleKey:function handleKey(e,i,s){var o,a,r,l=n[i],u=this.parseKey(e);if(!l)return console.warn(\"Component not defined!\");if(o=\"undefined\"==typeof l.ltr?l:Foundation.rtl()?t.extend({},l.ltr,l.rtl):t.extend({},l.rtl,l.ltr),a=o[u],r=s[a],r&&\"function\"==typeof r){var d=r.apply();(s.handled||\"function\"==typeof s.handled)&&s.handled(d);}else(s.unhandled||\"function\"==typeof s.unhandled)&&s.unhandled();},findFocusable:function findFocusable(e){return e.find(\"a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]\").filter(function(){return t(this).is(\":visible\")&&!(t(this).attr(\"tabindex\")<0);});},register:function register(t,e){n[t]=e;}};Foundation.Keyboard=s;}(jQuery),!function(t){function e(t){var e={};return\"string\"!=typeof t?e:(t=t.trim().slice(1,-1))?e=t.split(\"&\").reduce(function(t,e){var i=e.replace(/\\+/g,\" \").split(\"=\"),n=i[0],s=i[1];return n=decodeURIComponent(n),s=void 0===s?null:decodeURIComponent(s),t.hasOwnProperty(n)?Array.isArray(t[n])?t[n].push(s):t[n]=[t[n],s]:t[n]=s,t;},{}):e;}var i={queries:[],current:\"\",_init:function _init(){var i,n=this,s=t(\".foundation-mq\").css(\"font-family\");i=e(s);for(var o in i){i.hasOwnProperty(o)&&n.queries.push({name:o,value:\"only screen and (min-width: \"+i[o]+\")\"});}this.current=this._getCurrentSize(),this._watcher();},atLeast:function atLeast(t){var e=this.get(t);return e?window.matchMedia(e).matches:!1;},get:function get(t){for(var e in this.queries){if(this.queries.hasOwnProperty(e)){var i=this.queries[e];if(t===i.name)return i.value;}}return null;},_getCurrentSize:function _getCurrentSize(){for(var t,e=0;e<this.queries.length;e++){var i=this.queries[e];window.matchMedia(i.value).matches&&(t=i);}return\"object\"==(typeof t===\"undefined\"?\"undefined\":_typeof(t))?t.name:t;},_watcher:function _watcher(){var e=this;t(window).on(\"resize.zf.mediaquery\",function(){var i=e._getCurrentSize(),n=e.current;i!==n&&(e.current=i,t(window).trigger(\"changed.zf.mediaquery\",[i,n]));});}};Foundation.MediaQuery=i,window.matchMedia||(window.matchMedia=function(){\"use strict\";var t=window.styleMedia||window.media;if(!t){var e=document.createElement(\"style\"),i=document.getElementsByTagName(\"script\")[0],n=null;e.type=\"text/css\",e.id=\"matchmediajs-test\",i.parentNode.insertBefore(e,i),n=\"getComputedStyle\"in window&&window.getComputedStyle(e,null)||e.currentStyle,t={matchMedium:function matchMedium(t){var i=\"@media \"+t+\"{ #matchmediajs-test { width: 1px; } }\";return e.styleSheet?e.styleSheet.cssText=i:e.textContent=i,\"1px\"===n.width;}};}return function(e){return{matches:t.matchMedium(e||\"all\"),media:e||\"all\"};};}()),Foundation.MediaQuery=i;}(jQuery),!function(t){function e(t,e,i){function n(r){a||(a=window.performance.now()),o=r-a,i.apply(e),t>o?s=window.requestAnimationFrame(n,e):(window.cancelAnimationFrame(s),e.trigger(\"finished.zf.animate\",[e]).triggerHandler(\"finished.zf.animate\",[e]));}var s,o,a=null;s=window.requestAnimationFrame(n);}function i(e,i,o,a){function r(){e||i.hide(),l(),a&&a.apply(i);}function l(){i[0].style.transitionDuration=0,i.removeClass(u+\" \"+d+\" \"+o);}if(i=t(i).eq(0),i.length){var u=e?n[0]:n[1],d=e?s[0]:s[1];l(),i.addClass(o).css(\"transition\",\"none\"),requestAnimationFrame(function(){i.addClass(u),e&&i.show();}),requestAnimationFrame(function(){i[0].offsetWidth,i.css(\"transition\",\"\").addClass(d);}),i.one(Foundation.transitionend(i),r);}}var n=[\"mui-enter\",\"mui-leave\"],s=[\"mui-enter-active\",\"mui-leave-active\"],o={animateIn:function animateIn(t,e,n){i(!0,t,e,n);},animateOut:function animateOut(t,e,n){i(!1,t,e,n);}};Foundation.Move=e,Foundation.Motion=o;}(jQuery),!function(t){var e={Feather:function Feather(e){var i=arguments.length<=1||void 0===arguments[1]?\"zf\":arguments[1];e.attr(\"role\",\"menubar\");var n=e.find(\"li\").attr({role:\"menuitem\"}),s=\"is-\"+i+\"-submenu\",o=s+\"-item\",a=\"is-\"+i+\"-submenu-parent\";e.find(\"a:first\").attr(\"tabindex\",0),n.each(function(){var e=t(this),i=e.children(\"ul\");i.length&&(e.addClass(a).attr({\"aria-haspopup\":!0,\"aria-expanded\":!1,\"aria-label\":e.children(\"a:first\").text()}),i.addClass(\"submenu \"+s).attr({\"data-submenu\":\"\",\"aria-hidden\":!0,role:\"menu\"})),e.parent(\"[data-submenu]\").length&&e.addClass(\"is-submenu-item \"+o);});},Burn:function Burn(t,e){var i=(t.find(\"li\").removeAttr(\"tabindex\"),\"is-\"+e+\"-submenu\"),n=i+\"-item\",s=\"is-\"+e+\"-submenu-parent\";t.find(\"*\").removeClass(i+\" \"+n+\" \"+s+\" is-submenu-item submenu is-active\").removeAttr(\"data-submenu\").css(\"display\",\"\");}};Foundation.Nest=e;}(jQuery),!function(t){function e(t,e,i){var n,s,o=this,a=e.duration,r=Object.keys(t.data())[0]||\"timer\",l=-1;this.isPaused=!1,this.restart=function(){l=-1,clearTimeout(s),this.start();},this.start=function(){this.isPaused=!1,clearTimeout(s),l=0>=l?a:l,t.data(\"paused\",!1),n=Date.now(),s=setTimeout(function(){e.infinite&&o.restart(),i();},l),t.trigger(\"timerstart.zf.\"+r);},this.pause=function(){this.isPaused=!0,clearTimeout(s),t.data(\"paused\",!0);var e=Date.now();l-=e-n,t.trigger(\"timerpaused.zf.\"+r);};}function i(e,i){function n(){s--,0===s&&i();}var s=e.length;0===s&&i(),e.each(function(){this.complete?n():\"undefined\"!=typeof this.naturalWidth&&this.naturalWidth>0?n():t(this).one(\"load\",function(){n();});});}Foundation.Timer=e,Foundation.onImagesLoaded=i;}(jQuery),function(t){function e(){this.removeEventListener(\"touchmove\",i),this.removeEventListener(\"touchend\",e),u=!1;}function i(i){if(t.spotSwipe.preventDefault&&i.preventDefault(),u){var n,s=i.touches[0].pageX,a=(i.touches[0].pageY,o-s);l=new Date().getTime()-r,Math.abs(a)>=t.spotSwipe.moveThreshold&&l<=t.spotSwipe.timeThreshold&&(n=a>0?\"left\":\"right\"),n&&(i.preventDefault(),e.call(this),t(this).trigger(\"swipe\",n).trigger(\"swipe\"+n));}}function n(t){1==t.touches.length&&(o=t.touches[0].pageX,a=t.touches[0].pageY,u=!0,r=new Date().getTime(),this.addEventListener(\"touchmove\",i,!1),this.addEventListener(\"touchend\",e,!1));}function s(){this.addEventListener&&this.addEventListener(\"touchstart\",n,!1);}t.spotSwipe={version:\"1.0.0\",enabled:\"ontouchstart\"in document.documentElement,preventDefault:!1,moveThreshold:75,timeThreshold:200};var o,a,r,l,u=!1;t.event.special.swipe={setup:s},t.each([\"left\",\"up\",\"down\",\"right\"],function(){t.event.special[\"swipe\"+this]={setup:function setup(){t(this).on(\"swipe\",t.noop);}};});}(jQuery),!function(t){t.fn.addTouch=function(){this.each(function(i,n){t(n).bind(\"touchstart touchmove touchend touchcancel\",function(){e(event);});});var e=function e(t){var e,i=t.changedTouches,n=i[0],s={touchstart:\"mousedown\",touchmove:\"mousemove\",touchend:\"mouseup\"},o=s[t.type];\"MouseEvent\"in window&&\"function\"==typeof window.MouseEvent?e=new window.MouseEvent(o,{bubbles:!0,cancelable:!0,screenX:n.screenX,screenY:n.screenY,clientX:n.clientX,clientY:n.clientY}):(e=document.createEvent(\"MouseEvent\"),e.initMouseEvent(o,!0,!0,window,1,n.screenX,n.screenY,n.clientX,n.clientY,!1,!1,!1,!1,0,null)),n.target.dispatchEvent(e);};};}(jQuery),!function(t){function e(){o(),n(),s(),i();}function i(e){var i=t(\"[data-yeti-box]\"),n=[\"dropdown\",\"tooltip\",\"reveal\"];if(e&&(\"string\"==typeof e?n.push(e):\"object\"==(typeof e===\"undefined\"?\"undefined\":_typeof(e))&&\"string\"==typeof e[0]?n.concat(e):console.error(\"Plugin names must be strings\")),i.length){var s=n.map(function(t){return\"closeme.zf.\"+t;}).join(\" \");t(window).off(s).on(s,function(e,i){var n=e.namespace.split(\".\")[0],s=t(\"[data-\"+n+\"]\").not('[data-yeti-box=\"'+i+'\"]');s.each(function(){var e=t(this);e.triggerHandler(\"close.zf.trigger\",[e]);});});}}function n(e){var i=void 0,n=t(\"[data-resize]\");n.length&&t(window).off(\"resize.zf.trigger\").on(\"resize.zf.trigger\",function(s){i&&clearTimeout(i),i=setTimeout(function(){a||n.each(function(){t(this).triggerHandler(\"resizeme.zf.trigger\");}),n.attr(\"data-events\",\"resize\");},e||10);});}function s(e){var i=void 0,n=t(\"[data-scroll]\");n.length&&t(window).off(\"scroll.zf.trigger\").on(\"scroll.zf.trigger\",function(s){i&&clearTimeout(i),i=setTimeout(function(){a||n.each(function(){t(this).triggerHandler(\"scrollme.zf.trigger\");}),n.attr(\"data-events\",\"scroll\");},e||10);});}function o(){if(!a)return!1;var e=document.querySelectorAll(\"[data-resize], [data-scroll], [data-mutate]\"),i=function i(e){var i=t(e[0].target);switch(i.attr(\"data-events\")){case\"resize\":i.triggerHandler(\"resizeme.zf.trigger\",[i]);break;case\"scroll\":i.triggerHandler(\"scrollme.zf.trigger\",[i,window.pageYOffset]);break;default:return!1;}};if(e.length)for(var n=0;n<=e.length-1;n++){var s=new a(i);s.observe(e[n],{attributes:!0,childList:!1,characterData:!1,subtree:!1,attributeFilter:[\"data-events\"]});}}var a=function(){for(var t=[\"WebKit\",\"Moz\",\"O\",\"Ms\",\"\"],e=0;e<t.length;e++){if(t[e]+\"MutationObserver\"in window)return window[t[e]+\"MutationObserver\"];}return!1;}(),r=function r(e,i){e.data(i).split(\" \").forEach(function(n){t(\"#\"+n)[\"close\"===i?\"trigger\":\"triggerHandler\"](i+\".zf.trigger\",[e]);});};t(document).on(\"click.zf.trigger\",\"[data-open]\",function(){r(t(this),\"open\");}),t(document).on(\"click.zf.trigger\",\"[data-close]\",function(){var e=t(this).data(\"close\");e?r(t(this),\"close\"):t(this).trigger(\"close.zf.trigger\");}),t(document).on(\"click.zf.trigger\",\"[data-toggle]\",function(){r(t(this),\"toggle\");}),t(document).on(\"close.zf.trigger\",\"[data-closable]\",function(e){e.stopPropagation();var i=t(this).data(\"closable\");\"\"!==i?Foundation.Motion.animateOut(t(this),i,function(){t(this).trigger(\"closed.zf\");}):t(this).fadeOut().trigger(\"closed.zf\");}),t(document).on(\"focus.zf.trigger blur.zf.trigger\",\"[data-toggle-focus]\",function(){var e=t(this).data(\"toggle-focus\");t(\"#\"+e).triggerHandler(\"toggle.zf.trigger\",[t(this)]);}),t(window).load(function(){e();}),Foundation.IHearYou=e;}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i){var n=arguments.length<=1||void 0===arguments[1]?{}:arguments[1];_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Abide\");}return _createClass(e,[{key:\"_init\",value:function value(){this.$inputs=this.$element.find(\"input, textarea, select\"),this._events();}},{key:\"_events\",value:function value(){var e=this;this.$element.off(\".abide\").on(\"reset.zf.abide\",function(){e.resetForm();}).on(\"submit.zf.abide\",function(){return e.validateForm();}),\"fieldChange\"===this.options.validateOn&&this.$inputs.off(\"change.zf.abide\").on(\"change.zf.abide\",function(i){e.validateInput(t(i.target));}),this.options.liveValidate&&this.$inputs.off(\"input.zf.abide\").on(\"input.zf.abide\",function(i){e.validateInput(t(i.target));});}},{key:\"_reflow\",value:function value(){this._init();}},{key:\"requiredCheck\",value:function value(t){if(!t.attr(\"required\"))return!0;var e=!0;switch(t[0].type){case\"checkbox\":e=t[0].checked;break;case\"select\":case\"select-one\":case\"select-multiple\":var i=t.find(\"option:selected\");i.length&&i.val()||(e=!1);break;default:t.val()&&t.val().length||(e=!1);}return e;}},{key:\"findFormError\",value:function value(t){var e=t.siblings(this.options.formErrorSelector);return e.length||(e=t.parent().find(this.options.formErrorSelector)),e;}},{key:\"findLabel\",value:function value(t){var e=t[0].id,i=this.$element.find('label[for=\"'+e+'\"]');return i.length?i:t.closest(\"label\");}},{key:\"findRadioLabels\",value:function value(e){var i=this,n=e.map(function(e,n){var s=n.id,o=i.$element.find('label[for=\"'+s+'\"]');return o.length||(o=t(n).closest(\"label\")),o[0];});return t(n);}},{key:\"addErrorClasses\",value:function value(t){var e=this.findLabel(t),i=this.findFormError(t);e.length&&e.addClass(this.options.labelErrorClass),i.length&&i.addClass(this.options.formErrorClass),t.addClass(this.options.inputErrorClass).attr(\"data-invalid\",\"\");}},{key:\"removeRadioErrorClasses\",value:function value(t){var e=this.$element.find(':radio[name=\"'+t+'\"]'),i=this.findRadioLabels(e),n=this.findFormError(e);i.length&&i.removeClass(this.options.labelErrorClass),n.length&&n.removeClass(this.options.formErrorClass),e.removeClass(this.options.inputErrorClass).removeAttr(\"data-invalid\");}},{key:\"removeErrorClasses\",value:function value(t){if(\"radio\"==t[0].type)return this.removeRadioErrorClasses(t.attr(\"name\"));var e=this.findLabel(t),i=this.findFormError(t);e.length&&e.removeClass(this.options.labelErrorClass),i.length&&i.removeClass(this.options.formErrorClass),t.removeClass(this.options.inputErrorClass).removeAttr(\"data-invalid\");}},{key:\"validateInput\",value:function value(t){var e=this.requiredCheck(t),i=!1,n=!0,s=t.attr(\"data-validator\"),o=!0;if(t.is(\"[data-abide-ignore]\")||t.is('[type=\"hidden\"]'))return!0;switch(t[0].type){case\"radio\":i=this.validateRadio(t.attr(\"name\"));break;case\"checkbox\":i=e;break;case\"select\":case\"select-one\":case\"select-multiple\":i=e;break;default:i=this.validateText(t);}s&&(n=this.matchValidation(t,s,t.attr(\"required\"))),t.attr(\"data-equalto\")&&(o=this.options.validators.equalTo(t));var a=-1===[e,i,n,o].indexOf(!1),r=(a?\"valid\":\"invalid\")+\".zf.abide\";return this[a?\"removeErrorClasses\":\"addErrorClasses\"](t),t.trigger(r,[t]),a;}},{key:\"validateForm\",value:function value(){var e=[],i=this;this.$inputs.each(function(){e.push(i.validateInput(t(this)));});var n=-1===e.indexOf(!1);return this.$element.find(\"[data-abide-error]\").css(\"display\",n?\"none\":\"block\"),this.$element.trigger((n?\"formvalid\":\"forminvalid\")+\".zf.abide\",[this.$element]),n;}},{key:\"validateText\",value:function value(t,e){e=e||t.attr(\"pattern\")||t.attr(\"type\");var i=t.val(),n=!1;return i.length?n=this.options.patterns.hasOwnProperty(e)?this.options.patterns[e].test(i):e!==t.attr(\"type\")?new RegExp(e).test(i):!0:t.prop(\"required\")||(n=!0),n;}},{key:\"validateRadio\",value:function value(e){var i=this.$element.find(':radio[name=\"'+e+'\"]'),n=!1,s=!1;return i.each(function(e,i){t(i).attr(\"required\")&&(s=!0);}),s||(n=!0),n||i.each(function(e,i){t(i).prop(\"checked\")&&(n=!0);}),n;}},{key:\"matchValidation\",value:function value(t,e,i){var n=this;i=!!i;var s=e.split(\" \").map(function(e){return n.options.validators[e](t,i,t.parent());});return-1===s.indexOf(!1);}},{key:\"resetForm\",value:function value(){var e=this.$element,i=this.options;t(\".\"+i.labelErrorClass,e).not(\"small\").removeClass(i.labelErrorClass),t(\".\"+i.inputErrorClass,e).not(\"small\").removeClass(i.inputErrorClass),t(i.formErrorSelector+\".\"+i.formErrorClass).removeClass(i.formErrorClass),e.find(\"[data-abide-error]\").css(\"display\",\"none\"),t(\":input\",e).not(\":button, :submit, :reset, :hidden, :radio, :checkbox, [data-abide-ignore]\").val(\"\").removeAttr(\"data-invalid\"),t(\":input:radio\",e).not(\"[data-abide-ignore]\").prop(\"checked\",!1).removeAttr(\"data-invalid\"),t(\":input:checkbox\",e).not(\"[data-abide-ignore]\").prop(\"checked\",!1).removeAttr(\"data-invalid\"),e.trigger(\"formreset.zf.abide\",[e]);}},{key:\"destroy\",value:function value(){var e=this;this.$element.off(\".abide\").find(\"[data-abide-error]\").css(\"display\",\"none\"),this.$inputs.off(\".abide\").each(function(){e.removeErrorClasses(t(this));}),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={validateOn:\"fieldChange\",labelErrorClass:\"is-invalid-label\",inputErrorClass:\"is-invalid-input\",formErrorSelector:\".form-error\",formErrorClass:\"is-visible\",liveValidate:!1,patterns:{alpha:/^[a-zA-Z]+$/,alpha_numeric:/^[a-zA-Z0-9]+$/,integer:/^[-+]?\\d+$/,number:/^[-+]?\\d*(?:[\\.\\,]\\d+)?$/,card:/^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\\d{3})\\d{11})$/,cvv:/^([0-9]){3,4}$/,email:/^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$/,url:/^(https?|ftp|file|ssh):\\/\\/(((([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:)*@)?(((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5]))|((([a-zA-Z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-zA-Z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-zA-Z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-zA-Z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-zA-Z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-zA-Z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?)(:\\d*)?)(\\/((([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)+(\\/(([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)*)*)?)?(\\?((([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|[\\uE000-\\uF8FF]|\\/|\\?)*)?(\\#((([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|\\/|\\?)*)?$/,domain:/^([a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,8}$/,datetime:/^([0-2][0-9]{3})\\-([0-1][0-9])\\-([0-3][0-9])T([0-5][0-9])\\:([0-5][0-9])\\:([0-5][0-9])(Z|([\\-\\+]([0-1][0-9])\\:00))$/,date:/(?:19|20)[0-9]{2}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-9])|(?:(?!02)(?:0[1-9]|1[0-2])-(?:30))|(?:(?:0[13578]|1[02])-31))$/,time:/^(0[0-9]|1[0-9]|2[0-3])(:[0-5][0-9]){2}$/,dateISO:/^\\d{4}[\\/\\-]\\d{1,2}[\\/\\-]\\d{1,2}$/,month_day_year:/^(0[1-9]|1[012])[- \\/.](0[1-9]|[12][0-9]|3[01])[- \\/.]\\d{4}$/,day_month_year:/^(0[1-9]|[12][0-9]|3[01])[- \\/.](0[1-9]|1[012])[- \\/.]\\d{4}$/,color:/^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/},validators:{equalTo:function equalTo(e,i,n){return t(\"#\"+e.attr(\"data-equalto\")).val()===e.val();}}},Foundation.plugin(e,\"Abide\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Accordion\"),Foundation.Keyboard.register(\"Accordion\",{ENTER:\"toggle\",SPACE:\"toggle\",ARROW_DOWN:\"next\",ARROW_UP:\"previous\"});}return _createClass(e,[{key:\"_init\",value:function value(){this.$element.attr(\"role\",\"tablist\"),this.$tabs=this.$element.children(\"li, [data-accordion-item]\"),this.$tabs.each(function(e,i){var n=t(i),s=n.children(\"[data-tab-content]\"),o=s[0].id||Foundation.GetYoDigits(6,\"accordion\"),a=i.id||o+\"-label\";n.find(\"a:first\").attr({\"aria-controls\":o,role:\"tab\",id:a,\"aria-expanded\":!1,\"aria-selected\":!1}),s.attr({role:\"tabpanel\",\"aria-labelledby\":a,\"aria-hidden\":!0,id:o});});var e=this.$element.find(\".is-active\").children(\"[data-tab-content]\");e.length&&this.down(e,!0),this._events();}},{key:\"_events\",value:function value(){var e=this;this.$tabs.each(function(){var i=t(this),n=i.children(\"[data-tab-content]\");n.length&&i.children(\"a\").off(\"click.zf.accordion keydown.zf.accordion\").on(\"click.zf.accordion\",function(t){t.preventDefault(),i.hasClass(\"is-active\")?(e.options.allowAllClosed||i.siblings().hasClass(\"is-active\"))&&e.up(n):e.down(n);}).on(\"keydown.zf.accordion\",function(t){Foundation.Keyboard.handleKey(t,\"Accordion\",{toggle:function toggle(){e.toggle(n);},next:function next(){var t=i.next().find(\"a\").focus();e.options.multiExpand||t.trigger(\"click.zf.accordion\");},previous:function previous(){var t=i.prev().find(\"a\").focus();e.options.multiExpand||t.trigger(\"click.zf.accordion\");},handled:function handled(){t.preventDefault(),t.stopPropagation();}});});});}},{key:\"toggle\",value:function value(t){if(t.parent().hasClass(\"is-active\")){if(!this.options.allowAllClosed&&!t.parent().siblings().hasClass(\"is-active\"))return;this.up(t);}else this.down(t);}},{key:\"down\",value:function value(e,i){var n=this;if(!this.options.multiExpand&&!i){var s=this.$element.children(\".is-active\").children(\"[data-tab-content]\");s.length&&this.up(s);}e.attr(\"aria-hidden\",!1).parent(\"[data-tab-content]\").addBack().parent().addClass(\"is-active\"),e.slideDown(this.options.slideSpeed,function(){n.$element.trigger(\"down.zf.accordion\",[e]);}),t(\"#\"+e.attr(\"aria-labelledby\")).attr({\"aria-expanded\":!0,\"aria-selected\":!0});}},{key:\"up\",value:function value(e){var i=e.parent().siblings(),n=this,s=this.options.multiExpand?i.hasClass(\"is-active\"):e.parent().hasClass(\"is-active\");(this.options.allowAllClosed||s)&&(e.slideUp(n.options.slideSpeed,function(){n.$element.trigger(\"up.zf.accordion\",[e]);}),e.attr(\"aria-hidden\",!0).parent().removeClass(\"is-active\"),t(\"#\"+e.attr(\"aria-labelledby\")).attr({\"aria-expanded\":!1,\"aria-selected\":!1}));}},{key:\"destroy\",value:function value(){this.$element.find(\"[data-tab-content]\").stop(!0).slideUp(0).css(\"display\",\"\"),this.$element.find(\"a\").off(\".zf.accordion\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={slideSpeed:250,multiExpand:!1,allowAllClosed:!1},Foundation.plugin(e,\"Accordion\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),Foundation.Nest.Feather(this.$element,\"accordion\"),this._init(),Foundation.registerPlugin(this,\"AccordionMenu\"),Foundation.Keyboard.register(\"AccordionMenu\",{ENTER:\"toggle\",SPACE:\"toggle\",ARROW_RIGHT:\"open\",ARROW_UP:\"up\",ARROW_DOWN:\"down\",ARROW_LEFT:\"close\",ESCAPE:\"closeAll\",TAB:\"down\",SHIFT_TAB:\"up\"});}return _createClass(e,[{key:\"_init\",value:function value(){this.$element.find(\"[data-submenu]\").not(\".is-active\").slideUp(0),this.$element.attr({role:\"tablist\",\"aria-multiselectable\":this.options.multiOpen}),this.$menuLinks=this.$element.find(\".is-accordion-submenu-parent\"),this.$menuLinks.each(function(){var e=this.id||Foundation.GetYoDigits(6,\"acc-menu-link\"),i=t(this),n=i.children(\"[data-submenu]\"),s=n[0].id||Foundation.GetYoDigits(6,\"acc-menu\"),o=n.hasClass(\"is-active\");i.attr({\"aria-controls\":s,\"aria-expanded\":o,role:\"tab\",id:e}),n.attr({\"aria-labelledby\":e,\"aria-hidden\":!o,role:\"tabpanel\",id:s});});var e=this.$element.find(\".is-active\");if(e.length){var i=this;e.each(function(){i.down(t(this));});}this._events();}},{key:\"_events\",value:function value(){var e=this;this.$element.find(\"li\").each(function(){var i=t(this).children(\"[data-submenu]\");i.length&&t(this).children(\"a\").off(\"click.zf.accordionMenu\").on(\"click.zf.accordionMenu\",function(t){t.preventDefault(),e.toggle(i);});}).on(\"keydown.zf.accordionmenu\",function(i){var n,s,o=t(this),a=o.parent(\"ul\").children(\"li\"),r=o.children(\"[data-submenu]\");a.each(function(e){return t(this).is(o)?(n=a.eq(Math.max(0,e-1)).find(\"a\").first(),s=a.eq(Math.min(e+1,a.length-1)).find(\"a\").first(),t(this).children(\"[data-submenu]:visible\").length&&(s=o.find(\"li:first-child\").find(\"a\").first()),t(this).is(\":first-child\")?n=o.parents(\"li\").first().find(\"a\").first():n.children(\"[data-submenu]:visible\").length&&(n=n.find(\"li:last-child\").find(\"a\").first()),void(t(this).is(\":last-child\")&&(s=o.parents(\"li\").first().next(\"li\").find(\"a\").first()))):void 0;}),Foundation.Keyboard.handleKey(i,\"AccordionMenu\",{open:function open(){r.is(\":hidden\")&&(e.down(r),r.find(\"li\").first().find(\"a\").first().focus());},close:function close(){r.length&&!r.is(\":hidden\")?e.up(r):o.parent(\"[data-submenu]\").length&&(e.up(o.parent(\"[data-submenu]\")),o.parents(\"li\").first().find(\"a\").first().focus());},up:function up(){return n.attr(\"tabindex\",-1).focus(),!0;},down:function down(){return s.attr(\"tabindex\",-1).focus(),!0;},toggle:function toggle(){o.children(\"[data-submenu]\").length&&e.toggle(o.children(\"[data-submenu]\"));},closeAll:function closeAll(){e.hideAll();},handled:function handled(t){t&&i.preventDefault(),i.stopImmediatePropagation();}});});}},{key:\"hideAll\",value:function value(){this.$element.find(\"[data-submenu]\").slideUp(this.options.slideSpeed);}},{key:\"toggle\",value:function value(t){t.is(\":animated\")||(t.is(\":hidden\")?this.down(t):this.up(t));}},{key:\"down\",value:function value(t){var e=this;this.options.multiOpen||this.up(this.$element.find(\".is-active\").not(t.parentsUntil(this.$element).add(t))),t.addClass(\"is-active\").attr({\"aria-hidden\":!1}).parent(\".is-accordion-submenu-parent\").attr({\"aria-expanded\":!0}),t.slideDown(e.options.slideSpeed,function(){e.$element.trigger(\"down.zf.accordionMenu\",[t]);});}},{key:\"up\",value:function value(t){var e=this;t.slideUp(e.options.slideSpeed,function(){e.$element.trigger(\"up.zf.accordionMenu\",[t]);});var i=t.find(\"[data-submenu]\").slideUp(0).addBack().attr(\"aria-hidden\",!0);i.parent(\".is-accordion-submenu-parent\").attr(\"aria-expanded\",!1);}},{key:\"destroy\",value:function value(){this.$element.find(\"[data-submenu]\").slideDown(0).css(\"display\",\"\"),this.$element.find(\"a\").off(\"click.zf.accordionMenu\"),Foundation.Nest.Burn(this.$element,\"accordion\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={slideSpeed:250,multiOpen:!0},Foundation.plugin(e,\"AccordionMenu\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),Foundation.Nest.Feather(this.$element,\"drilldown\"),this._init(),Foundation.registerPlugin(this,\"Drilldown\"),Foundation.Keyboard.register(\"Drilldown\",{ENTER:\"open\",SPACE:\"open\",ARROW_RIGHT:\"next\",ARROW_UP:\"up\",ARROW_DOWN:\"down\",ARROW_LEFT:\"previous\",ESCAPE:\"close\",TAB:\"down\",SHIFT_TAB:\"up\"});}return _createClass(e,[{key:\"_init\",value:function value(){this.$submenuAnchors=this.$element.find(\"li.is-drilldown-submenu-parent\").children(\"a\"),this.$submenus=this.$submenuAnchors.parent(\"li\").children(\"[data-submenu]\"),this.$menuItems=this.$element.find(\"li\").not(\".js-drilldown-back\").attr(\"role\",\"menuitem\").find(\"a\"),this._prepareMenu(),this._keyboardEvents();}},{key:\"_prepareMenu\",value:function value(){var e=this;this.$submenuAnchors.each(function(){var i=t(this),n=i.parent();e.options.parentLink&&i.clone().prependTo(n.children(\"[data-submenu]\")).wrap('<li class=\"is-submenu-parent-item is-submenu-item is-drilldown-submenu-item\" role=\"menu-item\"></li>'),i.data(\"savedHref\",i.attr(\"href\")).removeAttr(\"href\"),i.children(\"[data-submenu]\").attr({\"aria-hidden\":!0,tabindex:0,role:\"menu\"}),e._events(i);}),this.$submenus.each(function(){var i=t(this),n=i.find(\".js-drilldown-back\");n.length||i.prepend(e.options.backButton),e._back(i);}),this.$element.parent().hasClass(\"is-drilldown\")||(this.$wrapper=t(this.options.wrapper).addClass(\"is-drilldown\"),this.$wrapper=this.$element.wrap(this.$wrapper).parent().css(this._getMaxDims()));}},{key:\"_events\",value:function value(e){var i=this;e.off(\"click.zf.drilldown\").on(\"click.zf.drilldown\",function(n){if(t(n.target).parentsUntil(\"ul\",\"li\").hasClass(\"is-drilldown-submenu-parent\")&&(n.stopImmediatePropagation(),n.preventDefault()),i._show(e.parent(\"li\")),i.options.closeOnClick){var s=t(\"body\");s.off(\".zf.drilldown\").on(\"click.zf.drilldown\",function(e){e.target===i.$element[0]||t.contains(i.$element[0],e.target)||(e.preventDefault(),i._hideAll(),s.off(\".zf.drilldown\"));});}});}},{key:\"_keyboardEvents\",value:function value(){var e=this;this.$menuItems.add(this.$element.find(\".js-drilldown-back > a\")).on(\"keydown.zf.drilldown\",function(i){var n,s,o=t(this),a=o.parent(\"li\").parent(\"ul\").children(\"li\").children(\"a\");a.each(function(e){return t(this).is(o)?(n=a.eq(Math.max(0,e-1)),void(s=a.eq(Math.min(e+1,a.length-1)))):void 0;}),Foundation.Keyboard.handleKey(i,\"Drilldown\",{next:function next(){return o.is(e.$submenuAnchors)?(e._show(o.parent(\"li\")),o.parent(\"li\").one(Foundation.transitionend(o),function(){o.parent(\"li\").find(\"ul li a\").filter(e.$menuItems).first().focus();}),!0):void 0;},previous:function previous(){return e._hide(o.parent(\"li\").parent(\"ul\")),o.parent(\"li\").parent(\"ul\").one(Foundation.transitionend(o),function(){setTimeout(function(){o.parent(\"li\").parent(\"ul\").parent(\"li\").children(\"a\").first().focus();},1);}),!0;},up:function up(){return n.focus(),!0;},down:function down(){return s.focus(),!0;},close:function close(){e._back();},open:function open(){return o.is(e.$menuItems)?o.is(e.$submenuAnchors)&&(e._show(o.parent(\"li\")),o.parent(\"li\").one(Foundation.transitionend(o),function(){o.parent(\"li\").find(\"ul li a\").filter(e.$menuItems).first().focus();})):(e._hide(o.parent(\"li\").parent(\"ul\")),o.parent(\"li\").parent(\"ul\").one(Foundation.transitionend(o),function(){setTimeout(function(){o.parent(\"li\").parent(\"ul\").parent(\"li\").children(\"a\").first().focus();},1);})),!0;},handled:function handled(t){t&&i.preventDefault(),i.stopImmediatePropagation();}});});}},{key:\"_hideAll\",value:function value(){var t=this.$element.find(\".is-drilldown-submenu.is-active\").addClass(\"is-closing\");t.one(Foundation.transitionend(t),function(e){t.removeClass(\"is-active is-closing\");}),this.$element.trigger(\"closed.zf.drilldown\");}},{key:\"_back\",value:function value(t){var e=this;t.off(\"click.zf.drilldown\"),t.children(\".js-drilldown-back\").on(\"click.zf.drilldown\",function(i){i.stopImmediatePropagation(),e._hide(t);});}},{key:\"_menuLinkEvents\",value:function value(){var t=this;this.$menuItems.not(\".is-drilldown-submenu-parent\").off(\"click.zf.drilldown\").on(\"click.zf.drilldown\",function(e){setTimeout(function(){t._hideAll();},0);});}},{key:\"_show\",value:function value(t){t.children(\"[data-submenu]\").addClass(\"is-active\"),this.$element.trigger(\"open.zf.drilldown\",[t]);}},{key:\"_hide\",value:function value(t){t.addClass(\"is-closing\").one(Foundation.transitionend(t),function(){t.removeClass(\"is-active is-closing\"),t.blur();}),t.trigger(\"hide.zf.drilldown\",[t]);}},{key:\"_getMaxDims\",value:function value(){var e=0,i={};return this.$submenus.add(this.$element).each(function(){var i=t(this).children(\"li\").length;e=i>e?i:e;}),i[\"min-height\"]=e*this.$menuItems[0].getBoundingClientRect().height+\"px\",i[\"max-width\"]=this.$element[0].getBoundingClientRect().width+\"px\",i;}},{key:\"destroy\",value:function value(){this._hideAll(),Foundation.Nest.Burn(this.$element,\"drilldown\"),this.$element.unwrap().find(\".js-drilldown-back, .is-submenu-parent-item\").remove().end().find(\".is-active, .is-closing, .is-drilldown-submenu\").removeClass(\"is-active is-closing is-drilldown-submenu\").end().find(\"[data-submenu]\").removeAttr(\"aria-hidden tabindex role\"),this.$submenuAnchors.each(function(){t(this).off(\".zf.drilldown\");}),this.$element.find(\"a\").each(function(){var e=t(this);e.data(\"savedHref\")&&e.attr(\"href\",e.data(\"savedHref\")).removeData(\"savedHref\");}),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={backButton:'<li class=\"js-drilldown-back\"><a tabindex=\"0\">Back</a></li>',wrapper:\"<div></div>\",parentLink:!1,closeOnClick:!1},Foundation.plugin(e,\"Drilldown\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Dropdown\"),Foundation.Keyboard.register(\"Dropdown\",{ENTER:\"open\",SPACE:\"open\",ESCAPE:\"close\",TAB:\"tab_forward\",SHIFT_TAB:\"tab_backward\"});}return _createClass(e,[{key:\"_init\",value:function value(){var e=this.$element.attr(\"id\");this.$anchor=t('[data-toggle=\"'+e+'\"]')||t('[data-open=\"'+e+'\"]'),this.$anchor.attr({\"aria-controls\":e,\"data-is-focus\":!1,\"data-yeti-box\":e,\"aria-haspopup\":!0,\"aria-expanded\":!1}),this.options.positionClass=this.getPositionClass(),this.counter=4,this.usedPositions=[],this.$element.attr({\"aria-hidden\":\"true\",\"data-yeti-box\":e,\"data-resize\":e,\"aria-labelledby\":this.$anchor[0].id||Foundation.GetYoDigits(6,\"dd-anchor\")}),this._events();}},{key:\"getPositionClass\",value:function value(){var t=this.$element[0].className.match(/(top|left|right|bottom)/g);t=t?t[0]:\"\";var e=/float-(\\S+)\\s/.exec(this.$anchor[0].className);e=e?e[1]:\"\";var i=e?e+\" \"+t:t;return i;}},{key:\"_reposition\",value:function value(t){this.usedPositions.push(t?t:\"bottom\"),!t&&this.usedPositions.indexOf(\"top\")<0?this.$element.addClass(\"top\"):\"top\"===t&&this.usedPositions.indexOf(\"bottom\")<0?this.$element.removeClass(t):\"left\"===t&&this.usedPositions.indexOf(\"right\")<0?this.$element.removeClass(t).addClass(\"right\"):\"right\"===t&&this.usedPositions.indexOf(\"left\")<0?this.$element.removeClass(t).addClass(\"left\"):!t&&this.usedPositions.indexOf(\"top\")>-1&&this.usedPositions.indexOf(\"left\")<0?this.$element.addClass(\"left\"):\"top\"===t&&this.usedPositions.indexOf(\"bottom\")>-1&&this.usedPositions.indexOf(\"left\")<0?this.$element.removeClass(t).addClass(\"left\"):\"left\"===t&&this.usedPositions.indexOf(\"right\")>-1&&this.usedPositions.indexOf(\"bottom\")<0?this.$element.removeClass(t):\"right\"===t&&this.usedPositions.indexOf(\"left\")>-1&&this.usedPositions.indexOf(\"bottom\")<0?this.$element.removeClass(t):this.$element.removeClass(t),this.classChanged=!0,this.counter--;}},{key:\"_setPosition\",value:function value(){if(\"false\"===this.$anchor.attr(\"aria-expanded\"))return!1;var t=this.getPositionClass(),e=Foundation.Box.GetDimensions(this.$element),i=(Foundation.Box.GetDimensions(this.$anchor),\"left\"===t?\"left\":\"right\"===t?\"left\":\"top\"),n=\"top\"===i?\"height\":\"width\";\"height\"===n?this.options.vOffset:this.options.hOffset;if(e.width>=e.windowDims.width||!this.counter&&!Foundation.Box.ImNotTouchingYou(this.$element))return this.$element.offset(Foundation.Box.GetOffsets(this.$element,this.$anchor,\"center bottom\",this.options.vOffset,this.options.hOffset,!0)).css({width:e.windowDims.width-2*this.options.hOffset,height:\"auto\"}),this.classChanged=!0,!1;for(this.$element.offset(Foundation.Box.GetOffsets(this.$element,this.$anchor,t,this.options.vOffset,this.options.hOffset));!Foundation.Box.ImNotTouchingYou(this.$element,!1,!0)&&this.counter;){this._reposition(t),this._setPosition();}}},{key:\"_events\",value:function value(){var e=this;this.$element.on({\"open.zf.trigger\":this.open.bind(this),\"close.zf.trigger\":this.close.bind(this),\"toggle.zf.trigger\":this.toggle.bind(this),\"resizeme.zf.trigger\":this._setPosition.bind(this)}),this.options.hover&&(this.$anchor.off(\"mouseenter.zf.dropdown mouseleave.zf.dropdown\").on(\"mouseenter.zf.dropdown\",function(){clearTimeout(e.timeout),e.timeout=setTimeout(function(){e.open(),e.$anchor.data(\"hover\",!0);},e.options.hoverDelay);}).on(\"mouseleave.zf.dropdown\",function(){clearTimeout(e.timeout),e.timeout=setTimeout(function(){e.close(),e.$anchor.data(\"hover\",!1);},e.options.hoverDelay);}),this.options.hoverPane&&this.$element.off(\"mouseenter.zf.dropdown mouseleave.zf.dropdown\").on(\"mouseenter.zf.dropdown\",function(){clearTimeout(e.timeout);}).on(\"mouseleave.zf.dropdown\",function(){clearTimeout(e.timeout),e.timeout=setTimeout(function(){e.close(),e.$anchor.data(\"hover\",!1);},e.options.hoverDelay);})),this.$anchor.add(this.$element).on(\"keydown.zf.dropdown\",function(i){var n=t(this),s=Foundation.Keyboard.findFocusable(e.$element);Foundation.Keyboard.handleKey(i,\"Dropdown\",{tab_forward:function tab_forward(){e.$element.find(\":focus\").is(s.eq(-1))&&(e.options.trapFocus?(s.eq(0).focus(),i.preventDefault()):e.close());},tab_backward:function tab_backward(){(e.$element.find(\":focus\").is(s.eq(0))||e.$element.is(\":focus\"))&&(e.options.trapFocus?(s.eq(-1).focus(),i.preventDefault()):e.close());},open:function open(){n.is(e.$anchor)&&(e.open(),e.$element.attr(\"tabindex\",-1).focus(),i.preventDefault());},close:function close(){e.close(),e.$anchor.focus();}});});}},{key:\"_addBodyHandler\",value:function value(){var e=t(document.body).not(this.$element),i=this;e.off(\"click.zf.dropdown\").on(\"click.zf.dropdown\",function(t){i.$anchor.is(t.target)||i.$anchor.find(t.target).length||i.$element.find(t.target).length||(i.close(),e.off(\"click.zf.dropdown\"));});}},{key:\"open\",value:function value(){if(this.$element.trigger(\"closeme.zf.dropdown\",this.$element.attr(\"id\")),this.$anchor.addClass(\"hover\").attr({\"aria-expanded\":!0}),this._setPosition(),this.$element.addClass(\"is-open\").attr({\"aria-hidden\":!1}),this.options.autoFocus){var t=Foundation.Keyboard.findFocusable(this.$element);t.length&&t.eq(0).focus();}this.options.closeOnClick&&this._addBodyHandler(),this.$element.trigger(\"show.zf.dropdown\",[this.$element]);}},{key:\"close\",value:function value(){if(!this.$element.hasClass(\"is-open\"))return!1;if(this.$element.removeClass(\"is-open\").attr({\"aria-hidden\":!0}),this.$anchor.removeClass(\"hover\").attr(\"aria-expanded\",!1),this.classChanged){var t=this.getPositionClass();t&&this.$element.removeClass(t),this.$element.addClass(this.options.positionClass).css({height:\"\",width:\"\"}),this.classChanged=!1,this.counter=4,this.usedPositions.length=0;}this.$element.trigger(\"hide.zf.dropdown\",[this.$element]);}},{key:\"toggle\",value:function value(){if(this.$element.hasClass(\"is-open\")){if(this.$anchor.data(\"hover\"))return;this.close();}else this.open();}},{key:\"destroy\",value:function value(){this.$element.off(\".zf.trigger\").hide(),this.$anchor.off(\".zf.dropdown\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={hoverDelay:250,hover:!1,hoverPane:!1,vOffset:1,hOffset:1,positionClass:\"\",trapFocus:!1,autoFocus:!1,closeOnClick:!1},Foundation.plugin(e,\"Dropdown\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),Foundation.Nest.Feather(this.$element,\"dropdown\"),this._init(),Foundation.registerPlugin(this,\"DropdownMenu\"),Foundation.Keyboard.register(\"DropdownMenu\",{ENTER:\"open\",SPACE:\"open\",ARROW_RIGHT:\"next\",ARROW_UP:\"up\",ARROW_DOWN:\"down\",ARROW_LEFT:\"previous\",ESCAPE:\"close\"});}return _createClass(e,[{key:\"_init\",value:function value(){var t=this.$element.find(\"li.is-dropdown-submenu-parent\");this.$element.children(\".is-dropdown-submenu-parent\").children(\".is-dropdown-submenu\").addClass(\"first-sub\"),this.$menuItems=this.$element.find('[role=\"menuitem\"]'),this.$tabs=this.$element.children('[role=\"menuitem\"]'),this.$tabs.find(\"ul.is-dropdown-submenu\").addClass(this.options.verticalClass),this.$element.hasClass(this.options.rightClass)||\"right\"===this.options.alignment||Foundation.rtl()||this.$element.parents(\".top-bar-right\").is(\"*\")?(this.options.alignment=\"right\",t.addClass(\"opens-left\")):t.addClass(\"opens-right\"),this.changed=!1,this._events();}},{key:\"_events\",value:function value(){var e=this,i=\"ontouchstart\"in window||\"undefined\"!=typeof window.ontouchstart,n=\"is-dropdown-submenu-parent\",s=function s(_s){var o=t(_s.target).parentsUntil(\"ul\",\".\"+n),a=o.hasClass(n),r=\"true\"===o.attr(\"data-is-click\");o.children(\".is-dropdown-submenu\");if(a)if(r){if(!e.options.closeOnClick||!e.options.clickOpen&&!i||e.options.forceFollow&&i)return;_s.stopImmediatePropagation(),_s.preventDefault(),e._hide(o);}else _s.preventDefault(),_s.stopImmediatePropagation(),e._show(o.children(\".is-dropdown-submenu\")),o.add(o.parentsUntil(e.$element,\".\"+n)).attr(\"data-is-click\",!0);};(this.options.clickOpen||i)&&this.$menuItems.on(\"click.zf.dropdownmenu touchstart.zf.dropdownmenu\",s),this.options.disableHover||this.$menuItems.on(\"mouseenter.zf.dropdownmenu\",function(i){var s=t(this),o=s.hasClass(n);o&&(clearTimeout(e.delay),e.delay=setTimeout(function(){e._show(s.children(\".is-dropdown-submenu\"));},e.options.hoverDelay));}).on(\"mouseleave.zf.dropdownmenu\",function(i){var s=t(this),o=s.hasClass(n);if(o&&e.options.autoclose){if(\"true\"===s.attr(\"data-is-click\")&&e.options.clickOpen)return!1;clearTimeout(e.delay),e.delay=setTimeout(function(){e._hide(s);},e.options.closingTime);}}),this.$menuItems.on(\"keydown.zf.dropdownmenu\",function(i){var n,s,o=t(i.target).parentsUntil(\"ul\",'[role=\"menuitem\"]'),a=e.$tabs.index(o)>-1,r=a?e.$tabs:o.siblings(\"li\").add(o);r.each(function(e){return t(this).is(o)?(n=r.eq(e-1),void(s=r.eq(e+1))):void 0;});var l=function l(){o.is(\":last-child\")||(s.children(\"a:first\").focus(),i.preventDefault());},u=function u(){n.children(\"a:first\").focus(),i.preventDefault();},d=function d(){var t=o.children(\"ul.is-dropdown-submenu\");t.length&&(e._show(t),o.find(\"li > a:first\").focus(),i.preventDefault());},h=function h(){var t=o.parent(\"ul\").parent(\"li\");t.children(\"a:first\").focus(),e._hide(t),i.preventDefault();},c={open:d,close:function close(){e._hide(e.$element),e.$menuItems.find(\"a:first\").focus(),i.preventDefault();},handled:function handled(){i.stopImmediatePropagation();}};a?e.$element.hasClass(e.options.verticalClass)?\"left\"===e.options.alignment?t.extend(c,{down:l,up:u,next:d,previous:h}):t.extend(c,{down:l,up:u,next:h,previous:d}):t.extend(c,{next:l,previous:u,down:d,up:h}):\"left\"===e.options.alignment?t.extend(c,{next:d,previous:h,down:l,up:u}):t.extend(c,{next:h,previous:d,down:l,up:u}),Foundation.Keyboard.handleKey(i,\"DropdownMenu\",c);});}},{key:\"_addBodyHandler\",value:function value(){var e=t(document.body),i=this;e.off(\"mouseup.zf.dropdownmenu touchend.zf.dropdownmenu\").on(\"mouseup.zf.dropdownmenu touchend.zf.dropdownmenu\",function(t){var n=i.$element.find(t.target);n.length||(i._hide(),e.off(\"mouseup.zf.dropdownmenu touchend.zf.dropdownmenu\"));});}},{key:\"_show\",value:function value(e){var i=this.$tabs.index(this.$tabs.filter(function(i,n){return t(n).find(e).length>0;})),n=e.parent(\"li.is-dropdown-submenu-parent\").siblings(\"li.is-dropdown-submenu-parent\");this._hide(n,i),e.css(\"visibility\",\"hidden\").addClass(\"js-dropdown-active\").attr({\"aria-hidden\":!1}).parent(\"li.is-dropdown-submenu-parent\").addClass(\"is-active\").attr({\"aria-expanded\":!0});var s=Foundation.Box.ImNotTouchingYou(e,null,!0);if(!s){var o=\"left\"===this.options.alignment?\"-right\":\"-left\",a=e.parent(\".is-dropdown-submenu-parent\");a.removeClass(\"opens\"+o).addClass(\"opens-\"+this.options.alignment),s=Foundation.Box.ImNotTouchingYou(e,null,!0),s||a.removeClass(\"opens-\"+this.options.alignment).addClass(\"opens-inner\"),this.changed=!0;}e.css(\"visibility\",\"\"),this.options.closeOnClick&&this._addBodyHandler(),this.$element.trigger(\"show.zf.dropdownmenu\",[e]);}},{key:\"_hide\",value:function value(t,e){var i;i=t&&t.length?t:void 0!==e?this.$tabs.not(function(t,i){return t===e;}):this.$element;var n=i.hasClass(\"is-active\")||i.find(\".is-active\").length>0;if(n){if(i.find(\"li.is-active\").add(i).attr({\"aria-expanded\":!1,\"data-is-click\":!1}).removeClass(\"is-active\"),i.find(\"ul.js-dropdown-active\").attr({\"aria-hidden\":!0}).removeClass(\"js-dropdown-active\"),this.changed||i.find(\"opens-inner\").length){var s=\"left\"===this.options.alignment?\"right\":\"left\";i.find(\"li.is-dropdown-submenu-parent\").add(i).removeClass(\"opens-inner opens-\"+this.options.alignment).addClass(\"opens-\"+s),this.changed=!1;}this.$element.trigger(\"hide.zf.dropdownmenu\",[i]);}}},{key:\"destroy\",value:function value(){this.$menuItems.off(\".zf.dropdownmenu\").removeAttr(\"data-is-click\").removeClass(\"is-right-arrow is-left-arrow is-down-arrow opens-right opens-left opens-inner\"),t(document.body).off(\".zf.dropdownmenu\"),Foundation.Nest.Burn(this.$element,\"dropdown\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={disableHover:!1,autoclose:!0,hoverDelay:50,clickOpen:!1,closingTime:500,alignment:\"left\",closeOnClick:!0,verticalClass:\"vertical\",rightClass:\"align-right\",forceFollow:!0},Foundation.plugin(e,\"DropdownMenu\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Equalizer\");}return _createClass(e,[{key:\"_init\",value:function value(){var e=this.$element.attr(\"data-equalizer\")||\"\",i=this.$element.find('[data-equalizer-watch=\"'+e+'\"]');this.$watched=i.length?i:this.$element.find(\"[data-equalizer-watch]\"),this.$element.attr(\"data-resize\",e||Foundation.GetYoDigits(6,\"eq\")),this.hasNested=this.$element.find(\"[data-equalizer]\").length>0,this.isNested=this.$element.parentsUntil(document.body,\"[data-equalizer]\").length>0,this.isOn=!1,this._bindHandler={onResizeMeBound:this._onResizeMe.bind(this),onPostEqualizedBound:this._onPostEqualized.bind(this)};var n,s=this.$element.find(\"img\");this.options.equalizeOn?(n=this._checkMQ(),t(window).on(\"changed.zf.mediaquery\",this._checkMQ.bind(this))):this._events(),(void 0!==n&&n===!1||void 0===n)&&(s.length?Foundation.onImagesLoaded(s,this._reflow.bind(this)):this._reflow());}},{key:\"_pauseEvents\",value:function value(){this.isOn=!1,this.$element.off({\".zf.equalizer\":this._bindHandler.onPostEqualizedBound,\"resizeme.zf.trigger\":this._bindHandler.onResizeMeBound});}},{key:\"_onResizeMe\",value:function value(t){this._reflow();}},{key:\"_onPostEqualized\",value:function value(t){t.target!==this.$element[0]&&this._reflow();}},{key:\"_events\",value:function value(){this._pauseEvents(),this.hasNested?this.$element.on(\"postequalized.zf.equalizer\",this._bindHandler.onPostEqualizedBound):this.$element.on(\"resizeme.zf.trigger\",this._bindHandler.onResizeMeBound),this.isOn=!0;}},{key:\"_checkMQ\",value:function value(){var t=!Foundation.MediaQuery.atLeast(this.options.equalizeOn);return t?this.isOn&&(this._pauseEvents(),this.$watched.css(\"height\",\"auto\")):this.isOn||this._events(),t;}},{key:\"_killswitch\",value:function value(){}},{key:\"_reflow\",value:function value(){return!this.options.equalizeOnStack&&this._isStacked()?(this.$watched.css(\"height\",\"auto\"),!1):void(this.options.equalizeByRow?this.getHeightsByRow(this.applyHeightByRow.bind(this)):this.getHeights(this.applyHeight.bind(this)));}},{key:\"_isStacked\",value:function value(){return this.$watched[0].getBoundingClientRect().top!==this.$watched[1].getBoundingClientRect().top;}},{key:\"getHeights\",value:function value(t){for(var e=[],i=0,n=this.$watched.length;n>i;i++){this.$watched[i].style.height=\"auto\",e.push(this.$watched[i].offsetHeight);}t(e);}},{key:\"getHeightsByRow\",value:function value(e){var i=this.$watched.length?this.$watched.first().offset().top:0,n=[],s=0;n[s]=[];for(var o=0,a=this.$watched.length;a>o;o++){this.$watched[o].style.height=\"auto\";var r=t(this.$watched[o]).offset().top;r!=i&&(s++,n[s]=[],i=r),n[s].push([this.$watched[o],this.$watched[o].offsetHeight]);}for(var l=0,u=n.length;u>l;l++){var d=t(n[l]).map(function(){return this[1];}).get(),h=Math.max.apply(null,d);n[l].push(h);}e(n);}},{key:\"applyHeight\",value:function value(t){var e=Math.max.apply(null,t);this.$element.trigger(\"preequalized.zf.equalizer\"),this.$watched.css(\"height\",e),this.$element.trigger(\"postequalized.zf.equalizer\");}},{key:\"applyHeightByRow\",value:function value(e){this.$element.trigger(\"preequalized.zf.equalizer\");for(var i=0,n=e.length;n>i;i++){var s=e[i].length,o=e[i][s-1];if(2>=s)t(e[i][0][0]).css({height:\"auto\"});else{this.$element.trigger(\"preequalizedrow.zf.equalizer\");for(var a=0,r=s-1;r>a;a++){t(e[i][a][0]).css({height:o});}this.$element.trigger(\"postequalizedrow.zf.equalizer\");}}this.$element.trigger(\"postequalized.zf.equalizer\");}},{key:\"destroy\",value:function value(){this._pauseEvents(),this.$watched.css(\"height\",\"auto\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={equalizeOnStack:!0,equalizeByRow:!1,equalizeOn:\"\"},Foundation.plugin(e,\"Equalizer\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,n),this.rules=[],this.currentPath=\"\",this._init(),this._events(),Foundation.registerPlugin(this,\"Interchange\");}return _createClass(e,[{key:\"_init\",value:function value(){this._addBreakpoints(),this._generateRules(),this._reflow();}},{key:\"_events\",value:function value(){t(window).on(\"resize.zf.interchange\",Foundation.util.throttle(this._reflow.bind(this),50));}},{key:\"_reflow\",value:function value(){var t;for(var e in this.rules){if(this.rules.hasOwnProperty(e)){var i=this.rules[e];window.matchMedia(i.query).matches&&(t=i);}}t&&this.replace(t.path);}},{key:\"_addBreakpoints\",value:function value(){for(var t in Foundation.MediaQuery.queries){if(Foundation.MediaQuery.queries.hasOwnProperty(t)){var i=Foundation.MediaQuery.queries[t];e.SPECIAL_QUERIES[i.name]=i.value;}}}},{key:\"_generateRules\",value:function value(t){var i,n=[];i=this.options.rules?this.options.rules:this.$element.data(\"interchange\").match(/\\[.*?\\]/g);for(var s in i){if(i.hasOwnProperty(s)){var o=i[s].slice(1,-1).split(\", \"),a=o.slice(0,-1).join(\"\"),r=o[o.length-1];e.SPECIAL_QUERIES[r]&&(r=e.SPECIAL_QUERIES[r]),n.push({path:a,query:r});}}this.rules=n;}},{key:\"replace\",value:function value(e){if(this.currentPath!==e){var i=this,n=\"replaced.zf.interchange\";\"IMG\"===this.$element[0].nodeName?this.$element.attr(\"src\",e).load(function(){i.currentPath=e;}).trigger(n):e.match(/\\.(gif|jpg|jpeg|png|svg|tiff)([?#].*)?/i)?this.$element.css({\"background-image\":\"url(\"+e+\")\"}).trigger(n):t.get(e,function(s){i.$element.html(s).trigger(n),t(s).foundation(),i.currentPath=e;});}}},{key:\"destroy\",value:function value(){}}]),e;}();e.defaults={rules:null},e.SPECIAL_QUERIES={landscape:\"screen and (orientation: landscape)\",portrait:\"screen and (orientation: portrait)\",retina:\"only screen and (-webkit-min-device-pixel-ratio: 2), only screen and (min--moz-device-pixel-ratio: 2), only screen and (-o-min-device-pixel-ratio: 2/1), only screen and (min-device-pixel-ratio: 2), only screen and (min-resolution: 192dpi), only screen and (min-resolution: 2dppx)\"},Foundation.plugin(e,\"Interchange\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Magellan\");}return _createClass(e,[{key:\"_init\",value:function value(){var e=this.$element[0].id||Foundation.GetYoDigits(6,\"magellan\");this.$targets=t(\"[data-magellan-target]\"),this.$links=this.$element.find(\"a\"),this.$element.attr({\"data-resize\":e,\"data-scroll\":e,id:e}),this.$active=t(),this.scrollPos=parseInt(window.pageYOffset,10),this._events();}},{key:\"calcPoints\",value:function value(){var e=this,i=document.body,n=document.documentElement;this.points=[],this.winHeight=Math.round(Math.max(window.innerHeight,n.clientHeight)),this.docHeight=Math.round(Math.max(i.scrollHeight,i.offsetHeight,n.clientHeight,n.scrollHeight,n.offsetHeight)),this.$targets.each(function(){var i=t(this),n=Math.round(i.offset().top-e.options.threshold);i.targetPoint=n,e.points.push(n);});}},{key:\"_events\",value:function value(){var e=this;t(\"html, body\"),{duration:e.options.animationDuration,easing:e.options.animationEasing};t(window).one(\"load\",function(){e.options.deepLinking&&location.hash&&e.scrollToLoc(location.hash),e.calcPoints(),e._updateActive();}),this.$element.on({\"resizeme.zf.trigger\":this.reflow.bind(this),\"scrollme.zf.trigger\":this._updateActive.bind(this)}).on(\"click.zf.magellan\",'a[href^=\"#\"]',function(t){t.preventDefault();var i=this.getAttribute(\"href\");e.scrollToLoc(i);});}},{key:\"scrollToLoc\",value:function value(e){var i=Math.round(t(e).offset().top-this.options.threshold/2-this.options.barOffset);t(\"html, body\").stop(!0).animate({scrollTop:i},this.options.animationDuration,this.options.animationEasing);}},{key:\"reflow\",value:function value(){this.calcPoints(),this._updateActive();}},{key:\"_updateActive\",value:function value(){var t,e=parseInt(window.pageYOffset,10);if(e+this.winHeight===this.docHeight)t=this.points.length-1;else if(e<this.points[0])t=0;else{var i=this.scrollPos<e,n=this,s=this.points.filter(function(t,s){return i?t-n.options.barOffset<=e:t-n.options.barOffset-n.options.threshold<=e;});t=s.length?s.length-1:0;}if(this.$active.removeClass(this.options.activeClass),this.$active=this.$links.eq(t).addClass(this.options.activeClass),this.options.deepLinking){var o=this.$active[0].getAttribute(\"href\");window.history.pushState?window.history.pushState(null,null,o):window.location.hash=o;}this.scrollPos=e,this.$element.trigger(\"update.zf.magellan\",[this.$active]);}},{key:\"destroy\",value:function value(){if(this.$element.off(\".zf.trigger .zf.magellan\").find(\".\"+this.options.activeClass).removeClass(this.options.activeClass),this.options.deepLinking){var t=this.$active[0].getAttribute(\"href\");window.location.hash.replace(t,\"\");}Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={animationDuration:500,animationEasing:\"linear\",threshold:50,activeClass:\"active\",deepLinking:!1,barOffset:0},Foundation.plugin(e,\"Magellan\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this.$lastTrigger=t(),this.$triggers=t(),this._init(),this._events(),Foundation.registerPlugin(this,\"OffCanvas\");}return _createClass(e,[{key:\"_init\",value:function value(){var e=this.$element.attr(\"id\");if(this.$element.attr(\"aria-hidden\",\"true\"),this.$triggers=t(document).find('[data-open=\"'+e+'\"], [data-close=\"'+e+'\"], [data-toggle=\"'+e+'\"]').attr(\"aria-expanded\",\"false\").attr(\"aria-controls\",e),this.options.closeOnClick)if(t(\".js-off-canvas-exit\").length)this.$exiter=t(\".js-off-canvas-exit\");else{var i=document.createElement(\"div\");i.setAttribute(\"class\",\"js-off-canvas-exit\"),t(\"[data-off-canvas-content]\").append(i),this.$exiter=t(i);}this.options.isRevealed=this.options.isRevealed||new RegExp(this.options.revealClass,\"g\").test(this.$element[0].className),this.options.isRevealed&&(this.options.revealOn=this.options.revealOn||this.$element[0].className.match(/(reveal-for-medium|reveal-for-large)/g)[0].split(\"-\")[2],this._setMQChecker()),this.options.transitionTime||(this.options.transitionTime=1e3*parseFloat(window.getComputedStyle(t(\"[data-off-canvas-wrapper]\")[0]).transitionDuration));}},{key:\"_events\",value:function value(){this.$element.off(\".zf.trigger .zf.offcanvas\").on({\"open.zf.trigger\":this.open.bind(this),\"close.zf.trigger\":this.close.bind(this),\"toggle.zf.trigger\":this.toggle.bind(this),\"keydown.zf.offcanvas\":this._handleKeyboard.bind(this)}),this.options.closeOnClick&&this.$exiter.length&&this.$exiter.on({\"click.zf.offcanvas\":this.close.bind(this)});}},{key:\"_setMQChecker\",value:function value(){var e=this;t(window).on(\"changed.zf.mediaquery\",function(){Foundation.MediaQuery.atLeast(e.options.revealOn)?e.reveal(!0):e.reveal(!1);}).one(\"load.zf.offcanvas\",function(){Foundation.MediaQuery.atLeast(e.options.revealOn)&&e.reveal(!0);});}},{key:\"reveal\",value:function value(t){var e=this.$element.find(\"[data-close]\");t?(this.close(),this.isRevealed=!0,this.$element.off(\"open.zf.trigger toggle.zf.trigger\"),e.length&&e.hide()):(this.isRevealed=!1,this.$element.on({\"open.zf.trigger\":this.open.bind(this),\"toggle.zf.trigger\":this.toggle.bind(this)}),e.length&&e.show());}},{key:\"open\",value:function value(e,i){if(!this.$element.hasClass(\"is-open\")&&!this.isRevealed){var n=this;t(document.body);this.options.forceTop&&t(\"body\").scrollTop(0),Foundation.Move(this.options.transitionTime,this.$element,function(){t(\"[data-off-canvas-wrapper]\").addClass(\"is-off-canvas-open is-open-\"+n.options.position),n.$element.addClass(\"is-open\");}),this.$triggers.attr(\"aria-expanded\",\"true\"),this.$element.attr(\"aria-hidden\",\"false\").trigger(\"opened.zf.offcanvas\"),this.options.closeOnClick&&this.$exiter.addClass(\"is-visible\"),i&&(this.$lastTrigger=i),this.options.autoFocus&&this.$element.one(Foundation.transitionend(this.$element),function(){n.$element.find(\"a, button\").eq(0).focus();}),this.options.trapFocus&&(t(\"[data-off-canvas-content]\").attr(\"tabindex\",\"-1\"),this._trapFocus());}}},{key:\"_trapFocus\",value:function value(){var t=Foundation.Keyboard.findFocusable(this.$element),e=t.eq(0),i=t.eq(-1);t.off(\".zf.offcanvas\").on(\"keydown.zf.offcanvas\",function(t){9!==t.which&&9!==t.keycode||(t.target!==i[0]||t.shiftKey||(t.preventDefault(),e.focus()),t.target===e[0]&&t.shiftKey&&(t.preventDefault(),i.focus()));});}},{key:\"close\",value:function value(e){if(this.$element.hasClass(\"is-open\")&&!this.isRevealed){var i=this;t(\"[data-off-canvas-wrapper]\").removeClass(\"is-off-canvas-open is-open-\"+i.options.position),i.$element.removeClass(\"is-open\"),this.$element.attr(\"aria-hidden\",\"true\").trigger(\"closed.zf.offcanvas\"),this.options.closeOnClick&&this.$exiter.removeClass(\"is-visible\"),this.$triggers.attr(\"aria-expanded\",\"false\"),this.options.trapFocus&&t(\"[data-off-canvas-content]\").removeAttr(\"tabindex\");}}},{key:\"toggle\",value:function value(t,e){this.$element.hasClass(\"is-open\")?this.close(t,e):this.open(t,e);}},{key:\"_handleKeyboard\",value:function value(t){27===t.which&&(t.stopPropagation(),t.preventDefault(),this.close(),this.$lastTrigger.focus());}},{key:\"destroy\",value:function value(){this.close(),this.$element.off(\".zf.trigger .zf.offcanvas\"),this.$exiter.off(\".zf.offcanvas\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={closeOnClick:!0,transitionTime:0,position:\"left\",forceTop:!0,isRevealed:!1,revealOn:null,autoFocus:!0,revealClass:\"reveal-for-\",trapFocus:!1},Foundation.plugin(e,\"OffCanvas\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Orbit\"),Foundation.Keyboard.register(\"Orbit\",{ltr:{ARROW_RIGHT:\"next\",ARROW_LEFT:\"previous\"},rtl:{ARROW_LEFT:\"next\",ARROW_RIGHT:\"previous\"}});}return _createClass(e,[{key:\"_init\",value:function value(){this.$wrapper=this.$element.find(\".\"+this.options.containerClass),this.$slides=this.$element.find(\".\"+this.options.slideClass);var t=this.$element.find(\"img\"),e=this.$slides.filter(\".is-active\");e.length||this.$slides.eq(0).addClass(\"is-active\"),this.options.useMUI||this.$slides.addClass(\"no-motionui\"),t.length?Foundation.onImagesLoaded(t,this._prepareForOrbit.bind(this)):this._prepareForOrbit(),this.options.bullets&&this._loadBullets(),this._events(),this.options.autoPlay&&this.$slides.length>1&&this.geoSync(),this.options.accessible&&this.$wrapper.attr(\"tabindex\",0);}},{key:\"_loadBullets\",value:function value(){this.$bullets=this.$element.find(\".\"+this.options.boxOfBullets).find(\"button\");}},{key:\"geoSync\",value:function value(){var t=this;this.timer=new Foundation.Timer(this.$element,{duration:this.options.timerDelay,infinite:!1},function(){t.changeSlide(!0);}),this.timer.start();}},{key:\"_prepareForOrbit\",value:function value(){var t=this;this._setWrapperHeight(function(e){t._setSlideHeight(e);});}},{key:\"_setWrapperHeight\",value:function value(e){var i,n=0,s=0;this.$slides.each(function(){i=this.getBoundingClientRect().height,t(this).attr(\"data-slide\",s),s&&t(this).css({position:\"relative\",display:\"none\"}),n=i>n?i:n,s++;}),s===this.$slides.length&&(this.$wrapper.css({height:n}),e(n));}},{key:\"_setSlideHeight\",value:function value(e){this.$slides.each(function(){t(this).css(\"max-height\",e);});}},{key:\"_events\",value:function value(){var e=this;if(this.$slides.length>1){if(this.options.swipe&&this.$slides.off(\"swipeleft.zf.orbit swiperight.zf.orbit\").on(\"swipeleft.zf.orbit\",function(t){t.preventDefault(),e.changeSlide(!0);}).on(\"swiperight.zf.orbit\",function(t){t.preventDefault(),e.changeSlide(!1);}),this.options.autoPlay&&(this.$slides.on(\"click.zf.orbit\",function(){e.$element.data(\"clickedOn\",!e.$element.data(\"clickedOn\")),e.timer[e.$element.data(\"clickedOn\")?\"pause\":\"start\"]();}),this.options.pauseOnHover&&this.$element.on(\"mouseenter.zf.orbit\",function(){e.timer.pause();}).on(\"mouseleave.zf.orbit\",function(){e.$element.data(\"clickedOn\")||e.timer.start();})),this.options.navButtons){var i=this.$element.find(\".\"+this.options.nextClass+\", .\"+this.options.prevClass);i.attr(\"tabindex\",0).on(\"click.zf.orbit touchend.zf.orbit\",function(i){i.preventDefault(),e.changeSlide(t(this).hasClass(e.options.nextClass));});}this.options.bullets&&this.$bullets.on(\"click.zf.orbit touchend.zf.orbit\",function(){if(/is-active/g.test(this.className))return!1;var i=t(this).data(\"slide\"),n=i>e.$slides.filter(\".is-active\").data(\"slide\"),s=e.$slides.eq(i);e.changeSlide(n,s,i);}),this.$wrapper.add(this.$bullets).on(\"keydown.zf.orbit\",function(i){Foundation.Keyboard.handleKey(i,\"Orbit\",{next:function next(){e.changeSlide(!0);},previous:function previous(){e.changeSlide(!1);},handled:function handled(){t(i.target).is(e.$bullets)&&e.$bullets.filter(\".is-active\").focus();}});});}}},{key:\"changeSlide\",value:function value(t,e,i){var n=this.$slides.filter(\".is-active\").eq(0);if(/mui/g.test(n[0].className))return!1;var s,o=this.$slides.first(),a=this.$slides.last(),r=t?\"Right\":\"Left\",l=t?\"Left\":\"Right\",u=this;s=e?e:t?this.options.infiniteWrap?n.next(\".\"+this.options.slideClass).length?n.next(\".\"+this.options.slideClass):o:n.next(\".\"+this.options.slideClass):this.options.infiniteWrap?n.prev(\".\"+this.options.slideClass).length?n.prev(\".\"+this.options.slideClass):a:n.prev(\".\"+this.options.slideClass),s.length&&(this.options.bullets&&(i=i||this.$slides.index(s),this._updateBullets(i)),this.options.useMUI?(Foundation.Motion.animateIn(s.addClass(\"is-active\").css({position:\"absolute\",top:0}),this.options[\"animInFrom\"+r],function(){s.css({position:\"relative\",display:\"block\"}).attr(\"aria-live\",\"polite\");}),Foundation.Motion.animateOut(n.removeClass(\"is-active\"),this.options[\"animOutTo\"+l],function(){n.removeAttr(\"aria-live\"),u.options.autoPlay&&!u.timer.isPaused&&u.timer.restart();})):(n.removeClass(\"is-active is-in\").removeAttr(\"aria-live\").hide(),s.addClass(\"is-active is-in\").attr(\"aria-live\",\"polite\").show(),this.options.autoPlay&&!this.timer.isPaused&&this.timer.restart()),this.$element.trigger(\"slidechange.zf.orbit\",[s]));}},{key:\"_updateBullets\",value:function value(t){var e=this.$element.find(\".\"+this.options.boxOfBullets).find(\".is-active\").removeClass(\"is-active\").blur(),i=e.find(\"span:last\").detach();this.$bullets.eq(t).addClass(\"is-active\").append(i);}},{key:\"destroy\",value:function value(){this.$element.off(\".zf.orbit\").find(\"*\").off(\".zf.orbit\").end().hide(),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={bullets:!0,navButtons:!0,animInFromRight:\"slide-in-right\",animOutToRight:\"slide-out-right\",animInFromLeft:\"slide-in-left\",animOutToLeft:\"slide-out-left\",autoPlay:!0,timerDelay:5e3,infiniteWrap:!0,swipe:!0,pauseOnHover:!0,accessible:!0,containerClass:\"orbit-container\",slideClass:\"orbit-slide\",boxOfBullets:\"orbit-bullets\",nextClass:\"orbit-next\",prevClass:\"orbit-previous\",useMUI:!0},Foundation.plugin(e,\"Orbit\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=t(i),this.rules=this.$element.data(\"responsive-menu\"),this.currentMq=null,this.currentPlugin=null,this._init(),this._events(),Foundation.registerPlugin(this,\"ResponsiveMenu\");}return _createClass(e,[{key:\"_init\",value:function value(){if(\"string\"==typeof this.rules){for(var e={},n=this.rules.split(\" \"),s=0;s<n.length;s++){var o=n[s].split(\"-\"),a=o.length>1?o[0]:\"small\",r=o.length>1?o[1]:o[0];null!==i[r]&&(e[a]=i[r]);}this.rules=e;}t.isEmptyObject(this.rules)||this._checkMediaQueries();}},{key:\"_events\",value:function value(){var e=this;t(window).on(\"changed.zf.mediaquery\",function(){e._checkMediaQueries();});}},{key:\"_checkMediaQueries\",value:function value(){var e,n=this;t.each(this.rules,function(t){Foundation.MediaQuery.atLeast(t)&&(e=t);}),e&&(this.currentPlugin instanceof this.rules[e].plugin||(t.each(i,function(t,e){n.$element.removeClass(e.cssClass);}),this.$element.addClass(this.rules[e].cssClass),this.currentPlugin&&this.currentPlugin.destroy(),this.currentPlugin=new this.rules[e].plugin(this.$element,{})));}},{key:\"destroy\",value:function value(){this.currentPlugin.destroy(),t(window).off(\".zf.ResponsiveMenu\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={};var i={dropdown:{cssClass:\"dropdown\",plugin:Foundation._plugins[\"dropdown-menu\"]||null},drilldown:{cssClass:\"drilldown\",plugin:Foundation._plugins.drilldown||null},accordion:{cssClass:\"accordion-menu\",plugin:Foundation._plugins[\"accordion-menu\"]||null}};Foundation.plugin(e,\"ResponsiveMenu\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=t(i),this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),this._events(),Foundation.registerPlugin(this,\"ResponsiveToggle\");}return _createClass(e,[{key:\"_init\",value:function value(){var e=this.$element.data(\"responsive-toggle\");e||console.error(\"Your tab bar needs an ID of a Menu as the value of data-tab-bar.\"),this.$targetMenu=t(\"#\"+e),this.$toggler=this.$element.find(\"[data-toggle]\"),this._update();}},{key:\"_events\",value:function value(){this._updateMqHandler=this._update.bind(this),t(window).on(\"changed.zf.mediaquery\",this._updateMqHandler),this.$toggler.on(\"click.zf.responsiveToggle\",this.toggleMenu.bind(this));}},{key:\"_update\",value:function value(){Foundation.MediaQuery.atLeast(this.options.hideFor)?(this.$element.hide(),this.$targetMenu.show()):(this.$element.show(),this.$targetMenu.hide());}},{key:\"toggleMenu\",value:function value(){Foundation.MediaQuery.atLeast(this.options.hideFor)||(this.$targetMenu.toggle(0),this.$element.trigger(\"toggled.zf.responsiveToggle\"));}},{key:\"destroy\",value:function value(){this.$element.off(\".zf.responsiveToggle\"),this.$toggler.off(\".zf.responsiveToggle\"),t(window).off(\"changed.zf.mediaquery\",this._updateMqHandler),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={hideFor:\"medium\"},Foundation.plugin(e,\"ResponsiveToggle\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){function e(){return /iP(ad|hone|od).*OS/.test(window.navigator.userAgent);}function i(){return /Android/.test(window.navigator.userAgent);}function n(){return e()||i();}var s=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Reveal\"),Foundation.Keyboard.register(\"Reveal\",{ENTER:\"open\",SPACE:\"open\",ESCAPE:\"close\",TAB:\"tab_forward\",SHIFT_TAB:\"tab_backward\"});}return _createClass(e,[{key:\"_init\",value:function value(){this.id=this.$element.attr(\"id\"),this.isActive=!1,this.cached={mq:Foundation.MediaQuery.current},this.isMobile=n(),this.$anchor=t(t('[data-open=\"'+this.id+'\"]').length?'[data-open=\"'+this.id+'\"]':'[data-toggle=\"'+this.id+'\"]'),this.$anchor.attr({\"aria-controls\":this.id,\"aria-haspopup\":!0,tabindex:0}),(this.options.fullScreen||this.$element.hasClass(\"full\"))&&(this.options.fullScreen=!0,this.options.overlay=!1),this.options.overlay&&!this.$overlay&&(this.$overlay=this._makeOverlay(this.id)),this.$element.attr({role:\"dialog\",\"aria-hidden\":!0,\"data-yeti-box\":this.id,\"data-resize\":this.id}),this.$overlay?this.$element.detach().appendTo(this.$overlay):(this.$element.detach().appendTo(t(\"body\")),this.$element.addClass(\"without-overlay\")),this._events(),this.options.deepLink&&window.location.hash===\"#\"+this.id&&t(window).one(\"load.zf.reveal\",this.open.bind(this));}},{key:\"_makeOverlay\",value:function value(e){var i=t(\"<div></div>\").addClass(\"reveal-overlay\").appendTo(\"body\");return i;}},{key:\"_updatePosition\",value:function value(){var e,i,n=this.$element.outerWidth(),s=t(window).width(),o=this.$element.outerHeight(),a=t(window).height();e=\"auto\"===this.options.hOffset?parseInt((s-n)/2,10):parseInt(this.options.hOffset,10),i=\"auto\"===this.options.vOffset?o>a?parseInt(Math.min(100,a/10),10):parseInt((a-o)/4,10):parseInt(this.options.vOffset,10),this.$element.css({top:i+\"px\"}),this.$overlay&&\"auto\"===this.options.hOffset||(this.$element.css({left:e+\"px\"}),this.$element.css({margin:\"0px\"}));}},{key:\"_events\",value:function value(){var e=this,i=this;this.$element.on({\"open.zf.trigger\":this.open.bind(this),\"close.zf.trigger\":function closeZfTrigger(n,s){return n.target===i.$element[0]||t(n.target).parents(\"[data-closable]\")[0]===s?e.close.apply(e):void 0;},\"toggle.zf.trigger\":this.toggle.bind(this),\"resizeme.zf.trigger\":function resizemeZfTrigger(){i._updatePosition();}}),this.$anchor.length&&this.$anchor.on(\"keydown.zf.reveal\",function(t){13!==t.which&&32!==t.which||(t.stopPropagation(),t.preventDefault(),i.open());}),this.options.closeOnClick&&this.options.overlay&&this.$overlay.off(\".zf.reveal\").on(\"click.zf.reveal\",function(e){e.target===i.$element[0]||t.contains(i.$element[0],e.target)||i.close();}),this.options.deepLink&&t(window).on(\"popstate.zf.reveal:\"+this.id,this._handleState.bind(this));}},{key:\"_handleState\",value:function value(t){window.location.hash!==\"#\"+this.id||this.isActive?this.close():this.open();}},{key:\"open\",value:function value(){var e=this;if(this.options.deepLink){var i=\"#\"+this.id;window.history.pushState?window.history.pushState(null,null,i):window.location.hash=i;}if(this.isActive=!0,this.$element.css({visibility:\"hidden\"}).show().scrollTop(0),this.options.overlay&&this.$overlay.css({visibility:\"hidden\"}).show(),this._updatePosition(),this.$element.hide().css({visibility:\"\"}),this.$overlay&&(this.$overlay.css({visibility:\"\"}).hide(),this.$element.hasClass(\"fast\")?this.$overlay.addClass(\"fast\"):this.$element.hasClass(\"slow\")&&this.$overlay.addClass(\"slow\")),this.options.multipleOpened||this.$element.trigger(\"closeme.zf.reveal\",this.id),this.options.animationIn){var n;!function(){var t=function t(){n.$element.attr({\"aria-hidden\":!1,tabindex:-1}).focus(),console.log(\"focus\");};n=e,e.options.overlay&&Foundation.Motion.animateIn(e.$overlay,\"fade-in\"),Foundation.Motion.animateIn(e.$element,e.options.animationIn,function(){e.focusableElements=Foundation.Keyboard.findFocusable(e.$element),t();});}();}else this.options.overlay&&this.$overlay.show(0),this.$element.show(this.options.showDelay);this.$element.attr({\"aria-hidden\":!1,tabindex:-1}).focus(),this.$element.trigger(\"open.zf.reveal\"),this.isMobile?(this.originalScrollPos=window.pageYOffset,t(\"html, body\").addClass(\"is-reveal-open\")):t(\"body\").addClass(\"is-reveal-open\"),setTimeout(function(){e._extraHandlers();},0);}},{key:\"_extraHandlers\",value:function value(){var e=this;this.focusableElements=Foundation.Keyboard.findFocusable(this.$element),this.options.overlay||!this.options.closeOnClick||this.options.fullScreen||t(\"body\").on(\"click.zf.reveal\",function(i){i.target===e.$element[0]||t.contains(e.$element[0],i.target)||e.close();}),this.options.closeOnEsc&&t(window).on(\"keydown.zf.reveal\",function(t){Foundation.Keyboard.handleKey(t,\"Reveal\",{close:function close(){e.options.closeOnEsc&&(e.close(),e.$anchor.focus());}});}),this.$element.on(\"keydown.zf.reveal\",function(i){var n=t(this);Foundation.Keyboard.handleKey(i,\"Reveal\",{tab_forward:function tab_forward(){return e.$element.find(\":focus\").is(e.focusableElements.eq(-1))?(e.focusableElements.eq(0).focus(),!0):0===e.focusableElements.length?!0:void 0;},tab_backward:function tab_backward(){return e.$element.find(\":focus\").is(e.focusableElements.eq(0))||e.$element.is(\":focus\")?(e.focusableElements.eq(-1).focus(),!0):0===e.focusableElements.length?!0:void 0;},open:function open(){e.$element.find(\":focus\").is(e.$element.find(\"[data-close]\"))?setTimeout(function(){e.$anchor.focus();},1):n.is(e.focusableElements)&&e.open();},close:function close(){e.options.closeOnEsc&&(e.close(),e.$anchor.focus());},handled:function handled(t){t&&i.preventDefault();}});});}},{key:\"close\",value:function value(){function e(){i.isMobile?(t(\"html, body\").removeClass(\"is-reveal-open\"),i.originalScrollPos&&(t(\"body\").scrollTop(i.originalScrollPos),i.originalScrollPos=null)):t(\"body\").removeClass(\"is-reveal-open\"),i.$element.attr(\"aria-hidden\",!0),i.$element.trigger(\"closed.zf.reveal\");}if(!this.isActive||!this.$element.is(\":visible\"))return!1;var i=this;this.options.animationOut?(this.options.overlay?Foundation.Motion.animateOut(this.$overlay,\"fade-out\",e):e(),Foundation.Motion.animateOut(this.$element,this.options.animationOut)):(this.options.overlay?this.$overlay.hide(0,e):e(),this.$element.hide(this.options.hideDelay)),this.options.closeOnEsc&&t(window).off(\"keydown.zf.reveal\"),!this.options.overlay&&this.options.closeOnClick&&t(\"body\").off(\"click.zf.reveal\"),this.$element.off(\"keydown.zf.reveal\"),this.options.resetOnClose&&this.$element.html(this.$element.html()),this.isActive=!1,i.options.deepLink&&(window.history.replaceState?window.history.replaceState(\"\",document.title,window.location.pathname):window.location.hash=\"\");}},{key:\"toggle\",value:function value(){this.isActive?this.close():this.open();}},{key:\"destroy\",value:function value(){this.options.overlay&&(this.$element.appendTo(t(\"body\")),this.$overlay.hide().off().remove()),this.$element.hide().off(),this.$anchor.off(\".zf\"),t(window).off(\".zf.reveal:\"+this.id),Foundation.unregisterPlugin(this);}}]),e;}();s.defaults={animationIn:\"\",animationOut:\"\",showDelay:0,hideDelay:0,closeOnClick:!0,closeOnEsc:!0,multipleOpened:!1,vOffset:\"auto\",hOffset:\"auto\",fullScreen:!1,btmOffsetPct:10,overlay:!0,resetOnClose:!1,deepLink:!1},Foundation.plugin(s,\"Reveal\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){function e(t,e){return t/e;}function i(t,e,i,n){return Math.abs(t.position()[e]+t[n]()/2-i);}var n=function(){function n(e,i){_classCallCheck(this,n),this.$element=e,this.options=t.extend({},n.defaults,this.$element.data(),i),this._init(),Foundation.registerPlugin(this,\"Slider\"),Foundation.Keyboard.register(\"Slider\",{ltr:{ARROW_RIGHT:\"increase\",ARROW_UP:\"increase\",ARROW_DOWN:\"decrease\",ARROW_LEFT:\"decrease\",SHIFT_ARROW_RIGHT:\"increase_fast\",SHIFT_ARROW_UP:\"increase_fast\",SHIFT_ARROW_DOWN:\"decrease_fast\",SHIFT_ARROW_LEFT:\"decrease_fast\"},rtl:{ARROW_LEFT:\"increase\",ARROW_RIGHT:\"decrease\",SHIFT_ARROW_LEFT:\"increase_fast\",SHIFT_ARROW_RIGHT:\"decrease_fast\"}});}return _createClass(n,[{key:\"_init\",value:function value(){this.inputs=this.$element.find(\"input\"),this.handles=this.$element.find(\"[data-slider-handle]\"),this.$handle=this.handles.eq(0),this.$input=this.inputs.length?this.inputs.eq(0):t(\"#\"+this.$handle.attr(\"aria-controls\")),this.$fill=this.$element.find(\"[data-slider-fill]\").css(this.options.vertical?\"height\":\"width\",0);var e=!1,i=this;(this.options.disabled||this.$element.hasClass(this.options.disabledClass))&&(this.options.disabled=!0,this.$element.addClass(this.options.disabledClass)),this.inputs.length||(this.inputs=t().add(this.$input),this.options.binding=!0),this._setInitAttr(0),this._events(this.$handle),this.handles[1]&&(this.options.doubleSided=!0,this.$handle2=this.handles.eq(1),this.$input2=this.inputs.length>1?this.inputs.eq(1):t(\"#\"+this.$handle2.attr(\"aria-controls\")),this.inputs[1]||(this.inputs=this.inputs.add(this.$input2)),e=!0,this._setHandlePos(this.$handle,this.options.initialStart,!0,function(){i._setHandlePos(i.$handle2,i.options.initialEnd,!0);}),this._setInitAttr(1),this._events(this.$handle2)),e||this._setHandlePos(this.$handle,this.options.initialStart,!0);}},{key:\"_setHandlePos\",value:function value(t,i,n,s){if(!this.$element.hasClass(this.options.disabledClass)){i=parseFloat(i),i<this.options.start?i=this.options.start:i>this.options.end&&(i=this.options.end);var o=this.options.doubleSided;if(o)if(0===this.handles.index(t)){var a=parseFloat(this.$handle2.attr(\"aria-valuenow\"));i=i>=a?a-this.options.step:i;}else{var r=parseFloat(this.$handle.attr(\"aria-valuenow\"));i=r>=i?r+this.options.step:i;}this.options.vertical&&!n&&(i=this.options.end-i);var l=this,u=this.options.vertical,d=u?\"height\":\"width\",h=u?\"top\":\"left\",c=t[0].getBoundingClientRect()[d],f=this.$element[0].getBoundingClientRect()[d],p=e(i-this.options.start,this.options.end-this.options.start).toFixed(2),m=(f-c)*p,v=(100*e(m,f)).toFixed(this.options.decimal);i=parseFloat(i.toFixed(this.options.decimal));var g={};if(this._setValues(t,i),o){var w,y=0===this.handles.index(t),b=~~(100*e(c,f));if(y)g[h]=v+\"%\",w=parseFloat(this.$handle2[0].style[h])-v+b,s&&\"function\"==typeof s&&s();else{var $=parseFloat(this.$handle[0].style[h]);w=v-(isNaN($)?this.options.initialStart/((this.options.end-this.options.start)/100):$)+b;}g[\"min-\"+d]=w+\"%\";}this.$element.one(\"finished.zf.animate\",function(){l.$element.trigger(\"moved.zf.slider\",[t]);});var C=this.$element.data(\"dragging\")?1e3/60:this.options.moveTime;Foundation.Move(C,t,function(){t.css(h,v+\"%\"),l.options.doubleSided?l.$fill.css(g):l.$fill.css(d,100*p+\"%\");}),clearTimeout(l.timeout),l.timeout=setTimeout(function(){l.$element.trigger(\"changed.zf.slider\",[t]);},l.options.changedDelay);}}},{key:\"_setInitAttr\",value:function value(t){var e=this.inputs.eq(t).attr(\"id\")||Foundation.GetYoDigits(6,\"slider\");this.inputs.eq(t).attr({id:e,max:this.options.end,min:this.options.start,step:this.options.step}),this.handles.eq(t).attr({role:\"slider\",\"aria-controls\":e,\"aria-valuemax\":this.options.end,\"aria-valuemin\":this.options.start,\"aria-valuenow\":0===t?this.options.initialStart:this.options.initialEnd,\"aria-orientation\":this.options.vertical?\"vertical\":\"horizontal\",tabindex:0});}},{key:\"_setValues\",value:function value(t,e){var i=this.options.doubleSided?this.handles.index(t):0;this.inputs.eq(i).val(e),t.attr(\"aria-valuenow\",e);}},{key:\"_handleEvent\",value:function value(n,s,o){var a,r;if(o)a=this._adjustValue(null,o),r=!0;else{n.preventDefault();var l=this,u=this.options.vertical,d=u?\"height\":\"width\",h=u?\"top\":\"left\",c=u?n.pageY:n.pageX,f=(this.$handle[0].getBoundingClientRect()[d]/2,this.$element[0].getBoundingClientRect()[d]),p=u?t(window).scrollTop():t(window).scrollLeft(),m=this.$element.offset()[h];n.clientY===n.pageY&&(c+=p);var v,g=c-m;if(v=0>g?0:g>f?f:g,offsetPct=e(v,f),a=(this.options.end-this.options.start)*offsetPct+this.options.start,Foundation.rtl()&&!this.options.vertical&&(a=this.options.end-a),a=l._adjustValue(null,a),r=!1,!s){var w=i(this.$handle,h,v,d),y=i(this.$handle2,h,v,d);s=y>=w?this.$handle:this.$handle2;}}this._setHandlePos(s,a,r);}},{key:\"_adjustValue\",value:function value(t,e){var i,n,s,o,a=this.options.step,r=parseFloat(a/2);return i=t?parseFloat(t.attr(\"aria-valuenow\")):e,n=i%a,s=i-n,o=s+a,0===n?i:i=i>=s+r?o:s;}},{key:\"_events\",value:function value(e){var i,n=this;if(this.inputs.off(\"change.zf.slider\").on(\"change.zf.slider\",function(e){var i=n.inputs.index(t(this));n._handleEvent(e,n.handles.eq(i),t(this).val());}),this.options.clickSelect&&this.$element.off(\"click.zf.slider\").on(\"click.zf.slider\",function(e){return n.$element.data(\"dragging\")?!1:void(t(e.target).is(\"[data-slider-handle]\")||(n.options.doubleSided?n._handleEvent(e):n._handleEvent(e,n.$handle)));}),this.options.draggable){this.handles.addTouch();var s=t(\"body\");e.off(\"mousedown.zf.slider\").on(\"mousedown.zf.slider\",function(o){e.addClass(\"is-dragging\"),n.$fill.addClass(\"is-dragging\"),n.$element.data(\"dragging\",!0),i=t(o.currentTarget),s.on(\"mousemove.zf.slider\",function(t){t.preventDefault(),n._handleEvent(t,i);}).on(\"mouseup.zf.slider\",function(t){n._handleEvent(t,i),e.removeClass(\"is-dragging\"),n.$fill.removeClass(\"is-dragging\"),n.$element.data(\"dragging\",!1),s.off(\"mousemove.zf.slider mouseup.zf.slider\");});}).on(\"selectstart.zf.slider touchmove.zf.slider\",function(t){t.preventDefault();});}e.off(\"keydown.zf.slider\").on(\"keydown.zf.slider\",function(e){var i,s=t(this),o=n.options.doubleSided?n.handles.index(s):0,a=parseFloat(n.inputs.eq(o).val());Foundation.Keyboard.handleKey(e,\"Slider\",{decrease:function decrease(){i=a-n.options.step;},increase:function increase(){i=a+n.options.step;},decrease_fast:function decrease_fast(){i=a-10*n.options.step;},increase_fast:function increase_fast(){i=a+10*n.options.step;},handled:function handled(){e.preventDefault(),n._setHandlePos(s,i,!0);}});});}},{key:\"destroy\",value:function value(){this.handles.off(\".zf.slider\"),this.inputs.off(\".zf.slider\"),this.$element.off(\".zf.slider\"),Foundation.unregisterPlugin(this);}}]),n;}();n.defaults={start:0,end:100,step:1,initialStart:0,initialEnd:100,binding:!1,clickSelect:!0,vertical:!1,draggable:!0,disabled:!1,doubleSided:!1,decimal:2,moveTime:200,disabledClass:\"disabled\",invertVertical:!1,changedDelay:500},Foundation.plugin(n,\"Slider\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){function e(t){return parseInt(window.getComputedStyle(document.body,null).fontSize,10)*t;}var i=function(){function i(e,n){_classCallCheck(this,i),this.$element=e,this.options=t.extend({},i.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Sticky\");}return _createClass(i,[{key:\"_init\",value:function value(){var e=this.$element.parent(\"[data-sticky-container]\"),i=this.$element[0].id||Foundation.GetYoDigits(6,\"sticky\"),n=this;e.length||(this.wasWrapped=!0),this.$container=e.length?e:t(this.options.container).wrapInner(this.$element),this.$container.addClass(this.options.containerClass),this.$element.addClass(this.options.stickyClass).attr({\"data-resize\":i}),this.scrollCount=this.options.checkEvery,this.isStuck=!1,t(window).one(\"load.zf.sticky\",function(){\"\"!==n.options.anchor?n.$anchor=t(\"#\"+n.options.anchor):n._parsePoints(),n._setSizes(function(){n._calc(!1);}),n._events(i.split(\"-\").reverse().join(\"-\"));});}},{key:\"_parsePoints\",value:function value(){for(var e=\"\"==this.options.topAnchor?1:this.options.topAnchor,i=\"\"==this.options.btmAnchor?document.documentElement.scrollHeight:this.options.btmAnchor,n=[e,i],s={},o=0,a=n.length;a>o&&n[o];o++){var r;if(\"number\"==typeof n[o])r=n[o];else{var l=n[o].split(\":\"),u=t(\"#\"+l[0]);r=u.offset().top,l[1]&&\"bottom\"===l[1].toLowerCase()&&(r+=u[0].getBoundingClientRect().height);}s[o]=r;}this.points=s;}},{key:\"_events\",value:function value(e){var i=this,n=this.scrollListener=\"scroll.zf.\"+e;this.isOn||(this.canStick&&(this.isOn=!0,t(window).off(n).on(n,function(t){0===i.scrollCount?(i.scrollCount=i.options.checkEvery,i._setSizes(function(){i._calc(!1,window.pageYOffset);})):(i.scrollCount--,i._calc(!1,window.pageYOffset));})),this.$element.off(\"resizeme.zf.trigger\").on(\"resizeme.zf.trigger\",function(t,s){i._setSizes(function(){i._calc(!1),i.canStick?i.isOn||i._events(e):i.isOn&&i._pauseListeners(n);});}));}},{key:\"_pauseListeners\",value:function value(e){this.isOn=!1,t(window).off(e),this.$element.trigger(\"pause.zf.sticky\");}},{key:\"_calc\",value:function value(t,e){return t&&this._setSizes(),this.canStick?(e||(e=window.pageYOffset),void(e>=this.topPoint?e<=this.bottomPoint?this.isStuck||this._setSticky():this.isStuck&&this._removeSticky(!1):this.isStuck&&this._removeSticky(!0))):(this.isStuck&&this._removeSticky(!0),!1);}},{key:\"_setSticky\",value:function value(){var t=this,e=this.options.stickTo,i=\"top\"===e?\"marginTop\":\"marginBottom\",n=\"top\"===e?\"bottom\":\"top\",s={};s[i]=this.options[i]+\"em\",s[e]=0,s[n]=\"auto\",s.left=this.$container.offset().left+parseInt(window.getComputedStyle(this.$container[0])[\"padding-left\"],10),this.isStuck=!0,this.$element.removeClass(\"is-anchored is-at-\"+n).addClass(\"is-stuck is-at-\"+e).css(s).trigger(\"sticky.zf.stuckto:\"+e),this.$element.on(\"transitionend webkitTransitionEnd oTransitionEnd otransitionend MSTransitionEnd\",function(){t._setSizes();});}},{key:\"_removeSticky\",value:function value(t){var e=this.options.stickTo,i=\"top\"===e,n={},s=(this.points?this.points[1]-this.points[0]:this.anchorHeight)-this.elemHeight,o=i?\"marginTop\":\"marginBottom\",a=t?\"top\":\"bottom\";n[o]=0,n.bottom=\"auto\",t?n.top=0:n.top=s,n.left=\"\",this.isStuck=!1,this.$element.removeClass(\"is-stuck is-at-\"+e).addClass(\"is-anchored is-at-\"+a).css(n).trigger(\"sticky.zf.unstuckfrom:\"+a);}},{key:\"_setSizes\",value:function value(t){this.canStick=Foundation.MediaQuery.atLeast(this.options.stickyOn),this.canStick||t();var e=this.$container[0].getBoundingClientRect().width,i=window.getComputedStyle(this.$container[0]),n=parseInt(i[\"padding-right\"],10);this.$anchor&&this.$anchor.length?this.anchorHeight=this.$anchor[0].getBoundingClientRect().height:this._parsePoints(),this.$element.css({\"max-width\":e-n+\"px\"});var s=this.$element[0].getBoundingClientRect().height||this.containerHeight;\"none\"==this.$element.css(\"display\")&&(s=0),this.containerHeight=s,this.$container.css({height:s}),this.elemHeight=s,this.isStuck&&this.$element.css({left:this.$container.offset().left+parseInt(i[\"padding-left\"],10)}),this._setBreakPoints(s,function(){t&&t();});}},{key:\"_setBreakPoints\",value:function value(t,i){if(!this.canStick){if(!i)return!1;i();}var n=e(this.options.marginTop),s=e(this.options.marginBottom),o=this.points?this.points[0]:this.$anchor.offset().top,a=this.points?this.points[1]:o+this.anchorHeight,r=window.innerHeight;\"top\"===this.options.stickTo?(o-=n,a-=t+n):\"bottom\"===this.options.stickTo&&(o-=r-(t+s),a-=r-s),this.topPoint=o,this.bottomPoint=a,i&&i();}},{key:\"destroy\",value:function value(){this._removeSticky(!0),this.$element.removeClass(this.options.stickyClass+\" is-anchored is-at-top\").css({height:\"\",top:\"\",bottom:\"\",\"max-width\":\"\"}).off(\"resizeme.zf.trigger\"),this.$anchor&&this.$anchor.length&&this.$anchor.off(\"change.zf.sticky\"),t(window).off(this.scrollListener),this.wasWrapped?this.$element.unwrap():this.$container.removeClass(this.options.containerClass).css({height:\"\"}),Foundation.unregisterPlugin(this);}}]),i;}();i.defaults={container:\"<div data-sticky-container></div>\",stickTo:\"top\",anchor:\"\",topAnchor:\"\",btmAnchor:\"\",marginTop:1,marginBottom:1,stickyOn:\"medium\",stickyClass:\"sticky\",containerClass:\"sticky-container\",checkEvery:-1},Foundation.plugin(i,\"Sticky\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Tabs\"),Foundation.Keyboard.register(\"Tabs\",{ENTER:\"open\",SPACE:\"open\",ARROW_RIGHT:\"next\",ARROW_UP:\"previous\",ARROW_DOWN:\"next\",ARROW_LEFT:\"previous\"});}return _createClass(e,[{key:\"_init\",value:function value(){var e=this;if(this.$tabTitles=this.$element.find(\".\"+this.options.linkClass),this.$tabContent=t('[data-tabs-content=\"'+this.$element[0].id+'\"]'),this.$tabTitles.each(function(){var i=t(this),n=i.find(\"a\"),s=i.hasClass(\"is-active\"),o=n[0].hash.slice(1),a=n[0].id?n[0].id:o+\"-label\",r=t(\"#\"+o);i.attr({role:\"presentation\"}),n.attr({role:\"tab\",\"aria-controls\":o,\"aria-selected\":s,id:a}),r.attr({role:\"tabpanel\",\"aria-hidden\":!s,\"aria-labelledby\":a}),s&&e.options.autoFocus&&n.focus();}),this.options.matchHeight){var i=this.$tabContent.find(\"img\");i.length?Foundation.onImagesLoaded(i,this._setHeight.bind(this)):this._setHeight();}this._events();}},{key:\"_events\",value:function value(){this._addKeyHandler(),this._addClickHandler(),this._setHeightMqHandler=null,this.options.matchHeight&&(this._setHeightMqHandler=this._setHeight.bind(this),t(window).on(\"changed.zf.mediaquery\",this._setHeightMqHandler));}},{key:\"_addClickHandler\",value:function value(){var e=this;this.$element.off(\"click.zf.tabs\").on(\"click.zf.tabs\",\".\"+this.options.linkClass,function(i){i.preventDefault(),i.stopPropagation(),t(this).hasClass(\"is-active\")||e._handleTabChange(t(this));});}},{key:\"_addKeyHandler\",value:function value(){var e=this;e.$element.find(\"li:first-of-type\"),e.$element.find(\"li:last-of-type\");this.$tabTitles.off(\"keydown.zf.tabs\").on(\"keydown.zf.tabs\",function(i){if(9!==i.which){var n,s,o=t(this),a=o.parent(\"ul\").children(\"li\");a.each(function(i){return t(this).is(o)?void(e.options.wrapOnKeys?(n=0===i?a.last():a.eq(i-1),s=i===a.length-1?a.first():a.eq(i+1)):(n=a.eq(Math.max(0,i-1)),s=a.eq(Math.min(i+1,a.length-1)))):void 0;}),Foundation.Keyboard.handleKey(i,\"Tabs\",{open:function open(){o.find('[role=\"tab\"]').focus(),e._handleTabChange(o);},previous:function previous(){n.find('[role=\"tab\"]').focus(),e._handleTabChange(n);},next:function next(){s.find('[role=\"tab\"]').focus(),e._handleTabChange(s);},handled:function handled(){i.stopPropagation(),i.preventDefault();}});}});}},{key:\"_handleTabChange\",value:function value(e){var i=e.find('[role=\"tab\"]'),n=i[0].hash,s=this.$tabContent.find(n),o=this.$element.find(\".\"+this.options.linkClass+\".is-active\").removeClass(\"is-active\").find('[role=\"tab\"]').attr({\"aria-selected\":\"false\"});t(\"#\"+o.attr(\"aria-controls\")).removeClass(\"is-active\").attr({\"aria-hidden\":\"true\"}),e.addClass(\"is-active\"),i.attr({\"aria-selected\":\"true\"}),s.addClass(\"is-active\").attr({\"aria-hidden\":\"false\"}),this.$element.trigger(\"change.zf.tabs\",[e]);}},{key:\"selectTab\",value:function value(t){var e;e=\"object\"==(typeof t===\"undefined\"?\"undefined\":_typeof(t))?t[0].id:t,e.indexOf(\"#\")<0&&(e=\"#\"+e);var i=this.$tabTitles.find('[href=\"'+e+'\"]').parent(\".\"+this.options.linkClass);this._handleTabChange(i);}},{key:\"_setHeight\",value:function value(){var e=0;this.$tabContent.find(\".\"+this.options.panelClass).css(\"height\",\"\").each(function(){var i=t(this),n=i.hasClass(\"is-active\");n||i.css({visibility:\"hidden\",display:\"block\"});var s=this.getBoundingClientRect().height;n||i.css({visibility:\"\",display:\"\"}),e=s>e?s:e;}).css(\"height\",e+\"px\");}},{key:\"destroy\",value:function value(){this.$element.find(\".\"+this.options.linkClass).off(\".zf.tabs\").hide().end().find(\".\"+this.options.panelClass).hide(),this.options.matchHeight&&null!=this._setHeightMqHandler&&t(window).off(\"changed.zf.mediaquery\",this._setHeightMqHandler),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={autoFocus:!1,wrapOnKeys:!0,matchHeight:!1,linkClass:\"tabs-title\",panelClass:\"tabs-panel\"},Foundation.plugin(e,\"Tabs\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,i.data(),n),this.className=\"\",this._init(),this._events(),Foundation.registerPlugin(this,\"Toggler\");}return _createClass(e,[{key:\"_init\",value:function value(){var e;this.options.animate?(e=this.options.animate.split(\" \"),this.animationIn=e[0],this.animationOut=e[1]||null):(e=this.$element.data(\"toggler\"),this.className=\".\"===e[0]?e.slice(1):e);var i=this.$element[0].id;t('[data-open=\"'+i+'\"], [data-close=\"'+i+'\"], [data-toggle=\"'+i+'\"]').attr(\"aria-controls\",i),this.$element.attr(\"aria-expanded\",!this.$element.is(\":hidden\"));}},{key:\"_events\",value:function value(){this.$element.off(\"toggle.zf.trigger\").on(\"toggle.zf.trigger\",this.toggle.bind(this));}},{key:\"toggle\",value:function value(){this[this.options.animate?\"_toggleAnimate\":\"_toggleClass\"]();}},{key:\"_toggleClass\",value:function value(){this.$element.toggleClass(this.className);var t=this.$element.hasClass(this.className);t?this.$element.trigger(\"on.zf.toggler\"):this.$element.trigger(\"off.zf.toggler\"),this._updateARIA(t);}},{key:\"_toggleAnimate\",value:function value(){var t=this;this.$element.is(\":hidden\")?Foundation.Motion.animateIn(this.$element,this.animationIn,function(){t._updateARIA(!0),this.trigger(\"on.zf.toggler\");}):Foundation.Motion.animateOut(this.$element,this.animationOut,function(){t._updateARIA(!1),this.trigger(\"off.zf.toggler\");});}},{key:\"_updateARIA\",value:function value(t){this.$element.attr(\"aria-expanded\",!!t);}},{key:\"destroy\",value:function value(){this.$element.off(\".zf.toggler\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={animate:!1},Foundation.plugin(e,\"Toggler\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this.isActive=!1,this.isClick=!1,this._init(),Foundation.registerPlugin(this,\"Tooltip\");}return _createClass(e,[{key:\"_init\",value:function value(){var e=this.$element.attr(\"aria-describedby\")||Foundation.GetYoDigits(6,\"tooltip\");this.options.positionClass=this.options.positionClass||this._getPositionClass(this.$element),this.options.tipText=this.options.tipText||this.$element.attr(\"title\"),this.template=this.options.template?t(this.options.template):this._buildTemplate(e),this.template.appendTo(document.body).text(this.options.tipText).hide(),this.$element.attr({title:\"\",\"aria-describedby\":e,\"data-yeti-box\":e,\"data-toggle\":e,\"data-resize\":e}).addClass(this.triggerClass),this.usedPositions=[],this.counter=4,this.classChanged=!1,this._events();}},{key:\"_getPositionClass\",value:function value(t){if(!t)return\"\";var e=t[0].className.match(/\\b(top|left|right)\\b/g);return e=e?e[0]:\"\";}},{key:\"_buildTemplate\",value:function value(e){var i=(this.options.tooltipClass+\" \"+this.options.positionClass+\" \"+this.options.templateClasses).trim(),n=t(\"<div></div>\").addClass(i).attr({role:\"tooltip\",\"aria-hidden\":!0,\"data-is-active\":!1,\"data-is-focus\":!1,id:e});return n;}},{key:\"_reposition\",value:function value(t){this.usedPositions.push(t?t:\"bottom\"),!t&&this.usedPositions.indexOf(\"top\")<0?this.template.addClass(\"top\"):\"top\"===t&&this.usedPositions.indexOf(\"bottom\")<0?this.template.removeClass(t):\"left\"===t&&this.usedPositions.indexOf(\"right\")<0?this.template.removeClass(t).addClass(\"right\"):\"right\"===t&&this.usedPositions.indexOf(\"left\")<0?this.template.removeClass(t).addClass(\"left\"):!t&&this.usedPositions.indexOf(\"top\")>-1&&this.usedPositions.indexOf(\"left\")<0?this.template.addClass(\"left\"):\"top\"===t&&this.usedPositions.indexOf(\"bottom\")>-1&&this.usedPositions.indexOf(\"left\")<0?this.template.removeClass(t).addClass(\"left\"):\"left\"===t&&this.usedPositions.indexOf(\"right\")>-1&&this.usedPositions.indexOf(\"bottom\")<0?this.template.removeClass(t):\"right\"===t&&this.usedPositions.indexOf(\"left\")>-1&&this.usedPositions.indexOf(\"bottom\")<0?this.template.removeClass(t):this.template.removeClass(t),this.classChanged=!0,this.counter--;}},{key:\"_setPosition\",value:function value(){var t=this._getPositionClass(this.template),e=Foundation.Box.GetDimensions(this.template),i=Foundation.Box.GetDimensions(this.$element),n=\"left\"===t?\"left\":\"right\"===t?\"left\":\"top\",s=\"top\"===n?\"height\":\"width\";\"height\"===s?this.options.vOffset:this.options.hOffset;if(e.width>=e.windowDims.width||!this.counter&&!Foundation.Box.ImNotTouchingYou(this.template))return this.template.offset(Foundation.Box.GetOffsets(this.template,this.$element,\"center bottom\",this.options.vOffset,this.options.hOffset,!0)).css({width:i.windowDims.width-2*this.options.hOffset,height:\"auto\"}),!1;for(this.template.offset(Foundation.Box.GetOffsets(this.template,this.$element,\"center \"+(t||\"bottom\"),this.options.vOffset,this.options.hOffset));!Foundation.Box.ImNotTouchingYou(this.template)&&this.counter;){this._reposition(t),this._setPosition();}}},{key:\"show\",value:function value(){if(\"all\"!==this.options.showOn&&!Foundation.MediaQuery.atLeast(this.options.showOn))return!1;var t=this;this.template.css(\"visibility\",\"hidden\").show(),this._setPosition(),this.$element.trigger(\"closeme.zf.tooltip\",this.template.attr(\"id\")),this.template.attr({\"data-is-active\":!0,\"aria-hidden\":!1}),t.isActive=!0,this.template.stop().hide().css(\"visibility\",\"\").fadeIn(this.options.fadeInDuration,function(){}),this.$element.trigger(\"show.zf.tooltip\");}},{key:\"hide\",value:function value(){var t=this;this.template.stop().attr({\"aria-hidden\":!0,\"data-is-active\":!1}).fadeOut(this.options.fadeOutDuration,function(){t.isActive=!1,t.isClick=!1,t.classChanged&&(t.template.removeClass(t._getPositionClass(t.template)).addClass(t.options.positionClass),t.usedPositions=[],t.counter=4,t.classChanged=!1);}),this.$element.trigger(\"hide.zf.tooltip\");}},{key:\"_events\",value:function value(){var t=this,e=(this.template,!1);this.options.disableHover||this.$element.on(\"mouseenter.zf.tooltip\",function(e){t.isActive||(t.timeout=setTimeout(function(){t.show();},t.options.hoverDelay));}).on(\"mouseleave.zf.tooltip\",function(i){clearTimeout(t.timeout),(!e||t.isClick&&!t.options.clickOpen)&&t.hide();}),this.options.clickOpen?this.$element.on(\"mousedown.zf.tooltip\",function(e){e.stopImmediatePropagation(),t.isClick||(t.isClick=!0,!t.options.disableHover&&t.$element.attr(\"tabindex\")||t.isActive||t.show());}):this.$element.on(\"mousedown.zf.tooltip\",function(e){e.stopImmediatePropagation(),t.isClick=!0;}),this.options.disableForTouch||this.$element.on(\"tap.zf.tooltip touchend.zf.tooltip\",function(e){t.isActive?t.hide():t.show();}),this.$element.on({\"close.zf.trigger\":this.hide.bind(this)}),this.$element.on(\"focus.zf.tooltip\",function(i){return e=!0,t.isClick?(t.options.clickOpen||(e=!1),!1):void t.show();}).on(\"focusout.zf.tooltip\",function(i){e=!1,t.isClick=!1,t.hide();}).on(\"resizeme.zf.trigger\",function(){t.isActive&&t._setPosition();});}},{key:\"toggle\",value:function value(){this.isActive?this.hide():this.show();}},{key:\"destroy\",value:function value(){this.$element.attr(\"title\",this.template.text()).off(\".zf.trigger .zf.tootip\").removeAttr(\"aria-describedby\").removeAttr(\"data-yeti-box\").removeAttr(\"data-toggle\").removeAttr(\"data-resize\"),this.template.remove(),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={disableForTouch:!1,hoverDelay:200,fadeInDuration:150,fadeOutDuration:150,disableHover:!1,templateClasses:\"\",tooltipClass:\"tooltip\",triggerClass:\"has-tip\",showOn:\"small\",template:\"\",tipText:\"\",touchCloseText:\"Tap to close.\",clickOpen:!0,positionClass:\"\",vOffset:10,hOffset:12},Foundation.plugin(e,\"Tooltip\");}(jQuery);"

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {'use strict';
	
	var React = __webpack_require__(8);
	var ReactDOM = __webpack_require__(165);
	
	var _require = __webpack_require__(166);
	
	var Route = _require.Route;
	var Router = _require.Router;
	var IndexRoute = _require.IndexRoute;
	var hashHistory = _require.hashHistory;
	
	//load foundation
	
	$(document).foundation();
	
	// App css
	__webpack_require__(229);
	
	// ReactDOM.render(
	//   <p>Boilerplate 3 Project</p>,
	//   document.getElementById("app")
	// );
	
	// require('./redux-example.jsx');
	__webpack_require__(249);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = jQuery;

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(9);

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule React
	 */
	
	'use strict';
	
	var ReactDOM = __webpack_require__(10);
	var ReactDOMServer = __webpack_require__(155);
	var ReactIsomorphic = __webpack_require__(159);
	
	var assign = __webpack_require__(46);
	var deprecated = __webpack_require__(164);
	
	// `version` will be added here by ReactIsomorphic.
	var React = {};
	
	assign(React, ReactIsomorphic);
	
	assign(React, {
	  // ReactDOM
	  findDOMNode: deprecated('findDOMNode', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.findDOMNode),
	  render: deprecated('render', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.render),
	  unmountComponentAtNode: deprecated('unmountComponentAtNode', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.unmountComponentAtNode),
	
	  // ReactDOMServer
	  renderToString: deprecated('renderToString', 'ReactDOMServer', 'react-dom/server', ReactDOMServer, ReactDOMServer.renderToString),
	  renderToStaticMarkup: deprecated('renderToStaticMarkup', 'ReactDOMServer', 'react-dom/server', ReactDOMServer, ReactDOMServer.renderToStaticMarkup)
	});
	
	React.__SECRET_DOM_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactDOM;
	React.__SECRET_DOM_SERVER_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactDOMServer;
	
	module.exports = React;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOM
	 */
	
	/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(12);
	var ReactDOMTextComponent = __webpack_require__(13);
	var ReactDefaultInjection = __webpack_require__(78);
	var ReactInstanceHandles = __webpack_require__(52);
	var ReactMount = __webpack_require__(35);
	var ReactPerf = __webpack_require__(25);
	var ReactReconciler = __webpack_require__(57);
	var ReactUpdates = __webpack_require__(61);
	var ReactVersion = __webpack_require__(153);
	
	var findDOMNode = __webpack_require__(98);
	var renderSubtreeIntoContainer = __webpack_require__(154);
	var warning = __webpack_require__(32);
	
	ReactDefaultInjection.inject();
	
	var render = ReactPerf.measure('React', 'render', ReactMount.render);
	
	var React = {
	  findDOMNode: findDOMNode,
	  render: render,
	  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
	  version: ReactVersion,
	
	  /* eslint-disable camelcase */
	  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
	  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
	};
	
	// Inject the runtime into a devtools global hook regardless of browser.
	// Allows for debugging when the hook is injected on the page.
	/* eslint-enable camelcase */
	if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
	  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
	    CurrentOwner: ReactCurrentOwner,
	    InstanceHandles: ReactInstanceHandles,
	    Mount: ReactMount,
	    Reconciler: ReactReconciler,
	    TextComponent: ReactDOMTextComponent
	  });
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  var ExecutionEnvironment = __webpack_require__(16);
	  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
	
	    // First check if devtools is not installed
	    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
	      // If we're in Chrome or Firefox, provide a download link if not installed.
	      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
	        console.debug('Download the React DevTools for a better development experience: ' + 'https://fb.me/react-devtools');
	      }
	    }
	
	    // If we're in IE8, check to see if we are in compatibility mode and provide
	    // information on preventing compatibility mode
	    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;
	
	    process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : undefined;
	
	    var expectedFeatures = [
	    // shims
	    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.split, String.prototype.trim,
	
	    // shams
	    Object.create, Object.freeze];
	
	    for (var i = 0; i < expectedFeatures.length; i++) {
	      if (!expectedFeatures[i]) {
	        console.error('One or more ES5 shim/shams expected by React are not available: ' + 'https://fb.me/react-warning-polyfills');
	        break;
	      }
	    }
	  }
	}
	
	module.exports = React;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 11 */
/***/ function(module, exports) {

	'use strict';
	
	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout() {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	})();
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch (e) {
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch (e) {
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e) {
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e) {
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while (len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () {
	    return '/';
	};
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function () {
	    return 0;
	};

/***/ },
/* 12 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactCurrentOwner
	 */
	
	'use strict';
	
	/**
	 * Keeps track of the current owner.
	 *
	 * The current owner is the component who should own any components that are
	 * currently being constructed.
	 */
	
	var ReactCurrentOwner = {
	
	  /**
	   * @internal
	   * @type {ReactComponent}
	   */
	  current: null
	
	};
	
	module.exports = ReactCurrentOwner;

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTextComponent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(14);
	var DOMPropertyOperations = __webpack_require__(29);
	var ReactComponentBrowserEnvironment = __webpack_require__(33);
	var ReactMount = __webpack_require__(35);
	
	var assign = __webpack_require__(46);
	var escapeTextContentForBrowser = __webpack_require__(28);
	var setTextContent = __webpack_require__(27);
	var validateDOMNesting = __webpack_require__(77);
	
	/**
	 * Text nodes violate a couple assumptions that React makes about components:
	 *
	 *  - When mounting text into the DOM, adjacent text nodes are merged.
	 *  - Text nodes cannot be assigned a React root ID.
	 *
	 * This component is used to wrap strings in elements so that they can undergo
	 * the same reconciliation that is applied to elements.
	 *
	 * TODO: Investigate representing React components in the DOM with text nodes.
	 *
	 * @class ReactDOMTextComponent
	 * @extends ReactComponent
	 * @internal
	 */
	var ReactDOMTextComponent = function ReactDOMTextComponent(props) {
	  // This constructor and its argument is currently used by mocks.
	};
	
	assign(ReactDOMTextComponent.prototype, {
	
	  /**
	   * @param {ReactText} text
	   * @internal
	   */
	  construct: function construct(text) {
	    // TODO: This is really a ReactText (ReactNode), not a ReactElement
	    this._currentElement = text;
	    this._stringText = '' + text;
	
	    // Properties
	    this._rootNodeID = null;
	    this._mountIndex = 0;
	  },
	
	  /**
	   * Creates the markup for this text node. This node is not intended to have
	   * any features besides containing text content.
	   *
	   * @param {string} rootID DOM ID of the root node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {string} Markup for this text node.
	   * @internal
	   */
	  mountComponent: function mountComponent(rootID, transaction, context) {
	    if (process.env.NODE_ENV !== 'production') {
	      if (context[validateDOMNesting.ancestorInfoContextKey]) {
	        validateDOMNesting('span', null, context[validateDOMNesting.ancestorInfoContextKey]);
	      }
	    }
	
	    this._rootNodeID = rootID;
	    if (transaction.useCreateElement) {
	      var ownerDocument = context[ReactMount.ownerDocumentContextKey];
	      var el = ownerDocument.createElement('span');
	      DOMPropertyOperations.setAttributeForID(el, rootID);
	      // Populate node cache
	      ReactMount.getID(el);
	      setTextContent(el, this._stringText);
	      return el;
	    } else {
	      var escapedText = escapeTextContentForBrowser(this._stringText);
	
	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd wrap this in a `span` for the reasons stated above, but
	        // since this is a situation where React won't take over (static pages),
	        // we can simply return the text as it is.
	        return escapedText;
	      }
	
	      return '<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' + escapedText + '</span>';
	    }
	  },
	
	  /**
	   * Updates this component by updating the text content.
	   *
	   * @param {ReactText} nextText The next text content
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  receiveComponent: function receiveComponent(nextText, transaction) {
	    if (nextText !== this._currentElement) {
	      this._currentElement = nextText;
	      var nextStringText = '' + nextText;
	      if (nextStringText !== this._stringText) {
	        // TODO: Save this as pending props and use performUpdateIfNecessary
	        // and/or updateComponent to do the actual update for consistency with
	        // other component types?
	        this._stringText = nextStringText;
	        var node = ReactMount.getNode(this._rootNodeID);
	        DOMChildrenOperations.updateTextContent(node, nextStringText);
	      }
	    }
	  },
	
	  unmountComponent: function unmountComponent() {
	    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
	  }
	
	});
	
	module.exports = ReactDOMTextComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMChildrenOperations
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var Danger = __webpack_require__(15);
	var ReactMultiChildUpdateTypes = __webpack_require__(23);
	var ReactPerf = __webpack_require__(25);
	
	var setInnerHTML = __webpack_require__(26);
	var setTextContent = __webpack_require__(27);
	var invariant = __webpack_require__(20);
	
	/**
	 * Inserts `childNode` as a child of `parentNode` at the `index`.
	 *
	 * @param {DOMElement} parentNode Parent node in which to insert.
	 * @param {DOMElement} childNode Child node to insert.
	 * @param {number} index Index at which to insert the child.
	 * @internal
	 */
	function insertChildAt(parentNode, childNode, index) {
	  // By exploiting arrays returning `undefined` for an undefined index, we can
	  // rely exclusively on `insertBefore(node, null)` instead of also using
	  // `appendChild(node)`. However, using `undefined` is not allowed by all
	  // browsers so we must replace it with `null`.
	
	  // fix render order error in safari
	  // IE8 will throw error when index out of list size.
	  var beforeChild = index >= parentNode.childNodes.length ? null : parentNode.childNodes.item(index);
	
	  parentNode.insertBefore(childNode, beforeChild);
	}
	
	/**
	 * Operations for updating with DOM children.
	 */
	var DOMChildrenOperations = {
	
	  dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,
	
	  updateTextContent: setTextContent,
	
	  /**
	   * Updates a component's children by processing a series of updates. The
	   * update configurations are each expected to have a `parentNode` property.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @param {array<string>} markupList List of markup strings.
	   * @internal
	   */
	  processUpdates: function processUpdates(updates, markupList) {
	    var update;
	    // Mapping from parent IDs to initial child orderings.
	    var initialChildren = null;
	    // List of children that will be moved or removed.
	    var updatedChildren = null;
	
	    for (var i = 0; i < updates.length; i++) {
	      update = updates[i];
	      if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING || update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {
	        var updatedIndex = update.fromIndex;
	        var updatedChild = update.parentNode.childNodes[updatedIndex];
	        var parentID = update.parentID;
	
	        !updatedChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processUpdates(): Unable to find child %s of element. This ' + 'probably means the DOM was unexpectedly mutated (e.g., by the ' + 'browser), usually due to forgetting a <tbody> when using tables, ' + 'nesting tags like <form>, <p>, or <a>, or using non-SVG elements ' + 'in an <svg> parent. Try inspecting the child nodes of the element ' + 'with React ID `%s`.', updatedIndex, parentID) : invariant(false) : undefined;
	
	        initialChildren = initialChildren || {};
	        initialChildren[parentID] = initialChildren[parentID] || [];
	        initialChildren[parentID][updatedIndex] = updatedChild;
	
	        updatedChildren = updatedChildren || [];
	        updatedChildren.push(updatedChild);
	      }
	    }
	
	    var renderedMarkup;
	    // markupList is either a list of markup or just a list of elements
	    if (markupList.length && typeof markupList[0] === 'string') {
	      renderedMarkup = Danger.dangerouslyRenderMarkup(markupList);
	    } else {
	      renderedMarkup = markupList;
	    }
	
	    // Remove updated children first so that `toIndex` is consistent.
	    if (updatedChildren) {
	      for (var j = 0; j < updatedChildren.length; j++) {
	        updatedChildren[j].parentNode.removeChild(updatedChildren[j]);
	      }
	    }
	
	    for (var k = 0; k < updates.length; k++) {
	      update = updates[k];
	      switch (update.type) {
	        case ReactMultiChildUpdateTypes.INSERT_MARKUP:
	          insertChildAt(update.parentNode, renderedMarkup[update.markupIndex], update.toIndex);
	          break;
	        case ReactMultiChildUpdateTypes.MOVE_EXISTING:
	          insertChildAt(update.parentNode, initialChildren[update.parentID][update.fromIndex], update.toIndex);
	          break;
	        case ReactMultiChildUpdateTypes.SET_MARKUP:
	          setInnerHTML(update.parentNode, update.content);
	          break;
	        case ReactMultiChildUpdateTypes.TEXT_CONTENT:
	          setTextContent(update.parentNode, update.content);
	          break;
	        case ReactMultiChildUpdateTypes.REMOVE_NODE:
	          // Already removed by the for-loop above.
	          break;
	      }
	    }
	  }
	
	};
	
	ReactPerf.measureMethods(DOMChildrenOperations, 'DOMChildrenOperations', {
	  updateTextContent: 'updateTextContent'
	});
	
	module.exports = DOMChildrenOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Danger
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(16);
	
	var createNodesFromMarkup = __webpack_require__(17);
	var emptyFunction = __webpack_require__(22);
	var getMarkupWrap = __webpack_require__(21);
	var invariant = __webpack_require__(20);
	
	var OPEN_TAG_NAME_EXP = /^(<[^ \/>]+)/;
	var RESULT_INDEX_ATTR = 'data-danger-index';
	
	/**
	 * Extracts the `nodeName` from a string of markup.
	 *
	 * NOTE: Extracting the `nodeName` does not require a regular expression match
	 * because we make assumptions about React-generated markup (i.e. there are no
	 * spaces surrounding the opening tag and there is at least one attribute).
	 *
	 * @param {string} markup String of markup.
	 * @return {string} Node name of the supplied markup.
	 * @see http://jsperf.com/extract-nodename
	 */
	function getNodeName(markup) {
	  return markup.substring(1, markup.indexOf(' '));
	}
	
	var Danger = {
	
	  /**
	   * Renders markup into an array of nodes. The markup is expected to render
	   * into a list of root nodes. Also, the length of `resultList` and
	   * `markupList` should be the same.
	   *
	   * @param {array<string>} markupList List of markup strings to render.
	   * @return {array<DOMElement>} List of rendered nodes.
	   * @internal
	   */
	  dangerouslyRenderMarkup: function dangerouslyRenderMarkup(markupList) {
	    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyRenderMarkup(...): Cannot render markup in a worker ' + 'thread. Make sure `window` and `document` are available globally ' + 'before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString for server rendering.') : invariant(false) : undefined;
	    var nodeName;
	    var markupByNodeName = {};
	    // Group markup by `nodeName` if a wrap is necessary, else by '*'.
	    for (var i = 0; i < markupList.length; i++) {
	      !markupList[i] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyRenderMarkup(...): Missing markup.') : invariant(false) : undefined;
	      nodeName = getNodeName(markupList[i]);
	      nodeName = getMarkupWrap(nodeName) ? nodeName : '*';
	      markupByNodeName[nodeName] = markupByNodeName[nodeName] || [];
	      markupByNodeName[nodeName][i] = markupList[i];
	    }
	    var resultList = [];
	    var resultListAssignmentCount = 0;
	    for (nodeName in markupByNodeName) {
	      if (!markupByNodeName.hasOwnProperty(nodeName)) {
	        continue;
	      }
	      var markupListByNodeName = markupByNodeName[nodeName];
	
	      // This for-in loop skips the holes of the sparse array. The order of
	      // iteration should follow the order of assignment, which happens to match
	      // numerical index order, but we don't rely on that.
	      var resultIndex;
	      for (resultIndex in markupListByNodeName) {
	        if (markupListByNodeName.hasOwnProperty(resultIndex)) {
	          var markup = markupListByNodeName[resultIndex];
	
	          // Push the requested markup with an additional RESULT_INDEX_ATTR
	          // attribute.  If the markup does not start with a < character, it
	          // will be discarded below (with an appropriate console.error).
	          markupListByNodeName[resultIndex] = markup.replace(OPEN_TAG_NAME_EXP,
	          // This index will be parsed back out below.
	          '$1 ' + RESULT_INDEX_ATTR + '="' + resultIndex + '" ');
	        }
	      }
	
	      // Render each group of markup with similar wrapping `nodeName`.
	      var renderNodes = createNodesFromMarkup(markupListByNodeName.join(''), emptyFunction // Do nothing special with <script> tags.
	      );
	
	      for (var j = 0; j < renderNodes.length; ++j) {
	        var renderNode = renderNodes[j];
	        if (renderNode.hasAttribute && renderNode.hasAttribute(RESULT_INDEX_ATTR)) {
	
	          resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR);
	          renderNode.removeAttribute(RESULT_INDEX_ATTR);
	
	          !!resultList.hasOwnProperty(resultIndex) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Assigning to an already-occupied result index.') : invariant(false) : undefined;
	
	          resultList[resultIndex] = renderNode;
	
	          // This should match resultList.length and markupList.length when
	          // we're done.
	          resultListAssignmentCount += 1;
	        } else if (process.env.NODE_ENV !== 'production') {
	          console.error('Danger: Discarding unexpected node:', renderNode);
	        }
	      }
	    }
	
	    // Although resultList was populated out of order, it should now be a dense
	    // array.
	    !(resultListAssignmentCount === resultList.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Did not assign to every index of resultList.') : invariant(false) : undefined;
	
	    !(resultList.length === markupList.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Expected markup to render %s nodes, but rendered %s.', markupList.length, resultList.length) : invariant(false) : undefined;
	
	    return resultList;
	  },
	
	  /**
	   * Replaces a node with a string of markup at its current position within its
	   * parent. The markup must render into a single root node.
	   *
	   * @param {DOMElement} oldChild Child node to replace.
	   * @param {string} markup Markup to render in place of the child node.
	   * @internal
	   */
	  dangerouslyReplaceNodeWithMarkup: function dangerouslyReplaceNodeWithMarkup(oldChild, markup) {
	    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a ' + 'worker thread. Make sure `window` and `document` are available ' + 'globally before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;
	    !markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : invariant(false) : undefined;
	    !(oldChild.tagName.toLowerCase() !== 'html') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the ' + '<html> node. This is because browser quirks make this unreliable ' + 'and/or slow. If you want to render to the root you must use ' + 'server rendering. See ReactDOMServer.renderToString().') : invariant(false) : undefined;
	
	    var newChild;
	    if (typeof markup === 'string') {
	      newChild = createNodesFromMarkup(markup, emptyFunction)[0];
	    } else {
	      newChild = markup;
	    }
	    oldChild.parentNode.replaceChild(newChild, oldChild);
	  }
	
	};
	
	module.exports = Danger;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 16 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ExecutionEnvironment
	 */
	
	'use strict';
	
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	
	/**
	 * Simple, lightweight module assisting with the detection and context of
	 * Worker. Helps avoid circular dependencies and allows code to reason about
	 * whether or not they are in a Worker, even if they never include the main
	 * `ReactWorker` dependency.
	 */
	var ExecutionEnvironment = {
	
	  canUseDOM: canUseDOM,
	
	  canUseWorkers: typeof Worker !== 'undefined',
	
	  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
	
	  canUseViewport: canUseDOM && !!window.screen,
	
	  isInWorker: !canUseDOM // For now, this is true - might change in the future.
	
	};
	
	module.exports = ExecutionEnvironment;

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule createNodesFromMarkup
	 * @typechecks
	 */
	
	/*eslint-disable fb-www/unsafe-html*/
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(16);
	
	var createArrayFromMixed = __webpack_require__(18);
	var getMarkupWrap = __webpack_require__(21);
	var invariant = __webpack_require__(20);
	
	/**
	 * Dummy container used to render all markup.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Pattern used by `getNodeName`.
	 */
	var nodeNamePattern = /^\s*<(\w+)/;
	
	/**
	 * Extracts the `nodeName` of the first element in a string of markup.
	 *
	 * @param {string} markup String of markup.
	 * @return {?string} Node name of the supplied markup.
	 */
	function getNodeName(markup) {
	  var nodeNameMatch = markup.match(nodeNamePattern);
	  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
	}
	
	/**
	 * Creates an array containing the nodes rendered from the supplied markup. The
	 * optionally supplied `handleScript` function will be invoked once for each
	 * <script> element that is rendered. If no `handleScript` function is supplied,
	 * an exception is thrown if any <script> elements are rendered.
	 *
	 * @param {string} markup A string of valid HTML markup.
	 * @param {?function} handleScript Invoked once for each rendered <script>.
	 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
	 */
	function createNodesFromMarkup(markup, handleScript) {
	  var node = dummyNode;
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : undefined;
	  var nodeName = getNodeName(markup);
	
	  var wrap = nodeName && getMarkupWrap(nodeName);
	  if (wrap) {
	    node.innerHTML = wrap[1] + markup + wrap[2];
	
	    var wrapDepth = wrap[0];
	    while (wrapDepth--) {
	      node = node.lastChild;
	    }
	  } else {
	    node.innerHTML = markup;
	  }
	
	  var scripts = node.getElementsByTagName('script');
	  if (scripts.length) {
	    !handleScript ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : undefined;
	    createArrayFromMixed(scripts).forEach(handleScript);
	  }
	
	  var nodes = createArrayFromMixed(node.childNodes);
	  while (node.lastChild) {
	    node.removeChild(node.lastChild);
	  }
	  return nodes;
	}
	
	module.exports = createNodesFromMarkup;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule createArrayFromMixed
	 * @typechecks
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var toArray = __webpack_require__(19);
	
	/**
	 * Perform a heuristic test to determine if an object is "array-like".
	 *
	 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
	 *   Joshu replied: "Mu."
	 *
	 * This function determines if its argument has "array nature": it returns
	 * true if the argument is an actual array, an `arguments' object, or an
	 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
	 *
	 * It will return false for other array-like objects like Filelist.
	 *
	 * @param {*} obj
	 * @return {boolean}
	 */
	function hasArrayNature(obj) {
	  return (
	    // not null/false
	    !!obj && (
	    // arrays are objects, NodeLists are functions in Safari
	    (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == 'object' || typeof obj == 'function') &&
	    // quacks like an array
	    'length' in obj &&
	    // not window
	    !('setInterval' in obj) &&
	    // no DOM node should be considered an array-like
	    // a 'select' element has 'length' and 'item' properties on IE8
	    typeof obj.nodeType != 'number' && (
	    // a real array
	    Array.isArray(obj) ||
	    // arguments
	    'callee' in obj ||
	    // HTMLCollection/NodeList
	    'item' in obj)
	  );
	}
	
	/**
	 * Ensure that the argument is an array by wrapping it in an array if it is not.
	 * Creates a copy of the argument if it is already an array.
	 *
	 * This is mostly useful idiomatically:
	 *
	 *   var createArrayFromMixed = require('createArrayFromMixed');
	 *
	 *   function takesOneOrMoreThings(things) {
	 *     things = createArrayFromMixed(things);
	 *     ...
	 *   }
	 *
	 * This allows you to treat `things' as an array, but accept scalars in the API.
	 *
	 * If you need to convert an array-like object, like `arguments`, into an array
	 * use toArray instead.
	 *
	 * @param {*} obj
	 * @return {array}
	 */
	function createArrayFromMixed(obj) {
	  if (!hasArrayNature(obj)) {
	    return [obj];
	  } else if (Array.isArray(obj)) {
	    return obj.slice();
	  } else {
	    return toArray(obj);
	  }
	}
	
	module.exports = createArrayFromMixed;

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule toArray
	 * @typechecks
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var invariant = __webpack_require__(20);
	
	/**
	 * Convert array-like objects to arrays.
	 *
	 * This API assumes the caller knows the contents of the data type. For less
	 * well defined inputs use createArrayFromMixed.
	 *
	 * @param {object|function|filelist} obj
	 * @return {array}
	 */
	function toArray(obj) {
	  var length = obj.length;
	
	  // Some browse builtin objects can report typeof 'function' (e.g. NodeList in
	  // old versions of Safari).
	  !(!Array.isArray(obj) && ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' || typeof obj === 'function')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : undefined;
	
	  !(typeof length === 'number') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : undefined;
	
	  !(length === 0 || length - 1 in obj) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : undefined;
	
	  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
	  // without method will throw during the slice call and skip straight to the
	  // fallback.
	  if (obj.hasOwnProperty) {
	    try {
	      return Array.prototype.slice.call(obj);
	    } catch (e) {
	      // IE < 9 does not support Array#slice on collections objects
	    }
	  }
	
	  // Fall back to copying key by key. This assumes all keys have a value,
	  // so will not preserve sparsely populated inputs.
	  var ret = Array(length);
	  for (var ii = 0; ii < length; ii++) {
	    ret[ii] = obj[ii];
	  }
	  return ret;
	}
	
	module.exports = toArray;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule invariant
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	function invariant(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}
	
	module.exports = invariant;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getMarkupWrap
	 */
	
	/*eslint-disable fb-www/unsafe-html */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(16);
	
	var invariant = __webpack_require__(20);
	
	/**
	 * Dummy container used to detect which wraps are necessary.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Some browsers cannot use `innerHTML` to render certain elements standalone,
	 * so we wrap them, render the wrapped nodes, then extract the desired node.
	 *
	 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
	 */
	
	var shouldWrap = {};
	
	var selectWrap = [1, '<select multiple="true">', '</select>'];
	var tableWrap = [1, '<table>', '</table>'];
	var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
	
	var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];
	
	var markupWrap = {
	  '*': [1, '?<div>', '</div>'],
	
	  'area': [1, '<map>', '</map>'],
	  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
	  'legend': [1, '<fieldset>', '</fieldset>'],
	  'param': [1, '<object>', '</object>'],
	  'tr': [2, '<table><tbody>', '</tbody></table>'],
	
	  'optgroup': selectWrap,
	  'option': selectWrap,
	
	  'caption': tableWrap,
	  'colgroup': tableWrap,
	  'tbody': tableWrap,
	  'tfoot': tableWrap,
	  'thead': tableWrap,
	
	  'td': trWrap,
	  'th': trWrap
	};
	
	// Initialize the SVG elements since we know they'll always need to be wrapped
	// consistently. If they are created inside a <div> they will be initialized in
	// the wrong namespace (and will not display).
	var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
	svgElements.forEach(function (nodeName) {
	  markupWrap[nodeName] = svgWrap;
	  shouldWrap[nodeName] = true;
	});
	
	/**
	 * Gets the markup wrap configuration for the supplied `nodeName`.
	 *
	 * NOTE: This lazily detects which wraps are necessary for the current browser.
	 *
	 * @param {string} nodeName Lowercase `nodeName`.
	 * @return {?array} Markup wrap configuration, if applicable.
	 */
	function getMarkupWrap(nodeName) {
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : undefined;
	  if (!markupWrap.hasOwnProperty(nodeName)) {
	    nodeName = '*';
	  }
	  if (!shouldWrap.hasOwnProperty(nodeName)) {
	    if (nodeName === '*') {
	      dummyNode.innerHTML = '<link />';
	    } else {
	      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
	    }
	    shouldWrap[nodeName] = !dummyNode.firstChild;
	  }
	  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
	}
	
	module.exports = getMarkupWrap;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 22 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule emptyFunction
	 */
	
	"use strict";
	
	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}
	
	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	function emptyFunction() {}
	
	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};
	
	module.exports = emptyFunction;

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMultiChildUpdateTypes
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(24);
	
	/**
	 * When a component's children are updated, a series of update configuration
	 * objects are created in order to batch and serialize the required changes.
	 *
	 * Enumerates all the possible types of update configurations.
	 *
	 * @internal
	 */
	var ReactMultiChildUpdateTypes = keyMirror({
	  INSERT_MARKUP: null,
	  MOVE_EXISTING: null,
	  REMOVE_NODE: null,
	  SET_MARKUP: null,
	  TEXT_CONTENT: null
	});
	
	module.exports = ReactMultiChildUpdateTypes;

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule keyMirror
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(20);
	
	/**
	 * Constructs an enumeration with keys equal to their value.
	 *
	 * For example:
	 *
	 *   var COLORS = keyMirror({blue: null, red: null});
	 *   var myColor = COLORS.blue;
	 *   var isColorValid = !!COLORS[myColor];
	 *
	 * The last line could not be performed if the values of the generated enum were
	 * not equal to their keys.
	 *
	 *   Input:  {key1: val1, key2: val2}
	 *   Output: {key1: key1, key2: key2}
	 *
	 * @param {object} obj
	 * @return {object}
	 */
	var keyMirror = function keyMirror(obj) {
	  var ret = {};
	  var key;
	  !(obj instanceof Object && !Array.isArray(obj)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'keyMirror(...): Argument must be an object.') : invariant(false) : undefined;
	  for (key in obj) {
	    if (!obj.hasOwnProperty(key)) {
	      continue;
	    }
	    ret[key] = key;
	  }
	  return ret;
	};
	
	module.exports = keyMirror;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPerf
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * ReactPerf is a general AOP system designed to measure performance. This
	 * module only has the hooks: see ReactDefaultPerf for the analysis tool.
	 */
	
	var ReactPerf = {
	  /**
	   * Boolean to enable/disable measurement. Set to false by default to prevent
	   * accidental logging and perf loss.
	   */
	  enableMeasure: false,
	
	  /**
	   * Holds onto the measure function in use. By default, don't measure
	   * anything, but we'll override this if we inject a measure function.
	   */
	  storedMeasure: _noMeasure,
	
	  /**
	   * @param {object} object
	   * @param {string} objectName
	   * @param {object<string>} methodNames
	   */
	  measureMethods: function measureMethods(object, objectName, methodNames) {
	    if (process.env.NODE_ENV !== 'production') {
	      for (var key in methodNames) {
	        if (!methodNames.hasOwnProperty(key)) {
	          continue;
	        }
	        object[key] = ReactPerf.measure(objectName, methodNames[key], object[key]);
	      }
	    }
	  },
	
	  /**
	   * Use this to wrap methods you want to measure. Zero overhead in production.
	   *
	   * @param {string} objName
	   * @param {string} fnName
	   * @param {function} func
	   * @return {function}
	   */
	  measure: function measure(objName, fnName, func) {
	    if (process.env.NODE_ENV !== 'production') {
	      var measuredFunc = null;
	      var wrapper = function wrapper() {
	        if (ReactPerf.enableMeasure) {
	          if (!measuredFunc) {
	            measuredFunc = ReactPerf.storedMeasure(objName, fnName, func);
	          }
	          return measuredFunc.apply(this, arguments);
	        }
	        return func.apply(this, arguments);
	      };
	      wrapper.displayName = objName + '_' + fnName;
	      return wrapper;
	    }
	    return func;
	  },
	
	  injection: {
	    /**
	     * @param {function} measure
	     */
	    injectMeasure: function injectMeasure(measure) {
	      ReactPerf.storedMeasure = measure;
	    }
	  }
	};
	
	/**
	 * Simply passes through the measured function, without measuring it.
	 *
	 * @param {string} objName
	 * @param {string} fnName
	 * @param {function} func
	 * @return {function}
	 */
	function _noMeasure(objName, fnName, func) {
	  return func;
	}
	
	module.exports = ReactPerf;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule setInnerHTML
	 */
	
	/* globals MSApp */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(16);
	
	var WHITESPACE_TEST = /^[ \r\n\t\f]/;
	var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;
	
	/**
	 * Set the innerHTML property of a node, ensuring that whitespace is preserved
	 * even in IE8.
	 *
	 * @param {DOMElement} node
	 * @param {string} html
	 * @internal
	 */
	var setInnerHTML = function setInnerHTML(node, html) {
	  node.innerHTML = html;
	};
	
	// Win8 apps: Allow all html to be inserted
	if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
	  setInnerHTML = function setInnerHTML(node, html) {
	    MSApp.execUnsafeLocalFunction(function () {
	      node.innerHTML = html;
	    });
	  };
	}
	
	if (ExecutionEnvironment.canUseDOM) {
	  // IE8: When updating a just created node with innerHTML only leading
	  // whitespace is removed. When updating an existing node with innerHTML
	  // whitespace in root TextNodes is also collapsed.
	  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html
	
	  // Feature detection; only IE8 is known to behave improperly like this.
	  var testElement = document.createElement('div');
	  testElement.innerHTML = ' ';
	  if (testElement.innerHTML === '') {
	    setInnerHTML = function setInnerHTML(node, html) {
	      // Magic theory: IE8 supposedly differentiates between added and updated
	      // nodes when processing innerHTML, innerHTML on updated nodes suffers
	      // from worse whitespace behavior. Re-adding a node like this triggers
	      // the initial and more favorable whitespace behavior.
	      // TODO: What to do on a detached node?
	      if (node.parentNode) {
	        node.parentNode.replaceChild(node, node);
	      }
	
	      // We also implement a workaround for non-visible tags disappearing into
	      // thin air on IE8, this only happens if there is no visible text
	      // in-front of the non-visible tags. Piggyback on the whitespace fix
	      // and simply check if any non-visible tags appear in the source.
	      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
	        // Recover leading whitespace by temporarily prepending any character.
	        // \uFEFF has the potential advantage of being zero-width/invisible.
	        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
	        // in hopes that this is preserved even if "\uFEFF" is transformed to
	        // the actual Unicode character (by Babel, for example).
	        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
	        node.innerHTML = String.fromCharCode(0xFEFF) + html;
	
	        // deleteData leaves an empty `TextNode` which offsets the index of all
	        // children. Definitely want to avoid this.
	        var textNode = node.firstChild;
	        if (textNode.data.length === 1) {
	          node.removeChild(textNode);
	        } else {
	          textNode.deleteData(0, 1);
	        }
	      } else {
	        node.innerHTML = html;
	      }
	    };
	  }
	}
	
	module.exports = setInnerHTML;

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule setTextContent
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(16);
	var escapeTextContentForBrowser = __webpack_require__(28);
	var setInnerHTML = __webpack_require__(26);
	
	/**
	 * Set the textContent property of a node, ensuring that whitespace is preserved
	 * even in IE8. innerText is a poor substitute for textContent and, among many
	 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
	 * as it should.
	 *
	 * @param {DOMElement} node
	 * @param {string} text
	 * @internal
	 */
	var setTextContent = function setTextContent(node, text) {
	  node.textContent = text;
	};
	
	if (ExecutionEnvironment.canUseDOM) {
	  if (!('textContent' in document.documentElement)) {
	    setTextContent = function setTextContent(node, text) {
	      setInnerHTML(node, escapeTextContentForBrowser(text));
	    };
	  }
	}
	
	module.exports = setTextContent;

/***/ },
/* 28 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule escapeTextContentForBrowser
	 */
	
	'use strict';
	
	var ESCAPE_LOOKUP = {
	  '&': '&amp;',
	  '>': '&gt;',
	  '<': '&lt;',
	  '"': '&quot;',
	  '\'': '&#x27;'
	};
	
	var ESCAPE_REGEX = /[&><"']/g;
	
	function escaper(match) {
	  return ESCAPE_LOOKUP[match];
	}
	
	/**
	 * Escapes text to prevent scripting attacks.
	 *
	 * @param {*} text Text value to escape.
	 * @return {string} An escaped string.
	 */
	function escapeTextContentForBrowser(text) {
	  return ('' + text).replace(ESCAPE_REGEX, escaper);
	}
	
	module.exports = escapeTextContentForBrowser;

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMPropertyOperations
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(30);
	var ReactPerf = __webpack_require__(25);
	
	var quoteAttributeValueForBrowser = __webpack_require__(31);
	var warning = __webpack_require__(32);
	
	// Simplified subset
	var VALID_ATTRIBUTE_NAME_REGEX = /^[a-zA-Z_][\w\.\-]*$/;
	var illegalAttributeNameCache = {};
	var validatedAttributeNameCache = {};
	
	function isAttributeNameSafe(attributeName) {
	  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
	    return true;
	  }
	  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
	    return false;
	  }
	  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
	    validatedAttributeNameCache[attributeName] = true;
	    return true;
	  }
	  illegalAttributeNameCache[attributeName] = true;
	  process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : undefined;
	  return false;
	}
	
	function shouldIgnoreValue(propertyInfo, value) {
	  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  var reactProps = {
	    children: true,
	    dangerouslySetInnerHTML: true,
	    key: true,
	    ref: true
	  };
	  var warnedProperties = {};
	
	  var warnUnknownProperty = function warnUnknownProperty(name) {
	    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
	      return;
	    }
	
	    warnedProperties[name] = true;
	    var lowerCasedName = name.toLowerCase();
	
	    // data-* attributes should be lowercase; suggest the lowercase version
	    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;
	
	    // For now, only warn when we have a suggested correction. This prevents
	    // logging too much when using transferPropsTo.
	    process.env.NODE_ENV !== 'production' ? warning(standardName == null, 'Unknown DOM property %s. Did you mean %s?', name, standardName) : undefined;
	  };
	}
	
	/**
	 * Operations for dealing with DOM properties.
	 */
	var DOMPropertyOperations = {
	
	  /**
	   * Creates markup for the ID property.
	   *
	   * @param {string} id Unescaped ID.
	   * @return {string} Markup string.
	   */
	  createMarkupForID: function createMarkupForID(id) {
	    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
	  },
	
	  setAttributeForID: function setAttributeForID(node, id) {
	    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
	  },
	
	  /**
	   * Creates markup for a property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {?string} Markup string, or null if the property was invalid.
	   */
	  createMarkupForProperty: function createMarkupForProperty(name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      if (shouldIgnoreValue(propertyInfo, value)) {
	        return '';
	      }
	      var attributeName = propertyInfo.attributeName;
	      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	        return attributeName + '=""';
	      }
	      return attributeName + '=' + quoteAttributeValueForBrowser(value);
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      if (value == null) {
	        return '';
	      }
	      return name + '=' + quoteAttributeValueForBrowser(value);
	    } else if (process.env.NODE_ENV !== 'production') {
	      warnUnknownProperty(name);
	    }
	    return null;
	  },
	
	  /**
	   * Creates markup for a custom property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {string} Markup string, or empty string if the property was invalid.
	   */
	  createMarkupForCustomAttribute: function createMarkupForCustomAttribute(name, value) {
	    if (!isAttributeNameSafe(name) || value == null) {
	      return '';
	    }
	    return name + '=' + quoteAttributeValueForBrowser(value);
	  },
	
	  /**
	   * Sets the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   * @param {*} value
	   */
	  setValueForProperty: function setValueForProperty(node, name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, value);
	      } else if (shouldIgnoreValue(propertyInfo, value)) {
	        this.deleteValueForProperty(node, name);
	      } else if (propertyInfo.mustUseAttribute) {
	        var attributeName = propertyInfo.attributeName;
	        var namespace = propertyInfo.attributeNamespace;
	        // `setAttribute` with objects becomes only `[object]` in IE8/9,
	        // ('' + value) makes it output the correct toString()-value.
	        if (namespace) {
	          node.setAttributeNS(namespace, attributeName, '' + value);
	        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	          node.setAttribute(attributeName, '');
	        } else {
	          node.setAttribute(attributeName, '' + value);
	        }
	      } else {
	        var propName = propertyInfo.propertyName;
	        // Must explicitly cast values for HAS_SIDE_EFFECTS-properties to the
	        // property type before comparing; only `value` does and is string.
	        if (!propertyInfo.hasSideEffects || '' + node[propName] !== '' + value) {
	          // Contrary to `setAttribute`, object properties are properly
	          // `toString`ed by IE8/9.
	          node[propName] = value;
	        }
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      DOMPropertyOperations.setValueForAttribute(node, name, value);
	    } else if (process.env.NODE_ENV !== 'production') {
	      warnUnknownProperty(name);
	    }
	  },
	
	  setValueForAttribute: function setValueForAttribute(node, name, value) {
	    if (!isAttributeNameSafe(name)) {
	      return;
	    }
	    if (value == null) {
	      node.removeAttribute(name);
	    } else {
	      node.setAttribute(name, '' + value);
	    }
	  },
	
	  /**
	   * Deletes the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForProperty: function deleteValueForProperty(node, name) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, undefined);
	      } else if (propertyInfo.mustUseAttribute) {
	        node.removeAttribute(propertyInfo.attributeName);
	      } else {
	        var propName = propertyInfo.propertyName;
	        var defaultValue = DOMProperty.getDefaultValueForProperty(node.nodeName, propName);
	        if (!propertyInfo.hasSideEffects || '' + node[propName] !== defaultValue) {
	          node[propName] = defaultValue;
	        }
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      node.removeAttribute(name);
	    } else if (process.env.NODE_ENV !== 'production') {
	      warnUnknownProperty(name);
	    }
	  }
	
	};
	
	ReactPerf.measureMethods(DOMPropertyOperations, 'DOMPropertyOperations', {
	  setValueForProperty: 'setValueForProperty',
	  setValueForAttribute: 'setValueForAttribute',
	  deleteValueForProperty: 'deleteValueForProperty'
	});
	
	module.exports = DOMPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMProperty
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(20);
	
	function checkMask(value, bitmask) {
	  return (value & bitmask) === bitmask;
	}
	
	var DOMPropertyInjection = {
	  /**
	   * Mapping from normalized, camelcased property names to a configuration that
	   * specifies how the associated DOM property should be accessed or rendered.
	   */
	  MUST_USE_ATTRIBUTE: 0x1,
	  MUST_USE_PROPERTY: 0x2,
	  HAS_SIDE_EFFECTS: 0x4,
	  HAS_BOOLEAN_VALUE: 0x8,
	  HAS_NUMERIC_VALUE: 0x10,
	  HAS_POSITIVE_NUMERIC_VALUE: 0x20 | 0x10,
	  HAS_OVERLOADED_BOOLEAN_VALUE: 0x40,
	
	  /**
	   * Inject some specialized knowledge about the DOM. This takes a config object
	   * with the following properties:
	   *
	   * isCustomAttribute: function that given an attribute name will return true
	   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
	   * attributes where it's impossible to enumerate all of the possible
	   * attribute names,
	   *
	   * Properties: object mapping DOM property name to one of the
	   * DOMPropertyInjection constants or null. If your attribute isn't in here,
	   * it won't get written to the DOM.
	   *
	   * DOMAttributeNames: object mapping React attribute name to the DOM
	   * attribute name. Attribute names not specified use the **lowercase**
	   * normalized name.
	   *
	   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
	   * attribute namespace URL. (Attribute names not specified use no namespace.)
	   *
	   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
	   * Property names not specified use the normalized name.
	   *
	   * DOMMutationMethods: Properties that require special mutation methods. If
	   * `value` is undefined, the mutation method should unset the property.
	   *
	   * @param {object} domPropertyConfig the config as described above.
	   */
	  injectDOMPropertyConfig: function injectDOMPropertyConfig(domPropertyConfig) {
	    var Injection = DOMPropertyInjection;
	    var Properties = domPropertyConfig.Properties || {};
	    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
	    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
	    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
	    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
	
	    if (domPropertyConfig.isCustomAttribute) {
	      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
	    }
	
	    for (var propName in Properties) {
	      !!DOMProperty.properties.hasOwnProperty(propName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property ' + '\'%s\' which has already been injected. You may be accidentally ' + 'injecting the same DOM property config twice, or you may be ' + 'injecting two configs that have conflicting property names.', propName) : invariant(false) : undefined;
	
	      var lowerCased = propName.toLowerCase();
	      var propConfig = Properties[propName];
	
	      var propertyInfo = {
	        attributeName: lowerCased,
	        attributeNamespace: null,
	        propertyName: propName,
	        mutationMethod: null,
	
	        mustUseAttribute: checkMask(propConfig, Injection.MUST_USE_ATTRIBUTE),
	        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
	        hasSideEffects: checkMask(propConfig, Injection.HAS_SIDE_EFFECTS),
	        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
	        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
	        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
	        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
	      };
	
	      !(!propertyInfo.mustUseAttribute || !propertyInfo.mustUseProperty) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Cannot require using both attribute and property: %s', propName) : invariant(false) : undefined;
	      !(propertyInfo.mustUseProperty || !propertyInfo.hasSideEffects) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Properties that have side effects must use property: %s', propName) : invariant(false) : undefined;
	      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or ' + 'numeric value, but not a combination: %s', propName) : invariant(false) : undefined;
	
	      if (process.env.NODE_ENV !== 'production') {
	        DOMProperty.getPossibleStandardName[lowerCased] = propName;
	      }
	
	      if (DOMAttributeNames.hasOwnProperty(propName)) {
	        var attributeName = DOMAttributeNames[propName];
	        propertyInfo.attributeName = attributeName;
	        if (process.env.NODE_ENV !== 'production') {
	          DOMProperty.getPossibleStandardName[attributeName] = propName;
	        }
	      }
	
	      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
	        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
	      }
	
	      if (DOMPropertyNames.hasOwnProperty(propName)) {
	        propertyInfo.propertyName = DOMPropertyNames[propName];
	      }
	
	      if (DOMMutationMethods.hasOwnProperty(propName)) {
	        propertyInfo.mutationMethod = DOMMutationMethods[propName];
	      }
	
	      DOMProperty.properties[propName] = propertyInfo;
	    }
	  }
	};
	var defaultValueCache = {};
	
	/**
	 * DOMProperty exports lookup objects that can be used like functions:
	 *
	 *   > DOMProperty.isValid['id']
	 *   true
	 *   > DOMProperty.isValid['foobar']
	 *   undefined
	 *
	 * Although this may be confusing, it performs better in general.
	 *
	 * @see http://jsperf.com/key-exists
	 * @see http://jsperf.com/key-missing
	 */
	var DOMProperty = {
	
	  ID_ATTRIBUTE_NAME: 'data-reactid',
	
	  /**
	   * Map from property "standard name" to an object with info about how to set
	   * the property in the DOM. Each object contains:
	   *
	   * attributeName:
	   *   Used when rendering markup or with `*Attribute()`.
	   * attributeNamespace
	   * propertyName:
	   *   Used on DOM node instances. (This includes properties that mutate due to
	   *   external factors.)
	   * mutationMethod:
	   *   If non-null, used instead of the property or `setAttribute()` after
	   *   initial render.
	   * mustUseAttribute:
	   *   Whether the property must be accessed and mutated using `*Attribute()`.
	   *   (This includes anything that fails `<propName> in <element>`.)
	   * mustUseProperty:
	   *   Whether the property must be accessed and mutated as an object property.
	   * hasSideEffects:
	   *   Whether or not setting a value causes side effects such as triggering
	   *   resources to be loaded or text selection changes. If true, we read from
	   *   the DOM before updating to ensure that the value is only set if it has
	   *   changed.
	   * hasBooleanValue:
	   *   Whether the property should be removed when set to a falsey value.
	   * hasNumericValue:
	   *   Whether the property must be numeric or parse as a numeric and should be
	   *   removed when set to a falsey value.
	   * hasPositiveNumericValue:
	   *   Whether the property must be positive numeric or parse as a positive
	   *   numeric and should be removed when set to a falsey value.
	   * hasOverloadedBooleanValue:
	   *   Whether the property can be used as a flag as well as with a value.
	   *   Removed when strictly equal to false; present without a value when
	   *   strictly equal to true; present with a value otherwise.
	   */
	  properties: {},
	
	  /**
	   * Mapping from lowercase property names to the properly cased version, used
	   * to warn in the case of missing properties. Available only in __DEV__.
	   * @type {Object}
	   */
	  getPossibleStandardName: process.env.NODE_ENV !== 'production' ? {} : null,
	
	  /**
	   * All of the isCustomAttribute() functions that have been injected.
	   */
	  _isCustomAttributeFunctions: [],
	
	  /**
	   * Checks whether a property name is a custom attribute.
	   * @method
	   */
	  isCustomAttribute: function isCustomAttribute(attributeName) {
	    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
	      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
	      if (isCustomAttributeFn(attributeName)) {
	        return true;
	      }
	    }
	    return false;
	  },
	
	  /**
	   * Returns the default property value for a DOM property (i.e., not an
	   * attribute). Most default values are '' or false, but not all. Worse yet,
	   * some (in particular, `type`) vary depending on the type of element.
	   *
	   * TODO: Is it better to grab all the possible properties when creating an
	   * element to avoid having to create the same element twice?
	   */
	  getDefaultValueForProperty: function getDefaultValueForProperty(nodeName, prop) {
	    var nodeDefaults = defaultValueCache[nodeName];
	    var testElement;
	    if (!nodeDefaults) {
	      defaultValueCache[nodeName] = nodeDefaults = {};
	    }
	    if (!(prop in nodeDefaults)) {
	      testElement = document.createElement(nodeName);
	      nodeDefaults[prop] = testElement[prop];
	    }
	    return nodeDefaults[prop];
	  },
	
	  injection: DOMPropertyInjection
	};
	
	module.exports = DOMProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule quoteAttributeValueForBrowser
	 */
	
	'use strict';
	
	var escapeTextContentForBrowser = __webpack_require__(28);
	
	/**
	 * Escapes attribute value to prevent scripting attacks.
	 *
	 * @param {*} value Value to escape.
	 * @return {string} An escaped string.
	 */
	function quoteAttributeValueForBrowser(value) {
	  return '"' + escapeTextContentForBrowser(value) + '"';
	}
	
	module.exports = quoteAttributeValueForBrowser;

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule warning
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(22);
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = emptyFunction;
	
	if (process.env.NODE_ENV !== 'production') {
	  warning = function warning(condition, format) {
	    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	      args[_key - 2] = arguments[_key];
	    }
	
	    if (format === undefined) {
	      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	    }
	
	    if (format.indexOf('Failed Composite propType: ') === 0) {
	      return; // Ignore CompositeComponent proptype check.
	    }
	
	    if (!condition) {
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // --- Welcome to debugging React ---
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    }
	  };
	}
	
	module.exports = warning;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentBrowserEnvironment
	 */
	
	'use strict';
	
	var ReactDOMIDOperations = __webpack_require__(34);
	var ReactMount = __webpack_require__(35);
	
	/**
	 * Abstracts away all functionality of the reconciler that requires knowledge of
	 * the browser context. TODO: These callers should be refactored to avoid the
	 * need for this injection.
	 */
	var ReactComponentBrowserEnvironment = {
	
	  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,
	
	  replaceNodeWithMarkupByID: ReactDOMIDOperations.dangerouslyReplaceNodeWithMarkupByID,
	
	  /**
	   * If a particular environment requires that some resources be cleaned up,
	   * specify this in the injected Mixin. In the DOM, we would likely want to
	   * purge any cached node ID lookups.
	   *
	   * @private
	   */
	  unmountIDFromEnvironment: function unmountIDFromEnvironment(rootNodeID) {
	    ReactMount.purgeID(rootNodeID);
	  }
	
	};
	
	module.exports = ReactComponentBrowserEnvironment;

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMIDOperations
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(14);
	var DOMPropertyOperations = __webpack_require__(29);
	var ReactMount = __webpack_require__(35);
	var ReactPerf = __webpack_require__(25);
	
	var invariant = __webpack_require__(20);
	
	/**
	 * Errors for properties that should not be updated with `updatePropertyByID()`.
	 *
	 * @type {object}
	 * @private
	 */
	var INVALID_PROPERTY_ERRORS = {
	  dangerouslySetInnerHTML: '`dangerouslySetInnerHTML` must be set using `updateInnerHTMLByID()`.',
	  style: '`style` must be set using `updateStylesByID()`.'
	};
	
	/**
	 * Operations used to process updates to DOM nodes.
	 */
	var ReactDOMIDOperations = {
	
	  /**
	   * Updates a DOM node with new property values. This should only be used to
	   * update DOM properties in `DOMProperty`.
	   *
	   * @param {string} id ID of the node to update.
	   * @param {string} name A valid property name, see `DOMProperty`.
	   * @param {*} value New value of the property.
	   * @internal
	   */
	  updatePropertyByID: function updatePropertyByID(id, name, value) {
	    var node = ReactMount.getNode(id);
	    !!INVALID_PROPERTY_ERRORS.hasOwnProperty(name) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updatePropertyByID(...): %s', INVALID_PROPERTY_ERRORS[name]) : invariant(false) : undefined;
	
	    // If we're updating to null or undefined, we should remove the property
	    // from the DOM node instead of inadvertantly setting to a string. This
	    // brings us in line with the same behavior we have on initial render.
	    if (value != null) {
	      DOMPropertyOperations.setValueForProperty(node, name, value);
	    } else {
	      DOMPropertyOperations.deleteValueForProperty(node, name);
	    }
	  },
	
	  /**
	   * Replaces a DOM node that exists in the document with markup.
	   *
	   * @param {string} id ID of child to be replaced.
	   * @param {string} markup Dangerous markup to inject in place of child.
	   * @internal
	   * @see {Danger.dangerouslyReplaceNodeWithMarkup}
	   */
	  dangerouslyReplaceNodeWithMarkupByID: function dangerouslyReplaceNodeWithMarkupByID(id, markup) {
	    var node = ReactMount.getNode(id);
	    DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup(node, markup);
	  },
	
	  /**
	   * Updates a component's children by processing a series of updates.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @param {array<string>} markup List of markup strings.
	   * @internal
	   */
	  dangerouslyProcessChildrenUpdates: function dangerouslyProcessChildrenUpdates(updates, markup) {
	    for (var i = 0; i < updates.length; i++) {
	      updates[i].parentNode = ReactMount.getNode(updates[i].parentID);
	    }
	    DOMChildrenOperations.processUpdates(updates, markup);
	  }
	};
	
	ReactPerf.measureMethods(ReactDOMIDOperations, 'ReactDOMIDOperations', {
	  dangerouslyReplaceNodeWithMarkupByID: 'dangerouslyReplaceNodeWithMarkupByID',
	  dangerouslyProcessChildrenUpdates: 'dangerouslyProcessChildrenUpdates'
	});
	
	module.exports = ReactDOMIDOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMount
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(30);
	var ReactBrowserEventEmitter = __webpack_require__(36);
	var ReactCurrentOwner = __webpack_require__(12);
	var ReactDOMFeatureFlags = __webpack_require__(48);
	var ReactElement = __webpack_require__(49);
	var ReactEmptyComponentRegistry = __webpack_require__(51);
	var ReactInstanceHandles = __webpack_require__(52);
	var ReactInstanceMap = __webpack_require__(54);
	var ReactMarkupChecksum = __webpack_require__(55);
	var ReactPerf = __webpack_require__(25);
	var ReactReconciler = __webpack_require__(57);
	var ReactUpdateQueue = __webpack_require__(60);
	var ReactUpdates = __webpack_require__(61);
	
	var assign = __webpack_require__(46);
	var emptyObject = __webpack_require__(65);
	var containsNode = __webpack_require__(66);
	var instantiateReactComponent = __webpack_require__(69);
	var invariant = __webpack_require__(20);
	var setInnerHTML = __webpack_require__(26);
	var shouldUpdateReactComponent = __webpack_require__(74);
	var validateDOMNesting = __webpack_require__(77);
	var warning = __webpack_require__(32);
	
	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var nodeCache = {};
	
	var ELEMENT_NODE_TYPE = 1;
	var DOC_NODE_TYPE = 9;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	var ownerDocumentContextKey = '__ReactMount_ownerDocument$' + Math.random().toString(36).slice(2);
	
	/** Mapping from reactRootID to React component instance. */
	var instancesByReactRootID = {};
	
	/** Mapping from reactRootID to `container` nodes. */
	var containersByReactRootID = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  /** __DEV__-only mapping from reactRootID to root elements. */
	  var rootElementsByReactRootID = {};
	}
	
	// Used to store breadth-first search state in findComponentRoot.
	var findComponentRootReusableArray = [];
	
	/**
	 * Finds the index of the first character
	 * that's not common between the two given strings.
	 *
	 * @return {number} the index of the character where the strings diverge
	 */
	function firstDifferenceIndex(string1, string2) {
	  var minLen = Math.min(string1.length, string2.length);
	  for (var i = 0; i < minLen; i++) {
	    if (string1.charAt(i) !== string2.charAt(i)) {
	      return i;
	    }
	  }
	  return string1.length === string2.length ? -1 : minLen;
	}
	
	/**
	 * @param {DOMElement|DOMDocument} container DOM element that may contain
	 * a React component
	 * @return {?*} DOM element that may have the reactRoot ID, or null.
	 */
	function getReactRootElementInContainer(container) {
	  if (!container) {
	    return null;
	  }
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    return container.documentElement;
	  } else {
	    return container.firstChild;
	  }
	}
	
	/**
	 * @param {DOMElement} container DOM element that may contain a React component.
	 * @return {?string} A "reactRoot" ID, if a React component is rendered.
	 */
	function getReactRootID(container) {
	  var rootElement = getReactRootElementInContainer(container);
	  return rootElement && ReactMount.getID(rootElement);
	}
	
	/**
	 * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form
	 * element can return its control whose name or ID equals ATTR_NAME. All
	 * DOM nodes support `getAttributeNode` but this can also get called on
	 * other objects so just return '' if we're given something other than a
	 * DOM node (such as window).
	 *
	 * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.
	 * @return {string} ID of the supplied `domNode`.
	 */
	function getID(node) {
	  var id = internalGetID(node);
	  if (id) {
	    if (nodeCache.hasOwnProperty(id)) {
	      var cached = nodeCache[id];
	      if (cached !== node) {
	        !!isValid(cached, id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Two valid but unequal nodes with the same `%s`: %s', ATTR_NAME, id) : invariant(false) : undefined;
	
	        nodeCache[id] = node;
	      }
	    } else {
	      nodeCache[id] = node;
	    }
	  }
	
	  return id;
	}
	
	function internalGetID(node) {
	  // If node is something like a window, document, or text node, none of
	  // which support attributes or a .getAttribute method, gracefully return
	  // the empty string, as if the attribute were missing.
	  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';
	}
	
	/**
	 * Sets the React-specific ID of the given node.
	 *
	 * @param {DOMElement} node The DOM node whose ID will be set.
	 * @param {string} id The value of the ID attribute.
	 */
	function setID(node, id) {
	  var oldID = internalGetID(node);
	  if (oldID !== id) {
	    delete nodeCache[oldID];
	  }
	  node.setAttribute(ATTR_NAME, id);
	  nodeCache[id] = node;
	}
	
	/**
	 * Finds the node with the supplied React-generated DOM ID.
	 *
	 * @param {string} id A React-generated DOM ID.
	 * @return {DOMElement} DOM node with the suppled `id`.
	 * @internal
	 */
	function getNode(id) {
	  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
	    nodeCache[id] = ReactMount.findReactNodeByID(id);
	  }
	  return nodeCache[id];
	}
	
	/**
	 * Finds the node with the supplied public React instance.
	 *
	 * @param {*} instance A public React instance.
	 * @return {?DOMElement} DOM node with the suppled `id`.
	 * @internal
	 */
	function getNodeFromInstance(instance) {
	  var id = ReactInstanceMap.get(instance)._rootNodeID;
	  if (ReactEmptyComponentRegistry.isNullComponentID(id)) {
	    return null;
	  }
	  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
	    nodeCache[id] = ReactMount.findReactNodeByID(id);
	  }
	  return nodeCache[id];
	}
	
	/**
	 * A node is "valid" if it is contained by a currently mounted container.
	 *
	 * This means that the node does not have to be contained by a document in
	 * order to be considered valid.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @param {string} id The expected ID of the node.
	 * @return {boolean} Whether the node is contained by a mounted container.
	 */
	function isValid(node, id) {
	  if (node) {
	    !(internalGetID(node) === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Unexpected modification of `%s`', ATTR_NAME) : invariant(false) : undefined;
	
	    var container = ReactMount.findReactContainerForID(id);
	    if (container && containsNode(container, node)) {
	      return true;
	    }
	  }
	
	  return false;
	}
	
	/**
	 * Causes the cache to forget about one React-specific ID.
	 *
	 * @param {string} id The ID to forget.
	 */
	function purgeID(id) {
	  delete nodeCache[id];
	}
	
	var deepestNodeSoFar = null;
	function findDeepestCachedAncestorImpl(ancestorID) {
	  var ancestor = nodeCache[ancestorID];
	  if (ancestor && isValid(ancestor, ancestorID)) {
	    deepestNodeSoFar = ancestor;
	  } else {
	    // This node isn't populated in the cache, so presumably none of its
	    // descendants are. Break out of the loop.
	    return false;
	  }
	}
	
	/**
	 * Return the deepest cached node whose ID is a prefix of `targetID`.
	 */
	function findDeepestCachedAncestor(targetID) {
	  deepestNodeSoFar = null;
	  ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);
	
	  var foundNode = deepestNodeSoFar;
	  deepestNodeSoFar = null;
	  return foundNode;
	}
	
	/**
	 * Mounts this component and inserts it into the DOM.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {string} rootID DOM ID of the root node.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {ReactReconcileTransaction} transaction
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function mountComponentIntoNode(componentInstance, rootID, container, transaction, shouldReuseMarkup, context) {
	  if (ReactDOMFeatureFlags.useCreateElement) {
	    context = assign({}, context);
	    if (container.nodeType === DOC_NODE_TYPE) {
	      context[ownerDocumentContextKey] = container;
	    } else {
	      context[ownerDocumentContextKey] = container.ownerDocument;
	    }
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    if (context === emptyObject) {
	      context = {};
	    }
	    var tag = container.nodeName.toLowerCase();
	    context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(null, tag, null);
	  }
	  var markup = ReactReconciler.mountComponent(componentInstance, rootID, transaction, context);
	  componentInstance._renderedComponent._topLevelWrapper = componentInstance;
	  ReactMount._mountImageIntoNode(markup, container, shouldReuseMarkup, transaction);
	}
	
	/**
	 * Batched mount.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {string} rootID DOM ID of the root node.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function batchedMountComponentIntoNode(componentInstance, rootID, container, shouldReuseMarkup, context) {
	  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* forceHTML */shouldReuseMarkup);
	  transaction.perform(mountComponentIntoNode, null, componentInstance, rootID, container, transaction, shouldReuseMarkup, context);
	  ReactUpdates.ReactReconcileTransaction.release(transaction);
	}
	
	/**
	 * Unmounts a component and removes it from the DOM.
	 *
	 * @param {ReactComponent} instance React component instance.
	 * @param {DOMElement} container DOM element to unmount from.
	 * @final
	 * @internal
	 * @see {ReactMount.unmountComponentAtNode}
	 */
	function unmountComponentFromNode(instance, container) {
	  ReactReconciler.unmountComponent(instance);
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    container = container.documentElement;
	  }
	
	  // http://jsperf.com/emptying-a-node
	  while (container.lastChild) {
	    container.removeChild(container.lastChild);
	  }
	}
	
	/**
	 * True if the supplied DOM node has a direct React-rendered child that is
	 * not a React root element. Useful for warning in `render`,
	 * `unmountComponentAtNode`, etc.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM element contains a direct child that was
	 * rendered by React but is not a root element.
	 * @internal
	 */
	function hasNonRootReactChild(node) {
	  var reactRootID = getReactRootID(node);
	  return reactRootID ? reactRootID !== ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID) : false;
	}
	
	/**
	 * Returns the first (deepest) ancestor of a node which is rendered by this copy
	 * of React.
	 */
	function findFirstReactDOMImpl(node) {
	  // This node might be from another React instance, so we make sure not to
	  // examine the node cache here
	  for (; node && node.parentNode !== node; node = node.parentNode) {
	    if (node.nodeType !== 1) {
	      // Not a DOMElement, therefore not a React component
	      continue;
	    }
	    var nodeID = internalGetID(node);
	    if (!nodeID) {
	      continue;
	    }
	    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
	
	    // If containersByReactRootID contains the container we find by crawling up
	    // the tree, we know that this instance of React rendered the node.
	    // nb. isValid's strategy (with containsNode) does not work because render
	    // trees may be nested and we don't want a false positive in that case.
	    var current = node;
	    var lastID;
	    do {
	      lastID = internalGetID(current);
	      current = current.parentNode;
	      if (current == null) {
	        // The passed-in node has been detached from the container it was
	        // originally rendered into.
	        return null;
	      }
	    } while (lastID !== reactRootID);
	
	    if (current === containersByReactRootID[reactRootID]) {
	      return node;
	    }
	  }
	  return null;
	}
	
	/**
	 * Temporary (?) hack so that we can store all top-level pending updates on
	 * composites instead of having to worry about different types of components
	 * here.
	 */
	var TopLevelWrapper = function TopLevelWrapper() {};
	TopLevelWrapper.prototype.isReactComponent = {};
	if (process.env.NODE_ENV !== 'production') {
	  TopLevelWrapper.displayName = 'TopLevelWrapper';
	}
	TopLevelWrapper.prototype.render = function () {
	  // this.props is actually a ReactElement
	  return this.props;
	};
	
	/**
	 * Mounting is the process of initializing a React component by creating its
	 * representative DOM elements and inserting them into a supplied `container`.
	 * Any prior content inside `container` is destroyed in the process.
	 *
	 *   ReactMount.render(
	 *     component,
	 *     document.getElementById('container')
	 *   );
	 *
	 *   <div id="container">                   <-- Supplied `container`.
	 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
	 *       // ...                                 component.
	 *     </div>
	 *   </div>
	 *
	 * Inside of `container`, the first element rendered is the "reactRoot".
	 */
	var ReactMount = {
	
	  TopLevelWrapper: TopLevelWrapper,
	
	  /** Exposed for debugging purposes **/
	  _instancesByReactRootID: instancesByReactRootID,
	
	  /**
	   * This is a hook provided to support rendering React components while
	   * ensuring that the apparent scroll position of its `container` does not
	   * change.
	   *
	   * @param {DOMElement} container The `container` being rendered into.
	   * @param {function} renderCallback This must be called once to do the render.
	   */
	  scrollMonitor: function scrollMonitor(container, renderCallback) {
	    renderCallback();
	  },
	
	  /**
	   * Take a component that's already mounted into the DOM and replace its props
	   * @param {ReactComponent} prevComponent component instance already in the DOM
	   * @param {ReactElement} nextElement component instance to render
	   * @param {DOMElement} container container to render into
	   * @param {?function} callback function triggered on completion
	   */
	  _updateRootComponent: function _updateRootComponent(prevComponent, nextElement, container, callback) {
	    ReactMount.scrollMonitor(container, function () {
	      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement);
	      if (callback) {
	        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
	      }
	    });
	
	    if (process.env.NODE_ENV !== 'production') {
	      // Record the root element in case it later gets transplanted.
	      rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container);
	    }
	
	    return prevComponent;
	  },
	
	  /**
	   * Register a component into the instance map and starts scroll value
	   * monitoring
	   * @param {ReactComponent} nextComponent component instance to render
	   * @param {DOMElement} container container to render into
	   * @return {string} reactRoot ID prefix
	   */
	  _registerComponent: function _registerComponent(nextComponent, container) {
	    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : invariant(false) : undefined;
	
	    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
	
	    var reactRootID = ReactMount.registerContainer(container);
	    instancesByReactRootID[reactRootID] = nextComponent;
	    return reactRootID;
	  },
	
	  /**
	   * Render a new component into the DOM.
	   * @param {ReactElement} nextElement element to render
	   * @param {DOMElement} container container to render into
	   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
	   * @return {ReactComponent} nextComponent
	   */
	  _renderNewRootComponent: function _renderNewRootComponent(nextElement, container, shouldReuseMarkup, context) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case.
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;
	
	    var componentInstance = instantiateReactComponent(nextElement, null);
	    var reactRootID = ReactMount._registerComponent(componentInstance, container);
	
	    // The initial render is synchronous but any updates that happen during
	    // rendering, in componentWillMount or componentDidMount, will be batched
	    // according to the current batching strategy.
	
	    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, reactRootID, container, shouldReuseMarkup, context);
	
	    if (process.env.NODE_ENV !== 'production') {
	      // Record the root element in case it later gets transplanted.
	      rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container);
	    }
	
	    return componentInstance;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  renderSubtreeIntoContainer: function renderSubtreeIntoContainer(parentComponent, nextElement, container, callback) {
	    !(parentComponent != null && parentComponent._reactInternalInstance != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : invariant(false) : undefined;
	    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
	  },
	
	  _renderSubtreeIntoContainer: function _renderSubtreeIntoContainer(parentComponent, nextElement, container, callback) {
	    !ReactElement.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing an element string, make sure to instantiate ' + 'it by passing it to React.createElement.' : typeof nextElement === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' :
	    // Check if it quacks like an element
	    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : invariant(false) : undefined;
	
	    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : undefined;
	
	    var nextWrappedElement = new ReactElement(TopLevelWrapper, null, null, null, null, null, nextElement);
	
	    var prevComponent = instancesByReactRootID[getReactRootID(container)];
	
	    if (prevComponent) {
	      var prevWrappedElement = prevComponent._currentElement;
	      var prevElement = prevWrappedElement.props;
	      if (shouldUpdateReactComponent(prevElement, nextElement)) {
	        var publicInst = prevComponent._renderedComponent.getPublicInstance();
	        var updatedCallback = callback && function () {
	          callback.call(publicInst);
	        };
	        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, container, updatedCallback);
	        return publicInst;
	      } else {
	        ReactMount.unmountComponentAtNode(container);
	      }
	    }
	
	    var reactRootElement = getReactRootElementInContainer(container);
	    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
	    var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : undefined;
	
	      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
	        var rootElementSibling = reactRootElement;
	        while (rootElementSibling) {
	          if (internalGetID(rootElementSibling)) {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : undefined;
	            break;
	          }
	          rootElementSibling = rootElementSibling.nextSibling;
	        }
	      }
	    }
	
	    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
	    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, parentComponent != null ? parentComponent._reactInternalInstance._processChildContext(parentComponent._reactInternalInstance._context) : emptyObject)._renderedComponent.getPublicInstance();
	    if (callback) {
	      callback.call(component);
	    }
	    return component;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  render: function render(nextElement, container, callback) {
	    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
	  },
	
	  /**
	   * Registers a container node into which React components will be rendered.
	   * This also creates the "reactRoot" ID that will be assigned to the element
	   * rendered within.
	   *
	   * @param {DOMElement} container DOM element to register as a container.
	   * @return {string} The "reactRoot" ID of elements rendered within.
	   */
	  registerContainer: function registerContainer(container) {
	    var reactRootID = getReactRootID(container);
	    if (reactRootID) {
	      // If one exists, make sure it is a valid "reactRoot" ID.
	      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);
	    }
	    if (!reactRootID) {
	      // No valid "reactRoot" ID found, create one.
	      reactRootID = ReactInstanceHandles.createReactRootID();
	    }
	    containersByReactRootID[reactRootID] = container;
	    return reactRootID;
	  },
	
	  /**
	   * Unmounts and destroys the React component rendered in the `container`.
	   *
	   * @param {DOMElement} container DOM element containing a React component.
	   * @return {boolean} True if a component was found in and unmounted from
	   *                   `container`
	   */
	  unmountComponentAtNode: function unmountComponentAtNode(container) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case. (Strictly speaking, unmounting won't cause a
	    // render but we still don't expect to be in a render call here.)
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;
	
	    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : invariant(false) : undefined;
	
	    var reactRootID = getReactRootID(container);
	    var component = instancesByReactRootID[reactRootID];
	    if (!component) {
	      // Check if the node being unmounted was rendered by React, but isn't a
	      // root node.
	      var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	      // Check if the container itself is a React root node.
	      var containerID = internalGetID(container);
	      var isContainerReactRoot = containerID && containerID === ReactInstanceHandles.getReactRootIDFromNodeID(containerID);
	
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : undefined;
	      }
	
	      return false;
	    }
	    ReactUpdates.batchedUpdates(unmountComponentFromNode, component, container);
	    delete instancesByReactRootID[reactRootID];
	    delete containersByReactRootID[reactRootID];
	    if (process.env.NODE_ENV !== 'production') {
	      delete rootElementsByReactRootID[reactRootID];
	    }
	    return true;
	  },
	
	  /**
	   * Finds the container DOM element that contains React component to which the
	   * supplied DOM `id` belongs.
	   *
	   * @param {string} id The ID of an element rendered by a React component.
	   * @return {?DOMElement} DOM element that contains the `id`.
	   */
	  findReactContainerForID: function findReactContainerForID(id) {
	    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);
	    var container = containersByReactRootID[reactRootID];
	
	    if (process.env.NODE_ENV !== 'production') {
	      var rootElement = rootElementsByReactRootID[reactRootID];
	      if (rootElement && rootElement.parentNode !== container) {
	        process.env.NODE_ENV !== 'production' ? warning(
	        // Call internalGetID here because getID calls isValid which calls
	        // findReactContainerForID (this function).
	        internalGetID(rootElement) === reactRootID, 'ReactMount: Root element ID differed from reactRootID.') : undefined;
	        var containerChild = container.firstChild;
	        if (containerChild && reactRootID === internalGetID(containerChild)) {
	          // If the container has a new child with the same ID as the old
	          // root element, then rootElementsByReactRootID[reactRootID] is
	          // just stale and needs to be updated. The case that deserves a
	          // warning is when the container is empty.
	          rootElementsByReactRootID[reactRootID] = containerChild;
	        } else {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'ReactMount: Root element has been removed from its original ' + 'container. New container: %s', rootElement.parentNode) : undefined;
	        }
	      }
	    }
	
	    return container;
	  },
	
	  /**
	   * Finds an element rendered by React with the supplied ID.
	   *
	   * @param {string} id ID of a DOM node in the React component.
	   * @return {DOMElement} Root DOM node of the React component.
	   */
	  findReactNodeByID: function findReactNodeByID(id) {
	    var reactRoot = ReactMount.findReactContainerForID(id);
	    return ReactMount.findComponentRoot(reactRoot, id);
	  },
	
	  /**
	   * Traverses up the ancestors of the supplied node to find a node that is a
	   * DOM representation of a React component rendered by this copy of React.
	   *
	   * @param {*} node
	   * @return {?DOMEventTarget}
	   * @internal
	   */
	  getFirstReactDOM: function getFirstReactDOM(node) {
	    return findFirstReactDOMImpl(node);
	  },
	
	  /**
	   * Finds a node with the supplied `targetID` inside of the supplied
	   * `ancestorNode`.  Exploits the ID naming scheme to perform the search
	   * quickly.
	   *
	   * @param {DOMEventTarget} ancestorNode Search from this root.
	   * @pararm {string} targetID ID of the DOM representation of the component.
	   * @return {DOMEventTarget} DOM node with the supplied `targetID`.
	   * @internal
	   */
	  findComponentRoot: function findComponentRoot(ancestorNode, targetID) {
	    var firstChildren = findComponentRootReusableArray;
	    var childIndex = 0;
	
	    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This will throw on the next line; give an early warning
	      process.env.NODE_ENV !== 'production' ? warning(deepestAncestor != null, 'React can\'t find the root component node for data-reactid value ' + '`%s`. If you\'re seeing this message, it probably means that ' + 'you\'ve loaded two copies of React on the page. At this time, only ' + 'a single copy of React can be loaded at a time.', targetID) : undefined;
	    }
	
	    firstChildren[0] = deepestAncestor.firstChild;
	    firstChildren.length = 1;
	
	    while (childIndex < firstChildren.length) {
	      var child = firstChildren[childIndex++];
	      var targetChild;
	
	      while (child) {
	        var childID = ReactMount.getID(child);
	        if (childID) {
	          // Even if we find the node we're looking for, we finish looping
	          // through its siblings to ensure they're cached so that we don't have
	          // to revisit this node again. Otherwise, we make n^2 calls to getID
	          // when visiting the many children of a single node in order.
	
	          if (targetID === childID) {
	            targetChild = child;
	          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {
	            // If we find a child whose ID is an ancestor of the given ID,
	            // then we can be sure that we only want to search the subtree
	            // rooted at this child, so we can throw out the rest of the
	            // search state.
	            firstChildren.length = childIndex = 0;
	            firstChildren.push(child.firstChild);
	          }
	        } else {
	          // If this child had no ID, then there's a chance that it was
	          // injected automatically by the browser, as when a `<table>`
	          // element sprouts an extra `<tbody>` child as a side effect of
	          // `.innerHTML` parsing. Optimistically continue down this
	          // branch, but not before examining the other siblings.
	          firstChildren.push(child.firstChild);
	        }
	
	        child = child.nextSibling;
	      }
	
	      if (targetChild) {
	        // Emptying firstChildren/findComponentRootReusableArray is
	        // not necessary for correctness, but it helps the GC reclaim
	        // any nodes that were left at the end of the search.
	        firstChildren.length = 0;
	
	        return targetChild;
	      }
	    }
	
	    firstChildren.length = 0;
	
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findComponentRoot(..., %s): Unable to find element. This probably ' + 'means the DOM was unexpectedly mutated (e.g., by the browser), ' + 'usually due to forgetting a <tbody> when using tables, nesting tags ' + 'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' + 'parent. ' + 'Try inspecting the child nodes of the element with React ID `%s`.', targetID, ReactMount.getID(ancestorNode)) : invariant(false) : undefined;
	  },
	
	  _mountImageIntoNode: function _mountImageIntoNode(markup, container, shouldReuseMarkup, transaction) {
	    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : invariant(false) : undefined;
	
	    if (shouldReuseMarkup) {
	      var rootElement = getReactRootElementInContainer(container);
	      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
	        return;
	      } else {
	        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	
	        var rootMarkup = rootElement.outerHTML;
	        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);
	
	        var normalizedMarkup = markup;
	        if (process.env.NODE_ENV !== 'production') {
	          // because rootMarkup is retrieved from the DOM, various normalizations
	          // will have occurred which will not be present in `markup`. Here,
	          // insert markup into a <div> or <iframe> depending on the container
	          // type to perform the same normalizations before comparing.
	          var normalizer;
	          if (container.nodeType === ELEMENT_NODE_TYPE) {
	            normalizer = document.createElement('div');
	            normalizer.innerHTML = markup;
	            normalizedMarkup = normalizer.innerHTML;
	          } else {
	            normalizer = document.createElement('iframe');
	            document.body.appendChild(normalizer);
	            normalizer.contentDocument.write(markup);
	            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
	            document.body.removeChild(normalizer);
	          }
	        }
	
	        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
	        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);
	
	        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using ' + 'server rendering but the checksum was invalid. This usually ' + 'means you rendered a different component type or props on ' + 'the client from the one on the server, or your render() ' + 'methods are impure. React cannot handle this case due to ' + 'cross-browser quirks by rendering at the document root. You ' + 'should look for environment dependent code in your components ' + 'and ensure the props are the same client and server side:\n%s', difference) : invariant(false) : undefined;
	
	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : undefined;
	        }
	      }
	    }
	
	    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but ' + 'you didn\'t use server rendering. We can\'t do this ' + 'without using server rendering due to cross-browser quirks. ' + 'See ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;
	
	    if (transaction.useCreateElement) {
	      while (container.lastChild) {
	        container.removeChild(container.lastChild);
	      }
	      container.appendChild(markup);
	    } else {
	      setInnerHTML(container, markup);
	    }
	  },
	
	  ownerDocumentContextKey: ownerDocumentContextKey,
	
	  /**
	   * React ID utilities.
	   */
	
	  getReactRootID: getReactRootID,
	
	  getID: getID,
	
	  setID: setID,
	
	  getNode: getNode,
	
	  getNodeFromInstance: getNodeFromInstance,
	
	  isValid: isValid,
	
	  purgeID: purgeID
	};
	
	ReactPerf.measureMethods(ReactMount, 'ReactMount', {
	  _renderNewRootComponent: '_renderNewRootComponent',
	  _mountImageIntoNode: '_mountImageIntoNode'
	});
	
	module.exports = ReactMount;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactBrowserEventEmitter
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(37);
	var EventPluginHub = __webpack_require__(38);
	var EventPluginRegistry = __webpack_require__(39);
	var ReactEventEmitterMixin = __webpack_require__(44);
	var ReactPerf = __webpack_require__(25);
	var ViewportMetrics = __webpack_require__(45);
	
	var assign = __webpack_require__(46);
	var isEventSupported = __webpack_require__(47);
	
	/**
	 * Summary of `ReactBrowserEventEmitter` event handling:
	 *
	 *  - Top-level delegation is used to trap most native browser events. This
	 *    may only occur in the main thread and is the responsibility of
	 *    ReactEventListener, which is injected and can therefore support pluggable
	 *    event sources. This is the only work that occurs in the main thread.
	 *
	 *  - We normalize and de-duplicate events to account for browser quirks. This
	 *    may be done in the worker thread.
	 *
	 *  - Forward these native events (with the associated top-level type used to
	 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
	 *    to extract any synthetic events.
	 *
	 *  - The `EventPluginHub` will then process each event by annotating them with
	 *    "dispatches", a sequence of listeners and IDs that care about that event.
	 *
	 *  - The `EventPluginHub` then dispatches the events.
	 *
	 * Overview of React and the event system:
	 *
	 * +------------+    .
	 * |    DOM     |    .
	 * +------------+    .
	 *       |           .
	 *       v           .
	 * +------------+    .
	 * | ReactEvent |    .
	 * |  Listener  |    .
	 * +------------+    .                         +-----------+
	 *       |           .               +--------+|SimpleEvent|
	 *       |           .               |         |Plugin     |
	 * +-----|------+    .               v         +-----------+
	 * |     |      |    .    +--------------+                    +------------+
	 * |     +-----------.--->|EventPluginHub|                    |    Event   |
	 * |            |    .    |              |     +-----------+  | Propagators|
	 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
	 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
	 * |            |    .    |              |     +-----------+  |  utilities |
	 * |     +-----------.--->|              |                    +------------+
	 * |     |      |    .    +--------------+
	 * +-----|------+    .                ^        +-----------+
	 *       |           .                |        |Enter/Leave|
	 *       +           .                +-------+|Plugin     |
	 * +-------------+   .                         +-----------+
	 * | application |   .
	 * |-------------|   .
	 * |             |   .
	 * |             |   .
	 * +-------------+   .
	 *                   .
	 *    React Core     .  General Purpose Event Plugin System
	 */
	
	var alreadyListeningTo = {};
	var isMonitoringScrollValue = false;
	var reactTopListenersCounter = 0;
	
	// For events like 'submit' which don't consistently bubble (which we trap at a
	// lower node than `document`), binding at `document` would cause duplicate
	// events so we don't include them here
	var topEventMapping = {
	  topAbort: 'abort',
	  topBlur: 'blur',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topChange: 'change',
	  topClick: 'click',
	  topCompositionEnd: 'compositionend',
	  topCompositionStart: 'compositionstart',
	  topCompositionUpdate: 'compositionupdate',
	  topContextMenu: 'contextmenu',
	  topCopy: 'copy',
	  topCut: 'cut',
	  topDoubleClick: 'dblclick',
	  topDrag: 'drag',
	  topDragEnd: 'dragend',
	  topDragEnter: 'dragenter',
	  topDragExit: 'dragexit',
	  topDragLeave: 'dragleave',
	  topDragOver: 'dragover',
	  topDragStart: 'dragstart',
	  topDrop: 'drop',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topFocus: 'focus',
	  topInput: 'input',
	  topKeyDown: 'keydown',
	  topKeyPress: 'keypress',
	  topKeyUp: 'keyup',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topMouseDown: 'mousedown',
	  topMouseMove: 'mousemove',
	  topMouseOut: 'mouseout',
	  topMouseOver: 'mouseover',
	  topMouseUp: 'mouseup',
	  topPaste: 'paste',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topScroll: 'scroll',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topSelectionChange: 'selectionchange',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTextInput: 'textInput',
	  topTimeUpdate: 'timeupdate',
	  topTouchCancel: 'touchcancel',
	  topTouchEnd: 'touchend',
	  topTouchMove: 'touchmove',
	  topTouchStart: 'touchstart',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting',
	  topWheel: 'wheel'
	};
	
	/**
	 * To ensure no conflicts with other potential React instances on the page
	 */
	var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);
	
	function getListeningForDocument(mountAt) {
	  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
	  // directly.
	  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
	    mountAt[topListenersIDKey] = reactTopListenersCounter++;
	    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
	  }
	  return alreadyListeningTo[mountAt[topListenersIDKey]];
	}
	
	/**
	 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
	 * example:
	 *
	 *   ReactBrowserEventEmitter.putListener('myID', 'onClick', myFunction);
	 *
	 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
	 *
	 * @internal
	 */
	var ReactBrowserEventEmitter = assign({}, ReactEventEmitterMixin, {
	
	  /**
	   * Injectable event backend
	   */
	  ReactEventListener: null,
	
	  injection: {
	    /**
	     * @param {object} ReactEventListener
	     */
	    injectReactEventListener: function injectReactEventListener(ReactEventListener) {
	      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
	      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
	    }
	  },
	
	  /**
	   * Sets whether or not any created callbacks should be enabled.
	   *
	   * @param {boolean} enabled True if callbacks should be enabled.
	   */
	  setEnabled: function setEnabled(enabled) {
	    if (ReactBrowserEventEmitter.ReactEventListener) {
	      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
	    }
	  },
	
	  /**
	   * @return {boolean} True if callbacks are enabled.
	   */
	  isEnabled: function isEnabled() {
	    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
	  },
	
	  /**
	   * We listen for bubbled touch events on the document object.
	   *
	   * Firefox v8.01 (and possibly others) exhibited strange behavior when
	   * mounting `onmousemove` events at some node that was not the document
	   * element. The symptoms were that if your mouse is not moving over something
	   * contained within that mount point (for example on the background) the
	   * top-level listeners for `onmousemove` won't be called. However, if you
	   * register the `mousemove` on the document object, then it will of course
	   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
	   * top-level listeners to the document object only, at least for these
	   * movement types of events and possibly all events.
	   *
	   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
	   *
	   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
	   * they bubble to document.
	   *
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {object} contentDocumentHandle Document which owns the container
	   */
	  listenTo: function listenTo(registrationName, contentDocumentHandle) {
	    var mountAt = contentDocumentHandle;
	    var isListening = getListeningForDocument(mountAt);
	    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];
	
	    var topLevelTypes = EventConstants.topLevelTypes;
	    for (var i = 0; i < dependencies.length; i++) {
	      var dependency = dependencies[i];
	      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
	        if (dependency === topLevelTypes.topWheel) {
	          if (isEventSupported('wheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'wheel', mountAt);
	          } else if (isEventSupported('mousewheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'mousewheel', mountAt);
	          } else {
	            // Firefox needs to capture a different mouse scroll event.
	            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'DOMMouseScroll', mountAt);
	          }
	        } else if (dependency === topLevelTypes.topScroll) {
	
	          if (isEventSupported('scroll', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topScroll, 'scroll', mountAt);
	          } else {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topScroll, 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
	          }
	        } else if (dependency === topLevelTypes.topFocus || dependency === topLevelTypes.topBlur) {
	
	          if (isEventSupported('focus', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topFocus, 'focus', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topBlur, 'blur', mountAt);
	          } else if (isEventSupported('focusin')) {
	            // IE has `focusin` and `focusout` events which bubble.
	            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topFocus, 'focusin', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topBlur, 'focusout', mountAt);
	          }
	
	          // to make sure blur and focus event listeners are only attached once
	          isListening[topLevelTypes.topBlur] = true;
	          isListening[topLevelTypes.topFocus] = true;
	        } else if (topEventMapping.hasOwnProperty(dependency)) {
	          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
	        }
	
	        isListening[dependency] = true;
	      }
	    }
	  },
	
	  trapBubbledEvent: function trapBubbledEvent(topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  trapCapturedEvent: function trapCapturedEvent(topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  /**
	   * Listens to window scroll and resize events. We cache scroll values so that
	   * application code can access them without triggering reflows.
	   *
	   * NOTE: Scroll events do not bubble.
	   *
	   * @see http://www.quirksmode.org/dom/events/scroll.html
	   */
	  ensureScrollValueMonitoring: function ensureScrollValueMonitoring() {
	    if (!isMonitoringScrollValue) {
	      var refresh = ViewportMetrics.refreshScrollValues;
	      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
	      isMonitoringScrollValue = true;
	    }
	  },
	
	  eventNameDispatchConfigs: EventPluginHub.eventNameDispatchConfigs,
	
	  registrationNameModules: EventPluginHub.registrationNameModules,
	
	  putListener: EventPluginHub.putListener,
	
	  getListener: EventPluginHub.getListener,
	
	  deleteListener: EventPluginHub.deleteListener,
	
	  deleteAllListeners: EventPluginHub.deleteAllListeners
	
	});
	
	ReactPerf.measureMethods(ReactBrowserEventEmitter, 'ReactBrowserEventEmitter', {
	  putListener: 'putListener',
	  deleteListener: 'deleteListener'
	});
	
	module.exports = ReactBrowserEventEmitter;

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventConstants
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(24);
	
	var PropagationPhases = keyMirror({ bubbled: null, captured: null });
	
	/**
	 * Types of raw signals from the browser caught at the top level.
	 */
	var topLevelTypes = keyMirror({
	  topAbort: null,
	  topBlur: null,
	  topCanPlay: null,
	  topCanPlayThrough: null,
	  topChange: null,
	  topClick: null,
	  topCompositionEnd: null,
	  topCompositionStart: null,
	  topCompositionUpdate: null,
	  topContextMenu: null,
	  topCopy: null,
	  topCut: null,
	  topDoubleClick: null,
	  topDrag: null,
	  topDragEnd: null,
	  topDragEnter: null,
	  topDragExit: null,
	  topDragLeave: null,
	  topDragOver: null,
	  topDragStart: null,
	  topDrop: null,
	  topDurationChange: null,
	  topEmptied: null,
	  topEncrypted: null,
	  topEnded: null,
	  topError: null,
	  topFocus: null,
	  topInput: null,
	  topKeyDown: null,
	  topKeyPress: null,
	  topKeyUp: null,
	  topLoad: null,
	  topLoadedData: null,
	  topLoadedMetadata: null,
	  topLoadStart: null,
	  topMouseDown: null,
	  topMouseMove: null,
	  topMouseOut: null,
	  topMouseOver: null,
	  topMouseUp: null,
	  topPaste: null,
	  topPause: null,
	  topPlay: null,
	  topPlaying: null,
	  topProgress: null,
	  topRateChange: null,
	  topReset: null,
	  topScroll: null,
	  topSeeked: null,
	  topSeeking: null,
	  topSelectionChange: null,
	  topStalled: null,
	  topSubmit: null,
	  topSuspend: null,
	  topTextInput: null,
	  topTimeUpdate: null,
	  topTouchCancel: null,
	  topTouchEnd: null,
	  topTouchMove: null,
	  topTouchStart: null,
	  topVolumeChange: null,
	  topWaiting: null,
	  topWheel: null
	});
	
	var EventConstants = {
	  topLevelTypes: topLevelTypes,
	  PropagationPhases: PropagationPhases
	};
	
	module.exports = EventConstants;

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginHub
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var EventPluginRegistry = __webpack_require__(39);
	var EventPluginUtils = __webpack_require__(40);
	var ReactErrorUtils = __webpack_require__(41);
	
	var accumulateInto = __webpack_require__(42);
	var forEachAccumulated = __webpack_require__(43);
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	/**
	 * Internal store for event listeners
	 */
	var listenerBank = {};
	
	/**
	 * Internal queue of events that have accumulated their dispatches and are
	 * waiting to have their dispatches executed.
	 */
	var eventQueue = null;
	
	/**
	 * Dispatches an event and releases it back into the pool, unless persistent.
	 *
	 * @param {?object} event Synthetic event to be dispatched.
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @private
	 */
	var executeDispatchesAndRelease = function executeDispatchesAndRelease(event, simulated) {
	  if (event) {
	    EventPluginUtils.executeDispatchesInOrder(event, simulated);
	
	    if (!event.isPersistent()) {
	      event.constructor.release(event);
	    }
	  }
	};
	var executeDispatchesAndReleaseSimulated = function executeDispatchesAndReleaseSimulated(e) {
	  return executeDispatchesAndRelease(e, true);
	};
	var executeDispatchesAndReleaseTopLevel = function executeDispatchesAndReleaseTopLevel(e) {
	  return executeDispatchesAndRelease(e, false);
	};
	
	/**
	 * - `InstanceHandle`: [required] Module that performs logical traversals of DOM
	 *   hierarchy given ids of the logical DOM elements involved.
	 */
	var InstanceHandle = null;
	
	function validateInstanceHandle() {
	  var valid = InstanceHandle && InstanceHandle.traverseTwoPhase && InstanceHandle.traverseEnterLeave;
	  process.env.NODE_ENV !== 'production' ? warning(valid, 'InstanceHandle not injected before use!') : undefined;
	}
	
	/**
	 * This is a unified interface for event plugins to be installed and configured.
	 *
	 * Event plugins can implement the following properties:
	 *
	 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
	 *     Required. When a top-level event is fired, this method is expected to
	 *     extract synthetic events that will in turn be queued and dispatched.
	 *
	 *   `eventTypes` {object}
	 *     Optional, plugins that fire events must publish a mapping of registration
	 *     names that are used to register listeners. Values of this mapping must
	 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
	 *
	 *   `executeDispatch` {function(object, function, string)}
	 *     Optional, allows plugins to override how an event gets dispatched. By
	 *     default, the listener is simply invoked.
	 *
	 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
	 *
	 * @public
	 */
	var EventPluginHub = {
	
	  /**
	   * Methods for injecting dependencies.
	   */
	  injection: {
	
	    /**
	     * @param {object} InjectedMount
	     * @public
	     */
	    injectMount: EventPluginUtils.injection.injectMount,
	
	    /**
	     * @param {object} InjectedInstanceHandle
	     * @public
	     */
	    injectInstanceHandle: function injectInstanceHandle(InjectedInstanceHandle) {
	      InstanceHandle = InjectedInstanceHandle;
	      if (process.env.NODE_ENV !== 'production') {
	        validateInstanceHandle();
	      }
	    },
	
	    getInstanceHandle: function getInstanceHandle() {
	      if (process.env.NODE_ENV !== 'production') {
	        validateInstanceHandle();
	      }
	      return InstanceHandle;
	    },
	
	    /**
	     * @param {array} InjectedEventPluginOrder
	     * @public
	     */
	    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,
	
	    /**
	     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	     */
	    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
	
	  },
	
	  eventNameDispatchConfigs: EventPluginRegistry.eventNameDispatchConfigs,
	
	  registrationNameModules: EventPluginRegistry.registrationNameModules,
	
	  /**
	   * Stores `listener` at `listenerBank[registrationName][id]`. Is idempotent.
	   *
	   * @param {string} id ID of the DOM element.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {?function} listener The callback to store.
	   */
	  putListener: function putListener(id, registrationName, listener) {
	    !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener === 'undefined' ? 'undefined' : _typeof(listener)) : invariant(false) : undefined;
	
	    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
	    bankForRegistrationName[id] = listener;
	
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.didPutListener) {
	      PluginModule.didPutListener(id, registrationName, listener);
	    }
	  },
	
	  /**
	   * @param {string} id ID of the DOM element.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @return {?function} The stored callback.
	   */
	  getListener: function getListener(id, registrationName) {
	    var bankForRegistrationName = listenerBank[registrationName];
	    return bankForRegistrationName && bankForRegistrationName[id];
	  },
	
	  /**
	   * Deletes a listener from the registration bank.
	   *
	   * @param {string} id ID of the DOM element.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   */
	  deleteListener: function deleteListener(id, registrationName) {
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.willDeleteListener) {
	      PluginModule.willDeleteListener(id, registrationName);
	    }
	
	    var bankForRegistrationName = listenerBank[registrationName];
	    // TODO: This should never be null -- when is it?
	    if (bankForRegistrationName) {
	      delete bankForRegistrationName[id];
	    }
	  },
	
	  /**
	   * Deletes all listeners for the DOM element with the supplied ID.
	   *
	   * @param {string} id ID of the DOM element.
	   */
	  deleteAllListeners: function deleteAllListeners(id) {
	    for (var registrationName in listenerBank) {
	      if (!listenerBank[registrationName][id]) {
	        continue;
	      }
	
	      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	      if (PluginModule && PluginModule.willDeleteListener) {
	        PluginModule.willDeleteListener(id, registrationName);
	      }
	
	      delete listenerBank[registrationName][id];
	    }
	  },
	
	  /**
	   * Allows registered plugins an opportunity to extract events from top-level
	   * native browser events.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @internal
	   */
	  extractEvents: function extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    var events;
	    var plugins = EventPluginRegistry.plugins;
	    for (var i = 0; i < plugins.length; i++) {
	      // Not every plugin in the ordering may be loaded at runtime.
	      var possiblePlugin = plugins[i];
	      if (possiblePlugin) {
	        var extractedEvents = possiblePlugin.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);
	        if (extractedEvents) {
	          events = accumulateInto(events, extractedEvents);
	        }
	      }
	    }
	    return events;
	  },
	
	  /**
	   * Enqueues a synthetic event that should be dispatched when
	   * `processEventQueue` is invoked.
	   *
	   * @param {*} events An accumulation of synthetic events.
	   * @internal
	   */
	  enqueueEvents: function enqueueEvents(events) {
	    if (events) {
	      eventQueue = accumulateInto(eventQueue, events);
	    }
	  },
	
	  /**
	   * Dispatches all synthetic events on the event queue.
	   *
	   * @internal
	   */
	  processEventQueue: function processEventQueue(simulated) {
	    // Set `eventQueue` to null before processing it so that we can tell if more
	    // events get enqueued while processing.
	    var processingEventQueue = eventQueue;
	    eventQueue = null;
	    if (simulated) {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
	    } else {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
	    }
	    !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing ' + 'an event queue. Support for this has not yet been implemented.') : invariant(false) : undefined;
	    // This would be a good time to rethrow if any of the event handlers threw.
	    ReactErrorUtils.rethrowCaughtError();
	  },
	
	  /**
	   * These are needed for tests only. Do not use!
	   */
	  __purge: function __purge() {
	    listenerBank = {};
	  },
	
	  __getListenerBank: function __getListenerBank() {
	    return listenerBank;
	  }
	
	};
	
	module.exports = EventPluginHub;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginRegistry
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(20);
	
	/**
	 * Injectable ordering of event plugins.
	 */
	var EventPluginOrder = null;
	
	/**
	 * Injectable mapping from names to event plugin modules.
	 */
	var namesToPlugins = {};
	
	/**
	 * Recomputes the plugin list using the injected plugins and plugin ordering.
	 *
	 * @private
	 */
	function recomputePluginOrdering() {
	  if (!EventPluginOrder) {
	    // Wait until an `EventPluginOrder` is injected.
	    return;
	  }
	  for (var pluginName in namesToPlugins) {
	    var PluginModule = namesToPlugins[pluginName];
	    var pluginIndex = EventPluginOrder.indexOf(pluginName);
	    !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in ' + 'the plugin ordering, `%s`.', pluginName) : invariant(false) : undefined;
	    if (EventPluginRegistry.plugins[pluginIndex]) {
	      continue;
	    }
	    !PluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` ' + 'method, but `%s` does not.', pluginName) : invariant(false) : undefined;
	    EventPluginRegistry.plugins[pluginIndex] = PluginModule;
	    var publishedEvents = PluginModule.eventTypes;
	    for (var eventName in publishedEvents) {
	      !publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : invariant(false) : undefined;
	    }
	  }
	}
	
	/**
	 * Publishes an event so that it can be dispatched by the supplied plugin.
	 *
	 * @param {object} dispatchConfig Dispatch configuration for the event.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @return {boolean} True if the event was successfully published.
	 * @private
	 */
	function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
	  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'event name, `%s`.', eventName) : invariant(false) : undefined;
	  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
	
	  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
	  if (phasedRegistrationNames) {
	    for (var phaseName in phasedRegistrationNames) {
	      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
	        var phasedRegistrationName = phasedRegistrationNames[phaseName];
	        publishRegistrationName(phasedRegistrationName, PluginModule, eventName);
	      }
	    }
	    return true;
	  } else if (dispatchConfig.registrationName) {
	    publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);
	    return true;
	  }
	  return false;
	}
	
	/**
	 * Publishes a registration name that is used to identify dispatched events and
	 * can be used with `EventPluginHub.putListener` to register listeners.
	 *
	 * @param {string} registrationName Registration name to add.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @private
	 */
	function publishRegistrationName(registrationName, PluginModule, eventName) {
	  !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'registration name, `%s`.', registrationName) : invariant(false) : undefined;
	  EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
	  EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;
	}
	
	/**
	 * Registers plugins so that they can extract and dispatch events.
	 *
	 * @see {EventPluginHub}
	 */
	var EventPluginRegistry = {
	
	  /**
	   * Ordered list of injected plugins.
	   */
	  plugins: [],
	
	  /**
	   * Mapping from event name to dispatch config
	   */
	  eventNameDispatchConfigs: {},
	
	  /**
	   * Mapping from registration name to plugin module
	   */
	  registrationNameModules: {},
	
	  /**
	   * Mapping from registration name to event name
	   */
	  registrationNameDependencies: {},
	
	  /**
	   * Injects an ordering of plugins (by plugin name). This allows the ordering
	   * to be decoupled from injection of the actual plugins so that ordering is
	   * always deterministic regardless of packaging, on-the-fly injection, etc.
	   *
	   * @param {array} InjectedEventPluginOrder
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginOrder}
	   */
	  injectEventPluginOrder: function injectEventPluginOrder(InjectedEventPluginOrder) {
	    !!EventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than ' + 'once. You are likely trying to load more than one copy of React.') : invariant(false) : undefined;
	    // Clone the ordering so it cannot be dynamically mutated.
	    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
	    recomputePluginOrdering();
	  },
	
	  /**
	   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
	   * in the ordering injected by `injectEventPluginOrder`.
	   *
	   * Plugins can be injected as part of page initialization or on-the-fly.
	   *
	   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginsByName}
	   */
	  injectEventPluginsByName: function injectEventPluginsByName(injectedNamesToPlugins) {
	    var isOrderingDirty = false;
	    for (var pluginName in injectedNamesToPlugins) {
	      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
	        continue;
	      }
	      var PluginModule = injectedNamesToPlugins[pluginName];
	      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {
	        !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins ' + 'using the same name, `%s`.', pluginName) : invariant(false) : undefined;
	        namesToPlugins[pluginName] = PluginModule;
	        isOrderingDirty = true;
	      }
	    }
	    if (isOrderingDirty) {
	      recomputePluginOrdering();
	    }
	  },
	
	  /**
	   * Looks up the plugin for the supplied event.
	   *
	   * @param {object} event A synthetic event.
	   * @return {?object} The plugin that created the supplied event.
	   * @internal
	   */
	  getPluginModuleForEvent: function getPluginModuleForEvent(event) {
	    var dispatchConfig = event.dispatchConfig;
	    if (dispatchConfig.registrationName) {
	      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
	    }
	    for (var phase in dispatchConfig.phasedRegistrationNames) {
	      if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
	        continue;
	      }
	      var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
	      if (PluginModule) {
	        return PluginModule;
	      }
	    }
	    return null;
	  },
	
	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _resetEventPlugins: function _resetEventPlugins() {
	    EventPluginOrder = null;
	    for (var pluginName in namesToPlugins) {
	      if (namesToPlugins.hasOwnProperty(pluginName)) {
	        delete namesToPlugins[pluginName];
	      }
	    }
	    EventPluginRegistry.plugins.length = 0;
	
	    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
	    for (var eventName in eventNameDispatchConfigs) {
	      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
	        delete eventNameDispatchConfigs[eventName];
	      }
	    }
	
	    var registrationNameModules = EventPluginRegistry.registrationNameModules;
	    for (var registrationName in registrationNameModules) {
	      if (registrationNameModules.hasOwnProperty(registrationName)) {
	        delete registrationNameModules[registrationName];
	      }
	    }
	  }
	
	};
	
	module.exports = EventPluginRegistry;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginUtils
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(37);
	var ReactErrorUtils = __webpack_require__(41);
	
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	/**
	 * Injected dependencies:
	 */
	
	/**
	 * - `Mount`: [required] Module that can convert between React dom IDs and
	 *   actual node references.
	 */
	var injection = {
	  Mount: null,
	  injectMount: function injectMount(InjectedMount) {
	    injection.Mount = InjectedMount;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(InjectedMount && InjectedMount.getNode && InjectedMount.getID, 'EventPluginUtils.injection.injectMount(...): Injected Mount ' + 'module is missing getNode or getID.') : undefined;
	    }
	  }
	};
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	function isEndish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;
	}
	
	function isMoveish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;
	}
	function isStartish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;
	}
	
	var validateEventDispatches;
	if (process.env.NODE_ENV !== 'production') {
	  validateEventDispatches = function validateEventDispatches(event) {
	    var dispatchListeners = event._dispatchListeners;
	    var dispatchIDs = event._dispatchIDs;
	
	    var listenersIsArr = Array.isArray(dispatchListeners);
	    var idsIsArr = Array.isArray(dispatchIDs);
	    var IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0;
	    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
	
	    process.env.NODE_ENV !== 'production' ? warning(idsIsArr === listenersIsArr && IDsLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : undefined;
	  };
	}
	
	/**
	 * Dispatch the event to the listener.
	 * @param {SyntheticEvent} event SyntheticEvent to handle
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @param {function} listener Application-level callback
	 * @param {string} domID DOM id to pass to the callback.
	 */
	function executeDispatch(event, simulated, listener, domID) {
	  var type = event.type || 'unknown-event';
	  event.currentTarget = injection.Mount.getNode(domID);
	  if (simulated) {
	    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event, domID);
	  } else {
	    ReactErrorUtils.invokeGuardedCallback(type, listener, event, domID);
	  }
	  event.currentTarget = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches.
	 */
	function executeDispatchesInOrder(event, simulated) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchIDs = event._dispatchIDs;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and IDs are two parallel arrays that are always in sync.
	      executeDispatch(event, simulated, dispatchListeners[i], dispatchIDs[i]);
	    }
	  } else if (dispatchListeners) {
	    executeDispatch(event, simulated, dispatchListeners, dispatchIDs);
	  }
	  event._dispatchListeners = null;
	  event._dispatchIDs = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches, but stops
	 * at the first dispatch execution returning true, and returns that id.
	 *
	 * @return {?string} id of the first dispatch execution who's listener returns
	 * true, or null if no listener returned true.
	 */
	function executeDispatchesInOrderStopAtTrueImpl(event) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchIDs = event._dispatchIDs;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and IDs are two parallel arrays that are always in sync.
	      if (dispatchListeners[i](event, dispatchIDs[i])) {
	        return dispatchIDs[i];
	      }
	    }
	  } else if (dispatchListeners) {
	    if (dispatchListeners(event, dispatchIDs)) {
	      return dispatchIDs;
	    }
	  }
	  return null;
	}
	
	/**
	 * @see executeDispatchesInOrderStopAtTrueImpl
	 */
	function executeDispatchesInOrderStopAtTrue(event) {
	  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
	  event._dispatchIDs = null;
	  event._dispatchListeners = null;
	  return ret;
	}
	
	/**
	 * Execution of a "direct" dispatch - there must be at most one dispatch
	 * accumulated on the event or it is considered an error. It doesn't really make
	 * sense for an event with multiple dispatches (bubbled) to keep track of the
	 * return values at each dispatch execution, but it does tend to make sense when
	 * dealing with "direct" dispatches.
	 *
	 * @return {*} The return value of executing the single dispatch.
	 */
	function executeDirectDispatch(event) {
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  var dispatchListener = event._dispatchListeners;
	  var dispatchID = event._dispatchIDs;
	  !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : invariant(false) : undefined;
	  var res = dispatchListener ? dispatchListener(event, dispatchID) : null;
	  event._dispatchListeners = null;
	  event._dispatchIDs = null;
	  return res;
	}
	
	/**
	 * @param {SyntheticEvent} event
	 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
	 */
	function hasDispatches(event) {
	  return !!event._dispatchListeners;
	}
	
	/**
	 * General utilities that are useful in creating custom Event Plugins.
	 */
	var EventPluginUtils = {
	  isEndish: isEndish,
	  isMoveish: isMoveish,
	  isStartish: isStartish,
	
	  executeDirectDispatch: executeDirectDispatch,
	  executeDispatchesInOrder: executeDispatchesInOrder,
	  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
	  hasDispatches: hasDispatches,
	
	  getNode: function getNode(id) {
	    return injection.Mount.getNode(id);
	  },
	  getID: function getID(node) {
	    return injection.Mount.getID(node);
	  },
	
	  injection: injection
	};
	
	module.exports = EventPluginUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactErrorUtils
	 * @typechecks
	 */
	
	'use strict';
	
	var caughtError = null;
	
	/**
	 * Call a function while guarding against errors that happens within it.
	 *
	 * @param {?String} name of the guard to use for logging or debugging
	 * @param {Function} func The function to invoke
	 * @param {*} a First argument
	 * @param {*} b Second argument
	 */
	function invokeGuardedCallback(name, func, a, b) {
	  try {
	    return func(a, b);
	  } catch (x) {
	    if (caughtError === null) {
	      caughtError = x;
	    }
	    return undefined;
	  }
	}
	
	var ReactErrorUtils = {
	  invokeGuardedCallback: invokeGuardedCallback,
	
	  /**
	   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
	   * handler are sure to be rethrown by rethrowCaughtError.
	   */
	  invokeGuardedCallbackWithCatch: invokeGuardedCallback,
	
	  /**
	   * During execution of guarded functions we will capture the first error which
	   * we will rethrow to be handled by the top level error handler.
	   */
	  rethrowCaughtError: function rethrowCaughtError() {
	    if (caughtError) {
	      var error = caughtError;
	      caughtError = null;
	      throw error;
	    }
	  }
	};
	
	if (process.env.NODE_ENV !== 'production') {
	  /**
	   * To help development we can get better devtools integration by simulating a
	   * real browser event.
	   */
	  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
	    var fakeNode = document.createElement('react');
	    ReactErrorUtils.invokeGuardedCallback = function (name, func, a, b) {
	      var boundFunc = func.bind(null, a, b);
	      var evtType = 'react-' + name;
	      fakeNode.addEventListener(evtType, boundFunc, false);
	      var evt = document.createEvent('Event');
	      evt.initEvent(evtType, false, false);
	      fakeNode.dispatchEvent(evt);
	      fakeNode.removeEventListener(evtType, boundFunc, false);
	    };
	  }
	}
	
	module.exports = ReactErrorUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule accumulateInto
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(20);
	
	/**
	 *
	 * Accumulates items that must not be null or undefined into the first one. This
	 * is used to conserve memory by avoiding array allocations, and thus sacrifices
	 * API cleanness. Since `current` can be null before being passed in and not
	 * null after this function, make sure to assign it back to `current`:
	 *
	 * `a = accumulateInto(a, b);`
	 *
	 * This API should be sparingly used. Try `accumulate` for something cleaner.
	 *
	 * @return {*|array<*>} An accumulation of items.
	 */
	
	function accumulateInto(current, next) {
	  !(next != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : invariant(false) : undefined;
	  if (current == null) {
	    return next;
	  }
	
	  // Both are not empty. Warning: Never call x.concat(y) when you are not
	  // certain that x is an Array (x could be a string with concat method).
	  var currentIsArray = Array.isArray(current);
	  var nextIsArray = Array.isArray(next);
	
	  if (currentIsArray && nextIsArray) {
	    current.push.apply(current, next);
	    return current;
	  }
	
	  if (currentIsArray) {
	    current.push(next);
	    return current;
	  }
	
	  if (nextIsArray) {
	    // A bit too dangerous to mutate `next`.
	    return [current].concat(next);
	  }
	
	  return [current, next];
	}
	
	module.exports = accumulateInto;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 43 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule forEachAccumulated
	 */
	
	'use strict';
	
	/**
	 * @param {array} arr an "accumulation" of items which is either an Array or
	 * a single item. Useful when paired with the `accumulate` module. This is a
	 * simple utility that allows us to reason about a collection of items, but
	 * handling the case when there is exactly one item (and we do not need to
	 * allocate an array).
	 */
	
	var forEachAccumulated = function forEachAccumulated(arr, cb, scope) {
	  if (Array.isArray(arr)) {
	    arr.forEach(cb, scope);
	  } else if (arr) {
	    cb.call(scope, arr);
	  }
	};
	
	module.exports = forEachAccumulated;

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEventEmitterMixin
	 */
	
	'use strict';
	
	var EventPluginHub = __webpack_require__(38);
	
	function runEventQueueInBatch(events) {
	  EventPluginHub.enqueueEvents(events);
	  EventPluginHub.processEventQueue(false);
	}
	
	var ReactEventEmitterMixin = {
	
	  /**
	   * Streams a fired top-level event to `EventPluginHub` where plugins have the
	   * opportunity to create `ReactEvent`s to be dispatched.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {object} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native environment event.
	   */
	  handleTopLevel: function handleTopLevel(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    var events = EventPluginHub.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);
	    runEventQueueInBatch(events);
	  }
	};
	
	module.exports = ReactEventEmitterMixin;

/***/ },
/* 45 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ViewportMetrics
	 */
	
	'use strict';
	
	var ViewportMetrics = {
	
	  currentScrollLeft: 0,
	
	  currentScrollTop: 0,
	
	  refreshScrollValues: function refreshScrollValues(scrollPosition) {
	    ViewportMetrics.currentScrollLeft = scrollPosition.x;
	    ViewportMetrics.currentScrollTop = scrollPosition.y;
	  }
	
	};
	
	module.exports = ViewportMetrics;

/***/ },
/* 46 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Object.assign
	 */
	
	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign
	
	'use strict';
	
	function assign(target, sources) {
	  if (target == null) {
	    throw new TypeError('Object.assign target cannot be null or undefined');
	  }
	
	  var to = Object(target);
	  var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	  for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
	    var nextSource = arguments[nextIndex];
	    if (nextSource == null) {
	      continue;
	    }
	
	    var from = Object(nextSource);
	
	    // We don't currently support accessors nor proxies. Therefore this
	    // copy cannot throw. If we ever supported this then we must handle
	    // exceptions and side-effects. We don't support symbols so they won't
	    // be transferred.
	
	    for (var key in from) {
	      if (hasOwnProperty.call(from, key)) {
	        to[key] = from[key];
	      }
	    }
	  }
	
	  return to;
	}
	
	module.exports = assign;

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isEventSupported
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(16);
	
	var useHasFeature;
	if (ExecutionEnvironment.canUseDOM) {
	  useHasFeature = document.implementation && document.implementation.hasFeature &&
	  // always returns true in newer browsers as per the standard.
	  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
	  document.implementation.hasFeature('', '') !== true;
	}
	
	/**
	 * Checks if an event is supported in the current execution environment.
	 *
	 * NOTE: This will not work correctly for non-generic events such as `change`,
	 * `reset`, `load`, `error`, and `select`.
	 *
	 * Borrows from Modernizr.
	 *
	 * @param {string} eventNameSuffix Event name, e.g. "click".
	 * @param {?boolean} capture Check if the capture phase is supported.
	 * @return {boolean} True if the event is supported.
	 * @internal
	 * @license Modernizr 3.0.0pre (Custom Build) | MIT
	 */
	function isEventSupported(eventNameSuffix, capture) {
	  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
	    return false;
	  }
	
	  var eventName = 'on' + eventNameSuffix;
	  var isSupported = eventName in document;
	
	  if (!isSupported) {
	    var element = document.createElement('div');
	    element.setAttribute(eventName, 'return;');
	    isSupported = typeof element[eventName] === 'function';
	  }
	
	  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
	    // This is the only way to test support for the `wheel` event in IE9+.
	    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
	  }
	
	  return isSupported;
	}
	
	module.exports = isEventSupported;

/***/ },
/* 48 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMFeatureFlags
	 */
	
	'use strict';
	
	var ReactDOMFeatureFlags = {
	  useCreateElement: false
	};
	
	module.exports = ReactDOMFeatureFlags;

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactElement
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactCurrentOwner = __webpack_require__(12);
	
	var assign = __webpack_require__(46);
	var canDefineProperty = __webpack_require__(50);
	
	// The Symbol used to tag the ReactElement type. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;
	
	var RESERVED_PROPS = {
	  key: true,
	  ref: true,
	  __self: true,
	  __source: true
	};
	
	/**
	 * Base constructor for all React elements. This is only used to make this
	 * work with a dynamic instanceof check. Nothing should live on this prototype.
	 *
	 * @param {*} type
	 * @param {*} key
	 * @param {string|object} ref
	 * @param {*} self A *temporary* helper to detect places where `this` is
	 * different from the `owner` when React.createElement is called, so that we
	 * can warn. We want to get rid of owner and replace string `ref`s with arrow
	 * functions, and as long as `this` and owner are the same, there will be no
	 * change in behavior.
	 * @param {*} source An annotation object (added by a transpiler or otherwise)
	 * indicating filename, line number, and/or other information.
	 * @param {*} owner
	 * @param {*} props
	 * @internal
	 */
	var ReactElement = function ReactElement(type, key, ref, self, source, owner, props) {
	  var element = {
	    // This tag allow us to uniquely identify this as a React Element
	    $$typeof: REACT_ELEMENT_TYPE,
	
	    // Built-in properties that belong on the element
	    type: type,
	    key: key,
	    ref: ref,
	    props: props,
	
	    // Record the component responsible for creating this element.
	    _owner: owner
	  };
	
	  if (process.env.NODE_ENV !== 'production') {
	    // The validation flag is currently mutative. We put it on
	    // an external backing store so that we can freeze the whole object.
	    // This can be replaced with a WeakMap once they are implemented in
	    // commonly used development environments.
	    element._store = {};
	
	    // To make comparing ReactElements easier for testing purposes, we make
	    // the validation flag non-enumerable (where possible, which should
	    // include every environment we run tests in), so the test framework
	    // ignores it.
	    if (canDefineProperty) {
	      Object.defineProperty(element._store, 'validated', {
	        configurable: false,
	        enumerable: false,
	        writable: true,
	        value: false
	      });
	      // self and source are DEV only properties.
	      Object.defineProperty(element, '_self', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: self
	      });
	      // Two elements created in two different places should be considered
	      // equal for testing purposes and therefore we hide it from enumeration.
	      Object.defineProperty(element, '_source', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: source
	      });
	    } else {
	      element._store.validated = false;
	      element._self = self;
	      element._source = source;
	    }
	    Object.freeze(element.props);
	    Object.freeze(element);
	  }
	
	  return element;
	};
	
	ReactElement.createElement = function (type, config, children) {
	  var propName;
	
	  // Reserved names are extracted
	  var props = {};
	
	  var key = null;
	  var ref = null;
	  var self = null;
	  var source = null;
	
	  if (config != null) {
	    ref = config.ref === undefined ? null : config.ref;
	    key = config.key === undefined ? null : '' + config.key;
	    self = config.__self === undefined ? null : config.__self;
	    source = config.__source === undefined ? null : config.__source;
	    // Remaining properties are added to a new props object
	    for (propName in config) {
	      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }
	
	  // Resolve default props
	  if (type && type.defaultProps) {
	    var defaultProps = type.defaultProps;
	    for (propName in defaultProps) {
	      if (typeof props[propName] === 'undefined') {
	        props[propName] = defaultProps[propName];
	      }
	    }
	  }
	
	  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
	};
	
	ReactElement.createFactory = function (type) {
	  var factory = ReactElement.createElement.bind(null, type);
	  // Expose the type on the factory and the prototype so that it can be
	  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
	  // This should not be named `constructor` since this may not be the function
	  // that created the element, and it may not even be a constructor.
	  // Legacy hook TODO: Warn if this is accessed
	  factory.type = type;
	  return factory;
	};
	
	ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
	  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
	
	  return newElement;
	};
	
	ReactElement.cloneAndReplaceProps = function (oldElement, newProps) {
	  var newElement = ReactElement(oldElement.type, oldElement.key, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, newProps);
	
	  if (process.env.NODE_ENV !== 'production') {
	    // If the key on the original is valid, then the clone is valid
	    newElement._store.validated = oldElement._store.validated;
	  }
	
	  return newElement;
	};
	
	ReactElement.cloneElement = function (element, config, children) {
	  var propName;
	
	  // Original props are copied
	  var props = assign({}, element.props);
	
	  // Reserved names are extracted
	  var key = element.key;
	  var ref = element.ref;
	  // Self is preserved since the owner is preserved.
	  var self = element._self;
	  // Source is preserved since cloneElement is unlikely to be targeted by a
	  // transpiler, and the original source is probably a better indicator of the
	  // true owner.
	  var source = element._source;
	
	  // Owner will be preserved, unless ref is overridden
	  var owner = element._owner;
	
	  if (config != null) {
	    if (config.ref !== undefined) {
	      // Silently steal the ref from the parent.
	      ref = config.ref;
	      owner = ReactCurrentOwner.current;
	    }
	    if (config.key !== undefined) {
	      key = '' + config.key;
	    }
	    // Remaining properties override existing props
	    for (propName in config) {
	      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }
	
	  return ReactElement(element.type, key, ref, self, source, owner, props);
	};
	
	/**
	 * @param {?object} object
	 * @return {boolean} True if `object` is a valid component.
	 * @final
	 */
	ReactElement.isValidElement = function (object) {
	  return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	};
	
	module.exports = ReactElement;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule canDefineProperty
	 */
	
	'use strict';
	
	var canDefineProperty = false;
	if (process.env.NODE_ENV !== 'production') {
	  try {
	    Object.defineProperty({}, 'x', { get: function get() {} });
	    canDefineProperty = true;
	  } catch (x) {
	    // IE will fail on defineProperty
	  }
	}
	
	module.exports = canDefineProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 51 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEmptyComponentRegistry
	 */
	
	'use strict';
	
	// This registry keeps track of the React IDs of the components that rendered to
	// `null` (in reality a placeholder such as `noscript`)
	
	var nullComponentIDsRegistry = {};
	
	/**
	 * @param {string} id Component's `_rootNodeID`.
	 * @return {boolean} True if the component is rendered to null.
	 */
	function isNullComponentID(id) {
	  return !!nullComponentIDsRegistry[id];
	}
	
	/**
	 * Mark the component as having rendered to null.
	 * @param {string} id Component's `_rootNodeID`.
	 */
	function registerNullComponentID(id) {
	  nullComponentIDsRegistry[id] = true;
	}
	
	/**
	 * Unmark the component as having rendered to null: it renders to something now.
	 * @param {string} id Component's `_rootNodeID`.
	 */
	function deregisterNullComponentID(id) {
	  delete nullComponentIDsRegistry[id];
	}
	
	var ReactEmptyComponentRegistry = {
	  isNullComponentID: isNullComponentID,
	  registerNullComponentID: registerNullComponentID,
	  deregisterNullComponentID: deregisterNullComponentID
	};
	
	module.exports = ReactEmptyComponentRegistry;

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInstanceHandles
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactRootIndex = __webpack_require__(53);
	
	var invariant = __webpack_require__(20);
	
	var SEPARATOR = '.';
	var SEPARATOR_LENGTH = SEPARATOR.length;
	
	/**
	 * Maximum depth of traversals before we consider the possibility of a bad ID.
	 */
	var MAX_TREE_DEPTH = 10000;
	
	/**
	 * Creates a DOM ID prefix to use when mounting React components.
	 *
	 * @param {number} index A unique integer
	 * @return {string} React root ID.
	 * @internal
	 */
	function getReactRootIDString(index) {
	  return SEPARATOR + index.toString(36);
	}
	
	/**
	 * Checks if a character in the supplied ID is a separator or the end.
	 *
	 * @param {string} id A React DOM ID.
	 * @param {number} index Index of the character to check.
	 * @return {boolean} True if the character is a separator or end of the ID.
	 * @private
	 */
	function isBoundary(id, index) {
	  return id.charAt(index) === SEPARATOR || index === id.length;
	}
	
	/**
	 * Checks if the supplied string is a valid React DOM ID.
	 *
	 * @param {string} id A React DOM ID, maybe.
	 * @return {boolean} True if the string is a valid React DOM ID.
	 * @private
	 */
	function isValidID(id) {
	  return id === '' || id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR;
	}
	
	/**
	 * Checks if the first ID is an ancestor of or equal to the second ID.
	 *
	 * @param {string} ancestorID
	 * @param {string} descendantID
	 * @return {boolean} True if `ancestorID` is an ancestor of `descendantID`.
	 * @internal
	 */
	function isAncestorIDOf(ancestorID, descendantID) {
	  return descendantID.indexOf(ancestorID) === 0 && isBoundary(descendantID, ancestorID.length);
	}
	
	/**
	 * Gets the parent ID of the supplied React DOM ID, `id`.
	 *
	 * @param {string} id ID of a component.
	 * @return {string} ID of the parent, or an empty string.
	 * @private
	 */
	function getParentID(id) {
	  return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';
	}
	
	/**
	 * Gets the next DOM ID on the tree path from the supplied `ancestorID` to the
	 * supplied `destinationID`. If they are equal, the ID is returned.
	 *
	 * @param {string} ancestorID ID of an ancestor node of `destinationID`.
	 * @param {string} destinationID ID of the destination node.
	 * @return {string} Next ID on the path from `ancestorID` to `destinationID`.
	 * @private
	 */
	function getNextDescendantID(ancestorID, destinationID) {
	  !(isValidID(ancestorID) && isValidID(destinationID)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNextDescendantID(%s, %s): Received an invalid React DOM ID.', ancestorID, destinationID) : invariant(false) : undefined;
	  !isAncestorIDOf(ancestorID, destinationID) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNextDescendantID(...): React has made an invalid assumption about ' + 'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.', ancestorID, destinationID) : invariant(false) : undefined;
	  if (ancestorID === destinationID) {
	    return ancestorID;
	  }
	  // Skip over the ancestor and the immediate separator. Traverse until we hit
	  // another separator or we reach the end of `destinationID`.
	  var start = ancestorID.length + SEPARATOR_LENGTH;
	  var i;
	  for (i = start; i < destinationID.length; i++) {
	    if (isBoundary(destinationID, i)) {
	      break;
	    }
	  }
	  return destinationID.substr(0, i);
	}
	
	/**
	 * Gets the nearest common ancestor ID of two IDs.
	 *
	 * Using this ID scheme, the nearest common ancestor ID is the longest common
	 * prefix of the two IDs that immediately preceded a "marker" in both strings.
	 *
	 * @param {string} oneID
	 * @param {string} twoID
	 * @return {string} Nearest common ancestor ID, or the empty string if none.
	 * @private
	 */
	function getFirstCommonAncestorID(oneID, twoID) {
	  var minLength = Math.min(oneID.length, twoID.length);
	  if (minLength === 0) {
	    return '';
	  }
	  var lastCommonMarkerIndex = 0;
	  // Use `<=` to traverse until the "EOL" of the shorter string.
	  for (var i = 0; i <= minLength; i++) {
	    if (isBoundary(oneID, i) && isBoundary(twoID, i)) {
	      lastCommonMarkerIndex = i;
	    } else if (oneID.charAt(i) !== twoID.charAt(i)) {
	      break;
	    }
	  }
	  var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);
	  !isValidID(longestCommonID) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s', oneID, twoID, longestCommonID) : invariant(false) : undefined;
	  return longestCommonID;
	}
	
	/**
	 * Traverses the parent path between two IDs (either up or down). The IDs must
	 * not be the same, and there must exist a parent path between them. If the
	 * callback returns `false`, traversal is stopped.
	 *
	 * @param {?string} start ID at which to start traversal.
	 * @param {?string} stop ID at which to end traversal.
	 * @param {function} cb Callback to invoke each ID with.
	 * @param {*} arg Argument to invoke the callback with.
	 * @param {?boolean} skipFirst Whether or not to skip the first node.
	 * @param {?boolean} skipLast Whether or not to skip the last node.
	 * @private
	 */
	function traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {
	  start = start || '';
	  stop = stop || '';
	  !(start !== stop) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.', start) : invariant(false) : undefined;
	  var traverseUp = isAncestorIDOf(stop, start);
	  !(traverseUp || isAncestorIDOf(start, stop)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' + 'not have a parent path.', start, stop) : invariant(false) : undefined;
	  // Traverse from `start` to `stop` one depth at a time.
	  var depth = 0;
	  var traverse = traverseUp ? getParentID : getNextDescendantID;
	  for (var id = start;; /* until break */id = traverse(id, stop)) {
	    var ret;
	    if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {
	      ret = cb(id, traverseUp, arg);
	    }
	    if (ret === false || id === stop) {
	      // Only break //after// visiting `stop`.
	      break;
	    }
	    !(depth++ < MAX_TREE_DEPTH) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' + 'traversing the React DOM ID tree. This may be due to malformed IDs: %s', start, stop, id) : invariant(false) : undefined;
	  }
	}
	
	/**
	 * Manages the IDs assigned to DOM representations of React components. This
	 * uses a specific scheme in order to traverse the DOM efficiently (e.g. in
	 * order to simulate events).
	 *
	 * @internal
	 */
	var ReactInstanceHandles = {
	
	  /**
	   * Constructs a React root ID
	   * @return {string} A React root ID.
	   */
	  createReactRootID: function createReactRootID() {
	    return getReactRootIDString(ReactRootIndex.createReactRootIndex());
	  },
	
	  /**
	   * Constructs a React ID by joining a root ID with a name.
	   *
	   * @param {string} rootID Root ID of a parent component.
	   * @param {string} name A component's name (as flattened children).
	   * @return {string} A React ID.
	   * @internal
	   */
	  createReactID: function createReactID(rootID, name) {
	    return rootID + name;
	  },
	
	  /**
	   * Gets the DOM ID of the React component that is the root of the tree that
	   * contains the React component with the supplied DOM ID.
	   *
	   * @param {string} id DOM ID of a React component.
	   * @return {?string} DOM ID of the React component that is the root.
	   * @internal
	   */
	  getReactRootIDFromNodeID: function getReactRootIDFromNodeID(id) {
	    if (id && id.charAt(0) === SEPARATOR && id.length > 1) {
	      var index = id.indexOf(SEPARATOR, 1);
	      return index > -1 ? id.substr(0, index) : id;
	    }
	    return null;
	  },
	
	  /**
	   * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
	   * should would receive a `mouseEnter` or `mouseLeave` event.
	   *
	   * NOTE: Does not invoke the callback on the nearest common ancestor because
	   * nothing "entered" or "left" that element.
	   *
	   * @param {string} leaveID ID being left.
	   * @param {string} enterID ID being entered.
	   * @param {function} cb Callback to invoke on each entered/left ID.
	   * @param {*} upArg Argument to invoke the callback with on left IDs.
	   * @param {*} downArg Argument to invoke the callback with on entered IDs.
	   * @internal
	   */
	  traverseEnterLeave: function traverseEnterLeave(leaveID, enterID, cb, upArg, downArg) {
	    var ancestorID = getFirstCommonAncestorID(leaveID, enterID);
	    if (ancestorID !== leaveID) {
	      traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);
	    }
	    if (ancestorID !== enterID) {
	      traverseParentPath(ancestorID, enterID, cb, downArg, true, false);
	    }
	  },
	
	  /**
	   * Simulates the traversal of a two-phase, capture/bubble event dispatch.
	   *
	   * NOTE: This traversal happens on IDs without touching the DOM.
	   *
	   * @param {string} targetID ID of the target node.
	   * @param {function} cb Callback to invoke.
	   * @param {*} arg Argument to invoke the callback with.
	   * @internal
	   */
	  traverseTwoPhase: function traverseTwoPhase(targetID, cb, arg) {
	    if (targetID) {
	      traverseParentPath('', targetID, cb, arg, true, false);
	      traverseParentPath(targetID, '', cb, arg, false, true);
	    }
	  },
	
	  /**
	   * Same as `traverseTwoPhase` but skips the `targetID`.
	   */
	  traverseTwoPhaseSkipTarget: function traverseTwoPhaseSkipTarget(targetID, cb, arg) {
	    if (targetID) {
	      traverseParentPath('', targetID, cb, arg, true, true);
	      traverseParentPath(targetID, '', cb, arg, true, true);
	    }
	  },
	
	  /**
	   * Traverse a node ID, calling the supplied `cb` for each ancestor ID. For
	   * example, passing `.0.$row-0.1` would result in `cb` getting called
	   * with `.0`, `.0.$row-0`, and `.0.$row-0.1`.
	   *
	   * NOTE: This traversal happens on IDs without touching the DOM.
	   *
	   * @param {string} targetID ID of the target node.
	   * @param {function} cb Callback to invoke.
	   * @param {*} arg Argument to invoke the callback with.
	   * @internal
	   */
	  traverseAncestors: function traverseAncestors(targetID, cb, arg) {
	    traverseParentPath('', targetID, cb, arg, true, false);
	  },
	
	  getFirstCommonAncestorID: getFirstCommonAncestorID,
	
	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _getNextDescendantID: getNextDescendantID,
	
	  isAncestorIDOf: isAncestorIDOf,
	
	  SEPARATOR: SEPARATOR
	
	};
	
	module.exports = ReactInstanceHandles;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 53 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactRootIndex
	 * @typechecks
	 */
	
	'use strict';
	
	var ReactRootIndexInjection = {
	  /**
	   * @param {function} _createReactRootIndex
	   */
	  injectCreateReactRootIndex: function injectCreateReactRootIndex(_createReactRootIndex) {
	    ReactRootIndex.createReactRootIndex = _createReactRootIndex;
	  }
	};
	
	var ReactRootIndex = {
	  createReactRootIndex: null,
	  injection: ReactRootIndexInjection
	};
	
	module.exports = ReactRootIndex;

/***/ },
/* 54 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInstanceMap
	 */
	
	'use strict';
	
	/**
	 * `ReactInstanceMap` maintains a mapping from a public facing stateful
	 * instance (key) and the internal representation (value). This allows public
	 * methods to accept the user facing instance as an argument and map them back
	 * to internal methods.
	 */
	
	// TODO: Replace this with ES6: var ReactInstanceMap = new Map();
	
	var ReactInstanceMap = {
	
	  /**
	   * This API should be called `delete` but we'd have to make sure to always
	   * transform these to strings for IE support. When this transform is fully
	   * supported we can rename it.
	   */
	  remove: function remove(key) {
	    key._reactInternalInstance = undefined;
	  },
	
	  get: function get(key) {
	    return key._reactInternalInstance;
	  },
	
	  has: function has(key) {
	    return key._reactInternalInstance !== undefined;
	  },
	
	  set: function set(key, value) {
	    key._reactInternalInstance = value;
	  }
	
	};
	
	module.exports = ReactInstanceMap;

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMarkupChecksum
	 */
	
	'use strict';
	
	var adler32 = __webpack_require__(56);
	
	var TAG_END = /\/?>/;
	
	var ReactMarkupChecksum = {
	  CHECKSUM_ATTR_NAME: 'data-react-checksum',
	
	  /**
	   * @param {string} markup Markup string
	   * @return {string} Markup string with checksum attribute attached
	   */
	  addChecksumToMarkup: function addChecksumToMarkup(markup) {
	    var checksum = adler32(markup);
	
	    // Add checksum (handle both parent tags and self-closing tags)
	    return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
	  },
	
	  /**
	   * @param {string} markup to use
	   * @param {DOMElement} element root React element
	   * @returns {boolean} whether or not the markup is the same
	   */
	  canReuseMarkup: function canReuseMarkup(markup, element) {
	    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
	    var markupChecksum = adler32(markup);
	    return markupChecksum === existingChecksum;
	  }
	};
	
	module.exports = ReactMarkupChecksum;

/***/ },
/* 56 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule adler32
	 */
	
	'use strict';
	
	var MOD = 65521;
	
	// adler32 is not cryptographically strong, and is only used to sanity check that
	// markup generated on the server matches the markup generated on the client.
	// This implementation (a modified version of the SheetJS version) has been optimized
	// for our use case, at the expense of conforming to the adler32 specification
	// for non-ascii inputs.
	function adler32(data) {
	  var a = 1;
	  var b = 0;
	  var i = 0;
	  var l = data.length;
	  var m = l & ~0x3;
	  while (i < m) {
	    for (; i < Math.min(i + 4096, m); i += 4) {
	      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
	    }
	    a %= MOD;
	    b %= MOD;
	  }
	  for (; i < l; i++) {
	    b += a += data.charCodeAt(i);
	  }
	  a %= MOD;
	  b %= MOD;
	  return a | b << 16;
	}
	
	module.exports = adler32;

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactReconciler
	 */
	
	'use strict';
	
	var ReactRef = __webpack_require__(58);
	
	/**
	 * Helper to call ReactRef.attachRefs with this composite component, split out
	 * to avoid allocations in the transaction mount-ready queue.
	 */
	function attachRefs() {
	  ReactRef.attachRefs(this, this._currentElement);
	}
	
	var ReactReconciler = {
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {string} rootID DOM ID of the root node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function mountComponent(internalInstance, rootID, transaction, context) {
	    var markup = internalInstance.mountComponent(rootID, transaction, context);
	    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	    return markup;
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function unmountComponent(internalInstance) {
	    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
	    internalInstance.unmountComponent();
	  },
	
	  /**
	   * Update a component using a new element.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @internal
	   */
	  receiveComponent: function receiveComponent(internalInstance, nextElement, transaction, context) {
	    var prevElement = internalInstance._currentElement;
	
	    if (nextElement === prevElement && context === internalInstance._context) {
	      // Since elements are immutable after the owner is rendered,
	      // we can do a cheap identity compare here to determine if this is a
	      // superfluous reconcile. It's possible for state to be mutable but such
	      // change should trigger an update of the owner which would recreate
	      // the element. We explicitly check for the existence of an owner since
	      // it's possible for an element created outside a composite to be
	      // deeply mutated and reused.
	
	      // TODO: Bailing out early is just a perf optimization right?
	      // TODO: Removing the return statement should affect correctness?
	      return;
	    }
	
	    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);
	
	    if (refsChanged) {
	      ReactRef.detachRefs(internalInstance, prevElement);
	    }
	
	    internalInstance.receiveComponent(nextElement, transaction, context);
	
	    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	  },
	
	  /**
	   * Flush any dirty changes in a component.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function performUpdateIfNecessary(internalInstance, transaction) {
	    internalInstance.performUpdateIfNecessary(transaction);
	  }
	
	};
	
	module.exports = ReactReconciler;

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactRef
	 */
	
	'use strict';
	
	var ReactOwner = __webpack_require__(59);
	
	var ReactRef = {};
	
	function attachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(component.getPublicInstance());
	  } else {
	    // Legacy ref
	    ReactOwner.addComponentAsRefTo(component, ref, owner);
	  }
	}
	
	function detachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(null);
	  } else {
	    // Legacy ref
	    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
	  }
	}
	
	ReactRef.attachRefs = function (instance, element) {
	  if (element === null || element === false) {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    attachRef(ref, instance, element._owner);
	  }
	};
	
	ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
	  // If either the owner or a `ref` has changed, make sure the newest owner
	  // has stored a reference to `this`, and the previous owner (if different)
	  // has forgotten the reference to `this`. We use the element instead
	  // of the public this.props because the post processing cannot determine
	  // a ref. The ref conceptually lives on the element.
	
	  // TODO: Should this even be possible? The owner cannot change because
	  // it's forbidden by shouldUpdateReactComponent. The ref can change
	  // if you swap the keys of but not the refs. Reconsider where this check
	  // is made. It probably belongs where the key checking and
	  // instantiateReactComponent is done.
	
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	
	  return (
	    // This has a few false positives w/r/t empty components.
	    prevEmpty || nextEmpty || nextElement._owner !== prevElement._owner || nextElement.ref !== prevElement.ref
	  );
	};
	
	ReactRef.detachRefs = function (instance, element) {
	  if (element === null || element === false) {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    detachRef(ref, instance, element._owner);
	  }
	};
	
	module.exports = ReactRef;

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactOwner
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(20);
	
	/**
	 * ReactOwners are capable of storing references to owned components.
	 *
	 * All components are capable of //being// referenced by owner components, but
	 * only ReactOwner components are capable of //referencing// owned components.
	 * The named reference is known as a "ref".
	 *
	 * Refs are available when mounted and updated during reconciliation.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return (
	 *         <div onClick={this.handleClick}>
	 *           <CustomComponent ref="custom" />
	 *         </div>
	 *       );
	 *     },
	 *     handleClick: function() {
	 *       this.refs.custom.handleClick();
	 *     },
	 *     componentDidMount: function() {
	 *       this.refs.custom.initialize();
	 *     }
	 *   });
	 *
	 * Refs should rarely be used. When refs are used, they should only be done to
	 * control data that is not handled by React's data flow.
	 *
	 * @class ReactOwner
	 */
	var ReactOwner = {
	
	  /**
	   * @param {?object} object
	   * @return {boolean} True if `object` is a valid owner.
	   * @final
	   */
	  isValidOwner: function isValidOwner(object) {
	    return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
	  },
	
	  /**
	   * Adds a component by ref to an owner component.
	   *
	   * @param {ReactComponent} component Component to reference.
	   * @param {string} ref Name by which to refer to the component.
	   * @param {ReactOwner} owner Component on which to record the ref.
	   * @final
	   * @internal
	   */
	  addComponentAsRefTo: function addComponentAsRefTo(component, ref, owner) {
	    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might ' + 'be adding a ref to a component that was not created inside a component\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : undefined;
	    owner.attachRef(ref, component);
	  },
	
	  /**
	   * Removes a component by ref from an owner component.
	   *
	   * @param {ReactComponent} component Component to dereference.
	   * @param {string} ref Name of the ref to remove.
	   * @param {ReactOwner} owner Component on which the ref is recorded.
	   * @final
	   * @internal
	   */
	  removeComponentAsRefFrom: function removeComponentAsRefFrom(component, ref, owner) {
	    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might ' + 'be removing a ref to a component that was not created inside a component\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : undefined;
	    // Check that `component` is still the current ref because we do not want to
	    // detach the ref if another component stole it.
	    if (owner.getPublicInstance().refs[ref] === component.getPublicInstance()) {
	      owner.detachRef(ref);
	    }
	  }
	
	};
	
	module.exports = ReactOwner;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactUpdateQueue
	 */
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(12);
	var ReactElement = __webpack_require__(49);
	var ReactInstanceMap = __webpack_require__(54);
	var ReactUpdates = __webpack_require__(61);
	
	var assign = __webpack_require__(46);
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	function enqueueUpdate(internalInstance) {
	  ReactUpdates.enqueueUpdate(internalInstance);
	}
	
	function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
	  var internalInstance = ReactInstanceMap.get(publicInstance);
	  if (!internalInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      // Only warn when we have a callerName. Otherwise we should be silent.
	      // We're probably calling from enqueueCallback. We don't want to warn
	      // there because we already warned for the corresponding lifecycle method.
	      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor.displayName) : undefined;
	    }
	    return null;
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition ' + '(such as within `render`). Render methods should be a pure function ' + 'of props and state.', callerName) : undefined;
	  }
	
	  return internalInstance;
	}
	
	/**
	 * ReactUpdateQueue allows for state updates to be scheduled into a later
	 * reconciliation step.
	 */
	var ReactUpdateQueue = {
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function isMounted(publicInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      var owner = ReactCurrentOwner.current;
	      if (owner !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
	        owner._warnedAboutRefsInRender = true;
	      }
	    }
	    var internalInstance = ReactInstanceMap.get(publicInstance);
	    if (internalInstance) {
	      // During componentWillMount and render this will still be null but after
	      // that will always render to something. At least for now. So we can use
	      // this hack.
	      return !!internalInstance._renderedComponent;
	    } else {
	      return false;
	    }
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	  enqueueCallback: function enqueueCallback(publicInstance, callback) {
	    !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);
	
	    // Previously we would throw an error if we didn't have an internal
	    // instance. Since we want to make it a no-op instead, we mirror the same
	    // behavior we have in other enqueue* methods.
	    // We also need to ignore callbacks in componentWillMount. See
	    // enqueueUpdates.
	    if (!internalInstance) {
	      return null;
	    }
	
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    // TODO: The callback here is ignored when setState is called from
	    // componentWillMount. Either fix it or disallow doing so completely in
	    // favor of getInitialState. Alternatively, we can disallow
	    // componentWillMount during server-side rendering.
	    enqueueUpdate(internalInstance);
	  },
	
	  enqueueCallbackInternal: function enqueueCallbackInternal(internalInstance, callback) {
	    !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function enqueueForceUpdate(publicInstance) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingForceUpdate = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingStateQueue = [completeState];
	    internalInstance._pendingReplaceState = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function enqueueSetState(publicInstance, partialState) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
	    queue.push(partialState);
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Sets a subset of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialProps Subset of the next props.
	   * @internal
	   */
	  enqueueSetProps: function enqueueSetProps(publicInstance, partialProps) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setProps');
	    if (!internalInstance) {
	      return;
	    }
	    ReactUpdateQueue.enqueueSetPropsInternal(internalInstance, partialProps);
	  },
	
	  enqueueSetPropsInternal: function enqueueSetPropsInternal(internalInstance, partialProps) {
	    var topLevelWrapper = internalInstance._topLevelWrapper;
	    !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setProps(...): You called `setProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;
	
	    // Merge with the pending element if it exists, otherwise with existing
	    // element props.
	    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;
	    var element = wrapElement.props;
	    var props = assign({}, element.props, partialProps);
	    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));
	
	    enqueueUpdate(topLevelWrapper);
	  },
	
	  /**
	   * Replaces all of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} props New props.
	   * @internal
	   */
	  enqueueReplaceProps: function enqueueReplaceProps(publicInstance, props) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceProps');
	    if (!internalInstance) {
	      return;
	    }
	    ReactUpdateQueue.enqueueReplacePropsInternal(internalInstance, props);
	  },
	
	  enqueueReplacePropsInternal: function enqueueReplacePropsInternal(internalInstance, props) {
	    var topLevelWrapper = internalInstance._topLevelWrapper;
	    !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'replaceProps(...): You called `replaceProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;
	
	    // Merge with the pending element if it exists, otherwise with existing
	    // element props.
	    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;
	    var element = wrapElement.props;
	    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));
	
	    enqueueUpdate(topLevelWrapper);
	  },
	
	  enqueueElementInternal: function enqueueElementInternal(internalInstance, newElement) {
	    internalInstance._pendingElement = newElement;
	    enqueueUpdate(internalInstance);
	  }
	
	};
	
	module.exports = ReactUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactUpdates
	 */
	
	'use strict';
	
	var CallbackQueue = __webpack_require__(62);
	var PooledClass = __webpack_require__(63);
	var ReactPerf = __webpack_require__(25);
	var ReactReconciler = __webpack_require__(57);
	var Transaction = __webpack_require__(64);
	
	var assign = __webpack_require__(46);
	var invariant = __webpack_require__(20);
	
	var dirtyComponents = [];
	var asapCallbackQueue = CallbackQueue.getPooled();
	var asapEnqueued = false;
	
	var batchingStrategy = null;
	
	function ensureInjected() {
	  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching ' + 'strategy') : invariant(false) : undefined;
	}
	
	var NESTED_UPDATES = {
	  initialize: function initialize() {
	    this.dirtyComponentsLength = dirtyComponents.length;
	  },
	  close: function close() {
	    if (this.dirtyComponentsLength !== dirtyComponents.length) {
	      // Additional updates were enqueued by componentDidUpdate handlers or
	      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
	      // these new updates so that if A's componentDidUpdate calls setState on
	      // B, B will update before the callback A's updater provided when calling
	      // setState.
	      dirtyComponents.splice(0, this.dirtyComponentsLength);
	      flushBatchedUpdates();
	    } else {
	      dirtyComponents.length = 0;
	    }
	  }
	};
	
	var UPDATE_QUEUEING = {
	  initialize: function initialize() {
	    this.callbackQueue.reset();
	  },
	  close: function close() {
	    this.callbackQueue.notifyAll();
	  }
	};
	
	var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];
	
	function ReactUpdatesFlushTransaction() {
	  this.reinitializeTransaction();
	  this.dirtyComponentsLength = null;
	  this.callbackQueue = CallbackQueue.getPooled();
	  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled( /* forceHTML */false);
	}
	
	assign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {
	  getTransactionWrappers: function getTransactionWrappers() {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  destructor: function destructor() {
	    this.dirtyComponentsLength = null;
	    CallbackQueue.release(this.callbackQueue);
	    this.callbackQueue = null;
	    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
	    this.reconcileTransaction = null;
	  },
	
	  perform: function perform(method, scope, a) {
	    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
	    // with this transaction's wrappers around it.
	    return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
	  }
	});
	
	PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);
	
	function batchedUpdates(callback, a, b, c, d, e) {
	  ensureInjected();
	  batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
	}
	
	/**
	 * Array comparator for ReactComponents by mount ordering.
	 *
	 * @param {ReactComponent} c1 first component you're comparing
	 * @param {ReactComponent} c2 second component you're comparing
	 * @return {number} Return value usable by Array.prototype.sort().
	 */
	function mountOrderComparator(c1, c2) {
	  return c1._mountOrder - c2._mountOrder;
	}
	
	function runBatchedUpdates(transaction) {
	  var len = transaction.dirtyComponentsLength;
	  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to ' + 'match dirty-components array length (%s).', len, dirtyComponents.length) : invariant(false) : undefined;
	
	  // Since reconciling a component higher in the owner hierarchy usually (not
	  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
	  // them before their children by sorting the array.
	  dirtyComponents.sort(mountOrderComparator);
	
	  for (var i = 0; i < len; i++) {
	    // If a component is unmounted before pending changes apply, it will still
	    // be here, but we assume that it has cleared its _pendingCallbacks and
	    // that performUpdateIfNecessary is a noop.
	    var component = dirtyComponents[i];
	
	    // If performUpdateIfNecessary happens to enqueue any new updates, we
	    // shouldn't execute the callbacks until the next render happens, so
	    // stash the callbacks first
	    var callbacks = component._pendingCallbacks;
	    component._pendingCallbacks = null;
	
	    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction);
	
	    if (callbacks) {
	      for (var j = 0; j < callbacks.length; j++) {
	        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
	      }
	    }
	  }
	}
	
	var flushBatchedUpdates = function flushBatchedUpdates() {
	  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
	  // array and perform any updates enqueued by mount-ready handlers (i.e.,
	  // componentDidUpdate) but we need to check here too in order to catch
	  // updates enqueued by setState callbacks and asap calls.
	  while (dirtyComponents.length || asapEnqueued) {
	    if (dirtyComponents.length) {
	      var transaction = ReactUpdatesFlushTransaction.getPooled();
	      transaction.perform(runBatchedUpdates, null, transaction);
	      ReactUpdatesFlushTransaction.release(transaction);
	    }
	
	    if (asapEnqueued) {
	      asapEnqueued = false;
	      var queue = asapCallbackQueue;
	      asapCallbackQueue = CallbackQueue.getPooled();
	      queue.notifyAll();
	      CallbackQueue.release(queue);
	    }
	  }
	};
	flushBatchedUpdates = ReactPerf.measure('ReactUpdates', 'flushBatchedUpdates', flushBatchedUpdates);
	
	/**
	 * Mark a component as needing a rerender, adding an optional callback to a
	 * list of functions which will be executed once the rerender occurs.
	 */
	function enqueueUpdate(component) {
	  ensureInjected();
	
	  // Various parts of our code (such as ReactCompositeComponent's
	  // _renderValidatedComponent) assume that calls to render aren't nested;
	  // verify that that's the case. (This is called by each top-level update
	  // function, like setProps, setState, forceUpdate, etc.; creation and
	  // destruction of top-level components is guarded in ReactMount.)
	
	  if (!batchingStrategy.isBatchingUpdates) {
	    batchingStrategy.batchedUpdates(enqueueUpdate, component);
	    return;
	  }
	
	  dirtyComponents.push(component);
	}
	
	/**
	 * Enqueue a callback to be run at the end of the current batching cycle. Throws
	 * if no updates are currently being performed.
	 */
	function asap(callback, context) {
	  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context where' + 'updates are not being batched.') : invariant(false) : undefined;
	  asapCallbackQueue.enqueue(callback, context);
	  asapEnqueued = true;
	}
	
	var ReactUpdatesInjection = {
	  injectReconcileTransaction: function injectReconcileTransaction(ReconcileTransaction) {
	    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : invariant(false) : undefined;
	    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
	  },
	
	  injectBatchingStrategy: function injectBatchingStrategy(_batchingStrategy) {
	    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : invariant(false) : undefined;
	    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : invariant(false) : undefined;
	    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : invariant(false) : undefined;
	    batchingStrategy = _batchingStrategy;
	  }
	};
	
	var ReactUpdates = {
	  /**
	   * React references `ReactReconcileTransaction` using this property in order
	   * to allow dependency injection.
	   *
	   * @internal
	   */
	  ReactReconcileTransaction: null,
	
	  batchedUpdates: batchedUpdates,
	  enqueueUpdate: enqueueUpdate,
	  flushBatchedUpdates: flushBatchedUpdates,
	  injection: ReactUpdatesInjection,
	  asap: asap
	};
	
	module.exports = ReactUpdates;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CallbackQueue
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(63);
	
	var assign = __webpack_require__(46);
	var invariant = __webpack_require__(20);
	
	/**
	 * A specialized pseudo-event module to help keep track of components waiting to
	 * be notified when their DOM representations are available for use.
	 *
	 * This implements `PooledClass`, so you should never need to instantiate this.
	 * Instead, use `CallbackQueue.getPooled()`.
	 *
	 * @class ReactMountReady
	 * @implements PooledClass
	 * @internal
	 */
	function CallbackQueue() {
	  this._callbacks = null;
	  this._contexts = null;
	}
	
	assign(CallbackQueue.prototype, {
	
	  /**
	   * Enqueues a callback to be invoked when `notifyAll` is invoked.
	   *
	   * @param {function} callback Invoked when `notifyAll` is invoked.
	   * @param {?object} context Context to call `callback` with.
	   * @internal
	   */
	  enqueue: function enqueue(callback, context) {
	    this._callbacks = this._callbacks || [];
	    this._contexts = this._contexts || [];
	    this._callbacks.push(callback);
	    this._contexts.push(context);
	  },
	
	  /**
	   * Invokes all enqueued callbacks and clears the queue. This is invoked after
	   * the DOM representation of a component has been created or updated.
	   *
	   * @internal
	   */
	  notifyAll: function notifyAll() {
	    var callbacks = this._callbacks;
	    var contexts = this._contexts;
	    if (callbacks) {
	      !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : invariant(false) : undefined;
	      this._callbacks = null;
	      this._contexts = null;
	      for (var i = 0; i < callbacks.length; i++) {
	        callbacks[i].call(contexts[i]);
	      }
	      callbacks.length = 0;
	      contexts.length = 0;
	    }
	  },
	
	  /**
	   * Resets the internal queue.
	   *
	   * @internal
	   */
	  reset: function reset() {
	    this._callbacks = null;
	    this._contexts = null;
	  },
	
	  /**
	   * `PooledClass` looks for this.
	   */
	  destructor: function destructor() {
	    this.reset();
	  }
	
	});
	
	PooledClass.addPoolingTo(CallbackQueue);
	
	module.exports = CallbackQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule PooledClass
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(20);
	
	/**
	 * Static poolers. Several custom versions for each potential number of
	 * arguments. A completely generic pooler is easy to implement, but would
	 * require accessing the `arguments` object. In each of these, `this` refers to
	 * the Class itself, not an instance. If any others are needed, simply add them
	 * here, or in their own files.
	 */
	var oneArgumentPooler = function oneArgumentPooler(copyFieldsFrom) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, copyFieldsFrom);
	    return instance;
	  } else {
	    return new Klass(copyFieldsFrom);
	  }
	};
	
	var twoArgumentPooler = function twoArgumentPooler(a1, a2) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2);
	    return instance;
	  } else {
	    return new Klass(a1, a2);
	  }
	};
	
	var threeArgumentPooler = function threeArgumentPooler(a1, a2, a3) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3);
	  }
	};
	
	var fourArgumentPooler = function fourArgumentPooler(a1, a2, a3, a4) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4);
	  }
	};
	
	var fiveArgumentPooler = function fiveArgumentPooler(a1, a2, a3, a4, a5) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4, a5);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4, a5);
	  }
	};
	
	var standardReleaser = function standardReleaser(instance) {
	  var Klass = this;
	  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : invariant(false) : undefined;
	  instance.destructor();
	  if (Klass.instancePool.length < Klass.poolSize) {
	    Klass.instancePool.push(instance);
	  }
	};
	
	var DEFAULT_POOL_SIZE = 10;
	var DEFAULT_POOLER = oneArgumentPooler;
	
	/**
	 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
	 * itself (statically) not adding any prototypical fields. Any CopyConstructor
	 * you give this may have a `poolSize` property, and will look for a
	 * prototypical `destructor` on instances (optional).
	 *
	 * @param {Function} CopyConstructor Constructor that can be used to reset.
	 * @param {Function} pooler Customizable pooler.
	 */
	var addPoolingTo = function addPoolingTo(CopyConstructor, pooler) {
	  var NewKlass = CopyConstructor;
	  NewKlass.instancePool = [];
	  NewKlass.getPooled = pooler || DEFAULT_POOLER;
	  if (!NewKlass.poolSize) {
	    NewKlass.poolSize = DEFAULT_POOL_SIZE;
	  }
	  NewKlass.release = standardReleaser;
	  return NewKlass;
	};
	
	var PooledClass = {
	  addPoolingTo: addPoolingTo,
	  oneArgumentPooler: oneArgumentPooler,
	  twoArgumentPooler: twoArgumentPooler,
	  threeArgumentPooler: threeArgumentPooler,
	  fourArgumentPooler: fourArgumentPooler,
	  fiveArgumentPooler: fiveArgumentPooler
	};
	
	module.exports = PooledClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Transaction
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(20);
	
	/**
	 * `Transaction` creates a black box that is able to wrap any method such that
	 * certain invariants are maintained before and after the method is invoked
	 * (Even if an exception is thrown while invoking the wrapped method). Whoever
	 * instantiates a transaction can provide enforcers of the invariants at
	 * creation time. The `Transaction` class itself will supply one additional
	 * automatic invariant for you - the invariant that any transaction instance
	 * should not be run while it is already being run. You would typically create a
	 * single instance of a `Transaction` for reuse multiple times, that potentially
	 * is used to wrap several different methods. Wrappers are extremely simple -
	 * they only require implementing two methods.
	 *
	 * <pre>
	 *                       wrappers (injected at creation time)
	 *                                      +        +
	 *                                      |        |
	 *                    +-----------------|--------|--------------+
	 *                    |                 v        |              |
	 *                    |      +---------------+   |              |
	 *                    |   +--|    wrapper1   |---|----+         |
	 *                    |   |  +---------------+   v    |         |
	 *                    |   |          +-------------+  |         |
	 *                    |   |     +----|   wrapper2  |--------+   |
	 *                    |   |     |    +-------------+  |     |   |
	 *                    |   |     |                     |     |   |
	 *                    |   v     v                     v     v   | wrapper
	 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
	 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
	 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | +---+ +---+   +---------+   +---+ +---+ |
	 *                    |  initialize                    close    |
	 *                    +-----------------------------------------+
	 * </pre>
	 *
	 * Use cases:
	 * - Preserving the input selection ranges before/after reconciliation.
	 *   Restoring selection even in the event of an unexpected error.
	 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
	 *   while guaranteeing that afterwards, the event system is reactivated.
	 * - Flushing a queue of collected DOM mutations to the main UI thread after a
	 *   reconciliation takes place in a worker thread.
	 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
	 *   content.
	 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
	 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
	 * - (Future use case): Layout calculations before and after DOM updates.
	 *
	 * Transactional plugin API:
	 * - A module that has an `initialize` method that returns any precomputation.
	 * - and a `close` method that accepts the precomputation. `close` is invoked
	 *   when the wrapped process is completed, or has failed.
	 *
	 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
	 * that implement `initialize` and `close`.
	 * @return {Transaction} Single transaction for reuse in thread.
	 *
	 * @class Transaction
	 */
	var Mixin = {
	  /**
	   * Sets up this instance so that it is prepared for collecting metrics. Does
	   * so such that this setup method may be used on an instance that is already
	   * initialized, in a way that does not consume additional memory upon reuse.
	   * That can be useful if you decide to make your subclass of this mixin a
	   * "PooledClass".
	   */
	  reinitializeTransaction: function reinitializeTransaction() {
	    this.transactionWrappers = this.getTransactionWrappers();
	    if (this.wrapperInitData) {
	      this.wrapperInitData.length = 0;
	    } else {
	      this.wrapperInitData = [];
	    }
	    this._isInTransaction = false;
	  },
	
	  _isInTransaction: false,
	
	  /**
	   * @abstract
	   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
	   */
	  getTransactionWrappers: null,
	
	  isInTransaction: function isInTransaction() {
	    return !!this._isInTransaction;
	  },
	
	  /**
	   * Executes the function within a safety window. Use this for the top level
	   * methods that result in large amounts of computation/mutations that would
	   * need to be safety checked. The optional arguments helps prevent the need
	   * to bind in many cases.
	   *
	   * @param {function} method Member of scope to call.
	   * @param {Object} scope Scope to invoke from.
	   * @param {Object?=} a Argument to pass to the method.
	   * @param {Object?=} b Argument to pass to the method.
	   * @param {Object?=} c Argument to pass to the method.
	   * @param {Object?=} d Argument to pass to the method.
	   * @param {Object?=} e Argument to pass to the method.
	   * @param {Object?=} f Argument to pass to the method.
	   *
	   * @return {*} Return value from `method`.
	   */
	  perform: function perform(method, scope, a, b, c, d, e, f) {
	    !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there ' + 'is already an outstanding transaction.') : invariant(false) : undefined;
	    var errorThrown;
	    var ret;
	    try {
	      this._isInTransaction = true;
	      // Catching errors makes debugging more difficult, so we start with
	      // errorThrown set to true before setting it to false after calling
	      // close -- if it's still set to true in the finally block, it means
	      // one of these calls threw.
	      errorThrown = true;
	      this.initializeAll(0);
	      ret = method.call(scope, a, b, c, d, e, f);
	      errorThrown = false;
	    } finally {
	      try {
	        if (errorThrown) {
	          // If `method` throws, prefer to show that stack trace over any thrown
	          // by invoking `closeAll`.
	          try {
	            this.closeAll(0);
	          } catch (err) {}
	        } else {
	          // Since `method` didn't throw, we don't want to silence the exception
	          // here.
	          this.closeAll(0);
	        }
	      } finally {
	        this._isInTransaction = false;
	      }
	    }
	    return ret;
	  },
	
	  initializeAll: function initializeAll(startIndex) {
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      try {
	        // Catching errors makes debugging more difficult, so we start with the
	        // OBSERVED_ERROR state before overwriting it with the real return value
	        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
	        // block, it means wrapper.initialize threw.
	        this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
	        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
	      } finally {
	        if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
	          // The initializer for wrapper i threw an error; initialize the
	          // remaining wrappers but silence any exceptions from them to ensure
	          // that the first error is the one to bubble up.
	          try {
	            this.initializeAll(i + 1);
	          } catch (err) {}
	        }
	      }
	    }
	  },
	
	  /**
	   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
	   * them the respective return values of `this.transactionWrappers.init[i]`
	   * (`close`rs that correspond to initializers that failed will not be
	   * invoked).
	   */
	  closeAll: function closeAll(startIndex) {
	    !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : invariant(false) : undefined;
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      var initData = this.wrapperInitData[i];
	      var errorThrown;
	      try {
	        // Catching errors makes debugging more difficult, so we start with
	        // errorThrown set to true before setting it to false after calling
	        // close -- if it's still set to true in the finally block, it means
	        // wrapper.close threw.
	        errorThrown = true;
	        if (initData !== Transaction.OBSERVED_ERROR && wrapper.close) {
	          wrapper.close.call(this, initData);
	        }
	        errorThrown = false;
	      } finally {
	        if (errorThrown) {
	          // The closer for wrapper i threw an error; close the remaining
	          // wrappers but silence any exceptions from them to ensure that the
	          // first error is the one to bubble up.
	          try {
	            this.closeAll(i + 1);
	          } catch (e) {}
	        }
	      }
	    }
	    this.wrapperInitData.length = 0;
	  }
	};
	
	var Transaction = {
	
	  Mixin: Mixin,
	
	  /**
	   * Token to look for to determine if an error occurred.
	   */
	  OBSERVED_ERROR: {}
	
	};
	
	module.exports = Transaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule emptyObject
	 */
	
	'use strict';
	
	var emptyObject = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  Object.freeze(emptyObject);
	}
	
	module.exports = emptyObject;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule containsNode
	 * @typechecks
	 */
	
	'use strict';
	
	var isTextNode = __webpack_require__(67);
	
	/*eslint-disable no-bitwise */
	
	/**
	 * Checks if a given DOM node contains or is another DOM node.
	 *
	 * @param {?DOMNode} outerNode Outer DOM node.
	 * @param {?DOMNode} innerNode Inner DOM node.
	 * @return {boolean} True if `outerNode` contains or is `innerNode`.
	 */
	function containsNode(_x, _x2) {
	  var _again = true;
	
	  _function: while (_again) {
	    var outerNode = _x,
	        innerNode = _x2;
	    _again = false;
	
	    if (!outerNode || !innerNode) {
	      return false;
	    } else if (outerNode === innerNode) {
	      return true;
	    } else if (isTextNode(outerNode)) {
	      return false;
	    } else if (isTextNode(innerNode)) {
	      _x = outerNode;
	      _x2 = innerNode.parentNode;
	      _again = true;
	      continue _function;
	    } else if (outerNode.contains) {
	      return outerNode.contains(innerNode);
	    } else if (outerNode.compareDocumentPosition) {
	      return !!(outerNode.compareDocumentPosition(innerNode) & 16);
	    } else {
	      return false;
	    }
	  }
	}
	
	module.exports = containsNode;

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isTextNode
	 * @typechecks
	 */
	
	'use strict';
	
	var isNode = __webpack_require__(68);
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM text node.
	 */
	function isTextNode(object) {
	  return isNode(object) && object.nodeType == 3;
	}
	
	module.exports = isTextNode;

/***/ },
/* 68 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isNode
	 * @typechecks
	 */
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM node.
	 */
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	function isNode(object) {
	  return !!(object && (typeof Node === 'function' ? object instanceof Node : (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
	}
	
	module.exports = isNode;

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule instantiateReactComponent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactCompositeComponent = __webpack_require__(70);
	var ReactEmptyComponent = __webpack_require__(75);
	var ReactNativeComponent = __webpack_require__(76);
	
	var assign = __webpack_require__(46);
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	// To avoid a cyclic dependency, we create the final class in this module
	var ReactCompositeComponentWrapper = function ReactCompositeComponentWrapper() {};
	assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent.Mixin, {
	  _instantiateReactComponent: instantiateReactComponent
	});
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Check if the type reference is a known internal type. I.e. not a user
	 * provided composite type.
	 *
	 * @param {function} type
	 * @return {boolean} Returns true if this is a valid internal type.
	 */
	function isInternalComponentType(type) {
	  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
	}
	
	/**
	 * Given a ReactNode, create an instance that will actually be mounted.
	 *
	 * @param {ReactNode} node
	 * @return {object} A new instance of the element's constructor.
	 * @protected
	 */
	function instantiateReactComponent(node) {
	  var instance;
	
	  if (node === null || node === false) {
	    instance = new ReactEmptyComponent(instantiateReactComponent);
	  } else if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) === 'object') {
	    var element = node;
	    !(element && (typeof element.type === 'function' || typeof element.type === 'string')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) ' + 'or a class/function (for composite components) but got: %s.%s', element.type == null ? element.type : _typeof(element.type), getDeclarationErrorAddendum(element._owner)) : invariant(false) : undefined;
	
	    // Special case string values
	    if (typeof element.type === 'string') {
	      instance = ReactNativeComponent.createInternalComponent(element);
	    } else if (isInternalComponentType(element.type)) {
	      // This is temporarily available for custom components that are not string
	      // representations. I.e. ART. Once those are updated to use the string
	      // representation, we can drop this code path.
	      instance = new element.type(element);
	    } else {
	      instance = new ReactCompositeComponentWrapper();
	    }
	  } else if (typeof node === 'string' || typeof node === 'number') {
	    instance = ReactNativeComponent.createInstanceForText(node);
	  } else {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node === 'undefined' ? 'undefined' : _typeof(node)) : invariant(false) : undefined;
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(typeof instance.construct === 'function' && typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : undefined;
	  }
	
	  // Sets up the instance. This can probably just move into the constructor now.
	  instance.construct(node);
	
	  // These two fields are used by the DOM and ART diffing algorithms
	  // respectively. Instead of using expandos on components, we should be
	  // storing the state needed by the diffing algorithms elsewhere.
	  instance._mountIndex = 0;
	  instance._mountImage = null;
	
	  if (process.env.NODE_ENV !== 'production') {
	    instance._isOwnerNecessary = false;
	    instance._warnedAboutRefsInRender = false;
	  }
	
	  // Internal instances should fully constructed at this point, so they should
	  // not get any new fields added to them at this point.
	  if (process.env.NODE_ENV !== 'production') {
	    if (Object.preventExtensions) {
	      Object.preventExtensions(instance);
	    }
	  }
	
	  return instance;
	}
	
	module.exports = instantiateReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactCompositeComponent
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactComponentEnvironment = __webpack_require__(71);
	var ReactCurrentOwner = __webpack_require__(12);
	var ReactElement = __webpack_require__(49);
	var ReactInstanceMap = __webpack_require__(54);
	var ReactPerf = __webpack_require__(25);
	var ReactPropTypeLocations = __webpack_require__(72);
	var ReactPropTypeLocationNames = __webpack_require__(73);
	var ReactReconciler = __webpack_require__(57);
	var ReactUpdateQueue = __webpack_require__(60);
	
	var assign = __webpack_require__(46);
	var emptyObject = __webpack_require__(65);
	var invariant = __webpack_require__(20);
	var shouldUpdateReactComponent = __webpack_require__(74);
	var warning = __webpack_require__(32);
	
	function getDeclarationErrorAddendum(component) {
	  var owner = component._currentElement._owner || null;
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	function StatelessComponent(Component) {}
	StatelessComponent.prototype.render = function () {
	  var Component = ReactInstanceMap.get(this)._currentElement.type;
	  return Component(this.props, this.context, this.updater);
	};
	
	/**
	 * ------------------ The Life-Cycle of a Composite Component ------------------
	 *
	 * - constructor: Initialization of state. The instance is now retained.
	 *   - componentWillMount
	 *   - render
	 *   - [children's constructors]
	 *     - [children's componentWillMount and render]
	 *     - [children's componentDidMount]
	 *     - componentDidMount
	 *
	 *       Update Phases:
	 *       - componentWillReceiveProps (only called if parent updated)
	 *       - shouldComponentUpdate
	 *         - componentWillUpdate
	 *           - render
	 *           - [children's constructors or receive props phases]
	 *         - componentDidUpdate
	 *
	 *     - componentWillUnmount
	 *     - [children's componentWillUnmount]
	 *   - [children destroyed]
	 * - (destroyed): The instance is now blank, released by React and ready for GC.
	 *
	 * -----------------------------------------------------------------------------
	 */
	
	/**
	 * An incrementing ID assigned to each component when it is mounted. This is
	 * used to enforce the order in which `ReactUpdates` updates dirty components.
	 *
	 * @private
	 */
	var nextMountID = 1;
	
	/**
	 * @lends {ReactCompositeComponent.prototype}
	 */
	var ReactCompositeComponentMixin = {
	
	  /**
	   * Base constructor for all composite component.
	   *
	   * @param {ReactElement} element
	   * @final
	   * @internal
	   */
	  construct: function construct(element) {
	    this._currentElement = element;
	    this._rootNodeID = null;
	    this._instance = null;
	
	    // See ReactUpdateQueue
	    this._pendingElement = null;
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    this._renderedComponent = null;
	
	    this._context = null;
	    this._mountOrder = 0;
	    this._topLevelWrapper = null;
	
	    // See ReactUpdates and ReactUpdateQueue.
	    this._pendingCallbacks = null;
	  },
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {string} rootID DOM ID of the root node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function mountComponent(rootID, transaction, context) {
	    this._context = context;
	    this._mountOrder = nextMountID++;
	    this._rootNodeID = rootID;
	
	    var publicProps = this._processProps(this._currentElement.props);
	    var publicContext = this._processContext(context);
	
	    var Component = this._currentElement.type;
	
	    // Initialize the public class
	    var inst;
	    var renderedElement;
	
	    // This is a way to detect if Component is a stateless arrow function
	    // component, which is not newable. It might not be 100% reliable but is
	    // something we can do until we start detecting that Component extends
	    // React.Component. We already assume that typeof Component === 'function'.
	    var canInstantiate = 'prototype' in Component;
	
	    if (canInstantiate) {
	      if (process.env.NODE_ENV !== 'production') {
	        ReactCurrentOwner.current = this;
	        try {
	          inst = new Component(publicProps, publicContext, ReactUpdateQueue);
	        } finally {
	          ReactCurrentOwner.current = null;
	        }
	      } else {
	        inst = new Component(publicProps, publicContext, ReactUpdateQueue);
	      }
	    }
	
	    if (!canInstantiate || inst === null || inst === false || ReactElement.isValidElement(inst)) {
	      renderedElement = inst;
	      inst = new StatelessComponent(Component);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This will throw later in _renderValidatedComponent, but add an early
	      // warning now to help debugging
	      if (inst.render == null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`, returned ' + 'null/false from a stateless component, or tried to render an ' + 'element whose type is a function that isn\'t a React component.', Component.displayName || Component.name || 'Component') : undefined;
	      } else {
	        // We support ES6 inheriting from React.Component, the module pattern,
	        // and stateless components, but not ES6 classes that don't extend
	        process.env.NODE_ENV !== 'production' ? warning(Component.prototype && Component.prototype.isReactComponent || !canInstantiate || !(inst instanceof Component), '%s(...): React component classes must extend React.Component.', Component.displayName || Component.name || 'Component') : undefined;
	      }
	    }
	
	    // These should be set up in the constructor, but as a convenience for
	    // simpler class abstractions, we set them up after the fact.
	    inst.props = publicProps;
	    inst.context = publicContext;
	    inst.refs = emptyObject;
	    inst.updater = ReactUpdateQueue;
	
	    this._instance = inst;
	
	    // Store a reference from the instance back to the internal representation
	    ReactInstanceMap.set(inst, this);
	
	    if (process.env.NODE_ENV !== 'production') {
	      // Since plain JS classes are defined without any special initialization
	      // logic, we can not catch common errors early. Therefore, we have to
	      // catch them here, at initialization time, instead.
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : undefined;
	    }
	
	    var initialState = inst.state;
	    if (initialState === undefined) {
	      inst.state = initialState = null;
	    }
	    !((typeof initialState === 'undefined' ? 'undefined' : _typeof(initialState)) === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
	
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    if (inst.componentWillMount) {
	      inst.componentWillMount();
	      // When mounting, calls to `setState` by `componentWillMount` will set
	      // `this._pendingStateQueue` without triggering a re-render.
	      if (this._pendingStateQueue) {
	        inst.state = this._processPendingState(inst.props, inst.context);
	      }
	    }
	
	    // If not a stateless component, we now render
	    if (renderedElement === undefined) {
	      renderedElement = this._renderValidatedComponent();
	    }
	
	    this._renderedComponent = this._instantiateReactComponent(renderedElement);
	
	    var markup = ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, this._processChildContext(context));
	    if (inst.componentDidMount) {
	      transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
	    }
	
	    return markup;
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function unmountComponent() {
	    var inst = this._instance;
	
	    if (inst.componentWillUnmount) {
	      inst.componentWillUnmount();
	    }
	
	    ReactReconciler.unmountComponent(this._renderedComponent);
	    this._renderedComponent = null;
	    this._instance = null;
	
	    // Reset pending fields
	    // Even if this component is scheduled for another update in ReactUpdates,
	    // it would still be ignored because these fields are reset.
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	    this._pendingCallbacks = null;
	    this._pendingElement = null;
	
	    // These fields do not really need to be reset since this object is no
	    // longer accessible.
	    this._context = null;
	    this._rootNodeID = null;
	    this._topLevelWrapper = null;
	
	    // Delete the reference from the instance to this internal representation
	    // which allow the internals to be properly cleaned up even if the user
	    // leaks a reference to the public instance.
	    ReactInstanceMap.remove(inst);
	
	    // Some existing components rely on inst.props even after they've been
	    // destroyed (in event handlers).
	    // TODO: inst.props = null;
	    // TODO: inst.state = null;
	    // TODO: inst.context = null;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _maskContext: function _maskContext(context) {
	    var maskedContext = null;
	    var Component = this._currentElement.type;
	    var contextTypes = Component.contextTypes;
	    if (!contextTypes) {
	      return emptyObject;
	    }
	    maskedContext = {};
	    for (var contextName in contextTypes) {
	      maskedContext[contextName] = context[contextName];
	    }
	    return maskedContext;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`, and asserts that they are valid.
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _processContext: function _processContext(context) {
	    var maskedContext = this._maskContext(context);
	    if (process.env.NODE_ENV !== 'production') {
	      var Component = this._currentElement.type;
	      if (Component.contextTypes) {
	        this._checkPropTypes(Component.contextTypes, maskedContext, ReactPropTypeLocations.context);
	      }
	    }
	    return maskedContext;
	  },
	
	  /**
	   * @param {object} currentContext
	   * @return {object}
	   * @private
	   */
	  _processChildContext: function _processChildContext(currentContext) {
	    var Component = this._currentElement.type;
	    var inst = this._instance;
	    var childContext = inst.getChildContext && inst.getChildContext();
	    if (childContext) {
	      !(_typeof(Component.childContextTypes) === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
	      if (process.env.NODE_ENV !== 'production') {
	        this._checkPropTypes(Component.childContextTypes, childContext, ReactPropTypeLocations.childContext);
	      }
	      for (var name in childContext) {
	        !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : invariant(false) : undefined;
	      }
	      return assign({}, currentContext, childContext);
	    }
	    return currentContext;
	  },
	
	  /**
	   * Processes props by setting default values for unspecified props and
	   * asserting that the props are valid. Does not mutate its argument; returns
	   * a new props object with defaults merged in.
	   *
	   * @param {object} newProps
	   * @return {object}
	   * @private
	   */
	  _processProps: function _processProps(newProps) {
	    if (process.env.NODE_ENV !== 'production') {
	      var Component = this._currentElement.type;
	      if (Component.propTypes) {
	        this._checkPropTypes(Component.propTypes, newProps, ReactPropTypeLocations.prop);
	      }
	    }
	    return newProps;
	  },
	
	  /**
	   * Assert that the props are valid
	   *
	   * @param {object} propTypes Map of prop name to a ReactPropType
	   * @param {object} props
	   * @param {string} location e.g. "prop", "context", "child context"
	   * @private
	   */
	  _checkPropTypes: function _checkPropTypes(propTypes, props, location) {
	    // TODO: Stop validating prop types here and only use the element
	    // validation.
	    var componentName = this.getName();
	    for (var propName in propTypes) {
	      if (propTypes.hasOwnProperty(propName)) {
	        var error;
	        try {
	          // This is intentionally an invariant that gets caught. It's the same
	          // behavior as without this statement except with a better message.
	          !(typeof propTypes[propName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually ' + 'from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
	          error = propTypes[propName](props, propName, componentName, location);
	        } catch (ex) {
	          error = ex;
	        }
	        if (error instanceof Error) {
	          // We may want to extend this logic for similar errors in
	          // top-level render calls, so I'm abstracting it away into
	          // a function to minimize refactoring in the future
	          var addendum = getDeclarationErrorAddendum(this);
	
	          if (location === ReactPropTypeLocations.prop) {
	            // Preface gives us something to blacklist in warning module
	            process.env.NODE_ENV !== 'production' ? warning(false, 'Failed Composite propType: %s%s', error.message, addendum) : undefined;
	          } else {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'Failed Context Types: %s%s', error.message, addendum) : undefined;
	          }
	        }
	      }
	    }
	  },
	
	  receiveComponent: function receiveComponent(nextElement, transaction, nextContext) {
	    var prevElement = this._currentElement;
	    var prevContext = this._context;
	
	    this._pendingElement = null;
	
	    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
	  },
	
	  /**
	   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
	   * is set, update the component.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function performUpdateIfNecessary(transaction) {
	    if (this._pendingElement != null) {
	      ReactReconciler.receiveComponent(this, this._pendingElement || this._currentElement, transaction, this._context);
	    }
	
	    if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
	      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
	    }
	  },
	
	  /**
	   * Perform an update to a mounted component. The componentWillReceiveProps and
	   * shouldComponentUpdate methods are called, then (assuming the update isn't
	   * skipped) the remaining update lifecycle methods are called and the DOM
	   * representation is updated.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevParentElement
	   * @param {ReactElement} nextParentElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function updateComponent(transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
	    var inst = this._instance;
	
	    var nextContext = this._context === nextUnmaskedContext ? inst.context : this._processContext(nextUnmaskedContext);
	    var nextProps;
	
	    // Distinguish between a props update versus a simple state update
	    if (prevParentElement === nextParentElement) {
	      // Skip checking prop types again -- we don't read inst.props to avoid
	      // warning for DOM component props in this upgrade
	      nextProps = nextParentElement.props;
	    } else {
	      nextProps = this._processProps(nextParentElement.props);
	      // An update here will schedule an update but immediately set
	      // _pendingStateQueue which will ensure that any state updates gets
	      // immediately reconciled instead of waiting for the next batch.
	
	      if (inst.componentWillReceiveProps) {
	        inst.componentWillReceiveProps(nextProps, nextContext);
	      }
	    }
	
	    var nextState = this._processPendingState(nextProps, nextContext);
	
	    var shouldUpdate = this._pendingForceUpdate || !inst.shouldComponentUpdate || inst.shouldComponentUpdate(nextProps, nextState, nextContext);
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(typeof shouldUpdate !== 'undefined', '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : undefined;
	    }
	
	    if (shouldUpdate) {
	      this._pendingForceUpdate = false;
	      // Will set `this.props`, `this.state` and `this.context`.
	      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
	    } else {
	      // If it's determined that a component should not update, we still want
	      // to set props and state but we shortcut the rest of the update.
	      this._currentElement = nextParentElement;
	      this._context = nextUnmaskedContext;
	      inst.props = nextProps;
	      inst.state = nextState;
	      inst.context = nextContext;
	    }
	  },
	
	  _processPendingState: function _processPendingState(props, context) {
	    var inst = this._instance;
	    var queue = this._pendingStateQueue;
	    var replace = this._pendingReplaceState;
	    this._pendingReplaceState = false;
	    this._pendingStateQueue = null;
	
	    if (!queue) {
	      return inst.state;
	    }
	
	    if (replace && queue.length === 1) {
	      return queue[0];
	    }
	
	    var nextState = assign({}, replace ? queue[0] : inst.state);
	    for (var i = replace ? 1 : 0; i < queue.length; i++) {
	      var partial = queue[i];
	      assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
	    }
	
	    return nextState;
	  },
	
	  /**
	   * Merges new props and state, notifies delegate methods of update and
	   * performs update.
	   *
	   * @param {ReactElement} nextElement Next element
	   * @param {object} nextProps Next public object to set as properties.
	   * @param {?object} nextState Next object to set as state.
	   * @param {?object} nextContext Next public object to set as context.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {?object} unmaskedContext
	   * @private
	   */
	  _performComponentUpdate: function _performComponentUpdate(nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
	    var inst = this._instance;
	
	    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
	    var prevProps;
	    var prevState;
	    var prevContext;
	    if (hasComponentDidUpdate) {
	      prevProps = inst.props;
	      prevState = inst.state;
	      prevContext = inst.context;
	    }
	
	    if (inst.componentWillUpdate) {
	      inst.componentWillUpdate(nextProps, nextState, nextContext);
	    }
	
	    this._currentElement = nextElement;
	    this._context = unmaskedContext;
	    inst.props = nextProps;
	    inst.state = nextState;
	    inst.context = nextContext;
	
	    this._updateRenderedComponent(transaction, unmaskedContext);
	
	    if (hasComponentDidUpdate) {
	      transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
	    }
	  },
	
	  /**
	   * Call the component's `render` method and update the DOM accordingly.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  _updateRenderedComponent: function _updateRenderedComponent(transaction, context) {
	    var prevComponentInstance = this._renderedComponent;
	    var prevRenderedElement = prevComponentInstance._currentElement;
	    var nextRenderedElement = this._renderValidatedComponent();
	    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
	      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
	    } else {
	      // These two IDs are actually the same! But nothing should rely on that.
	      var thisID = this._rootNodeID;
	      var prevComponentID = prevComponentInstance._rootNodeID;
	      ReactReconciler.unmountComponent(prevComponentInstance);
	
	      this._renderedComponent = this._instantiateReactComponent(nextRenderedElement);
	      var nextMarkup = ReactReconciler.mountComponent(this._renderedComponent, thisID, transaction, this._processChildContext(context));
	      this._replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
	    }
	  },
	
	  /**
	   * @protected
	   */
	  _replaceNodeWithMarkupByID: function _replaceNodeWithMarkupByID(prevComponentID, nextMarkup) {
	    ReactComponentEnvironment.replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
	  },
	
	  /**
	   * @protected
	   */
	  _renderValidatedComponentWithoutOwnerOrContext: function _renderValidatedComponentWithoutOwnerOrContext() {
	    var inst = this._instance;
	    var renderedComponent = inst.render();
	    if (process.env.NODE_ENV !== 'production') {
	      // We allow auto-mocks to proceed as if they're returning null.
	      if (typeof renderedComponent === 'undefined' && inst.render._isMockFunction) {
	        // This is probably bad practice. Consider warning here and
	        // deprecating this convenience.
	        renderedComponent = null;
	      }
	    }
	
	    return renderedComponent;
	  },
	
	  /**
	   * @private
	   */
	  _renderValidatedComponent: function _renderValidatedComponent() {
	    var renderedComponent;
	    ReactCurrentOwner.current = this;
	    try {
	      renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();
	    } finally {
	      ReactCurrentOwner.current = null;
	    }
	    !(
	    // TODO: An `isValidNode` function would probably be more appropriate
	    renderedComponent === null || renderedComponent === false || ReactElement.isValidElement(renderedComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid ReactComponent must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
	    return renderedComponent;
	  },
	
	  /**
	   * Lazily allocates the refs object and stores `component` as `ref`.
	   *
	   * @param {string} ref Reference name.
	   * @param {component} component Component to store as `ref`.
	   * @final
	   * @private
	   */
	  attachRef: function attachRef(ref, component) {
	    var inst = this.getPublicInstance();
	    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : invariant(false) : undefined;
	    var publicComponentInstance = component.getPublicInstance();
	    if (process.env.NODE_ENV !== 'production') {
	      var componentName = component && component.getName ? component.getName() : 'a component';
	      process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : undefined;
	    }
	    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
	    refs[ref] = publicComponentInstance;
	  },
	
	  /**
	   * Detaches a reference name.
	   *
	   * @param {string} ref Name to dereference.
	   * @final
	   * @private
	   */
	  detachRef: function detachRef(ref) {
	    var refs = this.getPublicInstance().refs;
	    delete refs[ref];
	  },
	
	  /**
	   * Get a text description of the component that can be used to identify it
	   * in error messages.
	   * @return {string} The name or null.
	   * @internal
	   */
	  getName: function getName() {
	    var type = this._currentElement.type;
	    var constructor = this._instance && this._instance.constructor;
	    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
	  },
	
	  /**
	   * Get the publicly accessible representation of this component - i.e. what
	   * is exposed by refs and returned by render. Can be null for stateless
	   * components.
	   *
	   * @return {ReactComponent} the public component instance.
	   * @internal
	   */
	  getPublicInstance: function getPublicInstance() {
	    var inst = this._instance;
	    if (inst instanceof StatelessComponent) {
	      return null;
	    }
	    return inst;
	  },
	
	  // Stub
	  _instantiateReactComponent: null
	
	};
	
	ReactPerf.measureMethods(ReactCompositeComponentMixin, 'ReactCompositeComponent', {
	  mountComponent: 'mountComponent',
	  updateComponent: 'updateComponent',
	  _renderValidatedComponent: '_renderValidatedComponent'
	});
	
	var ReactCompositeComponent = {
	
	  Mixin: ReactCompositeComponentMixin
	
	};
	
	module.exports = ReactCompositeComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentEnvironment
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(20);
	
	var injected = false;
	
	var ReactComponentEnvironment = {
	
	  /**
	   * Optionally injectable environment dependent cleanup hook. (server vs.
	   * browser etc). Example: A browser system caches DOM nodes based on component
	   * ID and must remove that cache entry when this instance is unmounted.
	   */
	  unmountIDFromEnvironment: null,
	
	  /**
	   * Optionally injectable hook for swapping out mount images in the middle of
	   * the tree.
	   */
	  replaceNodeWithMarkupByID: null,
	
	  /**
	   * Optionally injectable hook for processing a queue of child updates. Will
	   * later move into MultiChildComponents.
	   */
	  processChildrenUpdates: null,
	
	  injection: {
	    injectEnvironment: function injectEnvironment(environment) {
	      !!injected ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : invariant(false) : undefined;
	      ReactComponentEnvironment.unmountIDFromEnvironment = environment.unmountIDFromEnvironment;
	      ReactComponentEnvironment.replaceNodeWithMarkupByID = environment.replaceNodeWithMarkupByID;
	      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
	      injected = true;
	    }
	  }
	
	};
	
	module.exports = ReactComponentEnvironment;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypeLocations
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(24);
	
	var ReactPropTypeLocations = keyMirror({
	  prop: null,
	  context: null,
	  childContext: null
	});
	
	module.exports = ReactPropTypeLocations;

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypeLocationNames
	 */
	
	'use strict';
	
	var ReactPropTypeLocationNames = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  ReactPropTypeLocationNames = {
	    prop: 'prop',
	    context: 'context',
	    childContext: 'child context'
	  };
	}
	
	module.exports = ReactPropTypeLocationNames;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 74 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule shouldUpdateReactComponent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Given a `prevElement` and `nextElement`, determines if the existing
	 * instance should be updated as opposed to being destroyed or replaced by a new
	 * instance. Both arguments are elements. This ensures that this logic can
	 * operate on stateless trees without any backing instance.
	 *
	 * @param {?object} prevElement
	 * @param {?object} nextElement
	 * @return {boolean} True if the existing instance should be updated.
	 * @protected
	 */
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	function shouldUpdateReactComponent(prevElement, nextElement) {
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	  if (prevEmpty || nextEmpty) {
	    return prevEmpty === nextEmpty;
	  }
	
	  var prevType = typeof prevElement === 'undefined' ? 'undefined' : _typeof(prevElement);
	  var nextType = typeof nextElement === 'undefined' ? 'undefined' : _typeof(nextElement);
	  if (prevType === 'string' || prevType === 'number') {
	    return nextType === 'string' || nextType === 'number';
	  } else {
	    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
	  }
	  return false;
	}
	
	module.exports = shouldUpdateReactComponent;

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEmptyComponent
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(49);
	var ReactEmptyComponentRegistry = __webpack_require__(51);
	var ReactReconciler = __webpack_require__(57);
	
	var assign = __webpack_require__(46);
	
	var placeholderElement;
	
	var ReactEmptyComponentInjection = {
	  injectEmptyComponent: function injectEmptyComponent(component) {
	    placeholderElement = ReactElement.createElement(component);
	  }
	};
	
	function registerNullComponentID() {
	  ReactEmptyComponentRegistry.registerNullComponentID(this._rootNodeID);
	}
	
	var ReactEmptyComponent = function ReactEmptyComponent(instantiate) {
	  this._currentElement = null;
	  this._rootNodeID = null;
	  this._renderedComponent = instantiate(placeholderElement);
	};
	assign(ReactEmptyComponent.prototype, {
	  construct: function construct(element) {},
	  mountComponent: function mountComponent(rootID, transaction, context) {
	    transaction.getReactMountReady().enqueue(registerNullComponentID, this);
	    this._rootNodeID = rootID;
	    return ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, context);
	  },
	  receiveComponent: function receiveComponent() {},
	  unmountComponent: function unmountComponent(rootID, transaction, context) {
	    ReactReconciler.unmountComponent(this._renderedComponent);
	    ReactEmptyComponentRegistry.deregisterNullComponentID(this._rootNodeID);
	    this._rootNodeID = null;
	    this._renderedComponent = null;
	  }
	});
	
	ReactEmptyComponent.injection = ReactEmptyComponentInjection;
	
	module.exports = ReactEmptyComponent;

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactNativeComponent
	 */
	
	'use strict';
	
	var assign = __webpack_require__(46);
	var invariant = __webpack_require__(20);
	
	var autoGenerateWrapperClass = null;
	var genericComponentClass = null;
	// This registry keeps track of wrapper classes around native tags.
	var tagToComponentClass = {};
	var textComponentClass = null;
	
	var ReactNativeComponentInjection = {
	  // This accepts a class that receives the tag string. This is a catch all
	  // that can render any kind of tag.
	  injectGenericComponentClass: function injectGenericComponentClass(componentClass) {
	    genericComponentClass = componentClass;
	  },
	  // This accepts a text component class that takes the text string to be
	  // rendered as props.
	  injectTextComponentClass: function injectTextComponentClass(componentClass) {
	    textComponentClass = componentClass;
	  },
	  // This accepts a keyed object with classes as values. Each key represents a
	  // tag. That particular tag will use this class instead of the generic one.
	  injectComponentClasses: function injectComponentClasses(componentClasses) {
	    assign(tagToComponentClass, componentClasses);
	  }
	};
	
	/**
	 * Get a composite component wrapper class for a specific tag.
	 *
	 * @param {ReactElement} element The tag for which to get the class.
	 * @return {function} The React class constructor function.
	 */
	function getComponentClassForElement(element) {
	  if (typeof element.type === 'function') {
	    return element.type;
	  }
	  var tag = element.type;
	  var componentClass = tagToComponentClass[tag];
	  if (componentClass == null) {
	    tagToComponentClass[tag] = componentClass = autoGenerateWrapperClass(tag);
	  }
	  return componentClass;
	}
	
	/**
	 * Get a native internal component class for a specific tag.
	 *
	 * @param {ReactElement} element The element to create.
	 * @return {function} The internal class constructor function.
	 */
	function createInternalComponent(element) {
	  !genericComponentClass ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : invariant(false) : undefined;
	  return new genericComponentClass(element.type, element.props);
	}
	
	/**
	 * @param {ReactText} text
	 * @return {ReactComponent}
	 */
	function createInstanceForText(text) {
	  return new textComponentClass(text);
	}
	
	/**
	 * @param {ReactComponent} component
	 * @return {boolean}
	 */
	function isTextComponent(component) {
	  return component instanceof textComponentClass;
	}
	
	var ReactNativeComponent = {
	  getComponentClassForElement: getComponentClassForElement,
	  createInternalComponent: createInternalComponent,
	  createInstanceForText: createInstanceForText,
	  isTextComponent: isTextComponent,
	  injection: ReactNativeComponentInjection
	};
	
	module.exports = ReactNativeComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule validateDOMNesting
	 */
	
	'use strict';
	
	var assign = __webpack_require__(46);
	var emptyFunction = __webpack_require__(22);
	var warning = __webpack_require__(32);
	
	var validateDOMNesting = emptyFunction;
	
	if (process.env.NODE_ENV !== 'production') {
	  // This validation code was written based on the HTML5 parsing spec:
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  //
	  // Note: this does not catch all invalid nesting, nor does it try to (as it's
	  // not clear what practical benefit doing so provides); instead, we warn only
	  // for cases where the parser will give a parse tree differing from what React
	  // intended. For example, <b><div></div></b> is invalid but we don't warn
	  // because it still parses correctly; we do warn for other cases like nested
	  // <p> tags where the beginning of the second element implicitly closes the
	  // first, causing a confusing mess.
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#special
	  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
	  // TODO: Distinguish by namespace here -- for <title>, including it here
	  // errs on the side of fewer warnings
	  'foreignObject', 'desc', 'title'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
	  var buttonScopeTags = inScopeTags.concat(['button']);
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
	  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];
	
	  var emptyAncestorInfo = {
	    parentTag: null,
	
	    formTag: null,
	    aTagInScope: null,
	    buttonTagInScope: null,
	    nobrTagInScope: null,
	    pTagInButtonScope: null,
	
	    listItemTagAutoclosing: null,
	    dlItemTagAutoclosing: null
	  };
	
	  var updatedAncestorInfo = function updatedAncestorInfo(oldInfo, tag, instance) {
	    var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo);
	    var info = { tag: tag, instance: instance };
	
	    if (inScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.aTagInScope = null;
	      ancestorInfo.buttonTagInScope = null;
	      ancestorInfo.nobrTagInScope = null;
	    }
	    if (buttonScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.pTagInButtonScope = null;
	    }
	
	    // See rules for 'li', 'dd', 'dt' start tags in
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
	      ancestorInfo.listItemTagAutoclosing = null;
	      ancestorInfo.dlItemTagAutoclosing = null;
	    }
	
	    ancestorInfo.parentTag = info;
	
	    if (tag === 'form') {
	      ancestorInfo.formTag = info;
	    }
	    if (tag === 'a') {
	      ancestorInfo.aTagInScope = info;
	    }
	    if (tag === 'button') {
	      ancestorInfo.buttonTagInScope = info;
	    }
	    if (tag === 'nobr') {
	      ancestorInfo.nobrTagInScope = info;
	    }
	    if (tag === 'p') {
	      ancestorInfo.pTagInButtonScope = info;
	    }
	    if (tag === 'li') {
	      ancestorInfo.listItemTagAutoclosing = info;
	    }
	    if (tag === 'dd' || tag === 'dt') {
	      ancestorInfo.dlItemTagAutoclosing = info;
	    }
	
	    return ancestorInfo;
	  };
	
	  /**
	   * Returns whether
	   */
	  var isTagValidWithParent = function isTagValidWithParent(tag, parentTag) {
	    // First, let's check if we're in an unusual parsing mode...
	    switch (parentTag) {
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
	      case 'select':
	        return tag === 'option' || tag === 'optgroup' || tag === '#text';
	      case 'optgroup':
	        return tag === 'option' || tag === '#text';
	      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
	      // but
	      case 'option':
	        return tag === '#text';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
	      // No special behavior since these rules fall back to "in body" mode for
	      // all except special table nodes which cause bad parsing behavior anyway.
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
	      case 'tr':
	        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
	      case 'tbody':
	      case 'thead':
	      case 'tfoot':
	        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
	      case 'colgroup':
	        return tag === 'col' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
	      case 'table':
	        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
	      case 'head':
	        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
	      case 'html':
	        return tag === 'head' || tag === 'body';
	    }
	
	    // Probably in the "in body" parsing mode, so we outlaw only tag combos
	    // where the parsing rules cause implicit opens or closes to be added.
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    switch (tag) {
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';
	
	      case 'rp':
	      case 'rt':
	        return impliedEndTags.indexOf(parentTag) === -1;
	
	      case 'caption':
	      case 'col':
	      case 'colgroup':
	      case 'frame':
	      case 'head':
	      case 'tbody':
	      case 'td':
	      case 'tfoot':
	      case 'th':
	      case 'thead':
	      case 'tr':
	        // These tags are only valid with a few parents that have special child
	        // parsing rules -- if we're down here, then none of those matched and
	        // so we allow it only if we don't know what the parent is, as all other
	        // cases are invalid.
	        return parentTag == null;
	    }
	
	    return true;
	  };
	
	  /**
	   * Returns whether
	   */
	  var findInvalidAncestorForTag = function findInvalidAncestorForTag(tag, ancestorInfo) {
	    switch (tag) {
	      case 'address':
	      case 'article':
	      case 'aside':
	      case 'blockquote':
	      case 'center':
	      case 'details':
	      case 'dialog':
	      case 'dir':
	      case 'div':
	      case 'dl':
	      case 'fieldset':
	      case 'figcaption':
	      case 'figure':
	      case 'footer':
	      case 'header':
	      case 'hgroup':
	      case 'main':
	      case 'menu':
	      case 'nav':
	      case 'ol':
	      case 'p':
	      case 'section':
	      case 'summary':
	      case 'ul':
	
	      case 'pre':
	      case 'listing':
	
	      case 'table':
	
	      case 'hr':
	
	      case 'xmp':
	
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return ancestorInfo.pTagInButtonScope;
	
	      case 'form':
	        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
	
	      case 'li':
	        return ancestorInfo.listItemTagAutoclosing;
	
	      case 'dd':
	      case 'dt':
	        return ancestorInfo.dlItemTagAutoclosing;
	
	      case 'button':
	        return ancestorInfo.buttonTagInScope;
	
	      case 'a':
	        // Spec says something about storing a list of markers, but it sounds
	        // equivalent to this check.
	        return ancestorInfo.aTagInScope;
	
	      case 'nobr':
	        return ancestorInfo.nobrTagInScope;
	    }
	
	    return null;
	  };
	
	  /**
	   * Given a ReactCompositeComponent instance, return a list of its recursive
	   * owners, starting at the root and ending with the instance itself.
	   */
	  var findOwnerStack = function findOwnerStack(instance) {
	    if (!instance) {
	      return [];
	    }
	
	    var stack = [];
	    /*eslint-disable space-after-keywords */
	    do {
	      /*eslint-enable space-after-keywords */
	      stack.push(instance);
	    } while (instance = instance._currentElement._owner);
	    stack.reverse();
	    return stack;
	  };
	
	  var didWarn = {};
	
	  validateDOMNesting = function validateDOMNesting(childTag, childInstance, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.parentTag;
	    var parentTag = parentInfo && parentInfo.tag;
	
	    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
	    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
	    var problematic = invalidParent || invalidAncestor;
	
	    if (problematic) {
	      var ancestorTag = problematic.tag;
	      var ancestorInstance = problematic.instance;
	
	      var childOwner = childInstance && childInstance._currentElement._owner;
	      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;
	
	      var childOwners = findOwnerStack(childOwner);
	      var ancestorOwners = findOwnerStack(ancestorOwner);
	
	      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
	      var i;
	
	      var deepestCommon = -1;
	      for (i = 0; i < minStackLen; i++) {
	        if (childOwners[i] === ancestorOwners[i]) {
	          deepestCommon = i;
	        } else {
	          break;
	        }
	      }
	
	      var UNKNOWN = '(unknown)';
	      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ownerInfo = [].concat(
	      // If the parent and child instances have a common owner ancestor, start
	      // with that -- otherwise we just start with the parent's owners.
	      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
	      // If we're warning about an invalid (non-parent) ancestry, add '...'
	      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');
	
	      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
	      if (didWarn[warnKey]) {
	        return;
	      }
	      didWarn[warnKey] = true;
	
	      if (invalidParent) {
	        var info = '';
	        if (ancestorTag === 'table' && childTag === 'tr') {
	          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
	        }
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a child of <%s>. ' + 'See %s.%s', childTag, ancestorTag, ownerInfo, info) : undefined;
	      } else {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a descendant of ' + '<%s>. See %s.', childTag, ancestorTag, ownerInfo) : undefined;
	      }
	    }
	  };
	
	  validateDOMNesting.ancestorInfoContextKey = '__validateDOMNesting_ancestorInfo$' + Math.random().toString(36).slice(2);
	
	  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;
	
	  // For testing
	  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.parentTag;
	    var parentTag = parentInfo && parentInfo.tag;
	    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
	  };
	}
	
	module.exports = validateDOMNesting;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultInjection
	 */
	
	'use strict';
	
	var BeforeInputEventPlugin = __webpack_require__(79);
	var ChangeEventPlugin = __webpack_require__(87);
	var ClientReactRootIndex = __webpack_require__(90);
	var DefaultEventPluginOrder = __webpack_require__(91);
	var EnterLeaveEventPlugin = __webpack_require__(92);
	var ExecutionEnvironment = __webpack_require__(16);
	var HTMLDOMPropertyConfig = __webpack_require__(96);
	var ReactBrowserComponentMixin = __webpack_require__(97);
	var ReactComponentBrowserEnvironment = __webpack_require__(33);
	var ReactDefaultBatchingStrategy = __webpack_require__(99);
	var ReactDOMComponent = __webpack_require__(100);
	var ReactDOMTextComponent = __webpack_require__(13);
	var ReactEventListener = __webpack_require__(125);
	var ReactInjection = __webpack_require__(128);
	var ReactInstanceHandles = __webpack_require__(52);
	var ReactMount = __webpack_require__(35);
	var ReactReconcileTransaction = __webpack_require__(132);
	var SelectEventPlugin = __webpack_require__(137);
	var ServerReactRootIndex = __webpack_require__(138);
	var SimpleEventPlugin = __webpack_require__(139);
	var SVGDOMPropertyConfig = __webpack_require__(148);
	
	var alreadyInjected = false;
	
	function inject() {
	  if (alreadyInjected) {
	    // TODO: This is currently true because these injections are shared between
	    // the client and the server package. They should be built independently
	    // and not share any injection state. Then this problem will be solved.
	    return;
	  }
	  alreadyInjected = true;
	
	  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);
	
	  /**
	   * Inject modules for resolving DOM hierarchy and plugin ordering.
	   */
	  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
	  ReactInjection.EventPluginHub.injectInstanceHandle(ReactInstanceHandles);
	  ReactInjection.EventPluginHub.injectMount(ReactMount);
	
	  /**
	   * Some important event plugins included by default (without having to require
	   * them).
	   */
	  ReactInjection.EventPluginHub.injectEventPluginsByName({
	    SimpleEventPlugin: SimpleEventPlugin,
	    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
	    ChangeEventPlugin: ChangeEventPlugin,
	    SelectEventPlugin: SelectEventPlugin,
	    BeforeInputEventPlugin: BeforeInputEventPlugin
	  });
	
	  ReactInjection.NativeComponent.injectGenericComponentClass(ReactDOMComponent);
	
	  ReactInjection.NativeComponent.injectTextComponentClass(ReactDOMTextComponent);
	
	  ReactInjection.Class.injectMixin(ReactBrowserComponentMixin);
	
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);
	
	  ReactInjection.EmptyComponent.injectEmptyComponent('noscript');
	
	  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
	  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	
	  ReactInjection.RootIndex.injectCreateReactRootIndex(ExecutionEnvironment.canUseDOM ? ClientReactRootIndex.createReactRootIndex : ServerReactRootIndex.createReactRootIndex);
	
	  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
	
	  if (process.env.NODE_ENV !== 'production') {
	    var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
	    if (/[?&]react_perf\b/.test(url)) {
	      var ReactDefaultPerf = __webpack_require__(149);
	      ReactDefaultPerf.start();
	    }
	  }
	}
	
	module.exports = {
	  inject: inject
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015 Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule BeforeInputEventPlugin
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var EventConstants = __webpack_require__(37);
	var EventPropagators = __webpack_require__(80);
	var ExecutionEnvironment = __webpack_require__(16);
	var FallbackCompositionState = __webpack_require__(81);
	var SyntheticCompositionEvent = __webpack_require__(83);
	var SyntheticInputEvent = __webpack_require__(85);
	
	var keyOf = __webpack_require__(86);
	
	var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
	var START_KEYCODE = 229;
	
	var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;
	
	var documentMode = null;
	if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
	  documentMode = document.documentMode;
	}
	
	// Webkit offers a very useful `textInput` event that can be used to
	// directly represent `beforeInput`. The IE `textinput` event is not as
	// useful, so we don't use it.
	var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();
	
	// In IE9+, we have access to composition events, but the data supplied
	// by the native compositionend event may be incorrect. Japanese ideographic
	// spaces, for instance (\u3000) are not recorded correctly.
	var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
	
	/**
	 * Opera <= 12 includes TextEvent in window, but does not fire
	 * text input events. Rely on keypress instead.
	 */
	function isPresto() {
	  var opera = window.opera;
	  return (typeof opera === 'undefined' ? 'undefined' : _typeof(opera)) === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
	}
	
	var SPACEBAR_CODE = 32;
	var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	// Events and their corresponding property names.
	var eventTypes = {
	  beforeInput: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onBeforeInput: null }),
	      captured: keyOf({ onBeforeInputCapture: null })
	    },
	    dependencies: [topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste]
	  },
	  compositionEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionEnd: null }),
	      captured: keyOf({ onCompositionEndCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  },
	  compositionStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionStart: null }),
	      captured: keyOf({ onCompositionStartCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  },
	  compositionUpdate: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionUpdate: null }),
	      captured: keyOf({ onCompositionUpdateCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  }
	};
	
	// Track whether we've ever handled a keypress on the space key.
	var hasSpaceKeypress = false;
	
	/**
	 * Return whether a native keypress event is assumed to be a command.
	 * This is required because Firefox fires `keypress` events for key commands
	 * (cut, copy, select-all, etc.) even though no character is inserted.
	 */
	function isKeypressCommand(nativeEvent) {
	  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
	  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
	  !(nativeEvent.ctrlKey && nativeEvent.altKey);
	}
	
	/**
	 * Translate native top level events into event types.
	 *
	 * @param {string} topLevelType
	 * @return {object}
	 */
	function getCompositionEventType(topLevelType) {
	  switch (topLevelType) {
	    case topLevelTypes.topCompositionStart:
	      return eventTypes.compositionStart;
	    case topLevelTypes.topCompositionEnd:
	      return eventTypes.compositionEnd;
	    case topLevelTypes.topCompositionUpdate:
	      return eventTypes.compositionUpdate;
	  }
	}
	
	/**
	 * Does our fallback best-guess model think this event signifies that
	 * composition has begun?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionStart(topLevelType, nativeEvent) {
	  return topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE;
	}
	
	/**
	 * Does our fallback mode think that this event is the end of composition?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionEnd(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case topLevelTypes.topKeyUp:
	      // Command keys insert or clear IME input.
	      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
	    case topLevelTypes.topKeyDown:
	      // Expect IME keyCode on each keydown. If we get any other
	      // code we must have exited earlier.
	      return nativeEvent.keyCode !== START_KEYCODE;
	    case topLevelTypes.topKeyPress:
	    case topLevelTypes.topMouseDown:
	    case topLevelTypes.topBlur:
	      // Events are not possible without cancelling IME.
	      return true;
	    default:
	      return false;
	  }
	}
	
	/**
	 * Google Input Tools provides composition data via a CustomEvent,
	 * with the `data` property populated in the `detail` object. If this
	 * is available on the event object, use it. If not, this is a plain
	 * composition event and we have nothing special to extract.
	 *
	 * @param {object} nativeEvent
	 * @return {?string}
	 */
	function getDataFromCustomEvent(nativeEvent) {
	  var detail = nativeEvent.detail;
	  if ((typeof detail === 'undefined' ? 'undefined' : _typeof(detail)) === 'object' && 'data' in detail) {
	    return detail.data;
	  }
	  return null;
	}
	
	// Track the current IME composition fallback object, if any.
	var currentComposition = null;
	
	/**
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {DOMEventTarget} topLevelTarget The listening component root node.
	 * @param {string} topLevelTargetID ID of `topLevelTarget`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?object} A SyntheticCompositionEvent.
	 */
	function extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	  var eventType;
	  var fallbackData;
	
	  if (canUseCompositionEvent) {
	    eventType = getCompositionEventType(topLevelType);
	  } else if (!currentComposition) {
	    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
	      eventType = eventTypes.compositionStart;
	    }
	  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	    eventType = eventTypes.compositionEnd;
	  }
	
	  if (!eventType) {
	    return null;
	  }
	
	  if (useFallbackCompositionData) {
	    // The current composition is stored statically and must not be
	    // overwritten while composition continues.
	    if (!currentComposition && eventType === eventTypes.compositionStart) {
	      currentComposition = FallbackCompositionState.getPooled(topLevelTarget);
	    } else if (eventType === eventTypes.compositionEnd) {
	      if (currentComposition) {
	        fallbackData = currentComposition.getData();
	      }
	    }
	  }
	
	  var event = SyntheticCompositionEvent.getPooled(eventType, topLevelTargetID, nativeEvent, nativeEventTarget);
	
	  if (fallbackData) {
	    // Inject data generated from fallback path into the synthetic event.
	    // This matches the property of native CompositionEventInterface.
	    event.data = fallbackData;
	  } else {
	    var customData = getDataFromCustomEvent(nativeEvent);
	    if (customData !== null) {
	      event.data = customData;
	    }
	  }
	
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The string corresponding to this `beforeInput` event.
	 */
	function getNativeBeforeInputChars(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case topLevelTypes.topCompositionEnd:
	      return getDataFromCustomEvent(nativeEvent);
	    case topLevelTypes.topKeyPress:
	      /**
	       * If native `textInput` events are available, our goal is to make
	       * use of them. However, there is a special case: the spacebar key.
	       * In Webkit, preventing default on a spacebar `textInput` event
	       * cancels character insertion, but it *also* causes the browser
	       * to fall back to its default spacebar behavior of scrolling the
	       * page.
	       *
	       * Tracking at:
	       * https://code.google.com/p/chromium/issues/detail?id=355103
	       *
	       * To avoid this issue, use the keypress event as if no `textInput`
	       * event is available.
	       */
	      var which = nativeEvent.which;
	      if (which !== SPACEBAR_CODE) {
	        return null;
	      }
	
	      hasSpaceKeypress = true;
	      return SPACEBAR_CHAR;
	
	    case topLevelTypes.topTextInput:
	      // Record the characters to be added to the DOM.
	      var chars = nativeEvent.data;
	
	      // If it's a spacebar character, assume that we have already handled
	      // it at the keypress level and bail immediately. Android Chrome
	      // doesn't give us keycodes, so we need to blacklist it.
	      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
	        return null;
	      }
	
	      return chars;
	
	    default:
	      // For other native event types, do nothing.
	      return null;
	  }
	}
	
	/**
	 * For browsers that do not provide the `textInput` event, extract the
	 * appropriate string to use for SyntheticInputEvent.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The fallback string for this `beforeInput` event.
	 */
	function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
	  // If we are currently composing (IME) and using a fallback to do so,
	  // try to extract the composed characters from the fallback object.
	  if (currentComposition) {
	    if (topLevelType === topLevelTypes.topCompositionEnd || isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	      var chars = currentComposition.getData();
	      FallbackCompositionState.release(currentComposition);
	      currentComposition = null;
	      return chars;
	    }
	    return null;
	  }
	
	  switch (topLevelType) {
	    case topLevelTypes.topPaste:
	      // If a paste event occurs after a keypress, throw out the input
	      // chars. Paste events should not lead to BeforeInput events.
	      return null;
	    case topLevelTypes.topKeyPress:
	      /**
	       * As of v27, Firefox may fire keypress events even when no character
	       * will be inserted. A few possibilities:
	       *
	       * - `which` is `0`. Arrow keys, Esc key, etc.
	       *
	       * - `which` is the pressed key code, but no char is available.
	       *   Ex: 'AltGr + d` in Polish. There is no modified character for
	       *   this key combination and no character is inserted into the
	       *   document, but FF fires the keypress for char code `100` anyway.
	       *   No `input` event will occur.
	       *
	       * - `which` is the pressed key code, but a command combination is
	       *   being used. Ex: `Cmd+C`. No character is inserted, and no
	       *   `input` event will occur.
	       */
	      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
	        return String.fromCharCode(nativeEvent.which);
	      }
	      return null;
	    case topLevelTypes.topCompositionEnd:
	      return useFallbackCompositionData ? null : nativeEvent.data;
	    default:
	      return null;
	  }
	}
	
	/**
	 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
	 * `textInput` or fallback behavior.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {DOMEventTarget} topLevelTarget The listening component root node.
	 * @param {string} topLevelTargetID ID of `topLevelTarget`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?object} A SyntheticInputEvent.
	 */
	function extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	  var chars;
	
	  if (canUseTextInputEvent) {
	    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
	  } else {
	    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
	  }
	
	  // If no characters are being inserted, no BeforeInput event should
	  // be fired.
	  if (!chars) {
	    return null;
	  }
	
	  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, topLevelTargetID, nativeEvent, nativeEventTarget);
	
	  event.data = chars;
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * Create an `onBeforeInput` event to match
	 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
	 *
	 * This event plugin is based on the native `textInput` event
	 * available in Chrome, Safari, Opera, and IE. This event fires after
	 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
	 *
	 * `beforeInput` is spec'd but not implemented in any browsers, and
	 * the `input` event does not provide any useful information about what has
	 * actually been added, contrary to the spec. Thus, `textInput` is the best
	 * available event to identify the characters that have actually been inserted
	 * into the target node.
	 *
	 * This plugin is also responsible for emitting `composition` events, thus
	 * allowing us to share composition fallback code for both `beforeInput` and
	 * `composition` event types.
	 */
	var BeforeInputEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    return [extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget)];
	  }
	};
	
	module.exports = BeforeInputEventPlugin;

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPropagators
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(37);
	var EventPluginHub = __webpack_require__(38);
	
	var warning = __webpack_require__(32);
	
	var accumulateInto = __webpack_require__(42);
	var forEachAccumulated = __webpack_require__(43);
	
	var PropagationPhases = EventConstants.PropagationPhases;
	var getListener = EventPluginHub.getListener;
	
	/**
	 * Some event types have a notion of different registration names for different
	 * "phases" of propagation. This finds listeners by a given phase.
	 */
	function listenerAtPhase(id, event, propagationPhase) {
	  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
	  return getListener(id, registrationName);
	}
	
	/**
	 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
	 * here, allows us to not have to bind or create functions for each event.
	 * Mutating the event's members allows us to not have to create a wrapping
	 * "dispatch" object that pairs the event with the listener.
	 */
	function accumulateDirectionalDispatches(domID, upwards, event) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(domID, 'Dispatching id must not be null') : undefined;
	  }
	  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
	  var listener = listenerAtPhase(domID, event, phase);
	  if (listener) {
	    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	    event._dispatchIDs = accumulateInto(event._dispatchIDs, domID);
	  }
	}
	
	/**
	 * Collect dispatches (must be entirely collected before dispatching - see unit
	 * tests). Lazily allocate the array to conserve memory.  We must loop through
	 * each event and perform the traversal for each one. We cannot perform a
	 * single traversal for the entire collection of events because each event may
	 * have a different target.
	 */
	function accumulateTwoPhaseDispatchesSingle(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(event.dispatchMarker, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
	 */
	function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    EventPluginHub.injection.getInstanceHandle().traverseTwoPhaseSkipTarget(event.dispatchMarker, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Accumulates without regard to direction, does not look for phased
	 * registration names. Same as `accumulateDirectDispatchesSingle` but without
	 * requiring that the `dispatchMarker` be the same as the dispatched ID.
	 */
	function accumulateDispatches(id, ignoredDirection, event) {
	  if (event && event.dispatchConfig.registrationName) {
	    var registrationName = event.dispatchConfig.registrationName;
	    var listener = getListener(id, registrationName);
	    if (listener) {
	      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	      event._dispatchIDs = accumulateInto(event._dispatchIDs, id);
	    }
	  }
	}
	
	/**
	 * Accumulates dispatches on an `SyntheticEvent`, but only for the
	 * `dispatchMarker`.
	 * @param {SyntheticEvent} event
	 */
	function accumulateDirectDispatchesSingle(event) {
	  if (event && event.dispatchConfig.registrationName) {
	    accumulateDispatches(event.dispatchMarker, null, event);
	  }
	}
	
	function accumulateTwoPhaseDispatches(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
	}
	
	function accumulateTwoPhaseDispatchesSkipTarget(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
	}
	
	function accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {
	  EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(fromID, toID, accumulateDispatches, leave, enter);
	}
	
	function accumulateDirectDispatches(events) {
	  forEachAccumulated(events, accumulateDirectDispatchesSingle);
	}
	
	/**
	 * A small set of propagation patterns, each of which will accept a small amount
	 * of information, and generate a set of "dispatch ready event objects" - which
	 * are sets of events that have already been annotated with a set of dispatched
	 * listener functions/ids. The API is designed this way to discourage these
	 * propagation strategies from actually executing the dispatches, since we
	 * always want to collect the entire set of dispatches before executing event a
	 * single one.
	 *
	 * @constructor EventPropagators
	 */
	var EventPropagators = {
	  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
	  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
	  accumulateDirectDispatches: accumulateDirectDispatches,
	  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
	};
	
	module.exports = EventPropagators;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule FallbackCompositionState
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(63);
	
	var assign = __webpack_require__(46);
	var getTextContentAccessor = __webpack_require__(82);
	
	/**
	 * This helper class stores information about text content of a target node,
	 * allowing comparison of content before and after a given event.
	 *
	 * Identify the node where selection currently begins, then observe
	 * both its text content and its current position in the DOM. Since the
	 * browser may natively replace the target node during composition, we can
	 * use its position to find its replacement.
	 *
	 * @param {DOMEventTarget} root
	 */
	function FallbackCompositionState(root) {
	  this._root = root;
	  this._startText = this.getText();
	  this._fallbackText = null;
	}
	
	assign(FallbackCompositionState.prototype, {
	  destructor: function destructor() {
	    this._root = null;
	    this._startText = null;
	    this._fallbackText = null;
	  },
	
	  /**
	   * Get current text of input.
	   *
	   * @return {string}
	   */
	  getText: function getText() {
	    if ('value' in this._root) {
	      return this._root.value;
	    }
	    return this._root[getTextContentAccessor()];
	  },
	
	  /**
	   * Determine the differing substring between the initially stored
	   * text content and the current content.
	   *
	   * @return {string}
	   */
	  getData: function getData() {
	    if (this._fallbackText) {
	      return this._fallbackText;
	    }
	
	    var start;
	    var startValue = this._startText;
	    var startLength = startValue.length;
	    var end;
	    var endValue = this.getText();
	    var endLength = endValue.length;
	
	    for (start = 0; start < startLength; start++) {
	      if (startValue[start] !== endValue[start]) {
	        break;
	      }
	    }
	
	    var minEnd = startLength - start;
	    for (end = 1; end <= minEnd; end++) {
	      if (startValue[startLength - end] !== endValue[endLength - end]) {
	        break;
	      }
	    }
	
	    var sliceTail = end > 1 ? 1 - end : undefined;
	    this._fallbackText = endValue.slice(start, sliceTail);
	    return this._fallbackText;
	  }
	});
	
	PooledClass.addPoolingTo(FallbackCompositionState);
	
	module.exports = FallbackCompositionState;

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getTextContentAccessor
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(16);
	
	var contentKey = null;
	
	/**
	 * Gets the key used to access text content on a DOM node.
	 *
	 * @return {?string} Key used to access text content.
	 * @internal
	 */
	function getTextContentAccessor() {
	  if (!contentKey && ExecutionEnvironment.canUseDOM) {
	    // Prefer textContent to innerText because many browsers support both but
	    // SVG <text> elements don't support innerText even when <div> does.
	    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
	  }
	  return contentKey;
	}
	
	module.exports = getTextContentAccessor;

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticCompositionEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(84);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
	 */
	var CompositionEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);
	
	module.exports = SyntheticCompositionEvent;

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(63);
	
	var assign = __webpack_require__(46);
	var emptyFunction = __webpack_require__(22);
	var warning = __webpack_require__(32);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var EventInterface = {
	  type: null,
	  target: null,
	  // currentTarget is set when dispatching; no use in copying it here
	  currentTarget: emptyFunction.thatReturnsNull,
	  eventPhase: null,
	  bubbles: null,
	  cancelable: null,
	  timeStamp: function timeStamp(event) {
	    return event.timeStamp || Date.now();
	  },
	  defaultPrevented: null,
	  isTrusted: null
	};
	
	/**
	 * Synthetic events are dispatched by event plugins, typically in response to a
	 * top-level event delegation handler.
	 *
	 * These systems should generally use pooling to reduce the frequency of garbage
	 * collection. The system should check `isPersistent` to determine whether the
	 * event should be released into the pool after being dispatched. Users that
	 * need a persisted event should invoke `persist`.
	 *
	 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
	 * normalizing browser quirks. Subclasses do not necessarily have to implement a
	 * DOM interface; custom application-specific events can also subclass this.
	 *
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 */
	function SyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  this.dispatchConfig = dispatchConfig;
	  this.dispatchMarker = dispatchMarker;
	  this.nativeEvent = nativeEvent;
	
	  var Interface = this.constructor.Interface;
	  for (var propName in Interface) {
	    if (!Interface.hasOwnProperty(propName)) {
	      continue;
	    }
	    var normalize = Interface[propName];
	    if (normalize) {
	      this[propName] = normalize(nativeEvent);
	    } else {
	      if (propName === 'target') {
	        this.target = nativeEventTarget;
	      } else {
	        this[propName] = nativeEvent[propName];
	      }
	    }
	  }
	
	  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
	  if (defaultPrevented) {
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  } else {
	    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
	  }
	  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
	}
	
	assign(SyntheticEvent.prototype, {
	
	  preventDefault: function preventDefault() {
	    this.defaultPrevented = true;
	    var event = this.nativeEvent;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(event, 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re calling `preventDefault` on a ' + 'released/nullified synthetic event. This is a no-op. See ' + 'https://fb.me/react-event-pooling for more information.') : undefined;
	    }
	    if (!event) {
	      return;
	    }
	
	    if (event.preventDefault) {
	      event.preventDefault();
	    } else {
	      event.returnValue = false;
	    }
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  },
	
	  stopPropagation: function stopPropagation() {
	    var event = this.nativeEvent;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(event, 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re calling `stopPropagation` on a ' + 'released/nullified synthetic event. This is a no-op. See ' + 'https://fb.me/react-event-pooling for more information.') : undefined;
	    }
	    if (!event) {
	      return;
	    }
	
	    if (event.stopPropagation) {
	      event.stopPropagation();
	    } else {
	      event.cancelBubble = true;
	    }
	    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * We release all dispatched `SyntheticEvent`s after each event loop, adding
	   * them back into the pool. This allows a way to hold onto a reference that
	   * won't be added back into the pool.
	   */
	  persist: function persist() {
	    this.isPersistent = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * Checks if this event should be released back into the pool.
	   *
	   * @return {boolean} True if this should not be released, false otherwise.
	   */
	  isPersistent: emptyFunction.thatReturnsFalse,
	
	  /**
	   * `PooledClass` looks for `destructor` on each instance it releases.
	   */
	  destructor: function destructor() {
	    var Interface = this.constructor.Interface;
	    for (var propName in Interface) {
	      this[propName] = null;
	    }
	    this.dispatchConfig = null;
	    this.dispatchMarker = null;
	    this.nativeEvent = null;
	  }
	
	});
	
	SyntheticEvent.Interface = EventInterface;
	
	/**
	 * Helper to reduce boilerplate when creating subclasses.
	 *
	 * @param {function} Class
	 * @param {?object} Interface
	 */
	SyntheticEvent.augmentClass = function (Class, Interface) {
	  var Super = this;
	
	  var prototype = Object.create(Super.prototype);
	  assign(prototype, Class.prototype);
	  Class.prototype = prototype;
	  Class.prototype.constructor = Class;
	
	  Class.Interface = assign({}, Super.Interface, Interface);
	  Class.augmentClass = Super.augmentClass;
	
	  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
	};
	
	PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);
	
	module.exports = SyntheticEvent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticInputEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(84);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
	 *      /#events-inputevents
	 */
	var InputEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);
	
	module.exports = SyntheticInputEvent;

/***/ },
/* 86 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule keyOf
	 */
	
	/**
	 * Allows extraction of a minified key. Let's the build system minify keys
	 * without losing the ability to dynamically use key strings as values
	 * themselves. Pass in an object with a single key/val pair and it will return
	 * you the string key of that single record. Suppose you want to grab the
	 * value for a key 'className' inside of an object. Key/val minification may
	 * have aliased that key to be 'xa12'. keyOf({className: null}) will return
	 * 'xa12' in that case. Resolve keys you want to use once at startup time, then
	 * reuse those resolutions.
	 */
	"use strict";
	
	var keyOf = function keyOf(oneKeyObj) {
	  var key;
	  for (key in oneKeyObj) {
	    if (!oneKeyObj.hasOwnProperty(key)) {
	      continue;
	    }
	    return key;
	  }
	  return null;
	};
	
	module.exports = keyOf;

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ChangeEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(37);
	var EventPluginHub = __webpack_require__(38);
	var EventPropagators = __webpack_require__(80);
	var ExecutionEnvironment = __webpack_require__(16);
	var ReactUpdates = __webpack_require__(61);
	var SyntheticEvent = __webpack_require__(84);
	
	var getEventTarget = __webpack_require__(88);
	var isEventSupported = __webpack_require__(47);
	var isTextInputElement = __webpack_require__(89);
	var keyOf = __webpack_require__(86);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var eventTypes = {
	  change: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onChange: null }),
	      captured: keyOf({ onChangeCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topChange, topLevelTypes.topClick, topLevelTypes.topFocus, topLevelTypes.topInput, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topSelectionChange]
	  }
	};
	
	/**
	 * For IE shims
	 */
	var activeElement = null;
	var activeElementID = null;
	var activeElementValue = null;
	var activeElementValueProp = null;
	
	/**
	 * SECTION: handle `change` event
	 */
	function shouldUseChangeEvent(elem) {
	  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
	}
	
	var doesChangeEventBubble = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // See `handleChange` comment below
	  doesChangeEventBubble = isEventSupported('change') && (!('documentMode' in document) || document.documentMode > 8);
	}
	
	function manualDispatchChangeEvent(nativeEvent) {
	  var event = SyntheticEvent.getPooled(eventTypes.change, activeElementID, nativeEvent, getEventTarget(nativeEvent));
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	
	  // If change and propertychange bubbled, we'd just bind to it like all the
	  // other events and have it go through ReactBrowserEventEmitter. Since it
	  // doesn't, we manually listen for the events and so we have to enqueue and
	  // process the abstract event manually.
	  //
	  // Batching is necessary here in order to ensure that all event handlers run
	  // before the next rerender (including event handlers attached to ancestor
	  // elements instead of directly on the input). Without this, controlled
	  // components don't work properly in conjunction with event bubbling because
	  // the component is rerendered and the value reverted before all the event
	  // handlers can run. See https://github.com/facebook/react/issues/708.
	  ReactUpdates.batchedUpdates(runEventInBatch, event);
	}
	
	function runEventInBatch(event) {
	  EventPluginHub.enqueueEvents(event);
	  EventPluginHub.processEventQueue(false);
	}
	
	function startWatchingForChangeEventIE8(target, targetID) {
	  activeElement = target;
	  activeElementID = targetID;
	  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
	}
	
	function stopWatchingForChangeEventIE8() {
	  if (!activeElement) {
	    return;
	  }
	  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
	  activeElement = null;
	  activeElementID = null;
	}
	
	function getTargetIDForChangeEvent(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topChange) {
	    return topLevelTargetID;
	  }
	}
	function handleEventsForChangeEventIE8(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topFocus) {
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForChangeEventIE8();
	    startWatchingForChangeEventIE8(topLevelTarget, topLevelTargetID);
	  } else if (topLevelType === topLevelTypes.topBlur) {
	    stopWatchingForChangeEventIE8();
	  }
	}
	
	/**
	 * SECTION: handle `input` event
	 */
	var isInputEventSupported = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // IE9 claims to support the input event but fails to trigger it when
	  // deleting text, so we ignore its input events
	  isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 9);
	}
	
	/**
	 * (For old IE.) Replacement getter/setter for the `value` property that gets
	 * set on the active element.
	 */
	var newValueProp = {
	  get: function get() {
	    return activeElementValueProp.get.call(this);
	  },
	  set: function set(val) {
	    // Cast to a string so we can do equality checks.
	    activeElementValue = '' + val;
	    activeElementValueProp.set.call(this, val);
	  }
	};
	
	/**
	 * (For old IE.) Starts tracking propertychange events on the passed-in element
	 * and override the value property so that we can distinguish user events from
	 * value changes in JS.
	 */
	function startWatchingForValueChange(target, targetID) {
	  activeElement = target;
	  activeElementID = targetID;
	  activeElementValue = target.value;
	  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');
	
	  // Not guarded in a canDefineProperty check: IE8 supports defineProperty only
	  // on DOM elements
	  Object.defineProperty(activeElement, 'value', newValueProp);
	  activeElement.attachEvent('onpropertychange', handlePropertyChange);
	}
	
	/**
	 * (For old IE.) Removes the event listeners from the currently-tracked element,
	 * if any exists.
	 */
	function stopWatchingForValueChange() {
	  if (!activeElement) {
	    return;
	  }
	
	  // delete restores the original property definition
	  delete activeElement.value;
	  activeElement.detachEvent('onpropertychange', handlePropertyChange);
	
	  activeElement = null;
	  activeElementID = null;
	  activeElementValue = null;
	  activeElementValueProp = null;
	}
	
	/**
	 * (For old IE.) Handles a propertychange event, sending a `change` event if
	 * the value of the active element has changed.
	 */
	function handlePropertyChange(nativeEvent) {
	  if (nativeEvent.propertyName !== 'value') {
	    return;
	  }
	  var value = nativeEvent.srcElement.value;
	  if (value === activeElementValue) {
	    return;
	  }
	  activeElementValue = value;
	
	  manualDispatchChangeEvent(nativeEvent);
	}
	
	/**
	 * If a `change` event should be fired, returns the target's ID.
	 */
	function getTargetIDForInputEvent(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topInput) {
	    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
	    // what we want so fall through here and trigger an abstract event
	    return topLevelTargetID;
	  }
	}
	
	// For IE8 and IE9.
	function handleEventsForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topFocus) {
	    // In IE8, we can capture almost all .value changes by adding a
	    // propertychange handler and looking for events with propertyName
	    // equal to 'value'
	    // In IE9, propertychange fires for most input events but is buggy and
	    // doesn't fire when text is deleted, but conveniently, selectionchange
	    // appears to fire in all of the remaining cases so we catch those and
	    // forward the event if the value has changed
	    // In either case, we don't want to call the event handler if the value
	    // is changed from JS so we redefine a setter for `.value` that updates
	    // our activeElementValue variable, allowing us to ignore those changes
	    //
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForValueChange();
	    startWatchingForValueChange(topLevelTarget, topLevelTargetID);
	  } else if (topLevelType === topLevelTypes.topBlur) {
	    stopWatchingForValueChange();
	  }
	}
	
	// For IE8 and IE9.
	function getTargetIDForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) {
	    // On the selectionchange event, the target is just document which isn't
	    // helpful for us so just check activeElement instead.
	    //
	    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
	    // propertychange on the first input event after setting `value` from a
	    // script and fires only keydown, keypress, keyup. Catching keyup usually
	    // gets it and catching keydown lets us fire an event for the first
	    // keystroke if user does a key repeat (it'll be a little delayed: right
	    // before the second keystroke). Other input methods (e.g., paste) seem to
	    // fire selectionchange normally.
	    if (activeElement && activeElement.value !== activeElementValue) {
	      activeElementValue = activeElement.value;
	      return activeElementID;
	    }
	  }
	}
	
	/**
	 * SECTION: handle `click` event
	 */
	function shouldUseClickEvent(elem) {
	  // Use the `click` event to detect changes to checkbox and radio inputs.
	  // This approach works across all browsers, whereas `change` does not fire
	  // until `blur` in IE8.
	  return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
	}
	
	function getTargetIDForClickEvent(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topClick) {
	    return topLevelTargetID;
	  }
	}
	
	/**
	 * This plugin creates an `onChange` event that normalizes change events
	 * across form elements. This event fires at a time when it's possible to
	 * change the element's value without seeing a flicker.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - select
	 */
	var ChangeEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	
	    var getTargetIDFunc, handleEventFunc;
	    if (shouldUseChangeEvent(topLevelTarget)) {
	      if (doesChangeEventBubble) {
	        getTargetIDFunc = getTargetIDForChangeEvent;
	      } else {
	        handleEventFunc = handleEventsForChangeEventIE8;
	      }
	    } else if (isTextInputElement(topLevelTarget)) {
	      if (isInputEventSupported) {
	        getTargetIDFunc = getTargetIDForInputEvent;
	      } else {
	        getTargetIDFunc = getTargetIDForInputEventIE;
	        handleEventFunc = handleEventsForInputEventIE;
	      }
	    } else if (shouldUseClickEvent(topLevelTarget)) {
	      getTargetIDFunc = getTargetIDForClickEvent;
	    }
	
	    if (getTargetIDFunc) {
	      var targetID = getTargetIDFunc(topLevelType, topLevelTarget, topLevelTargetID);
	      if (targetID) {
	        var event = SyntheticEvent.getPooled(eventTypes.change, targetID, nativeEvent, nativeEventTarget);
	        event.type = 'change';
	        EventPropagators.accumulateTwoPhaseDispatches(event);
	        return event;
	      }
	    }
	
	    if (handleEventFunc) {
	      handleEventFunc(topLevelType, topLevelTarget, topLevelTargetID);
	    }
	  }
	
	};
	
	module.exports = ChangeEventPlugin;

/***/ },
/* 88 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventTarget
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Gets the target node from a native browser event by accounting for
	 * inconsistencies in browser DOM APIs.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {DOMEventTarget} Target node.
	 */
	
	function getEventTarget(nativeEvent) {
	  var target = nativeEvent.target || nativeEvent.srcElement || window;
	  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
	  // @see http://www.quirksmode.org/js/events_properties.html
	  return target.nodeType === 3 ? target.parentNode : target;
	}
	
	module.exports = getEventTarget;

/***/ },
/* 89 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isTextInputElement
	 */
	
	'use strict';
	
	/**
	 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
	 */
	
	var supportedInputTypes = {
	  'color': true,
	  'date': true,
	  'datetime': true,
	  'datetime-local': true,
	  'email': true,
	  'month': true,
	  'number': true,
	  'password': true,
	  'range': true,
	  'search': true,
	  'tel': true,
	  'text': true,
	  'time': true,
	  'url': true,
	  'week': true
	};
	
	function isTextInputElement(elem) {
	  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName && (nodeName === 'input' && supportedInputTypes[elem.type] || nodeName === 'textarea');
	}
	
	module.exports = isTextInputElement;

/***/ },
/* 90 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ClientReactRootIndex
	 * @typechecks
	 */
	
	'use strict';
	
	var nextReactRootIndex = 0;
	
	var ClientReactRootIndex = {
	  createReactRootIndex: function createReactRootIndex() {
	    return nextReactRootIndex++;
	  }
	};
	
	module.exports = ClientReactRootIndex;

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DefaultEventPluginOrder
	 */
	
	'use strict';
	
	var keyOf = __webpack_require__(86);
	
	/**
	 * Module that is injectable into `EventPluginHub`, that specifies a
	 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
	 * plugins, without having to package every one of them. This is better than
	 * having plugins be ordered in the same order that they are injected because
	 * that ordering would be influenced by the packaging order.
	 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
	 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
	 */
	var DefaultEventPluginOrder = [keyOf({ ResponderEventPlugin: null }), keyOf({ SimpleEventPlugin: null }), keyOf({ TapEventPlugin: null }), keyOf({ EnterLeaveEventPlugin: null }), keyOf({ ChangeEventPlugin: null }), keyOf({ SelectEventPlugin: null }), keyOf({ BeforeInputEventPlugin: null })];
	
	module.exports = DefaultEventPluginOrder;

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EnterLeaveEventPlugin
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(37);
	var EventPropagators = __webpack_require__(80);
	var SyntheticMouseEvent = __webpack_require__(93);
	
	var ReactMount = __webpack_require__(35);
	var keyOf = __webpack_require__(86);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	var getFirstReactDOM = ReactMount.getFirstReactDOM;
	
	var eventTypes = {
	  mouseEnter: {
	    registrationName: keyOf({ onMouseEnter: null }),
	    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
	  },
	  mouseLeave: {
	    registrationName: keyOf({ onMouseLeave: null }),
	    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
	  }
	};
	
	var extractedEvents = [null, null];
	
	var EnterLeaveEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * For almost every interaction we care about, there will be both a top-level
	   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
	   * we do not extract duplicate events. However, moving the mouse into the
	   * browser from outside will not fire a `mouseout` event. In this case, we use
	   * the `mouseover` top-level event.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
	      return null;
	    }
	    if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver) {
	      // Must not be a mouse in or mouse out - ignoring.
	      return null;
	    }
	
	    var win;
	    if (topLevelTarget.window === topLevelTarget) {
	      // `topLevelTarget` is probably a window object.
	      win = topLevelTarget;
	    } else {
	      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	      var doc = topLevelTarget.ownerDocument;
	      if (doc) {
	        win = doc.defaultView || doc.parentWindow;
	      } else {
	        win = window;
	      }
	    }
	
	    var from;
	    var to;
	    var fromID = '';
	    var toID = '';
	    if (topLevelType === topLevelTypes.topMouseOut) {
	      from = topLevelTarget;
	      fromID = topLevelTargetID;
	      to = getFirstReactDOM(nativeEvent.relatedTarget || nativeEvent.toElement);
	      if (to) {
	        toID = ReactMount.getID(to);
	      } else {
	        to = win;
	      }
	      to = to || win;
	    } else {
	      from = win;
	      to = topLevelTarget;
	      toID = topLevelTargetID;
	    }
	
	    if (from === to) {
	      // Nothing pertains to our managed components.
	      return null;
	    }
	
	    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, fromID, nativeEvent, nativeEventTarget);
	    leave.type = 'mouseleave';
	    leave.target = from;
	    leave.relatedTarget = to;
	
	    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, toID, nativeEvent, nativeEventTarget);
	    enter.type = 'mouseenter';
	    enter.target = to;
	    enter.relatedTarget = from;
	
	    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, fromID, toID);
	
	    extractedEvents[0] = leave;
	    extractedEvents[1] = enter;
	
	    return extractedEvents;
	  }
	
	};
	
	module.exports = EnterLeaveEventPlugin;

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticMouseEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(94);
	var ViewportMetrics = __webpack_require__(45);
	
	var getEventModifierState = __webpack_require__(95);
	
	/**
	 * @interface MouseEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var MouseEventInterface = {
	  screenX: null,
	  screenY: null,
	  clientX: null,
	  clientY: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  getModifierState: getEventModifierState,
	  button: function button(event) {
	    // Webkit, Firefox, IE9+
	    // which:  1 2 3
	    // button: 0 1 2 (standard)
	    var button = event.button;
	    if ('which' in event) {
	      return button;
	    }
	    // IE<9
	    // which:  undefined
	    // button: 0 0 0
	    // button: 1 4 2 (onmouseup)
	    return button === 2 ? 2 : button === 4 ? 1 : 0;
	  },
	  buttons: null,
	  relatedTarget: function relatedTarget(event) {
	    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
	  },
	  // "Proprietary" Interface.
	  pageX: function pageX(event) {
	    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
	  },
	  pageY: function pageY(event) {
	    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);
	
	module.exports = SyntheticMouseEvent;

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticUIEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(84);
	
	var getEventTarget = __webpack_require__(88);
	
	/**
	 * @interface UIEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var UIEventInterface = {
	  view: function view(event) {
	    if (event.view) {
	      return event.view;
	    }
	
	    var target = getEventTarget(event);
	    if (target != null && target.window === target) {
	      // target is a window object
	      return target;
	    }
	
	    var doc = target.ownerDocument;
	    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	    if (doc) {
	      return doc.defaultView || doc.parentWindow;
	    } else {
	      return window;
	    }
	  },
	  detail: function detail(event) {
	    return event.detail || 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);
	
	module.exports = SyntheticUIEvent;

/***/ },
/* 95 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventModifierState
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Translation from modifier key to the associated property in the event.
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
	 */
	
	var modifierKeyToProp = {
	  'Alt': 'altKey',
	  'Control': 'ctrlKey',
	  'Meta': 'metaKey',
	  'Shift': 'shiftKey'
	};
	
	// IE8 does not implement getModifierState so we simply map it to the only
	// modifier keys exposed by the event itself, does not support Lock-keys.
	// Currently, all major browsers except Chrome seems to support Lock-keys.
	function modifierStateGetter(keyArg) {
	  var syntheticEvent = this;
	  var nativeEvent = syntheticEvent.nativeEvent;
	  if (nativeEvent.getModifierState) {
	    return nativeEvent.getModifierState(keyArg);
	  }
	  var keyProp = modifierKeyToProp[keyArg];
	  return keyProp ? !!nativeEvent[keyProp] : false;
	}
	
	function getEventModifierState(nativeEvent) {
	  return modifierStateGetter;
	}
	
	module.exports = getEventModifierState;

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule HTMLDOMPropertyConfig
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(30);
	var ExecutionEnvironment = __webpack_require__(16);
	
	var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
	var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
	var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
	var HAS_SIDE_EFFECTS = DOMProperty.injection.HAS_SIDE_EFFECTS;
	var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
	var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
	var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;
	
	var hasSVG;
	if (ExecutionEnvironment.canUseDOM) {
	  var implementation = document.implementation;
	  hasSVG = implementation && implementation.hasFeature && implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1');
	}
	
	var HTMLDOMPropertyConfig = {
	  isCustomAttribute: RegExp.prototype.test.bind(/^(data|aria)-[a-z_][a-z\d_.\-]*$/),
	  Properties: {
	    /**
	     * Standard Properties
	     */
	    accept: null,
	    acceptCharset: null,
	    accessKey: null,
	    action: null,
	    allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    allowTransparency: MUST_USE_ATTRIBUTE,
	    alt: null,
	    async: HAS_BOOLEAN_VALUE,
	    autoComplete: null,
	    // autoFocus is polyfilled/normalized by AutoFocusUtils
	    // autoFocus: HAS_BOOLEAN_VALUE,
	    autoPlay: HAS_BOOLEAN_VALUE,
	    capture: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    cellPadding: null,
	    cellSpacing: null,
	    charSet: MUST_USE_ATTRIBUTE,
	    challenge: MUST_USE_ATTRIBUTE,
	    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    classID: MUST_USE_ATTRIBUTE,
	    // To set className on SVG elements, it's necessary to use .setAttribute;
	    // this works on HTML elements too in all browsers except IE8. Conveniently,
	    // IE8 doesn't support SVG and so we can simply use the attribute in
	    // browsers that support SVG and the property in browsers that don't,
	    // regardless of whether the element is HTML or SVG.
	    className: hasSVG ? MUST_USE_ATTRIBUTE : MUST_USE_PROPERTY,
	    cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
	    colSpan: null,
	    content: null,
	    contentEditable: null,
	    contextMenu: MUST_USE_ATTRIBUTE,
	    controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    coords: null,
	    crossOrigin: null,
	    data: null, // For `<object />` acts as `src`.
	    dateTime: MUST_USE_ATTRIBUTE,
	    'default': HAS_BOOLEAN_VALUE,
	    defer: HAS_BOOLEAN_VALUE,
	    dir: null,
	    disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    download: HAS_OVERLOADED_BOOLEAN_VALUE,
	    draggable: null,
	    encType: null,
	    form: MUST_USE_ATTRIBUTE,
	    formAction: MUST_USE_ATTRIBUTE,
	    formEncType: MUST_USE_ATTRIBUTE,
	    formMethod: MUST_USE_ATTRIBUTE,
	    formNoValidate: HAS_BOOLEAN_VALUE,
	    formTarget: MUST_USE_ATTRIBUTE,
	    frameBorder: MUST_USE_ATTRIBUTE,
	    headers: null,
	    height: MUST_USE_ATTRIBUTE,
	    hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    high: null,
	    href: null,
	    hrefLang: null,
	    htmlFor: null,
	    httpEquiv: null,
	    icon: null,
	    id: MUST_USE_PROPERTY,
	    inputMode: MUST_USE_ATTRIBUTE,
	    integrity: null,
	    is: MUST_USE_ATTRIBUTE,
	    keyParams: MUST_USE_ATTRIBUTE,
	    keyType: MUST_USE_ATTRIBUTE,
	    kind: null,
	    label: null,
	    lang: null,
	    list: MUST_USE_ATTRIBUTE,
	    loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    low: null,
	    manifest: MUST_USE_ATTRIBUTE,
	    marginHeight: null,
	    marginWidth: null,
	    max: null,
	    maxLength: MUST_USE_ATTRIBUTE,
	    media: MUST_USE_ATTRIBUTE,
	    mediaGroup: null,
	    method: null,
	    min: null,
	    minLength: MUST_USE_ATTRIBUTE,
	    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    name: null,
	    nonce: MUST_USE_ATTRIBUTE,
	    noValidate: HAS_BOOLEAN_VALUE,
	    open: HAS_BOOLEAN_VALUE,
	    optimum: null,
	    pattern: null,
	    placeholder: null,
	    poster: null,
	    preload: null,
	    radioGroup: null,
	    readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    rel: null,
	    required: HAS_BOOLEAN_VALUE,
	    reversed: HAS_BOOLEAN_VALUE,
	    role: MUST_USE_ATTRIBUTE,
	    rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
	    rowSpan: null,
	    sandbox: null,
	    scope: null,
	    scoped: HAS_BOOLEAN_VALUE,
	    scrolling: null,
	    seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    shape: null,
	    size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
	    sizes: MUST_USE_ATTRIBUTE,
	    span: HAS_POSITIVE_NUMERIC_VALUE,
	    spellCheck: null,
	    src: null,
	    srcDoc: MUST_USE_PROPERTY,
	    srcLang: null,
	    srcSet: MUST_USE_ATTRIBUTE,
	    start: HAS_NUMERIC_VALUE,
	    step: null,
	    style: null,
	    summary: null,
	    tabIndex: null,
	    target: null,
	    title: null,
	    type: null,
	    useMap: null,
	    value: MUST_USE_PROPERTY | HAS_SIDE_EFFECTS,
	    width: MUST_USE_ATTRIBUTE,
	    wmode: MUST_USE_ATTRIBUTE,
	    wrap: null,
	
	    /**
	     * RDFa Properties
	     */
	    about: MUST_USE_ATTRIBUTE,
	    datatype: MUST_USE_ATTRIBUTE,
	    inlist: MUST_USE_ATTRIBUTE,
	    prefix: MUST_USE_ATTRIBUTE,
	    // property is also supported for OpenGraph in meta tags.
	    property: MUST_USE_ATTRIBUTE,
	    resource: MUST_USE_ATTRIBUTE,
	    'typeof': MUST_USE_ATTRIBUTE,
	    vocab: MUST_USE_ATTRIBUTE,
	
	    /**
	     * Non-standard Properties
	     */
	    // autoCapitalize and autoCorrect are supported in Mobile Safari for
	    // keyboard hints.
	    autoCapitalize: MUST_USE_ATTRIBUTE,
	    autoCorrect: MUST_USE_ATTRIBUTE,
	    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
	    autoSave: null,
	    // color is for Safari mask-icon link
	    color: null,
	    // itemProp, itemScope, itemType are for
	    // Microdata support. See http://schema.org/docs/gs.html
	    itemProp: MUST_USE_ATTRIBUTE,
	    itemScope: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    itemType: MUST_USE_ATTRIBUTE,
	    // itemID and itemRef are for Microdata support as well but
	    // only specified in the the WHATWG spec document. See
	    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
	    itemID: MUST_USE_ATTRIBUTE,
	    itemRef: MUST_USE_ATTRIBUTE,
	    // results show looking glass icon and recent searches on input
	    // search fields in WebKit/Blink
	    results: null,
	    // IE-only attribute that specifies security restrictions on an iframe
	    // as an alternative to the sandbox attribute on IE<10
	    security: MUST_USE_ATTRIBUTE,
	    // IE-only attribute that controls focus behavior
	    unselectable: MUST_USE_ATTRIBUTE
	  },
	  DOMAttributeNames: {
	    acceptCharset: 'accept-charset',
	    className: 'class',
	    htmlFor: 'for',
	    httpEquiv: 'http-equiv'
	  },
	  DOMPropertyNames: {
	    autoComplete: 'autocomplete',
	    autoFocus: 'autofocus',
	    autoPlay: 'autoplay',
	    autoSave: 'autosave',
	    // `encoding` is equivalent to `enctype`, IE8 lacks an `enctype` setter.
	    // http://www.w3.org/TR/html5/forms.html#dom-fs-encoding
	    encType: 'encoding',
	    hrefLang: 'hreflang',
	    radioGroup: 'radiogroup',
	    spellCheck: 'spellcheck',
	    srcDoc: 'srcdoc',
	    srcSet: 'srcset'
	  }
	};
	
	module.exports = HTMLDOMPropertyConfig;

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactBrowserComponentMixin
	 */
	
	'use strict';
	
	var ReactInstanceMap = __webpack_require__(54);
	
	var findDOMNode = __webpack_require__(98);
	var warning = __webpack_require__(32);
	
	var didWarnKey = '_getDOMNodeDidWarn';
	
	var ReactBrowserComponentMixin = {
	  /**
	   * Returns the DOM node rendered by this component.
	   *
	   * @return {DOMElement} The root node of this component.
	   * @final
	   * @protected
	   */
	  getDOMNode: function getDOMNode() {
	    process.env.NODE_ENV !== 'production' ? warning(this.constructor[didWarnKey], '%s.getDOMNode(...) is deprecated. Please use ' + 'ReactDOM.findDOMNode(instance) instead.', ReactInstanceMap.get(this).getName() || this.tagName || 'Unknown') : undefined;
	    this.constructor[didWarnKey] = true;
	    return findDOMNode(this);
	  }
	};
	
	module.exports = ReactBrowserComponentMixin;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule findDOMNode
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(12);
	var ReactInstanceMap = __webpack_require__(54);
	var ReactMount = __webpack_require__(35);
	
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	/**
	 * Returns the DOM node rendered by this element.
	 *
	 * @param {ReactComponent|DOMElement} componentOrElement
	 * @return {?DOMElement} The root node of this element.
	 */
	function findDOMNode(componentOrElement) {
	  if (process.env.NODE_ENV !== 'production') {
	    var owner = ReactCurrentOwner.current;
	    if (owner !== null) {
	      process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing getDOMNode or findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
	      owner._warnedAboutRefsInRender = true;
	    }
	  }
	  if (componentOrElement == null) {
	    return null;
	  }
	  if (componentOrElement.nodeType === 1) {
	    return componentOrElement;
	  }
	  if (ReactInstanceMap.has(componentOrElement)) {
	    return ReactMount.getNodeFromInstance(componentOrElement);
	  }
	  !(componentOrElement.render == null || typeof componentOrElement.render !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : invariant(false) : undefined;
	   true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : invariant(false) : undefined;
	}
	
	module.exports = findDOMNode;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultBatchingStrategy
	 */
	
	'use strict';
	
	var ReactUpdates = __webpack_require__(61);
	var Transaction = __webpack_require__(64);
	
	var assign = __webpack_require__(46);
	var emptyFunction = __webpack_require__(22);
	
	var RESET_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: function close() {
	    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
	  }
	};
	
	var FLUSH_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
	};
	
	var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];
	
	function ReactDefaultBatchingStrategyTransaction() {
	  this.reinitializeTransaction();
	}
	
	assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin, {
	  getTransactionWrappers: function getTransactionWrappers() {
	    return TRANSACTION_WRAPPERS;
	  }
	});
	
	var transaction = new ReactDefaultBatchingStrategyTransaction();
	
	var ReactDefaultBatchingStrategy = {
	  isBatchingUpdates: false,
	
	  /**
	   * Call the provided function in a context within which calls to `setState`
	   * and friends are batched such that components aren't updated unnecessarily.
	   */
	  batchedUpdates: function batchedUpdates(callback, a, b, c, d, e) {
	    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;
	
	    ReactDefaultBatchingStrategy.isBatchingUpdates = true;
	
	    // The code is written this way to avoid extra allocations
	    if (alreadyBatchingUpdates) {
	      callback(a, b, c, d, e);
	    } else {
	      transaction.perform(callback, null, a, b, c, d, e);
	    }
	  }
	};
	
	module.exports = ReactDefaultBatchingStrategy;

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMComponent
	 * @typechecks static-only
	 */
	
	/* global hasOwnProperty:true */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var AutoFocusUtils = __webpack_require__(101);
	var CSSPropertyOperations = __webpack_require__(103);
	var DOMProperty = __webpack_require__(30);
	var DOMPropertyOperations = __webpack_require__(29);
	var EventConstants = __webpack_require__(37);
	var ReactBrowserEventEmitter = __webpack_require__(36);
	var ReactComponentBrowserEnvironment = __webpack_require__(33);
	var ReactDOMButton = __webpack_require__(111);
	var ReactDOMInput = __webpack_require__(112);
	var ReactDOMOption = __webpack_require__(116);
	var ReactDOMSelect = __webpack_require__(119);
	var ReactDOMTextarea = __webpack_require__(120);
	var ReactMount = __webpack_require__(35);
	var ReactMultiChild = __webpack_require__(121);
	var ReactPerf = __webpack_require__(25);
	var ReactUpdateQueue = __webpack_require__(60);
	
	var assign = __webpack_require__(46);
	var canDefineProperty = __webpack_require__(50);
	var escapeTextContentForBrowser = __webpack_require__(28);
	var invariant = __webpack_require__(20);
	var isEventSupported = __webpack_require__(47);
	var keyOf = __webpack_require__(86);
	var setInnerHTML = __webpack_require__(26);
	var setTextContent = __webpack_require__(27);
	var shallowEqual = __webpack_require__(124);
	var validateDOMNesting = __webpack_require__(77);
	var warning = __webpack_require__(32);
	
	var deleteListener = ReactBrowserEventEmitter.deleteListener;
	var listenTo = ReactBrowserEventEmitter.listenTo;
	var registrationNameModules = ReactBrowserEventEmitter.registrationNameModules;
	
	// For quickly matching children type, to test if can be treated as content.
	var CONTENT_TYPES = { 'string': true, 'number': true };
	
	var CHILDREN = keyOf({ children: null });
	var STYLE = keyOf({ style: null });
	var HTML = keyOf({ __html: null });
	
	var ELEMENT_NODE_TYPE = 1;
	
	function getDeclarationErrorAddendum(internalInstance) {
	  if (internalInstance) {
	    var owner = internalInstance._currentElement._owner || null;
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' This DOM node was rendered by `' + name + '`.';
	      }
	    }
	  }
	  return '';
	}
	
	var legacyPropsDescriptor;
	if (process.env.NODE_ENV !== 'production') {
	  legacyPropsDescriptor = {
	    props: {
	      enumerable: false,
	      get: function get() {
	        var component = this._reactInternalComponent;
	        process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .props of a DOM node; instead, ' + 'recreate the props as `render` did originally or read the DOM ' + 'properties/attributes directly from this node (e.g., ' + 'this.refs.box.className).%s', getDeclarationErrorAddendum(component)) : undefined;
	        return component._currentElement.props;
	      }
	    }
	  };
	}
	
	function legacyGetDOMNode() {
	  if (process.env.NODE_ENV !== 'production') {
	    var component = this._reactInternalComponent;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .getDOMNode() of a DOM node; ' + 'instead, use the node directly.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  return this;
	}
	
	function legacyIsMounted() {
	  var component = this._reactInternalComponent;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .isMounted() of a DOM node.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  return !!component;
	}
	
	function legacySetStateEtc() {
	  if (process.env.NODE_ENV !== 'production') {
	    var component = this._reactInternalComponent;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setState(), .replaceState(), or ' + '.forceUpdate() of a DOM node. This is a no-op.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	}
	
	function legacySetProps(partialProps, callback) {
	  var component = this._reactInternalComponent;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setProps() of a DOM node. ' + 'Instead, call ReactDOM.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  if (!component) {
	    return;
	  }
	  ReactUpdateQueue.enqueueSetPropsInternal(component, partialProps);
	  if (callback) {
	    ReactUpdateQueue.enqueueCallbackInternal(component, callback);
	  }
	}
	
	function legacyReplaceProps(partialProps, callback) {
	  var component = this._reactInternalComponent;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .replaceProps() of a DOM node. ' + 'Instead, call ReactDOM.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  if (!component) {
	    return;
	  }
	  ReactUpdateQueue.enqueueReplacePropsInternal(component, partialProps);
	  if (callback) {
	    ReactUpdateQueue.enqueueCallbackInternal(component, callback);
	  }
	}
	
	function friendlyStringify(obj) {
	  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
	    if (Array.isArray(obj)) {
	      return '[' + obj.map(friendlyStringify).join(', ') + ']';
	    } else {
	      var pairs = [];
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) {
	          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
	          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
	        }
	      }
	      return '{' + pairs.join(', ') + '}';
	    }
	  } else if (typeof obj === 'string') {
	    return JSON.stringify(obj);
	  } else if (typeof obj === 'function') {
	    return '[function object]';
	  }
	  // Differs from JSON.stringify in that undefined becauses undefined and that
	  // inf and nan don't become null
	  return String(obj);
	}
	
	var styleMutationWarning = {};
	
	function checkAndWarnForMutatedStyle(style1, style2, component) {
	  if (style1 == null || style2 == null) {
	    return;
	  }
	  if (shallowEqual(style1, style2)) {
	    return;
	  }
	
	  var componentName = component._tag;
	  var owner = component._currentElement._owner;
	  var ownerName;
	  if (owner) {
	    ownerName = owner.getName();
	  }
	
	  var hash = ownerName + '|' + componentName;
	
	  if (styleMutationWarning.hasOwnProperty(hash)) {
	    return;
	  }
	
	  styleMutationWarning[hash] = true;
	
	  process.env.NODE_ENV !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : undefined;
	}
	
	/**
	 * @param {object} component
	 * @param {?object} props
	 */
	function assertValidProps(component, props) {
	  if (!props) {
	    return;
	  }
	  // Note the use of `==` which checks for null or undefined.
	  if (process.env.NODE_ENV !== 'production') {
	    if (voidElementTags[component._tag]) {
	      process.env.NODE_ENV !== 'production' ? warning(props.children == null && props.dangerouslySetInnerHTML == null, '%s is a void element tag and must not have `children` or ' + 'use `props.dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : undefined;
	    }
	  }
	  if (props.dangerouslySetInnerHTML != null) {
	    !(props.children == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : invariant(false) : undefined;
	    !(_typeof(props.dangerouslySetInnerHTML) === 'object' && HTML in props.dangerouslySetInnerHTML) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. ' + 'Please visit https://fb.me/react-invariant-dangerously-set-inner-html ' + 'for more information.') : invariant(false) : undefined;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : undefined;
	    process.env.NODE_ENV !== 'production' ? warning(!props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : undefined;
	  }
	  !(props.style == null || _typeof(props.style) === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, ' + 'not a string. For example, style={{marginRight: spacing + \'em\'}} when ' + 'using JSX.%s', getDeclarationErrorAddendum(component)) : invariant(false) : undefined;
	}
	
	function enqueuePutListener(id, registrationName, listener, transaction) {
	  if (process.env.NODE_ENV !== 'production') {
	    // IE8 has no API for event capturing and the `onScroll` event doesn't
	    // bubble.
	    process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : undefined;
	  }
	  var container = ReactMount.findReactContainerForID(id);
	  if (container) {
	    var doc = container.nodeType === ELEMENT_NODE_TYPE ? container.ownerDocument : container;
	    listenTo(registrationName, doc);
	  }
	  transaction.getReactMountReady().enqueue(putListener, {
	    id: id,
	    registrationName: registrationName,
	    listener: listener
	  });
	}
	
	function putListener() {
	  var listenerToPut = this;
	  ReactBrowserEventEmitter.putListener(listenerToPut.id, listenerToPut.registrationName, listenerToPut.listener);
	}
	
	// There are so many media events, it makes sense to just
	// maintain a list rather than create a `trapBubbledEvent` for each
	var mediaEvents = {
	  topAbort: 'abort',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTimeUpdate: 'timeupdate',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting'
	};
	
	function trapBubbledEventsLocal() {
	  var inst = this;
	  // If a component renders to null or if another component fatals and causes
	  // the state of the tree to be corrupted, `node` here can be null.
	  !inst._rootNodeID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Must be mounted to trap events') : invariant(false) : undefined;
	  var node = ReactMount.getNode(inst._rootNodeID);
	  !node ? process.env.NODE_ENV !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : invariant(false) : undefined;
	
	  switch (inst._tag) {
	    case 'iframe':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
	      break;
	    case 'video':
	    case 'audio':
	
	      inst._wrapperState.listeners = [];
	      // create listener for each media event
	      for (var event in mediaEvents) {
	        if (mediaEvents.hasOwnProperty(event)) {
	          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes[event], mediaEvents[event], node));
	        }
	      }
	
	      break;
	    case 'img':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
	      break;
	    case 'form':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit', node)];
	      break;
	  }
	}
	
	function mountReadyInputWrapper() {
	  ReactDOMInput.mountReadyWrapper(this);
	}
	
	function postUpdateSelectWrapper() {
	  ReactDOMSelect.postUpdateWrapper(this);
	}
	
	// For HTML, certain tags should omit their close tag. We keep a whitelist for
	// those special cased tags.
	
	var omittedCloseTags = {
	  'area': true,
	  'base': true,
	  'br': true,
	  'col': true,
	  'embed': true,
	  'hr': true,
	  'img': true,
	  'input': true,
	  'keygen': true,
	  'link': true,
	  'meta': true,
	  'param': true,
	  'source': true,
	  'track': true,
	  'wbr': true
	};
	
	// NOTE: menuitem's close tag should be omitted, but that causes problems.
	var newlineEatingTags = {
	  'listing': true,
	  'pre': true,
	  'textarea': true
	};
	
	// For HTML, certain tags cannot have children. This has the same purpose as
	// `omittedCloseTags` except that `menuitem` should still have its closing tag.
	
	var voidElementTags = assign({
	  'menuitem': true
	}, omittedCloseTags);
	
	// We accept any tag to be rendered but since this gets injected into arbitrary
	// HTML, we want to make sure that it's a safe tag.
	// http://www.w3.org/TR/REC-xml/#NT-Name
	
	var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
	var validatedTagCache = {};
	var hasOwnProperty = {}.hasOwnProperty;
	
	function validateDangerousTag(tag) {
	  if (!hasOwnProperty.call(validatedTagCache, tag)) {
	    !VALID_TAG_REGEX.test(tag) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : invariant(false) : undefined;
	    validatedTagCache[tag] = true;
	  }
	}
	
	function processChildContextDev(context, inst) {
	  // Pass down our tag name to child components for validation purposes
	  context = assign({}, context);
	  var info = context[validateDOMNesting.ancestorInfoContextKey];
	  context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(info, inst._tag, inst);
	  return context;
	}
	
	function isCustomComponent(tagName, props) {
	  return tagName.indexOf('-') >= 0 || props.is != null;
	}
	
	/**
	 * Creates a new React class that is idempotent and capable of containing other
	 * React components. It accepts event listeners and DOM properties that are
	 * valid according to `DOMProperty`.
	 *
	 *  - Event listeners: `onClick`, `onMouseDown`, etc.
	 *  - DOM properties: `className`, `name`, `title`, etc.
	 *
	 * The `style` property functions differently from the DOM API. It accepts an
	 * object mapping of style properties to values.
	 *
	 * @constructor ReactDOMComponent
	 * @extends ReactMultiChild
	 */
	function ReactDOMComponent(tag) {
	  validateDangerousTag(tag);
	  this._tag = tag.toLowerCase();
	  this._renderedChildren = null;
	  this._previousStyle = null;
	  this._previousStyleCopy = null;
	  this._rootNodeID = null;
	  this._wrapperState = null;
	  this._topLevelWrapper = null;
	  this._nodeWithLegacyProperties = null;
	  if (process.env.NODE_ENV !== 'production') {
	    this._unprocessedContextDev = null;
	    this._processedContextDev = null;
	  }
	}
	
	ReactDOMComponent.displayName = 'ReactDOMComponent';
	
	ReactDOMComponent.Mixin = {
	
	  construct: function construct(element) {
	    this._currentElement = element;
	  },
	
	  /**
	   * Generates root tag markup then recurses. This method has side effects and
	   * is not idempotent.
	   *
	   * @internal
	   * @param {string} rootID The root DOM ID for this node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} context
	   * @return {string} The computed markup.
	   */
	  mountComponent: function mountComponent(rootID, transaction, context) {
	    this._rootNodeID = rootID;
	
	    var props = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'iframe':
	      case 'img':
	      case 'form':
	      case 'video':
	      case 'audio':
	        this._wrapperState = {
	          listeners: null
	        };
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'button':
	        props = ReactDOMButton.getNativeProps(this, props, context);
	        break;
	      case 'input':
	        ReactDOMInput.mountWrapper(this, props, context);
	        props = ReactDOMInput.getNativeProps(this, props, context);
	        break;
	      case 'option':
	        ReactDOMOption.mountWrapper(this, props, context);
	        props = ReactDOMOption.getNativeProps(this, props, context);
	        break;
	      case 'select':
	        ReactDOMSelect.mountWrapper(this, props, context);
	        props = ReactDOMSelect.getNativeProps(this, props, context);
	        context = ReactDOMSelect.processChildContext(this, props, context);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.mountWrapper(this, props, context);
	        props = ReactDOMTextarea.getNativeProps(this, props, context);
	        break;
	    }
	
	    assertValidProps(this, props);
	    if (process.env.NODE_ENV !== 'production') {
	      if (context[validateDOMNesting.ancestorInfoContextKey]) {
	        validateDOMNesting(this._tag, this, context[validateDOMNesting.ancestorInfoContextKey]);
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      this._unprocessedContextDev = context;
	      this._processedContextDev = processChildContextDev(context, this);
	      context = this._processedContextDev;
	    }
	
	    var mountImage;
	    if (transaction.useCreateElement) {
	      var ownerDocument = context[ReactMount.ownerDocumentContextKey];
	      var el = ownerDocument.createElement(this._currentElement.type);
	      DOMPropertyOperations.setAttributeForID(el, this._rootNodeID);
	      // Populate node cache
	      ReactMount.getID(el);
	      this._updateDOMProperties({}, props, transaction, el);
	      this._createInitialChildren(transaction, props, context, el);
	      mountImage = el;
	    } else {
	      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
	      var tagContent = this._createContentMarkup(transaction, props, context);
	      if (!tagContent && omittedCloseTags[this._tag]) {
	        mountImage = tagOpen + '/>';
	      } else {
	        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
	      }
	    }
	
	    switch (this._tag) {
	      case 'input':
	        transaction.getReactMountReady().enqueue(mountReadyInputWrapper, this);
	      // falls through
	      case 'button':
	      case 'select':
	      case 'textarea':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	    }
	
	    return mountImage;
	  },
	
	  /**
	   * Creates markup for the open tag and all attributes.
	   *
	   * This method has side effects because events get registered.
	   *
	   * Iterating over object properties is faster than iterating over arrays.
	   * @see http://jsperf.com/obj-vs-arr-iteration
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @return {string} Markup of opening tag.
	   */
	  _createOpenTagMarkupAndPutListeners: function _createOpenTagMarkupAndPutListeners(transaction, props) {
	    var ret = '<' + this._currentElement.type;
	
	    for (var propKey in props) {
	      if (!props.hasOwnProperty(propKey)) {
	        continue;
	      }
	      var propValue = props[propKey];
	      if (propValue == null) {
	        continue;
	      }
	      if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (propValue) {
	          enqueuePutListener(this._rootNodeID, propKey, propValue, transaction);
	        }
	      } else {
	        if (propKey === STYLE) {
	          if (propValue) {
	            if (process.env.NODE_ENV !== 'production') {
	              // See `_updateDOMProperties`. style block
	              this._previousStyle = propValue;
	            }
	            propValue = this._previousStyleCopy = assign({}, props.style);
	          }
	          propValue = CSSPropertyOperations.createMarkupForStyles(propValue);
	        }
	        var markup = null;
	        if (this._tag != null && isCustomComponent(this._tag, props)) {
	          if (propKey !== CHILDREN) {
	            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
	          }
	        } else {
	          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
	        }
	        if (markup) {
	          ret += ' ' + markup;
	        }
	      }
	    }
	
	    // For static pages, no need to put React ID and checksum. Saves lots of
	    // bytes.
	    if (transaction.renderToStaticMarkup) {
	      return ret;
	    }
	
	    var markupForID = DOMPropertyOperations.createMarkupForID(this._rootNodeID);
	    return ret + ' ' + markupForID;
	  },
	
	  /**
	   * Creates markup for the content between the tags.
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @param {object} context
	   * @return {string} Content markup.
	   */
	  _createContentMarkup: function _createContentMarkup(transaction, props, context) {
	    var ret = '';
	
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        ret = innerHTML.__html;
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[_typeof(props.children)] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        ret = escapeTextContentForBrowser(contentToUse);
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        ret = mountImages.join('');
	      }
	    }
	    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
	      // text/html ignores the first character in these tags if it's a newline
	      // Prefer to break application/xml over text/html (for now) by adding
	      // a newline specifically to get eaten by the parser. (Alternately for
	      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
	      // \r is normalized out by HTMLTextAreaElement#value.)
	      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
	      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
	      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
	      // See: Parsing of "textarea" "listing" and "pre" elements
	      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
	      return '\n' + ret;
	    } else {
	      return ret;
	    }
	  },
	
	  _createInitialChildren: function _createInitialChildren(transaction, props, context, el) {
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        setInnerHTML(el, innerHTML.__html);
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[_typeof(props.children)] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        setTextContent(el, contentToUse);
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        for (var i = 0; i < mountImages.length; i++) {
	          el.appendChild(mountImages[i]);
	        }
	      }
	    }
	  },
	
	  /**
	   * Receives a next element and updates the component.
	   *
	   * @internal
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} context
	   */
	  receiveComponent: function receiveComponent(nextElement, transaction, context) {
	    var prevElement = this._currentElement;
	    this._currentElement = nextElement;
	    this.updateComponent(transaction, prevElement, nextElement, context);
	  },
	
	  /**
	   * Updates a native DOM component after it has already been allocated and
	   * attached to the DOM. Reconciles the root DOM node, then recurses.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevElement
	   * @param {ReactElement} nextElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function updateComponent(transaction, prevElement, nextElement, context) {
	    var lastProps = prevElement.props;
	    var nextProps = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'button':
	        lastProps = ReactDOMButton.getNativeProps(this, lastProps);
	        nextProps = ReactDOMButton.getNativeProps(this, nextProps);
	        break;
	      case 'input':
	        ReactDOMInput.updateWrapper(this);
	        lastProps = ReactDOMInput.getNativeProps(this, lastProps);
	        nextProps = ReactDOMInput.getNativeProps(this, nextProps);
	        break;
	      case 'option':
	        lastProps = ReactDOMOption.getNativeProps(this, lastProps);
	        nextProps = ReactDOMOption.getNativeProps(this, nextProps);
	        break;
	      case 'select':
	        lastProps = ReactDOMSelect.getNativeProps(this, lastProps);
	        nextProps = ReactDOMSelect.getNativeProps(this, nextProps);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.updateWrapper(this);
	        lastProps = ReactDOMTextarea.getNativeProps(this, lastProps);
	        nextProps = ReactDOMTextarea.getNativeProps(this, nextProps);
	        break;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // If the context is reference-equal to the old one, pass down the same
	      // processed object so the update bailout in ReactReconciler behaves
	      // correctly (and identically in dev and prod). See #5005.
	      if (this._unprocessedContextDev !== context) {
	        this._unprocessedContextDev = context;
	        this._processedContextDev = processChildContextDev(context, this);
	      }
	      context = this._processedContextDev;
	    }
	
	    assertValidProps(this, nextProps);
	    this._updateDOMProperties(lastProps, nextProps, transaction, null);
	    this._updateDOMChildren(lastProps, nextProps, transaction, context);
	
	    if (!canDefineProperty && this._nodeWithLegacyProperties) {
	      this._nodeWithLegacyProperties.props = nextProps;
	    }
	
	    if (this._tag === 'select') {
	      // <select> value update needs to occur after <option> children
	      // reconciliation
	      transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
	    }
	  },
	
	  /**
	   * Reconciles the properties by detecting differences in property values and
	   * updating the DOM as necessary. This function is probably the single most
	   * critical path for performance optimization.
	   *
	   * TODO: Benchmark whether checking for changed values in memory actually
	   *       improves performance (especially statically positioned elements).
	   * TODO: Benchmark the effects of putting this at the top since 99% of props
	   *       do not change for a given reconciliation.
	   * TODO: Benchmark areas that can be improved with caching.
	   *
	   * @private
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {ReactReconcileTransaction} transaction
	   * @param {?DOMElement} node
	   */
	  _updateDOMProperties: function _updateDOMProperties(lastProps, nextProps, transaction, node) {
	    var propKey;
	    var styleName;
	    var styleUpdates;
	    for (propKey in lastProps) {
	      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey)) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        var lastStyle = this._previousStyleCopy;
	        for (styleName in lastStyle) {
	          if (lastStyle.hasOwnProperty(styleName)) {
	            styleUpdates = styleUpdates || {};
	            styleUpdates[styleName] = '';
	          }
	        }
	        this._previousStyleCopy = null;
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (lastProps[propKey]) {
	          // Only call deleteListener if there was a listener previously or
	          // else willDeleteListener gets called when there wasn't actually a
	          // listener (e.g., onClick={null})
	          deleteListener(this._rootNodeID, propKey);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        if (!node) {
	          node = ReactMount.getNode(this._rootNodeID);
	        }
	        DOMPropertyOperations.deleteValueForProperty(node, propKey);
	      }
	    }
	    for (propKey in nextProps) {
	      var nextProp = nextProps[propKey];
	      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps[propKey];
	      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        if (nextProp) {
	          if (process.env.NODE_ENV !== 'production') {
	            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
	            this._previousStyle = nextProp;
	          }
	          nextProp = this._previousStyleCopy = assign({}, nextProp);
	        } else {
	          this._previousStyleCopy = null;
	        }
	        if (lastProp) {
	          // Unset styles on `lastProp` but not on `nextProp`.
	          for (styleName in lastProp) {
	            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = '';
	            }
	          }
	          // Update styles that changed since `lastProp`.
	          for (styleName in nextProp) {
	            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = nextProp[styleName];
	            }
	          }
	        } else {
	          // Relies on `updateStylesByID` not mutating `styleUpdates`.
	          styleUpdates = nextProp;
	        }
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (nextProp) {
	          enqueuePutListener(this._rootNodeID, propKey, nextProp, transaction);
	        } else if (lastProp) {
	          deleteListener(this._rootNodeID, propKey);
	        }
	      } else if (isCustomComponent(this._tag, nextProps)) {
	        if (!node) {
	          node = ReactMount.getNode(this._rootNodeID);
	        }
	        if (propKey === CHILDREN) {
	          nextProp = null;
	        }
	        DOMPropertyOperations.setValueForAttribute(node, propKey, nextProp);
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        if (!node) {
	          node = ReactMount.getNode(this._rootNodeID);
	        }
	        // If we're updating to null or undefined, we should remove the property
	        // from the DOM node instead of inadvertantly setting to a string. This
	        // brings us in line with the same behavior we have on initial render.
	        if (nextProp != null) {
	          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
	        } else {
	          DOMPropertyOperations.deleteValueForProperty(node, propKey);
	        }
	      }
	    }
	    if (styleUpdates) {
	      if (!node) {
	        node = ReactMount.getNode(this._rootNodeID);
	      }
	      CSSPropertyOperations.setValueForStyles(node, styleUpdates);
	    }
	  },
	
	  /**
	   * Reconciles the children with the various properties that affect the
	   * children content.
	   *
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   */
	  _updateDOMChildren: function _updateDOMChildren(lastProps, nextProps, transaction, context) {
	    var lastContent = CONTENT_TYPES[_typeof(lastProps.children)] ? lastProps.children : null;
	    var nextContent = CONTENT_TYPES[_typeof(nextProps.children)] ? nextProps.children : null;
	
	    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
	    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;
	
	    // Note the use of `!=` which checks for null or undefined.
	    var lastChildren = lastContent != null ? null : lastProps.children;
	    var nextChildren = nextContent != null ? null : nextProps.children;
	
	    // If we're switching from children to content/html or vice versa, remove
	    // the old content
	    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
	    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
	    if (lastChildren != null && nextChildren == null) {
	      this.updateChildren(null, transaction, context);
	    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
	      this.updateTextContent('');
	    }
	
	    if (nextContent != null) {
	      if (lastContent !== nextContent) {
	        this.updateTextContent('' + nextContent);
	      }
	    } else if (nextHtml != null) {
	      if (lastHtml !== nextHtml) {
	        this.updateMarkup('' + nextHtml);
	      }
	    } else if (nextChildren != null) {
	      this.updateChildren(nextChildren, transaction, context);
	    }
	  },
	
	  /**
	   * Destroys all event registrations for this instance. Does not remove from
	   * the DOM. That must be done by the parent.
	   *
	   * @internal
	   */
	  unmountComponent: function unmountComponent() {
	    switch (this._tag) {
	      case 'iframe':
	      case 'img':
	      case 'form':
	      case 'video':
	      case 'audio':
	        var listeners = this._wrapperState.listeners;
	        if (listeners) {
	          for (var i = 0; i < listeners.length; i++) {
	            listeners[i].remove();
	          }
	        }
	        break;
	      case 'input':
	        ReactDOMInput.unmountWrapper(this);
	        break;
	      case 'html':
	      case 'head':
	      case 'body':
	        /**
	         * Components like <html> <head> and <body> can't be removed or added
	         * easily in a cross-browser way, however it's valuable to be able to
	         * take advantage of React's reconciliation for styling and <title>
	         * management. So we just document it and throw in dangerous cases.
	         */
	         true ? process.env.NODE_ENV !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is ' + 'impossible to unmount some top-level components (eg <html>, ' + '<head>, and <body>) reliably and efficiently. To fix this, have a ' + 'single top-level component that never unmounts render these ' + 'elements.', this._tag) : invariant(false) : undefined;
	        break;
	    }
	
	    this.unmountChildren();
	    ReactBrowserEventEmitter.deleteAllListeners(this._rootNodeID);
	    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
	    this._rootNodeID = null;
	    this._wrapperState = null;
	    if (this._nodeWithLegacyProperties) {
	      var node = this._nodeWithLegacyProperties;
	      node._reactInternalComponent = null;
	      this._nodeWithLegacyProperties = null;
	    }
	  },
	
	  getPublicInstance: function getPublicInstance() {
	    if (!this._nodeWithLegacyProperties) {
	      var node = ReactMount.getNode(this._rootNodeID);
	
	      node._reactInternalComponent = this;
	      node.getDOMNode = legacyGetDOMNode;
	      node.isMounted = legacyIsMounted;
	      node.setState = legacySetStateEtc;
	      node.replaceState = legacySetStateEtc;
	      node.forceUpdate = legacySetStateEtc;
	      node.setProps = legacySetProps;
	      node.replaceProps = legacyReplaceProps;
	
	      if (process.env.NODE_ENV !== 'production') {
	        if (canDefineProperty) {
	          Object.defineProperties(node, legacyPropsDescriptor);
	        } else {
	          // updateComponent will update this property on subsequent renders
	          node.props = this._currentElement.props;
	        }
	      } else {
	        // updateComponent will update this property on subsequent renders
	        node.props = this._currentElement.props;
	      }
	
	      this._nodeWithLegacyProperties = node;
	    }
	    return this._nodeWithLegacyProperties;
	  }
	
	};
	
	ReactPerf.measureMethods(ReactDOMComponent, 'ReactDOMComponent', {
	  mountComponent: 'mountComponent',
	  updateComponent: 'updateComponent'
	});
	
	assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);
	
	module.exports = ReactDOMComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule AutoFocusUtils
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactMount = __webpack_require__(35);
	
	var findDOMNode = __webpack_require__(98);
	var focusNode = __webpack_require__(102);
	
	var Mixin = {
	  componentDidMount: function componentDidMount() {
	    if (this.props.autoFocus) {
	      focusNode(findDOMNode(this));
	    }
	  }
	};
	
	var AutoFocusUtils = {
	  Mixin: Mixin,
	
	  focusDOMComponent: function focusDOMComponent() {
	    focusNode(ReactMount.getNode(this._rootNodeID));
	  }
	};
	
	module.exports = AutoFocusUtils;

/***/ },
/* 102 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule focusNode
	 */
	
	'use strict';
	
	/**
	 * @param {DOMElement} node input/textarea to focus
	 */
	
	function focusNode(node) {
	  // IE8 can throw "Can't move focus to the control because it is invisible,
	  // not enabled, or of a type that does not accept the focus." for all kinds of
	  // reasons that are too expensive and fragile to test.
	  try {
	    node.focus();
	  } catch (e) {}
	}
	
	module.exports = focusNode;

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSPropertyOperations
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(104);
	var ExecutionEnvironment = __webpack_require__(16);
	var ReactPerf = __webpack_require__(25);
	
	var camelizeStyleName = __webpack_require__(105);
	var dangerousStyleValue = __webpack_require__(107);
	var hyphenateStyleName = __webpack_require__(108);
	var memoizeStringOnly = __webpack_require__(110);
	var warning = __webpack_require__(32);
	
	var processStyleName = memoizeStringOnly(function (styleName) {
	  return hyphenateStyleName(styleName);
	});
	
	var hasShorthandPropertyBug = false;
	var styleFloatAccessor = 'cssFloat';
	if (ExecutionEnvironment.canUseDOM) {
	  var tempStyle = document.createElement('div').style;
	  try {
	    // IE8 throws "Invalid argument." if resetting shorthand style properties.
	    tempStyle.font = '';
	  } catch (e) {
	    hasShorthandPropertyBug = true;
	  }
	  // IE8 only supports accessing cssFloat (standard) as styleFloat
	  if (document.documentElement.style.cssFloat === undefined) {
	    styleFloatAccessor = 'styleFloat';
	  }
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  // 'msTransform' is correct, but the other prefixes should be capitalized
	  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
	
	  // style values shouldn't contain a semicolon
	  var badStyleValueWithSemicolonPattern = /;\s*$/;
	
	  var warnedStyleNames = {};
	  var warnedStyleValues = {};
	
	  var warnHyphenatedStyleName = function warnHyphenatedStyleName(name) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?', name, camelizeStyleName(name)) : undefined;
	  };
	
	  var warnBadVendoredStyleName = function warnBadVendoredStyleName(name) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1)) : undefined;
	  };
	
	  var warnStyleValueWithSemicolon = function warnStyleValueWithSemicolon(name, value) {
	    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
	      return;
	    }
	
	    warnedStyleValues[value] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon. ' + 'Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, '')) : undefined;
	  };
	
	  /**
	   * @param {string} name
	   * @param {*} value
	   */
	  var warnValidStyle = function warnValidStyle(name, value) {
	    if (name.indexOf('-') > -1) {
	      warnHyphenatedStyleName(name);
	    } else if (badVendoredStyleNamePattern.test(name)) {
	      warnBadVendoredStyleName(name);
	    } else if (badStyleValueWithSemicolonPattern.test(value)) {
	      warnStyleValueWithSemicolon(name, value);
	    }
	  };
	}
	
	/**
	 * Operations for dealing with CSS properties.
	 */
	var CSSPropertyOperations = {
	
	  /**
	   * Serializes a mapping of style properties for use as inline styles:
	   *
	   *   > createMarkupForStyles({width: '200px', height: 0})
	   *   "width:200px;height:0;"
	   *
	   * Undefined values are ignored so that declarative programming is easier.
	   * The result should be HTML-escaped before insertion into the DOM.
	   *
	   * @param {object} styles
	   * @return {?string}
	   */
	  createMarkupForStyles: function createMarkupForStyles(styles) {
	    var serialized = '';
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      var styleValue = styles[styleName];
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styleValue);
	      }
	      if (styleValue != null) {
	        serialized += processStyleName(styleName) + ':';
	        serialized += dangerousStyleValue(styleName, styleValue) + ';';
	      }
	    }
	    return serialized || null;
	  },
	
	  /**
	   * Sets the value for multiple styles on a node.  If a value is specified as
	   * '' (empty string), the corresponding style property will be unset.
	   *
	   * @param {DOMElement} node
	   * @param {object} styles
	   */
	  setValueForStyles: function setValueForStyles(node, styles) {
	    var style = node.style;
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styles[styleName]);
	      }
	      var styleValue = dangerousStyleValue(styleName, styles[styleName]);
	      if (styleName === 'float') {
	        styleName = styleFloatAccessor;
	      }
	      if (styleValue) {
	        style[styleName] = styleValue;
	      } else {
	        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
	        if (expansion) {
	          // Shorthand property that IE8 won't like unsetting, so unset each
	          // component to placate it
	          for (var individualStyleName in expansion) {
	            style[individualStyleName] = '';
	          }
	        } else {
	          style[styleName] = '';
	        }
	      }
	    }
	  }
	
	};
	
	ReactPerf.measureMethods(CSSPropertyOperations, 'CSSPropertyOperations', {
	  setValueForStyles: 'setValueForStyles'
	});
	
	module.exports = CSSPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 104 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSProperty
	 */
	
	'use strict';
	
	/**
	 * CSS properties which accept numbers but are not in units of "px".
	 */
	
	var isUnitlessNumber = {
	  animationIterationCount: true,
	  boxFlex: true,
	  boxFlexGroup: true,
	  boxOrdinalGroup: true,
	  columnCount: true,
	  flex: true,
	  flexGrow: true,
	  flexPositive: true,
	  flexShrink: true,
	  flexNegative: true,
	  flexOrder: true,
	  fontWeight: true,
	  lineClamp: true,
	  lineHeight: true,
	  opacity: true,
	  order: true,
	  orphans: true,
	  tabSize: true,
	  widows: true,
	  zIndex: true,
	  zoom: true,
	
	  // SVG-related properties
	  fillOpacity: true,
	  stopOpacity: true,
	  strokeDashoffset: true,
	  strokeOpacity: true,
	  strokeWidth: true
	};
	
	/**
	 * @param {string} prefix vendor-specific prefix, eg: Webkit
	 * @param {string} key style name, eg: transitionDuration
	 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
	 * WebkitTransitionDuration
	 */
	function prefixKey(prefix, key) {
	  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
	}
	
	/**
	 * Support style names that may come passed in prefixed by adding permutations
	 * of vendor prefixes.
	 */
	var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
	
	// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
	// infinite loop, because it iterates over the newly added props too.
	Object.keys(isUnitlessNumber).forEach(function (prop) {
	  prefixes.forEach(function (prefix) {
	    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
	  });
	});
	
	/**
	 * Most style properties can be unset by doing .style[prop] = '' but IE8
	 * doesn't like doing that with shorthand properties so for the properties that
	 * IE8 breaks on, which are listed here, we instead unset each of the
	 * individual properties. See http://bugs.jquery.com/ticket/12385.
	 * The 4-value 'clock' properties like margin, padding, border-width seem to
	 * behave without any problems. Curiously, list-style works too without any
	 * special prodding.
	 */
	var shorthandPropertyExpansions = {
	  background: {
	    backgroundAttachment: true,
	    backgroundColor: true,
	    backgroundImage: true,
	    backgroundPositionX: true,
	    backgroundPositionY: true,
	    backgroundRepeat: true
	  },
	  backgroundPosition: {
	    backgroundPositionX: true,
	    backgroundPositionY: true
	  },
	  border: {
	    borderWidth: true,
	    borderStyle: true,
	    borderColor: true
	  },
	  borderBottom: {
	    borderBottomWidth: true,
	    borderBottomStyle: true,
	    borderBottomColor: true
	  },
	  borderLeft: {
	    borderLeftWidth: true,
	    borderLeftStyle: true,
	    borderLeftColor: true
	  },
	  borderRight: {
	    borderRightWidth: true,
	    borderRightStyle: true,
	    borderRightColor: true
	  },
	  borderTop: {
	    borderTopWidth: true,
	    borderTopStyle: true,
	    borderTopColor: true
	  },
	  font: {
	    fontStyle: true,
	    fontVariant: true,
	    fontWeight: true,
	    fontSize: true,
	    lineHeight: true,
	    fontFamily: true
	  },
	  outline: {
	    outlineWidth: true,
	    outlineStyle: true,
	    outlineColor: true
	  }
	};
	
	var CSSProperty = {
	  isUnitlessNumber: isUnitlessNumber,
	  shorthandPropertyExpansions: shorthandPropertyExpansions
	};
	
	module.exports = CSSProperty;

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule camelizeStyleName
	 * @typechecks
	 */
	
	'use strict';
	
	var camelize = __webpack_require__(106);
	
	var msPattern = /^-ms-/;
	
	/**
	 * Camelcases a hyphenated CSS property name, for example:
	 *
	 *   > camelizeStyleName('background-color')
	 *   < "backgroundColor"
	 *   > camelizeStyleName('-moz-transition')
	 *   < "MozTransition"
	 *   > camelizeStyleName('-ms-transition')
	 *   < "msTransition"
	 *
	 * As Andi Smith suggests
	 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
	 * is converted to lowercase `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelizeStyleName(string) {
	  return camelize(string.replace(msPattern, 'ms-'));
	}
	
	module.exports = camelizeStyleName;

/***/ },
/* 106 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule camelize
	 * @typechecks
	 */
	
	"use strict";
	
	var _hyphenPattern = /-(.)/g;
	
	/**
	 * Camelcases a hyphenated string, for example:
	 *
	 *   > camelize('background-color')
	 *   < "backgroundColor"
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelize(string) {
	  return string.replace(_hyphenPattern, function (_, character) {
	    return character.toUpperCase();
	  });
	}
	
	module.exports = camelize;

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule dangerousStyleValue
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(104);
	
	var isUnitlessNumber = CSSProperty.isUnitlessNumber;
	
	/**
	 * Convert a value into the proper css writable value. The style name `name`
	 * should be logical (no hyphens), as specified
	 * in `CSSProperty.isUnitlessNumber`.
	 *
	 * @param {string} name CSS property name such as `topMargin`.
	 * @param {*} value CSS property value such as `10px`.
	 * @return {string} Normalized style value with dimensions applied.
	 */
	function dangerousStyleValue(name, value) {
	  // Note that we've removed escapeTextForBrowser() calls here since the
	  // whole string will be escaped when the attribute is injected into
	  // the markup. If you provide unsafe user data here they can inject
	  // arbitrary CSS which may be problematic (I couldn't repro this):
	  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
	  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
	  // This is not an XSS hole but instead a potential CSS injection issue
	  // which has lead to a greater discussion about how we're going to
	  // trust URLs moving forward. See #2115901
	
	  var isEmpty = value == null || typeof value === 'boolean' || value === '';
	  if (isEmpty) {
	    return '';
	  }
	
	  var isNonNumeric = isNaN(value);
	  if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
	    return '' + value; // cast to string
	  }
	
	  if (typeof value === 'string') {
	    value = value.trim();
	  }
	  return value + 'px';
	}
	
	module.exports = dangerousStyleValue;

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule hyphenateStyleName
	 * @typechecks
	 */
	
	'use strict';
	
	var hyphenate = __webpack_require__(109);
	
	var msPattern = /^ms-/;
	
	/**
	 * Hyphenates a camelcased CSS property name, for example:
	 *
	 *   > hyphenateStyleName('backgroundColor')
	 *   < "background-color"
	 *   > hyphenateStyleName('MozTransition')
	 *   < "-moz-transition"
	 *   > hyphenateStyleName('msTransition')
	 *   < "-ms-transition"
	 *
	 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
	 * is converted to `-ms-`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenateStyleName(string) {
	  return hyphenate(string).replace(msPattern, '-ms-');
	}
	
	module.exports = hyphenateStyleName;

/***/ },
/* 109 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule hyphenate
	 * @typechecks
	 */
	
	'use strict';
	
	var _uppercasePattern = /([A-Z])/g;
	
	/**
	 * Hyphenates a camelcased string, for example:
	 *
	 *   > hyphenate('backgroundColor')
	 *   < "background-color"
	 *
	 * For CSS style names, use `hyphenateStyleName` instead which works properly
	 * with all vendor prefixes, including `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenate(string) {
	  return string.replace(_uppercasePattern, '-$1').toLowerCase();
	}
	
	module.exports = hyphenate;

/***/ },
/* 110 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule memoizeStringOnly
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Memoizes the return value of a function that accepts one string argument.
	 *
	 * @param {function} callback
	 * @return {function}
	 */
	
	function memoizeStringOnly(callback) {
	  var cache = {};
	  return function (string) {
	    if (!cache.hasOwnProperty(string)) {
	      cache[string] = callback.call(this, string);
	    }
	    return cache[string];
	  };
	}
	
	module.exports = memoizeStringOnly;

/***/ },
/* 111 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMButton
	 */
	
	'use strict';
	
	var mouseListenerNames = {
	  onClick: true,
	  onDoubleClick: true,
	  onMouseDown: true,
	  onMouseMove: true,
	  onMouseUp: true,
	
	  onClickCapture: true,
	  onDoubleClickCapture: true,
	  onMouseDownCapture: true,
	  onMouseMoveCapture: true,
	  onMouseUpCapture: true
	};
	
	/**
	 * Implements a <button> native component that does not receive mouse events
	 * when `disabled` is set.
	 */
	var ReactDOMButton = {
	  getNativeProps: function getNativeProps(inst, props, context) {
	    if (!props.disabled) {
	      return props;
	    }
	
	    // Copy the props, except the mouse listeners
	    var nativeProps = {};
	    for (var key in props) {
	      if (props.hasOwnProperty(key) && !mouseListenerNames[key]) {
	        nativeProps[key] = props[key];
	      }
	    }
	
	    return nativeProps;
	  }
	};
	
	module.exports = ReactDOMButton;

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMInput
	 */
	
	'use strict';
	
	var ReactDOMIDOperations = __webpack_require__(34);
	var LinkedValueUtils = __webpack_require__(113);
	var ReactMount = __webpack_require__(35);
	var ReactUpdates = __webpack_require__(61);
	
	var assign = __webpack_require__(46);
	var invariant = __webpack_require__(20);
	
	var instancesByReactID = {};
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMInput.updateWrapper(this);
	  }
	}
	
	/**
	 * Implements an <input> native component that allows setting these optional
	 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
	 *
	 * If `checked` or `value` are not supplied (or null/undefined), user actions
	 * that affect the checked state or value will trigger updates to the element.
	 *
	 * If they are supplied (and not null/undefined), the rendered element will not
	 * trigger updates to the element. Instead, the props must change in order for
	 * the rendered element to be updated.
	 *
	 * The rendered element will be initialized as unchecked (or `defaultChecked`)
	 * with an empty value (or `defaultValue`).
	 *
	 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
	 */
	var ReactDOMInput = {
	  getNativeProps: function getNativeProps(inst, props, context) {
	    var value = LinkedValueUtils.getValue(props);
	    var checked = LinkedValueUtils.getChecked(props);
	
	    var nativeProps = assign({}, props, {
	      defaultChecked: undefined,
	      defaultValue: undefined,
	      value: value != null ? value : inst._wrapperState.initialValue,
	      checked: checked != null ? checked : inst._wrapperState.initialChecked,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return nativeProps;
	  },
	
	  mountWrapper: function mountWrapper(inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);
	    }
	
	    var defaultValue = props.defaultValue;
	    inst._wrapperState = {
	      initialChecked: props.defaultChecked || false,
	      initialValue: defaultValue != null ? defaultValue : null,
	      onChange: _handleChange.bind(inst)
	    };
	  },
	
	  mountReadyWrapper: function mountReadyWrapper(inst) {
	    // Can't be in mountWrapper or else server rendering leaks.
	    instancesByReactID[inst._rootNodeID] = inst;
	  },
	
	  unmountWrapper: function unmountWrapper(inst) {
	    delete instancesByReactID[inst._rootNodeID];
	  },
	
	  updateWrapper: function updateWrapper(inst) {
	    var props = inst._currentElement.props;
	
	    // TODO: Shouldn't this be getChecked(props)?
	    var checked = props.checked;
	    if (checked != null) {
	      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'checked', checked || false);
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  // Here we use asap to wait until all updates have propagated, which
	  // is important when using controlled components within layers:
	  // https://github.com/facebook/react/issues/1698
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	
	  var name = props.name;
	  if (props.type === 'radio' && name != null) {
	    var rootNode = ReactMount.getNode(this._rootNodeID);
	    var queryRoot = rootNode;
	
	    while (queryRoot.parentNode) {
	      queryRoot = queryRoot.parentNode;
	    }
	
	    // If `rootNode.form` was non-null, then we could try `form.elements`,
	    // but that sometimes behaves strangely in IE8. We could also try using
	    // `form.getElementsByName`, but that will only return direct children
	    // and won't include inputs that use the HTML5 `form=` attribute. Since
	    // the input might not even be in a form, let's just use the global
	    // `querySelectorAll` to ensure we don't miss anything.
	    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');
	
	    for (var i = 0; i < group.length; i++) {
	      var otherNode = group[i];
	      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
	        continue;
	      }
	      // This will throw if radio buttons rendered by different copies of React
	      // and the same name are rendered into the same form (same as #1939).
	      // That's probably okay; we don't support it just as we don't support
	      // mixing React with non-React.
	      var otherID = ReactMount.getID(otherNode);
	      !otherID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the ' + 'same `name` is not supported.') : invariant(false) : undefined;
	      var otherInstance = instancesByReactID[otherID];
	      !otherInstance ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Unknown radio button ID %s.', otherID) : invariant(false) : undefined;
	      // If this is a controlled radio button group, forcing the input that
	      // was previously checked to update will cause it to be come re-checked
	      // as appropriate.
	      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
	    }
	  }
	
	  return returnValue;
	}
	
	module.exports = ReactDOMInput;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule LinkedValueUtils
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactPropTypes = __webpack_require__(114);
	var ReactPropTypeLocations = __webpack_require__(72);
	
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	var hasReadOnlyValue = {
	  'button': true,
	  'checkbox': true,
	  'image': true,
	  'hidden': true,
	  'radio': true,
	  'reset': true,
	  'submit': true
	};
	
	function _assertSingleLink(inputProps) {
	  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use ' + 'checkedLink, you probably don\'t want to use valueLink and vice versa.') : invariant(false) : undefined;
	}
	function _assertValueLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.value == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want ' + 'to use value or onChange, you probably don\'t want to use valueLink.') : invariant(false) : undefined;
	}
	
	function _assertCheckedLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.checked == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. ' + 'If you want to use checked or onChange, you probably don\'t want to ' + 'use checkedLink') : invariant(false) : undefined;
	}
	
	var propTypes = {
	  value: function value(props, propName, componentName) {
	    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  checked: function checked(props, propName, componentName) {
	    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  onChange: ReactPropTypes.func
	};
	
	var loggedTypeFailures = {};
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Provide a linked `value` attribute for controlled forms. You should not use
	 * this outside of the ReactDOM controlled form components.
	 */
	var LinkedValueUtils = {
	  checkPropTypes: function checkPropTypes(tagName, props, owner) {
	    for (var propName in propTypes) {
	      if (propTypes.hasOwnProperty(propName)) {
	        var error = propTypes[propName](props, propName, tagName, ReactPropTypeLocations.prop);
	      }
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var addendum = getDeclarationErrorAddendum(owner);
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : undefined;
	      }
	    }
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current value of the input either from value prop or link.
	   */
	  getValue: function getValue(inputProps) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.value;
	    }
	    return inputProps.value;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current checked status of the input either from checked prop
	   *             or link.
	   */
	  getChecked: function getChecked(inputProps) {
	    if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.value;
	    }
	    return inputProps.checked;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @param {SyntheticEvent} event change event to handle
	   */
	  executeOnChange: function executeOnChange(inputProps, event) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.requestChange(event.target.value);
	    } else if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.requestChange(event.target.checked);
	    } else if (inputProps.onChange) {
	      return inputProps.onChange.call(undefined, event);
	    }
	  }
	};
	
	module.exports = LinkedValueUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypes
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactElement = __webpack_require__(49);
	var ReactPropTypeLocationNames = __webpack_require__(73);
	
	var emptyFunction = __webpack_require__(22);
	var getIteratorFn = __webpack_require__(115);
	
	/**
	 * Collection of methods that allow declaration and validation of props that are
	 * supplied to React components. Example usage:
	 *
	 *   var Props = require('ReactPropTypes');
	 *   var MyArticle = React.createClass({
	 *     propTypes: {
	 *       // An optional string prop named "description".
	 *       description: Props.string,
	 *
	 *       // A required enum prop named "category".
	 *       category: Props.oneOf(['News','Photos']).isRequired,
	 *
	 *       // A prop named "dialog" that requires an instance of Dialog.
	 *       dialog: Props.instanceOf(Dialog).isRequired
	 *     },
	 *     render: function() { ... }
	 *   });
	 *
	 * A more formal specification of how these methods are used:
	 *
	 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	 *   decl := ReactPropTypes.{type}(.isRequired)?
	 *
	 * Each and every declaration produces a function with the same signature. This
	 * allows the creation of custom validation functions. For example:
	 *
	 *  var MyLink = React.createClass({
	 *    propTypes: {
	 *      // An optional string or URI prop named "href".
	 *      href: function(props, propName, componentName) {
	 *        var propValue = props[propName];
	 *        if (propValue != null && typeof propValue !== 'string' &&
	 *            !(propValue instanceof URI)) {
	 *          return new Error(
	 *            'Expected a string or an URI for ' + propName + ' in ' +
	 *            componentName
	 *          );
	 *        }
	 *      }
	 *    },
	 *    render: function() {...}
	 *  });
	 *
	 * @internal
	 */
	
	var ANONYMOUS = '<<anonymous>>';
	
	var ReactPropTypes = {
	  array: createPrimitiveTypeChecker('array'),
	  bool: createPrimitiveTypeChecker('boolean'),
	  func: createPrimitiveTypeChecker('function'),
	  number: createPrimitiveTypeChecker('number'),
	  object: createPrimitiveTypeChecker('object'),
	  string: createPrimitiveTypeChecker('string'),
	
	  any: createAnyTypeChecker(),
	  arrayOf: createArrayOfTypeChecker,
	  element: createElementTypeChecker(),
	  instanceOf: createInstanceTypeChecker,
	  node: createNodeChecker(),
	  objectOf: createObjectOfTypeChecker,
	  oneOf: createEnumTypeChecker,
	  oneOfType: createUnionTypeChecker,
	  shape: createShapeTypeChecker
	};
	
	function createChainableTypeChecker(validate) {
	  function checkType(isRequired, props, propName, componentName, location, propFullName) {
	    componentName = componentName || ANONYMOUS;
	    propFullName = propFullName || propName;
	    if (props[propName] == null) {
	      var locationName = ReactPropTypeLocationNames[location];
	      if (isRequired) {
	        return new Error('Required ' + locationName + ' `' + propFullName + '` was not specified in ' + ('`' + componentName + '`.'));
	      }
	      return null;
	    } else {
	      return validate(props, propName, componentName, location, propFullName);
	    }
	  }
	
	  var chainedCheckType = checkType.bind(null, false);
	  chainedCheckType.isRequired = checkType.bind(null, true);
	
	  return chainedCheckType;
	}
	
	function createPrimitiveTypeChecker(expectedType) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== expectedType) {
	      var locationName = ReactPropTypeLocationNames[location];
	      // `propValue` being instance of, say, date/regexp, pass the 'object'
	      // check, but we can offer a more precise error message here rather than
	      // 'of type `object`'.
	      var preciseType = getPreciseType(propValue);
	
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createAnyTypeChecker() {
	  return createChainableTypeChecker(emptyFunction.thatReturns(null));
	}
	
	function createArrayOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    if (!Array.isArray(propValue)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var propType = getPropType(propValue);
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	    }
	    for (var i = 0; i < propValue.length; i++) {
	      var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']');
	      if (error instanceof Error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createElementTypeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!ReactElement.isValidElement(props[propName])) {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a single ReactElement.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createInstanceTypeChecker(expectedClass) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!(props[propName] instanceof expectedClass)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var expectedClassName = expectedClass.name || ANONYMOUS;
	      var actualClassName = getClassName(props[propName]);
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createEnumTypeChecker(expectedValues) {
	  if (!Array.isArray(expectedValues)) {
	    return createChainableTypeChecker(function () {
	      return new Error('Invalid argument supplied to oneOf, expected an instance of array.');
	    });
	  }
	
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    for (var i = 0; i < expectedValues.length; i++) {
	      if (propValue === expectedValues[i]) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    var valuesString = JSON.stringify(expectedValues);
	    return new Error('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createObjectOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	    }
	    for (var key in propValue) {
	      if (propValue.hasOwnProperty(key)) {
	        var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createUnionTypeChecker(arrayOfTypeCheckers) {
	  if (!Array.isArray(arrayOfTypeCheckers)) {
	    return createChainableTypeChecker(function () {
	      return new Error('Invalid argument supplied to oneOfType, expected an instance of array.');
	    });
	  }
	
	  function validate(props, propName, componentName, location, propFullName) {
	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (checker(props, propName, componentName, location, propFullName) == null) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createNodeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!isNode(props[propName])) {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createShapeTypeChecker(shapeTypes) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	    }
	    for (var key in shapeTypes) {
	      var checker = shapeTypes[key];
	      if (!checker) {
	        continue;
	      }
	      var error = checker(propValue, key, componentName, location, propFullName + '.' + key);
	      if (error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function isNode(propValue) {
	  switch (typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue)) {
	    case 'number':
	    case 'string':
	    case 'undefined':
	      return true;
	    case 'boolean':
	      return !propValue;
	    case 'object':
	      if (Array.isArray(propValue)) {
	        return propValue.every(isNode);
	      }
	      if (propValue === null || ReactElement.isValidElement(propValue)) {
	        return true;
	      }
	
	      var iteratorFn = getIteratorFn(propValue);
	      if (iteratorFn) {
	        var iterator = iteratorFn.call(propValue);
	        var step;
	        if (iteratorFn !== propValue.entries) {
	          while (!(step = iterator.next()).done) {
	            if (!isNode(step.value)) {
	              return false;
	            }
	          }
	        } else {
	          // Iterator will provide entry [k,v] tuples rather than values.
	          while (!(step = iterator.next()).done) {
	            var entry = step.value;
	            if (entry) {
	              if (!isNode(entry[1])) {
	                return false;
	              }
	            }
	          }
	        }
	      } else {
	        return false;
	      }
	
	      return true;
	    default:
	      return false;
	  }
	}
	
	// Equivalent of `typeof` but with special handling for array and regexp.
	function getPropType(propValue) {
	  var propType = typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue);
	  if (Array.isArray(propValue)) {
	    return 'array';
	  }
	  if (propValue instanceof RegExp) {
	    // Old webkits (at least until Android 4.0) return 'function' rather than
	    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	    // passes PropTypes.object.
	    return 'object';
	  }
	  return propType;
	}
	
	// This handles more types than `getPropType`. Only used for error messages.
	// See `createPrimitiveTypeChecker`.
	function getPreciseType(propValue) {
	  var propType = getPropType(propValue);
	  if (propType === 'object') {
	    if (propValue instanceof Date) {
	      return 'date';
	    } else if (propValue instanceof RegExp) {
	      return 'regexp';
	    }
	  }
	  return propType;
	}
	
	// Returns class name of the object, if any.
	function getClassName(propValue) {
	  if (!propValue.constructor || !propValue.constructor.name) {
	    return '<<anonymous>>';
	  }
	  return propValue.constructor.name;
	}
	
	module.exports = ReactPropTypes;

/***/ },
/* 115 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getIteratorFn
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/* global Symbol */
	
	var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
	
	/**
	 * Returns the iterator method function contained on the iterable object.
	 *
	 * Be sure to invoke the function with the iterable as context:
	 *
	 *     var iteratorFn = getIteratorFn(myIterable);
	 *     if (iteratorFn) {
	 *       var iterator = iteratorFn.call(myIterable);
	 *       ...
	 *     }
	 *
	 * @param {?object} maybeIterable
	 * @return {?function}
	 */
	function getIteratorFn(maybeIterable) {
	  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	  if (typeof iteratorFn === 'function') {
	    return iteratorFn;
	  }
	}
	
	module.exports = getIteratorFn;

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMOption
	 */
	
	'use strict';
	
	var ReactChildren = __webpack_require__(117);
	var ReactDOMSelect = __webpack_require__(119);
	
	var assign = __webpack_require__(46);
	var warning = __webpack_require__(32);
	
	var valueContextKey = ReactDOMSelect.valueContextKey;
	
	/**
	 * Implements an <option> native component that warns when `selected` is set.
	 */
	var ReactDOMOption = {
	  mountWrapper: function mountWrapper(inst, props, context) {
	    // TODO (yungsters): Remove support for `selected` in <option>.
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : undefined;
	    }
	
	    // Look up whether this option is 'selected' via context
	    var selectValue = context[valueContextKey];
	
	    // If context key is null (e.g., no specified value or after initial mount)
	    // or missing (e.g., for <datalist>), we don't change props.selected
	    var selected = null;
	    if (selectValue != null) {
	      selected = false;
	      if (Array.isArray(selectValue)) {
	        // multiple
	        for (var i = 0; i < selectValue.length; i++) {
	          if ('' + selectValue[i] === '' + props.value) {
	            selected = true;
	            break;
	          }
	        }
	      } else {
	        selected = '' + selectValue === '' + props.value;
	      }
	    }
	
	    inst._wrapperState = { selected: selected };
	  },
	
	  getNativeProps: function getNativeProps(inst, props, context) {
	    var nativeProps = assign({ selected: undefined, children: undefined }, props);
	
	    // Read state only from initial mount because <select> updates value
	    // manually; we need the initial state only for server rendering
	    if (inst._wrapperState.selected != null) {
	      nativeProps.selected = inst._wrapperState.selected;
	    }
	
	    var content = '';
	
	    // Flatten children and warn if they aren't strings or numbers;
	    // invalid types are ignored.
	    ReactChildren.forEach(props.children, function (child) {
	      if (child == null) {
	        return;
	      }
	      if (typeof child === 'string' || typeof child === 'number') {
	        content += child;
	      } else {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : undefined;
	      }
	    });
	
	    if (content) {
	      nativeProps.children = content;
	    }
	
	    return nativeProps;
	  }
	
	};
	
	module.exports = ReactDOMOption;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildren
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(63);
	var ReactElement = __webpack_require__(49);
	
	var emptyFunction = __webpack_require__(22);
	var traverseAllChildren = __webpack_require__(118);
	
	var twoArgumentPooler = PooledClass.twoArgumentPooler;
	var fourArgumentPooler = PooledClass.fourArgumentPooler;
	
	var userProvidedKeyEscapeRegex = /\/(?!\/)/g;
	function escapeUserProvidedKey(text) {
	  return ('' + text).replace(userProvidedKeyEscapeRegex, '//');
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * traversal. Allows avoiding binding callbacks.
	 *
	 * @constructor ForEachBookKeeping
	 * @param {!function} forEachFunction Function to perform traversal with.
	 * @param {?*} forEachContext Context to perform context with.
	 */
	function ForEachBookKeeping(forEachFunction, forEachContext) {
	  this.func = forEachFunction;
	  this.context = forEachContext;
	  this.count = 0;
	}
	ForEachBookKeeping.prototype.destructor = function () {
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);
	
	function forEachSingleChild(bookKeeping, child, name) {
	  var func = bookKeeping.func;
	  var context = bookKeeping.context;
	
	  func.call(context, child, bookKeeping.count++);
	}
	
	/**
	 * Iterates through children that are typically specified as `props.children`.
	 *
	 * The provided forEachFunc(child, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} forEachFunc
	 * @param {*} forEachContext Context for forEachContext.
	 */
	function forEachChildren(children, forEachFunc, forEachContext) {
	  if (children == null) {
	    return children;
	  }
	  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
	  traverseAllChildren(children, forEachSingleChild, traverseContext);
	  ForEachBookKeeping.release(traverseContext);
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * mapping. Allows avoiding binding callbacks.
	 *
	 * @constructor MapBookKeeping
	 * @param {!*} mapResult Object containing the ordered map of results.
	 * @param {!function} mapFunction Function to perform mapping with.
	 * @param {?*} mapContext Context to perform mapping with.
	 */
	function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
	  this.result = mapResult;
	  this.keyPrefix = keyPrefix;
	  this.func = mapFunction;
	  this.context = mapContext;
	  this.count = 0;
	}
	MapBookKeeping.prototype.destructor = function () {
	  this.result = null;
	  this.keyPrefix = null;
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);
	
	function mapSingleChildIntoContext(bookKeeping, child, childKey) {
	  var result = bookKeeping.result;
	  var keyPrefix = bookKeeping.keyPrefix;
	  var func = bookKeeping.func;
	  var context = bookKeeping.context;
	
	  var mappedChild = func.call(context, child, bookKeeping.count++);
	  if (Array.isArray(mappedChild)) {
	    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
	  } else if (mappedChild != null) {
	    if (ReactElement.isValidElement(mappedChild)) {
	      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
	      // Keep both the (mapped) and old keys if they differ, just as
	      // traverseAllChildren used to do for objects as children
	      keyPrefix + (mappedChild !== child ? escapeUserProvidedKey(mappedChild.key || '') + '/' : '') + childKey);
	    }
	    result.push(mappedChild);
	  }
	}
	
	function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
	  var escapedPrefix = '';
	  if (prefix != null) {
	    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
	  }
	  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
	  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
	  MapBookKeeping.release(traverseContext);
	}
	
	/**
	 * Maps children that are typically specified as `props.children`.
	 *
	 * The provided mapFunction(child, key, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} func The map function.
	 * @param {*} context Context for mapFunction.
	 * @return {object} Object containing the ordered map of results.
	 */
	function mapChildren(children, func, context) {
	  if (children == null) {
	    return children;
	  }
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
	  return result;
	}
	
	function forEachSingleChildDummy(traverseContext, child, name) {
	  return null;
	}
	
	/**
	 * Count the number of children that are typically specified as
	 * `props.children`.
	 *
	 * @param {?*} children Children tree container.
	 * @return {number} The number of children.
	 */
	function countChildren(children, context) {
	  return traverseAllChildren(children, forEachSingleChildDummy, null);
	}
	
	/**
	 * Flatten a children object (typically specified as `props.children`) and
	 * return an array with appropriately re-keyed children.
	 */
	function toArray(children) {
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
	  return result;
	}
	
	var ReactChildren = {
	  forEach: forEachChildren,
	  map: mapChildren,
	  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
	  count: countChildren,
	  toArray: toArray
	};
	
	module.exports = ReactChildren;

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule traverseAllChildren
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactCurrentOwner = __webpack_require__(12);
	var ReactElement = __webpack_require__(49);
	var ReactInstanceHandles = __webpack_require__(52);
	
	var getIteratorFn = __webpack_require__(115);
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	var SEPARATOR = ReactInstanceHandles.SEPARATOR;
	var SUBSEPARATOR = ':';
	
	/**
	 * TODO: Test that a single child and an array with one item have the same key
	 * pattern.
	 */
	
	var userProvidedKeyEscaperLookup = {
	  '=': '=0',
	  '.': '=1',
	  ':': '=2'
	};
	
	var userProvidedKeyEscapeRegex = /[=.:]/g;
	
	var didWarnAboutMaps = false;
	
	function userProvidedKeyEscaper(match) {
	  return userProvidedKeyEscaperLookup[match];
	}
	
	/**
	 * Generate a key string that identifies a component within a set.
	 *
	 * @param {*} component A component that could contain a manual key.
	 * @param {number} index Index that is used if a manual key is not provided.
	 * @return {string}
	 */
	function getComponentKey(component, index) {
	  if (component && component.key != null) {
	    // Explicit key
	    return wrapUserProvidedKey(component.key);
	  }
	  // Implicit key determined by the index in the set
	  return index.toString(36);
	}
	
	/**
	 * Escape a component key so that it is safe to use in a reactid.
	 *
	 * @param {*} text Component key to be escaped.
	 * @return {string} An escaped string.
	 */
	function escapeUserProvidedKey(text) {
	  return ('' + text).replace(userProvidedKeyEscapeRegex, userProvidedKeyEscaper);
	}
	
	/**
	 * Wrap a `key` value explicitly provided by the user to distinguish it from
	 * implicitly-generated keys generated by a component's index in its parent.
	 *
	 * @param {string} key Value of a user-provided `key` attribute
	 * @return {string}
	 */
	function wrapUserProvidedKey(key) {
	  return '$' + escapeUserProvidedKey(key);
	}
	
	/**
	 * @param {?*} children Children tree container.
	 * @param {!string} nameSoFar Name of the key path so far.
	 * @param {!function} callback Callback to invoke with each child found.
	 * @param {?*} traverseContext Used to pass information throughout the traversal
	 * process.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
	  var type = typeof children === 'undefined' ? 'undefined' : _typeof(children);
	
	  if (type === 'undefined' || type === 'boolean') {
	    // All of the above are perceived as null.
	    children = null;
	  }
	
	  if (children === null || type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {
	    callback(traverseContext, children,
	    // If it's the only child, treat the name as if it was wrapped in an array
	    // so that it's consistent if the number of children grows.
	    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
	    return 1;
	  }
	
	  var child;
	  var nextName;
	  var subtreeCount = 0; // Count of children found in the current subtree.
	  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
	
	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      child = children[i];
	      nextName = nextNamePrefix + getComponentKey(child, i);
	      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	    }
	  } else {
	    var iteratorFn = getIteratorFn(children);
	    if (iteratorFn) {
	      var iterator = iteratorFn.call(children);
	      var step;
	      if (iteratorFn !== children.entries) {
	        var ii = 0;
	        while (!(step = iterator.next()).done) {
	          child = step.value;
	          nextName = nextNamePrefix + getComponentKey(child, ii++);
	          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	        }
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.') : undefined;
	          didWarnAboutMaps = true;
	        }
	        // Iterator will provide entry [k,v] tuples rather than values.
	        while (!(step = iterator.next()).done) {
	          var entry = step.value;
	          if (entry) {
	            child = entry[1];
	            nextName = nextNamePrefix + wrapUserProvidedKey(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
	            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	          }
	        }
	      }
	    } else if (type === 'object') {
	      var addendum = '';
	      if (process.env.NODE_ENV !== 'production') {
	        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
	        if (children._isReactElement) {
	          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
	        }
	        if (ReactCurrentOwner.current) {
	          var name = ReactCurrentOwner.current.getName();
	          if (name) {
	            addendum += ' Check the render method of `' + name + '`.';
	          }
	        }
	      }
	      var childrenString = String(children);
	       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : invariant(false) : undefined;
	    }
	  }
	
	  return subtreeCount;
	}
	
	/**
	 * Traverses children that are typically specified as `props.children`, but
	 * might also be specified through attributes:
	 *
	 * - `traverseAllChildren(this.props.children, ...)`
	 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
	 *
	 * The `traverseContext` is an optional argument that is passed through the
	 * entire traversal. It can be used to store accumulations or anything else that
	 * the callback might find relevant.
	 *
	 * @param {?*} children Children tree object.
	 * @param {!function} callback To invoke upon traversing each child.
	 * @param {?*} traverseContext Context for traversal.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildren(children, callback, traverseContext) {
	  if (children == null) {
	    return 0;
	  }
	
	  return traverseAllChildrenImpl(children, '', callback, traverseContext);
	}
	
	module.exports = traverseAllChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMSelect
	 */
	
	'use strict';
	
	var LinkedValueUtils = __webpack_require__(113);
	var ReactMount = __webpack_require__(35);
	var ReactUpdates = __webpack_require__(61);
	
	var assign = __webpack_require__(46);
	var warning = __webpack_require__(32);
	
	var valueContextKey = '__ReactDOMSelect_value$' + Math.random().toString(36).slice(2);
	
	function updateOptionsIfPendingUpdateAndMounted() {
	  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
	    this._wrapperState.pendingUpdate = false;
	
	    var props = this._currentElement.props;
	    var value = LinkedValueUtils.getValue(props);
	
	    if (value != null) {
	      updateOptions(this, Boolean(props.multiple), value);
	    }
	  }
	}
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	var valuePropNames = ['value', 'defaultValue'];
	
	/**
	 * Validation function for `value` and `defaultValue`.
	 * @private
	 */
	function checkSelectPropTypes(inst, props) {
	  var owner = inst._currentElement._owner;
	  LinkedValueUtils.checkPropTypes('select', props, owner);
	
	  for (var i = 0; i < valuePropNames.length; i++) {
	    var propName = valuePropNames[i];
	    if (props[propName] == null) {
	      continue;
	    }
	    if (props.multiple) {
	      process.env.NODE_ENV !== 'production' ? warning(Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;
	    } else {
	      process.env.NODE_ENV !== 'production' ? warning(!Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;
	    }
	  }
	}
	
	/**
	 * @param {ReactDOMComponent} inst
	 * @param {boolean} multiple
	 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
	 * @private
	 */
	function updateOptions(inst, multiple, propValue) {
	  var selectedValue, i;
	  var options = ReactMount.getNode(inst._rootNodeID).options;
	
	  if (multiple) {
	    selectedValue = {};
	    for (i = 0; i < propValue.length; i++) {
	      selectedValue['' + propValue[i]] = true;
	    }
	    for (i = 0; i < options.length; i++) {
	      var selected = selectedValue.hasOwnProperty(options[i].value);
	      if (options[i].selected !== selected) {
	        options[i].selected = selected;
	      }
	    }
	  } else {
	    // Do not set `select.value` as exact behavior isn't consistent across all
	    // browsers for all cases.
	    selectedValue = '' + propValue;
	    for (i = 0; i < options.length; i++) {
	      if (options[i].value === selectedValue) {
	        options[i].selected = true;
	        return;
	      }
	    }
	    if (options.length) {
	      options[0].selected = true;
	    }
	  }
	}
	
	/**
	 * Implements a <select> native component that allows optionally setting the
	 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
	 * stringable. If `multiple` is true, the prop must be an array of stringables.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that change the
	 * selected option will trigger updates to the rendered options.
	 *
	 * If it is supplied (and not null/undefined), the rendered options will not
	 * update in response to user actions. Instead, the `value` prop must change in
	 * order for the rendered options to update.
	 *
	 * If `defaultValue` is provided, any options with the supplied values will be
	 * selected.
	 */
	var ReactDOMSelect = {
	  valueContextKey: valueContextKey,
	
	  getNativeProps: function getNativeProps(inst, props, context) {
	    return assign({}, props, {
	      onChange: inst._wrapperState.onChange,
	      value: undefined
	    });
	  },
	
	  mountWrapper: function mountWrapper(inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      checkSelectPropTypes(inst, props);
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    inst._wrapperState = {
	      pendingUpdate: false,
	      initialValue: value != null ? value : props.defaultValue,
	      onChange: _handleChange.bind(inst),
	      wasMultiple: Boolean(props.multiple)
	    };
	  },
	
	  processChildContext: function processChildContext(inst, props, context) {
	    // Pass down initial value so initial generated markup has correct
	    // `selected` attributes
	    var childContext = assign({}, context);
	    childContext[valueContextKey] = inst._wrapperState.initialValue;
	    return childContext;
	  },
	
	  postUpdateWrapper: function postUpdateWrapper(inst) {
	    var props = inst._currentElement.props;
	
	    // After the initial mount, we control selected-ness manually so don't pass
	    // the context value down
	    inst._wrapperState.initialValue = undefined;
	
	    var wasMultiple = inst._wrapperState.wasMultiple;
	    inst._wrapperState.wasMultiple = Boolean(props.multiple);
	
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      inst._wrapperState.pendingUpdate = false;
	      updateOptions(inst, Boolean(props.multiple), value);
	    } else if (wasMultiple !== Boolean(props.multiple)) {
	      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
	      if (props.defaultValue != null) {
	        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
	      } else {
	        // Revert the select back to its default unselected state.
	        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
	      }
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  this._wrapperState.pendingUpdate = true;
	  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMSelect;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTextarea
	 */
	
	'use strict';
	
	var LinkedValueUtils = __webpack_require__(113);
	var ReactDOMIDOperations = __webpack_require__(34);
	var ReactUpdates = __webpack_require__(61);
	
	var assign = __webpack_require__(46);
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMTextarea.updateWrapper(this);
	  }
	}
	
	/**
	 * Implements a <textarea> native component that allows setting `value`, and
	 * `defaultValue`. This differs from the traditional DOM API because value is
	 * usually set as PCDATA children.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that affect the
	 * value will trigger updates to the element.
	 *
	 * If `value` is supplied (and not null/undefined), the rendered element will
	 * not trigger updates to the element. Instead, the `value` prop must change in
	 * order for the rendered element to be updated.
	 *
	 * The rendered element will be initialized with an empty value, the prop
	 * `defaultValue` if specified, or the children content (deprecated).
	 */
	var ReactDOMTextarea = {
	  getNativeProps: function getNativeProps(inst, props, context) {
	    !(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : invariant(false) : undefined;
	
	    // Always set children to the same thing. In IE9, the selection range will
	    // get reset if `textContent` is mutated.
	    var nativeProps = assign({}, props, {
	      defaultValue: undefined,
	      value: undefined,
	      children: inst._wrapperState.initialValue,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return nativeProps;
	  },
	
	  mountWrapper: function mountWrapper(inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
	    }
	
	    var defaultValue = props.defaultValue;
	    // TODO (yungsters): Remove support for children content in <textarea>.
	    var children = props.children;
	    if (children != null) {
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : undefined;
	      }
	      !(defaultValue == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : invariant(false) : undefined;
	      if (Array.isArray(children)) {
	        !(children.length <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : invariant(false) : undefined;
	        children = children[0];
	      }
	
	      defaultValue = '' + children;
	    }
	    if (defaultValue == null) {
	      defaultValue = '';
	    }
	    var value = LinkedValueUtils.getValue(props);
	
	    inst._wrapperState = {
	      // We save the initial value so that `ReactDOMComponent` doesn't update
	      // `textContent` (unnecessary since we update value).
	      // The initial value can be a boolean or object so that's why it's
	      // forced to be a string.
	      initialValue: '' + (value != null ? value : defaultValue),
	      onChange: _handleChange.bind(inst)
	    };
	  },
	
	  updateWrapper: function updateWrapper(inst) {
	    var props = inst._currentElement.props;
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMTextarea;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMultiChild
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactComponentEnvironment = __webpack_require__(71);
	var ReactMultiChildUpdateTypes = __webpack_require__(23);
	
	var ReactCurrentOwner = __webpack_require__(12);
	var ReactReconciler = __webpack_require__(57);
	var ReactChildReconciler = __webpack_require__(122);
	
	var flattenChildren = __webpack_require__(123);
	
	/**
	 * Updating children of a component may trigger recursive updates. The depth is
	 * used to batch recursive updates to render markup more efficiently.
	 *
	 * @type {number}
	 * @private
	 */
	var updateDepth = 0;
	
	/**
	 * Queue of update configuration objects.
	 *
	 * Each object has a `type` property that is in `ReactMultiChildUpdateTypes`.
	 *
	 * @type {array<object>}
	 * @private
	 */
	var updateQueue = [];
	
	/**
	 * Queue of markup to be rendered.
	 *
	 * @type {array<string>}
	 * @private
	 */
	var markupQueue = [];
	
	/**
	 * Enqueues markup to be rendered and inserted at a supplied index.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {string} markup Markup that renders into an element.
	 * @param {number} toIndex Destination index.
	 * @private
	 */
	function enqueueInsertMarkup(parentID, markup, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
	    markupIndex: markupQueue.push(markup) - 1,
	    content: null,
	    fromIndex: null,
	    toIndex: toIndex
	  });
	}
	
	/**
	 * Enqueues moving an existing element to another index.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {number} fromIndex Source index of the existing element.
	 * @param {number} toIndex Destination index of the element.
	 * @private
	 */
	function enqueueMove(parentID, fromIndex, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
	    markupIndex: null,
	    content: null,
	    fromIndex: fromIndex,
	    toIndex: toIndex
	  });
	}
	
	/**
	 * Enqueues removing an element at an index.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {number} fromIndex Index of the element to remove.
	 * @private
	 */
	function enqueueRemove(parentID, fromIndex) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.REMOVE_NODE,
	    markupIndex: null,
	    content: null,
	    fromIndex: fromIndex,
	    toIndex: null
	  });
	}
	
	/**
	 * Enqueues setting the markup of a node.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {string} markup Markup that renders into an element.
	 * @private
	 */
	function enqueueSetMarkup(parentID, markup) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.SET_MARKUP,
	    markupIndex: null,
	    content: markup,
	    fromIndex: null,
	    toIndex: null
	  });
	}
	
	/**
	 * Enqueues setting the text content.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {string} textContent Text content to set.
	 * @private
	 */
	function enqueueTextContent(parentID, textContent) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
	    markupIndex: null,
	    content: textContent,
	    fromIndex: null,
	    toIndex: null
	  });
	}
	
	/**
	 * Processes any enqueued updates.
	 *
	 * @private
	 */
	function processQueue() {
	  if (updateQueue.length) {
	    ReactComponentEnvironment.processChildrenUpdates(updateQueue, markupQueue);
	    clearQueue();
	  }
	}
	
	/**
	 * Clears any enqueued updates.
	 *
	 * @private
	 */
	function clearQueue() {
	  updateQueue.length = 0;
	  markupQueue.length = 0;
	}
	
	/**
	 * ReactMultiChild are capable of reconciling multiple children.
	 *
	 * @class ReactMultiChild
	 * @internal
	 */
	var ReactMultiChild = {
	
	  /**
	   * Provides common functionality for components that must reconcile multiple
	   * children. This is used by `ReactDOMComponent` to mount, update, and
	   * unmount child components.
	   *
	   * @lends {ReactMultiChild.prototype}
	   */
	  Mixin: {
	
	    _reconcilerInstantiateChildren: function _reconcilerInstantiateChildren(nestedChildren, transaction, context) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	        }
	      }
	      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
	    },
	
	    _reconcilerUpdateChildren: function _reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, transaction, context) {
	      var nextChildren;
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            nextChildren = flattenChildren(nextNestedChildrenElements);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	          return ReactChildReconciler.updateChildren(prevChildren, nextChildren, transaction, context);
	        }
	      }
	      nextChildren = flattenChildren(nextNestedChildrenElements);
	      return ReactChildReconciler.updateChildren(prevChildren, nextChildren, transaction, context);
	    },
	
	    /**
	     * Generates a "mount image" for each of the supplied children. In the case
	     * of `ReactDOMComponent`, a mount image is a string of markup.
	     *
	     * @param {?object} nestedChildren Nested child maps.
	     * @return {array} An array of mounted representations.
	     * @internal
	     */
	    mountChildren: function mountChildren(nestedChildren, transaction, context) {
	      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
	      this._renderedChildren = children;
	      var mountImages = [];
	      var index = 0;
	      for (var name in children) {
	        if (children.hasOwnProperty(name)) {
	          var child = children[name];
	          // Inlined for performance, see `ReactInstanceHandles.createReactID`.
	          var rootID = this._rootNodeID + name;
	          var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
	          child._mountIndex = index++;
	          mountImages.push(mountImage);
	        }
	      }
	      return mountImages;
	    },
	
	    /**
	     * Replaces any rendered children with a text content string.
	     *
	     * @param {string} nextContent String of content.
	     * @internal
	     */
	    updateTextContent: function updateTextContent(nextContent) {
	      updateDepth++;
	      var errorThrown = true;
	      try {
	        var prevChildren = this._renderedChildren;
	        // Remove any rendered children.
	        ReactChildReconciler.unmountChildren(prevChildren);
	        // TODO: The setTextContent operation should be enough
	        for (var name in prevChildren) {
	          if (prevChildren.hasOwnProperty(name)) {
	            this._unmountChild(prevChildren[name]);
	          }
	        }
	        // Set new text content.
	        this.setTextContent(nextContent);
	        errorThrown = false;
	      } finally {
	        updateDepth--;
	        if (!updateDepth) {
	          if (errorThrown) {
	            clearQueue();
	          } else {
	            processQueue();
	          }
	        }
	      }
	    },
	
	    /**
	     * Replaces any rendered children with a markup string.
	     *
	     * @param {string} nextMarkup String of markup.
	     * @internal
	     */
	    updateMarkup: function updateMarkup(nextMarkup) {
	      updateDepth++;
	      var errorThrown = true;
	      try {
	        var prevChildren = this._renderedChildren;
	        // Remove any rendered children.
	        ReactChildReconciler.unmountChildren(prevChildren);
	        for (var name in prevChildren) {
	          if (prevChildren.hasOwnProperty(name)) {
	            this._unmountChildByName(prevChildren[name], name);
	          }
	        }
	        this.setMarkup(nextMarkup);
	        errorThrown = false;
	      } finally {
	        updateDepth--;
	        if (!updateDepth) {
	          if (errorThrown) {
	            clearQueue();
	          } else {
	            processQueue();
	          }
	        }
	      }
	    },
	
	    /**
	     * Updates the rendered children with new children.
	     *
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @internal
	     */
	    updateChildren: function updateChildren(nextNestedChildrenElements, transaction, context) {
	      updateDepth++;
	      var errorThrown = true;
	      try {
	        this._updateChildren(nextNestedChildrenElements, transaction, context);
	        errorThrown = false;
	      } finally {
	        updateDepth--;
	        if (!updateDepth) {
	          if (errorThrown) {
	            clearQueue();
	          } else {
	            processQueue();
	          }
	        }
	      }
	    },
	
	    /**
	     * Improve performance by isolating this hot code path from the try/catch
	     * block in `updateChildren`.
	     *
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @final
	     * @protected
	     */
	    _updateChildren: function _updateChildren(nextNestedChildrenElements, transaction, context) {
	      var prevChildren = this._renderedChildren;
	      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, transaction, context);
	      this._renderedChildren = nextChildren;
	      if (!nextChildren && !prevChildren) {
	        return;
	      }
	      var name;
	      // `nextIndex` will increment for each child in `nextChildren`, but
	      // `lastIndex` will be the last index visited in `prevChildren`.
	      var lastIndex = 0;
	      var nextIndex = 0;
	      for (name in nextChildren) {
	        if (!nextChildren.hasOwnProperty(name)) {
	          continue;
	        }
	        var prevChild = prevChildren && prevChildren[name];
	        var nextChild = nextChildren[name];
	        if (prevChild === nextChild) {
	          this.moveChild(prevChild, nextIndex, lastIndex);
	          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	          prevChild._mountIndex = nextIndex;
	        } else {
	          if (prevChild) {
	            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
	            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	            this._unmountChild(prevChild);
	          }
	          // The child must be instantiated before it's mounted.
	          this._mountChildByNameAtIndex(nextChild, name, nextIndex, transaction, context);
	        }
	        nextIndex++;
	      }
	      // Remove children that are no longer present.
	      for (name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
	          this._unmountChild(prevChildren[name]);
	        }
	      }
	    },
	
	    /**
	     * Unmounts all rendered children. This should be used to clean up children
	     * when this component is unmounted.
	     *
	     * @internal
	     */
	    unmountChildren: function unmountChildren() {
	      var renderedChildren = this._renderedChildren;
	      ReactChildReconciler.unmountChildren(renderedChildren);
	      this._renderedChildren = null;
	    },
	
	    /**
	     * Moves a child component to the supplied index.
	     *
	     * @param {ReactComponent} child Component to move.
	     * @param {number} toIndex Destination index of the element.
	     * @param {number} lastIndex Last index visited of the siblings of `child`.
	     * @protected
	     */
	    moveChild: function moveChild(child, toIndex, lastIndex) {
	      // If the index of `child` is less than `lastIndex`, then it needs to
	      // be moved. Otherwise, we do not need to move it because a child will be
	      // inserted or moved before `child`.
	      if (child._mountIndex < lastIndex) {
	        enqueueMove(this._rootNodeID, child._mountIndex, toIndex);
	      }
	    },
	
	    /**
	     * Creates a child component.
	     *
	     * @param {ReactComponent} child Component to create.
	     * @param {string} mountImage Markup to insert.
	     * @protected
	     */
	    createChild: function createChild(child, mountImage) {
	      enqueueInsertMarkup(this._rootNodeID, mountImage, child._mountIndex);
	    },
	
	    /**
	     * Removes a child component.
	     *
	     * @param {ReactComponent} child Child to remove.
	     * @protected
	     */
	    removeChild: function removeChild(child) {
	      enqueueRemove(this._rootNodeID, child._mountIndex);
	    },
	
	    /**
	     * Sets this text content string.
	     *
	     * @param {string} textContent Text content to set.
	     * @protected
	     */
	    setTextContent: function setTextContent(textContent) {
	      enqueueTextContent(this._rootNodeID, textContent);
	    },
	
	    /**
	     * Sets this markup string.
	     *
	     * @param {string} markup Markup to set.
	     * @protected
	     */
	    setMarkup: function setMarkup(markup) {
	      enqueueSetMarkup(this._rootNodeID, markup);
	    },
	
	    /**
	     * Mounts a child with the supplied name.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to mount.
	     * @param {string} name Name of the child.
	     * @param {number} index Index at which to insert the child.
	     * @param {ReactReconcileTransaction} transaction
	     * @private
	     */
	    _mountChildByNameAtIndex: function _mountChildByNameAtIndex(child, name, index, transaction, context) {
	      // Inlined for performance, see `ReactInstanceHandles.createReactID`.
	      var rootID = this._rootNodeID + name;
	      var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
	      child._mountIndex = index;
	      this.createChild(child, mountImage);
	    },
	
	    /**
	     * Unmounts a rendered child.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to unmount.
	     * @private
	     */
	    _unmountChild: function _unmountChild(child) {
	      this.removeChild(child);
	      child._mountIndex = null;
	    }
	
	  }
	
	};
	
	module.exports = ReactMultiChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildReconciler
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactReconciler = __webpack_require__(57);
	
	var instantiateReactComponent = __webpack_require__(69);
	var shouldUpdateReactComponent = __webpack_require__(74);
	var traverseAllChildren = __webpack_require__(118);
	var warning = __webpack_require__(32);
	
	function instantiateChild(childInstances, child, name) {
	  // We found a component instance.
	  var keyUnique = childInstances[name] === undefined;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
	  }
	  if (child != null && keyUnique) {
	    childInstances[name] = instantiateReactComponent(child, null);
	  }
	}
	
	/**
	 * ReactChildReconciler provides helpers for initializing or updating a set of
	 * children. Its output is suitable for passing it onto ReactMultiChild which
	 * does diffed reordering and insertion.
	 */
	var ReactChildReconciler = {
	  /**
	   * Generates a "mount image" for each of the supplied children. In the case
	   * of `ReactDOMComponent`, a mount image is a string of markup.
	   *
	   * @param {?object} nestedChildNodes Nested child maps.
	   * @return {?object} A set of child instances.
	   * @internal
	   */
	  instantiateChildren: function instantiateChildren(nestedChildNodes, transaction, context) {
	    if (nestedChildNodes == null) {
	      return null;
	    }
	    var childInstances = {};
	    traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
	    return childInstances;
	  },
	
	  /**
	   * Updates the rendered children and returns a new set of children.
	   *
	   * @param {?object} prevChildren Previously initialized set of children.
	   * @param {?object} nextChildren Flat child element maps.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @return {?object} A new set of child instances.
	   * @internal
	   */
	  updateChildren: function updateChildren(prevChildren, nextChildren, transaction, context) {
	    // We currently don't have a way to track moves here but if we use iterators
	    // instead of for..in we can zip the iterators and check if an item has
	    // moved.
	    // TODO: If nothing has changed, return the prevChildren object so that we
	    // can quickly bailout if nothing has changed.
	    if (!nextChildren && !prevChildren) {
	      return null;
	    }
	    var name;
	    for (name in nextChildren) {
	      if (!nextChildren.hasOwnProperty(name)) {
	        continue;
	      }
	      var prevChild = prevChildren && prevChildren[name];
	      var prevElement = prevChild && prevChild._currentElement;
	      var nextElement = nextChildren[name];
	      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
	        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
	        nextChildren[name] = prevChild;
	      } else {
	        if (prevChild) {
	          ReactReconciler.unmountComponent(prevChild, name);
	        }
	        // The child must be instantiated before it's mounted.
	        var nextChildInstance = instantiateReactComponent(nextElement, null);
	        nextChildren[name] = nextChildInstance;
	      }
	    }
	    // Unmount children that are no longer present.
	    for (name in prevChildren) {
	      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
	        ReactReconciler.unmountComponent(prevChildren[name]);
	      }
	    }
	    return nextChildren;
	  },
	
	  /**
	   * Unmounts all rendered children. This should be used to clean up children
	   * when this component is unmounted.
	   *
	   * @param {?object} renderedChildren Previously initialized set of children.
	   * @internal
	   */
	  unmountChildren: function unmountChildren(renderedChildren) {
	    for (var name in renderedChildren) {
	      if (renderedChildren.hasOwnProperty(name)) {
	        var renderedChild = renderedChildren[name];
	        ReactReconciler.unmountComponent(renderedChild);
	      }
	    }
	  }
	
	};
	
	module.exports = ReactChildReconciler;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule flattenChildren
	 */
	
	'use strict';
	
	var traverseAllChildren = __webpack_require__(118);
	var warning = __webpack_require__(32);
	
	/**
	 * @param {function} traverseContext Context passed through traversal.
	 * @param {?ReactComponent} child React child component.
	 * @param {!string} name String name of key path to child.
	 */
	function flattenSingleChildIntoContext(traverseContext, child, name) {
	  // We found a component instance.
	  var result = traverseContext;
	  var keyUnique = result[name] === undefined;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
	  }
	  if (keyUnique && child != null) {
	    result[name] = child;
	  }
	}
	
	/**
	 * Flattens children that are typically specified as `props.children`. Any null
	 * children will not be included in the resulting object.
	 * @return {!object} flattened children keyed by name.
	 */
	function flattenChildren(children) {
	  if (children == null) {
	    return children;
	  }
	  var result = {};
	  traverseAllChildren(children, flattenSingleChildIntoContext, result);
	  return result;
	}
	
	module.exports = flattenChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 124 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule shallowEqual
	 * @typechecks
	 * 
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	/**
	 * Performs equality by iterating through keys on an object and returning false
	 * when any key has values which are not strictly equal between the arguments.
	 * Returns true when the values of all keys are strictly equal.
	 */
	function shallowEqual(objA, objB) {
	  if (objA === objB) {
	    return true;
	  }
	
	  if ((typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) !== 'object' || objA === null || (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'object' || objB === null) {
	    return false;
	  }
	
	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);
	
	  if (keysA.length !== keysB.length) {
	    return false;
	  }
	
	  // Test for A's keys different from B.
	  var bHasOwnProperty = hasOwnProperty.bind(objB);
	  for (var i = 0; i < keysA.length; i++) {
	    if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
	      return false;
	    }
	  }
	
	  return true;
	}
	
	module.exports = shallowEqual;

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEventListener
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var EventListener = __webpack_require__(126);
	var ExecutionEnvironment = __webpack_require__(16);
	var PooledClass = __webpack_require__(63);
	var ReactInstanceHandles = __webpack_require__(52);
	var ReactMount = __webpack_require__(35);
	var ReactUpdates = __webpack_require__(61);
	
	var assign = __webpack_require__(46);
	var getEventTarget = __webpack_require__(88);
	var getUnboundedScrollPosition = __webpack_require__(127);
	
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	/**
	 * Finds the parent React component of `node`.
	 *
	 * @param {*} node
	 * @return {?DOMEventTarget} Parent container, or `null` if the specified node
	 *                           is not nested.
	 */
	function findParent(node) {
	  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
	  // traversal, but caching is difficult to do correctly without using a
	  // mutation observer to listen for all DOM changes.
	  var nodeID = ReactMount.getID(node);
	  var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
	  var container = ReactMount.findReactContainerForID(rootID);
	  var parent = ReactMount.getFirstReactDOM(container);
	  return parent;
	}
	
	// Used to store ancestor hierarchy in top level callback
	function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
	  this.topLevelType = topLevelType;
	  this.nativeEvent = nativeEvent;
	  this.ancestors = [];
	}
	assign(TopLevelCallbackBookKeeping.prototype, {
	  destructor: function destructor() {
	    this.topLevelType = null;
	    this.nativeEvent = null;
	    this.ancestors.length = 0;
	  }
	});
	PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);
	
	function handleTopLevelImpl(bookKeeping) {
	  // TODO: Re-enable event.path handling
	  //
	  // if (bookKeeping.nativeEvent.path && bookKeeping.nativeEvent.path.length > 1) {
	  //   // New browsers have a path attribute on native events
	  //   handleTopLevelWithPath(bookKeeping);
	  // } else {
	  //   // Legacy browsers don't have a path attribute on native events
	  //   handleTopLevelWithoutPath(bookKeeping);
	  // }
	
	  void handleTopLevelWithPath; // temporarily unused
	  handleTopLevelWithoutPath(bookKeeping);
	}
	
	// Legacy browsers don't have a path attribute on native events
	function handleTopLevelWithoutPath(bookKeeping) {
	  var topLevelTarget = ReactMount.getFirstReactDOM(getEventTarget(bookKeeping.nativeEvent)) || window;
	
	  // Loop through the hierarchy, in case there's any nested components.
	  // It's important that we build the array of ancestors before calling any
	  // event handlers, because event handlers can modify the DOM, leading to
	  // inconsistencies with ReactMount's node cache. See #1105.
	  var ancestor = topLevelTarget;
	  while (ancestor) {
	    bookKeeping.ancestors.push(ancestor);
	    ancestor = findParent(ancestor);
	  }
	
	  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
	    topLevelTarget = bookKeeping.ancestors[i];
	    var topLevelTargetID = ReactMount.getID(topLevelTarget) || '';
	    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, topLevelTarget, topLevelTargetID, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
	  }
	}
	
	// New browsers have a path attribute on native events
	function handleTopLevelWithPath(bookKeeping) {
	  var path = bookKeeping.nativeEvent.path;
	  var currentNativeTarget = path[0];
	  var eventsFired = 0;
	  for (var i = 0; i < path.length; i++) {
	    var currentPathElement = path[i];
	    if (currentPathElement.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE) {
	      currentNativeTarget = path[i + 1];
	    }
	    // TODO: slow
	    var reactParent = ReactMount.getFirstReactDOM(currentPathElement);
	    if (reactParent === currentPathElement) {
	      var currentPathElementID = ReactMount.getID(currentPathElement);
	      var newRootID = ReactInstanceHandles.getReactRootIDFromNodeID(currentPathElementID);
	      bookKeeping.ancestors.push(currentPathElement);
	
	      var topLevelTargetID = ReactMount.getID(currentPathElement) || '';
	      eventsFired++;
	      ReactEventListener._handleTopLevel(bookKeeping.topLevelType, currentPathElement, topLevelTargetID, bookKeeping.nativeEvent, currentNativeTarget);
	
	      // Jump to the root of this React render tree
	      while (currentPathElementID !== newRootID) {
	        i++;
	        currentPathElement = path[i];
	        currentPathElementID = ReactMount.getID(currentPathElement);
	      }
	    }
	  }
	  if (eventsFired === 0) {
	    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, window, '', bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
	  }
	}
	
	function scrollValueMonitor(cb) {
	  var scrollPosition = getUnboundedScrollPosition(window);
	  cb(scrollPosition);
	}
	
	var ReactEventListener = {
	  _enabled: true,
	  _handleTopLevel: null,
	
	  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,
	
	  setHandleTopLevel: function setHandleTopLevel(handleTopLevel) {
	    ReactEventListener._handleTopLevel = handleTopLevel;
	  },
	
	  setEnabled: function setEnabled(enabled) {
	    ReactEventListener._enabled = !!enabled;
	  },
	
	  isEnabled: function isEnabled() {
	    return ReactEventListener._enabled;
	  },
	
	  /**
	   * Traps top-level events by using event bubbling.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} handle Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapBubbledEvent: function trapBubbledEvent(topLevelType, handlerBaseName, handle) {
	    var element = handle;
	    if (!element) {
	      return null;
	    }
	    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  /**
	   * Traps a top-level event by using event capturing.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} handle Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapCapturedEvent: function trapCapturedEvent(topLevelType, handlerBaseName, handle) {
	    var element = handle;
	    if (!element) {
	      return null;
	    }
	    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  monitorScrollValue: function monitorScrollValue(refresh) {
	    var callback = scrollValueMonitor.bind(null, refresh);
	    EventListener.listen(window, 'scroll', callback);
	  },
	
	  dispatchEvent: function dispatchEvent(topLevelType, nativeEvent) {
	    if (!ReactEventListener._enabled) {
	      return;
	    }
	
	    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
	    try {
	      // Event queue being processed in the same cycle allows
	      // `preventDefault`.
	      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
	    } finally {
	      TopLevelCallbackBookKeeping.release(bookKeeping);
	    }
	  }
	};
	
	module.exports = ReactEventListener;

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 * @providesModule EventListener
	 * @typechecks
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(22);
	
	/**
	 * Upstream version of event listener. Does not take into account specific
	 * nature of platform.
	 */
	var EventListener = {
	  /**
	   * Listen to DOM events during the bubble phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  listen: function listen(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, false);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, false);
	        }
	      };
	    } else if (target.attachEvent) {
	      target.attachEvent('on' + eventType, callback);
	      return {
	        remove: function remove() {
	          target.detachEvent('on' + eventType, callback);
	        }
	      };
	    }
	  },
	
	  /**
	   * Listen to DOM events during the capture phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  capture: function capture(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, true);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, true);
	        }
	      };
	    } else {
	      if (process.env.NODE_ENV !== 'production') {
	        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
	      }
	      return {
	        remove: emptyFunction
	      };
	    }
	  },
	
	  registerDefault: function registerDefault() {}
	};
	
	module.exports = EventListener;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 127 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getUnboundedScrollPosition
	 * @typechecks
	 */
	
	'use strict';
	
	/**
	 * Gets the scroll position of the supplied element or window.
	 *
	 * The return values are unbounded, unlike `getScrollPosition`. This means they
	 * may be negative or exceed the element boundaries (which is possible using
	 * inertial scrolling).
	 *
	 * @param {DOMWindow|DOMElement} scrollable
	 * @return {object} Map with `x` and `y` keys.
	 */
	
	function getUnboundedScrollPosition(scrollable) {
	  if (scrollable === window) {
	    return {
	      x: window.pageXOffset || document.documentElement.scrollLeft,
	      y: window.pageYOffset || document.documentElement.scrollTop
	    };
	  }
	  return {
	    x: scrollable.scrollLeft,
	    y: scrollable.scrollTop
	  };
	}
	
	module.exports = getUnboundedScrollPosition;

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInjection
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(30);
	var EventPluginHub = __webpack_require__(38);
	var ReactComponentEnvironment = __webpack_require__(71);
	var ReactClass = __webpack_require__(129);
	var ReactEmptyComponent = __webpack_require__(75);
	var ReactBrowserEventEmitter = __webpack_require__(36);
	var ReactNativeComponent = __webpack_require__(76);
	var ReactPerf = __webpack_require__(25);
	var ReactRootIndex = __webpack_require__(53);
	var ReactUpdates = __webpack_require__(61);
	
	var ReactInjection = {
	  Component: ReactComponentEnvironment.injection,
	  Class: ReactClass.injection,
	  DOMProperty: DOMProperty.injection,
	  EmptyComponent: ReactEmptyComponent.injection,
	  EventPluginHub: EventPluginHub.injection,
	  EventEmitter: ReactBrowserEventEmitter.injection,
	  NativeComponent: ReactNativeComponent.injection,
	  Perf: ReactPerf.injection,
	  RootIndex: ReactRootIndex.injection,
	  Updates: ReactUpdates.injection
	};
	
	module.exports = ReactInjection;

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactClass
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactComponent = __webpack_require__(130);
	var ReactElement = __webpack_require__(49);
	var ReactPropTypeLocations = __webpack_require__(72);
	var ReactPropTypeLocationNames = __webpack_require__(73);
	var ReactNoopUpdateQueue = __webpack_require__(131);
	
	var assign = __webpack_require__(46);
	var emptyObject = __webpack_require__(65);
	var invariant = __webpack_require__(20);
	var keyMirror = __webpack_require__(24);
	var keyOf = __webpack_require__(86);
	var warning = __webpack_require__(32);
	
	var MIXINS_KEY = keyOf({ mixins: null });
	
	/**
	 * Policies that describe methods in `ReactClassInterface`.
	 */
	var SpecPolicy = keyMirror({
	  /**
	   * These methods may be defined only once by the class specification or mixin.
	   */
	  DEFINE_ONCE: null,
	  /**
	   * These methods may be defined by both the class specification and mixins.
	   * Subsequent definitions will be chained. These methods must return void.
	   */
	  DEFINE_MANY: null,
	  /**
	   * These methods are overriding the base class.
	   */
	  OVERRIDE_BASE: null,
	  /**
	   * These methods are similar to DEFINE_MANY, except we assume they return
	   * objects. We try to merge the keys of the return values of all the mixed in
	   * functions. If there is a key conflict we throw.
	   */
	  DEFINE_MANY_MERGED: null
	});
	
	var injectedMixins = [];
	
	var warnedSetProps = false;
	function warnSetProps() {
	  if (!warnedSetProps) {
	    warnedSetProps = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'setProps(...) and replaceProps(...) are deprecated. ' + 'Instead, call render again at the top level.') : undefined;
	  }
	}
	
	/**
	 * Composite components are higher-level components that compose other composite
	 * or native components.
	 *
	 * To create a new type of `ReactClass`, pass a specification of
	 * your new class to `React.createClass`. The only requirement of your class
	 * specification is that you implement a `render` method.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return <div>Hello World</div>;
	 *     }
	 *   });
	 *
	 * The class specification supports a specific protocol of methods that have
	 * special meaning (e.g. `render`). See `ReactClassInterface` for
	 * more the comprehensive protocol. Any other properties and methods in the
	 * class specification will be available on the prototype.
	 *
	 * @interface ReactClassInterface
	 * @internal
	 */
	var ReactClassInterface = {
	
	  /**
	   * An array of Mixin objects to include when defining your component.
	   *
	   * @type {array}
	   * @optional
	   */
	  mixins: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * An object containing properties and methods that should be defined on
	   * the component's constructor instead of its prototype (static methods).
	   *
	   * @type {object}
	   * @optional
	   */
	  statics: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of prop types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  propTypes: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of context types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  contextTypes: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of context types this component sets for its children.
	   *
	   * @type {object}
	   * @optional
	   */
	  childContextTypes: SpecPolicy.DEFINE_MANY,
	
	  // ==== Definition methods ====
	
	  /**
	   * Invoked when the component is mounted. Values in the mapping will be set on
	   * `this.props` if that prop is not specified (i.e. using an `in` check).
	   *
	   * This method is invoked before `getInitialState` and therefore cannot rely
	   * on `this.state` or use `this.setState`.
	   *
	   * @return {object}
	   * @optional
	   */
	  getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * Invoked once before the component is mounted. The return value will be used
	   * as the initial value of `this.state`.
	   *
	   *   getInitialState: function() {
	   *     return {
	   *       isOn: false,
	   *       fooBaz: new BazFoo()
	   *     }
	   *   }
	   *
	   * @return {object}
	   * @optional
	   */
	  getInitialState: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * @return {object}
	   * @optional
	   */
	  getChildContext: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * Uses props from `this.props` and state from `this.state` to render the
	   * structure of the component.
	   *
	   * No guarantees are made about when or how often this method is invoked, so
	   * it must not have side effects.
	   *
	   *   render: function() {
	   *     var name = this.props.name;
	   *     return <div>Hello, {name}!</div>;
	   *   }
	   *
	   * @return {ReactComponent}
	   * @nosideeffects
	   * @required
	   */
	  render: SpecPolicy.DEFINE_ONCE,
	
	  // ==== Delegate methods ====
	
	  /**
	   * Invoked when the component is initially created and about to be mounted.
	   * This may have side effects, but any external subscriptions or data created
	   * by this method must be cleaned up in `componentWillUnmount`.
	   *
	   * @optional
	   */
	  componentWillMount: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component has been mounted and has a DOM representation.
	   * However, there is no guarantee that the DOM node is in the document.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been mounted (initialized and rendered) for the first time.
	   *
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidMount: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked before the component receives new props.
	   *
	   * Use this as an opportunity to react to a prop transition by updating the
	   * state using `this.setState`. Current props are accessed via `this.props`.
	   *
	   *   componentWillReceiveProps: function(nextProps, nextContext) {
	   *     this.setState({
	   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
	   *     });
	   *   }
	   *
	   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
	   * transition may cause a state change, but the opposite is not true. If you
	   * need it, you are probably looking for `componentWillUpdate`.
	   *
	   * @param {object} nextProps
	   * @optional
	   */
	  componentWillReceiveProps: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked while deciding if the component should be updated as a result of
	   * receiving new props, state and/or context.
	   *
	   * Use this as an opportunity to `return false` when you're certain that the
	   * transition to the new props/state/context will not require a component
	   * update.
	   *
	   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
	   *     return !equal(nextProps, this.props) ||
	   *       !equal(nextState, this.state) ||
	   *       !equal(nextContext, this.context);
	   *   }
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @return {boolean} True if the component should update.
	   * @optional
	   */
	  shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,
	
	  /**
	   * Invoked when the component is about to update due to a transition from
	   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
	   * and `nextContext`.
	   *
	   * Use this as an opportunity to perform preparation before an update occurs.
	   *
	   * NOTE: You **cannot** use `this.setState()` in this method.
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @param {ReactReconcileTransaction} transaction
	   * @optional
	   */
	  componentWillUpdate: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component's DOM representation has been updated.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been updated.
	   *
	   * @param {object} prevProps
	   * @param {?object} prevState
	   * @param {?object} prevContext
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidUpdate: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component is about to be removed from its parent and have
	   * its DOM representation destroyed.
	   *
	   * Use this as an opportunity to deallocate any external resources.
	   *
	   * NOTE: There is no `componentDidUnmount` since your component will have been
	   * destroyed by that point.
	   *
	   * @optional
	   */
	  componentWillUnmount: SpecPolicy.DEFINE_MANY,
	
	  // ==== Advanced methods ====
	
	  /**
	   * Updates the component's currently mounted DOM representation.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   * @overridable
	   */
	  updateComponent: SpecPolicy.OVERRIDE_BASE
	
	};
	
	/**
	 * Mapping from class specification keys to special processing functions.
	 *
	 * Although these are declared like instance properties in the specification
	 * when defining classes using `React.createClass`, they are actually static
	 * and are accessible on the constructor instead of the prototype. Despite
	 * being static, they must be defined outside of the "statics" key under
	 * which all other static methods are defined.
	 */
	var RESERVED_SPEC_KEYS = {
	  displayName: function displayName(Constructor, _displayName) {
	    Constructor.displayName = _displayName;
	  },
	  mixins: function mixins(Constructor, _mixins) {
	    if (_mixins) {
	      for (var i = 0; i < _mixins.length; i++) {
	        mixSpecIntoComponent(Constructor, _mixins[i]);
	      }
	    }
	  },
	  childContextTypes: function childContextTypes(Constructor, _childContextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, _childContextTypes, ReactPropTypeLocations.childContext);
	    }
	    Constructor.childContextTypes = assign({}, Constructor.childContextTypes, _childContextTypes);
	  },
	  contextTypes: function contextTypes(Constructor, _contextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, _contextTypes, ReactPropTypeLocations.context);
	    }
	    Constructor.contextTypes = assign({}, Constructor.contextTypes, _contextTypes);
	  },
	  /**
	   * Special case getDefaultProps which should move into statics but requires
	   * automatic merging.
	   */
	  getDefaultProps: function getDefaultProps(Constructor, _getDefaultProps) {
	    if (Constructor.getDefaultProps) {
	      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, _getDefaultProps);
	    } else {
	      Constructor.getDefaultProps = _getDefaultProps;
	    }
	  },
	  propTypes: function propTypes(Constructor, _propTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, _propTypes, ReactPropTypeLocations.prop);
	    }
	    Constructor.propTypes = assign({}, Constructor.propTypes, _propTypes);
	  },
	  statics: function statics(Constructor, _statics) {
	    mixStaticSpecIntoComponent(Constructor, _statics);
	  },
	  autobind: function autobind() {} };
	
	// noop
	function validateTypeDef(Constructor, typeDef, location) {
	  for (var propName in typeDef) {
	    if (typeDef.hasOwnProperty(propName)) {
	      // use a warning instead of an invariant so components
	      // don't show up in prod but not in __DEV__
	      process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : undefined;
	    }
	  }
	}
	
	function validateMethodOverride(proto, name) {
	  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;
	
	  // Disallow overriding of base class methods unless explicitly allowed.
	  if (ReactClassMixin.hasOwnProperty(name)) {
	    !(specPolicy === SpecPolicy.OVERRIDE_BASE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override ' + '`%s` from your class specification. Ensure that your method names ' + 'do not overlap with React methods.', name) : invariant(false) : undefined;
	  }
	
	  // Disallow defining methods more than once unless explicitly allowed.
	  if (proto.hasOwnProperty(name)) {
	    !(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define ' + '`%s` on your component more than once. This conflict may be due ' + 'to a mixin.', name) : invariant(false) : undefined;
	  }
	}
	
	/**
	 * Mixin helper which handles policy validation and reserved
	 * specification keys when building React classses.
	 */
	function mixSpecIntoComponent(Constructor, spec) {
	  if (!spec) {
	    return;
	  }
	
	  !(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component class as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;
	  !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;
	
	  var proto = Constructor.prototype;
	
	  // By handling mixins before any other properties, we ensure the same
	  // chaining order is applied to methods with DEFINE_MANY policy, whether
	  // mixins are listed before or after these methods in the spec.
	  if (spec.hasOwnProperty(MIXINS_KEY)) {
	    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
	  }
	
	  for (var name in spec) {
	    if (!spec.hasOwnProperty(name)) {
	      continue;
	    }
	
	    if (name === MIXINS_KEY) {
	      // We have already handled mixins in a special case above.
	      continue;
	    }
	
	    var property = spec[name];
	    validateMethodOverride(proto, name);
	
	    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
	      RESERVED_SPEC_KEYS[name](Constructor, property);
	    } else {
	      // Setup methods on prototype:
	      // The following member methods should not be automatically bound:
	      // 1. Expected ReactClass methods (in the "interface").
	      // 2. Overridden methods (that were mixed in).
	      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
	      var isAlreadyDefined = proto.hasOwnProperty(name);
	      var isFunction = typeof property === 'function';
	      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;
	
	      if (shouldAutoBind) {
	        if (!proto.__reactAutoBindMap) {
	          proto.__reactAutoBindMap = {};
	        }
	        proto.__reactAutoBindMap[name] = property;
	        proto[name] = property;
	      } else {
	        if (isAlreadyDefined) {
	          var specPolicy = ReactClassInterface[name];
	
	          // These cases should already be caught by validateMethodOverride.
	          !(isReactClassMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s ' + 'when mixing in component specs.', specPolicy, name) : invariant(false) : undefined;
	
	          // For methods which are defined more than once, call the existing
	          // methods before calling the new property, merging if appropriate.
	          if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
	            proto[name] = createMergedResultFunction(proto[name], property);
	          } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
	            proto[name] = createChainedFunction(proto[name], property);
	          }
	        } else {
	          proto[name] = property;
	          if (process.env.NODE_ENV !== 'production') {
	            // Add verbose displayName to the function, which helps when looking
	            // at profiling tools.
	            if (typeof property === 'function' && spec.displayName) {
	              proto[name].displayName = spec.displayName + '_' + name;
	            }
	          }
	        }
	      }
	    }
	  }
	}
	
	function mixStaticSpecIntoComponent(Constructor, statics) {
	  if (!statics) {
	    return;
	  }
	  for (var name in statics) {
	    var property = statics[name];
	    if (!statics.hasOwnProperty(name)) {
	      continue;
	    }
	
	    var isReserved = name in RESERVED_SPEC_KEYS;
	    !!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved ' + 'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' + 'as an instance property instead; it will still be accessible on the ' + 'constructor.', name) : invariant(false) : undefined;
	
	    var isInherited = name in Constructor;
	    !!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define ' + '`%s` on your component more than once. This conflict may be ' + 'due to a mixin.', name) : invariant(false) : undefined;
	    Constructor[name] = property;
	  }
	}
	
	/**
	 * Merge two objects, but throw if both contain the same key.
	 *
	 * @param {object} one The first object, which is mutated.
	 * @param {object} two The second object
	 * @return {object} one after it has been mutated to contain everything in two.
	 */
	function mergeIntoWithNoDuplicateKeys(one, two) {
	  !(one && two && (typeof one === 'undefined' ? 'undefined' : _typeof(one)) === 'object' && (typeof two === 'undefined' ? 'undefined' : _typeof(two)) === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : invariant(false) : undefined;
	
	  for (var key in two) {
	    if (two.hasOwnProperty(key)) {
	      !(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): ' + 'Tried to merge two objects with the same key: `%s`. This conflict ' + 'may be due to a mixin; in particular, this may be caused by two ' + 'getInitialState() or getDefaultProps() methods returning objects ' + 'with clashing keys.', key) : invariant(false) : undefined;
	      one[key] = two[key];
	    }
	  }
	  return one;
	}
	
	/**
	 * Creates a function that invokes two functions and merges their return values.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createMergedResultFunction(one, two) {
	  return function mergedResult() {
	    var a = one.apply(this, arguments);
	    var b = two.apply(this, arguments);
	    if (a == null) {
	      return b;
	    } else if (b == null) {
	      return a;
	    }
	    var c = {};
	    mergeIntoWithNoDuplicateKeys(c, a);
	    mergeIntoWithNoDuplicateKeys(c, b);
	    return c;
	  };
	}
	
	/**
	 * Creates a function that invokes two functions and ignores their return vales.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createChainedFunction(one, two) {
	  return function chainedFunction() {
	    one.apply(this, arguments);
	    two.apply(this, arguments);
	  };
	}
	
	/**
	 * Binds a method to the component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 * @param {function} method Method to be bound.
	 * @return {function} The bound method.
	 */
	function bindAutoBindMethod(component, method) {
	  var boundMethod = method.bind(component);
	  if (process.env.NODE_ENV !== 'production') {
	    boundMethod.__reactBoundContext = component;
	    boundMethod.__reactBoundMethod = method;
	    boundMethod.__reactBoundArguments = null;
	    var componentName = component.constructor.displayName;
	    var _bind = boundMethod.bind;
	    /* eslint-disable block-scoped-var, no-undef */
	    boundMethod.bind = function (newThis) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      // User is trying to bind() an autobound method; we effectively will
	      // ignore the value of "this" that the user is trying to use, so
	      // let's warn.
	      if (newThis !== component && newThis !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : undefined;
	      } else if (!args.length) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : undefined;
	        return boundMethod;
	      }
	      var reboundMethod = _bind.apply(boundMethod, arguments);
	      reboundMethod.__reactBoundContext = component;
	      reboundMethod.__reactBoundMethod = method;
	      reboundMethod.__reactBoundArguments = args;
	      return reboundMethod;
	      /* eslint-enable */
	    };
	  }
	  return boundMethod;
	}
	
	/**
	 * Binds all auto-bound methods in a component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 */
	function bindAutoBindMethods(component) {
	  for (var autoBindKey in component.__reactAutoBindMap) {
	    if (component.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {
	      var method = component.__reactAutoBindMap[autoBindKey];
	      component[autoBindKey] = bindAutoBindMethod(component, method);
	    }
	  }
	}
	
	/**
	 * Add more to the ReactClass base class. These are all legacy features and
	 * therefore not already part of the modern ReactComponent.
	 */
	var ReactClassMixin = {
	
	  /**
	   * TODO: This will be deprecated because state should always keep a consistent
	   * type signature and the only use case for this, is to avoid that.
	   */
	  replaceState: function replaceState(newState, callback) {
	    this.updater.enqueueReplaceState(this, newState);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback);
	    }
	  },
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function isMounted() {
	    return this.updater.isMounted(this);
	  },
	
	  /**
	   * Sets a subset of the props.
	   *
	   * @param {object} partialProps Subset of the next props.
	   * @param {?function} callback Called after props are updated.
	   * @final
	   * @public
	   * @deprecated
	   */
	  setProps: function setProps(partialProps, callback) {
	    if (process.env.NODE_ENV !== 'production') {
	      warnSetProps();
	    }
	    this.updater.enqueueSetProps(this, partialProps);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback);
	    }
	  },
	
	  /**
	   * Replace all the props.
	   *
	   * @param {object} newProps Subset of the next props.
	   * @param {?function} callback Called after props are updated.
	   * @final
	   * @public
	   * @deprecated
	   */
	  replaceProps: function replaceProps(newProps, callback) {
	    if (process.env.NODE_ENV !== 'production') {
	      warnSetProps();
	    }
	    this.updater.enqueueReplaceProps(this, newProps);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback);
	    }
	  }
	};
	
	var ReactClassComponent = function ReactClassComponent() {};
	assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);
	
	/**
	 * Module for creating composite components.
	 *
	 * @class ReactClass
	 */
	var ReactClass = {
	
	  /**
	   * Creates a composite component class given a class specification.
	   *
	   * @param {object} spec Class specification (which must define `render`).
	   * @return {function} Component constructor function.
	   * @public
	   */
	  createClass: function createClass(spec) {
	    var Constructor = function Constructor(props, context, updater) {
	      // This constructor is overridden by mocks. The argument is used
	      // by mocks to assert on what gets mounted.
	
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : undefined;
	      }
	
	      // Wire up auto-binding
	      if (this.__reactAutoBindMap) {
	        bindAutoBindMethods(this);
	      }
	
	      this.props = props;
	      this.context = context;
	      this.refs = emptyObject;
	      this.updater = updater || ReactNoopUpdateQueue;
	
	      this.state = null;
	
	      // ReactClasses doesn't have constructors. Instead, they use the
	      // getInitialState and componentWillMount methods for initialization.
	
	      var initialState = this.getInitialState ? this.getInitialState() : null;
	      if (process.env.NODE_ENV !== 'production') {
	        // We allow auto-mocks to proceed as if they're returning null.
	        if (typeof initialState === 'undefined' && this.getInitialState._isMockFunction) {
	          // This is probably bad practice. Consider warning here and
	          // deprecating this convenience.
	          initialState = null;
	        }
	      }
	      !((typeof initialState === 'undefined' ? 'undefined' : _typeof(initialState)) === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : invariant(false) : undefined;
	
	      this.state = initialState;
	    };
	    Constructor.prototype = new ReactClassComponent();
	    Constructor.prototype.constructor = Constructor;
	
	    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
	
	    mixSpecIntoComponent(Constructor, spec);
	
	    // Initialize the defaultProps property after all mixins have been merged.
	    if (Constructor.getDefaultProps) {
	      Constructor.defaultProps = Constructor.getDefaultProps();
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This is a tag to indicate that the use of these method names is ok,
	      // since it's used with createClass. If it's not, then it's likely a
	      // mistake so we'll warn you to use the static property, property
	      // initializer or constructor respectively.
	      if (Constructor.getDefaultProps) {
	        Constructor.getDefaultProps.isReactClassApproved = {};
	      }
	      if (Constructor.prototype.getInitialState) {
	        Constructor.prototype.getInitialState.isReactClassApproved = {};
	      }
	    }
	
	    !Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : invariant(false) : undefined;
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : undefined;
	    }
	
	    // Reduce time spent doing lookups by setting these on the prototype.
	    for (var methodName in ReactClassInterface) {
	      if (!Constructor.prototype[methodName]) {
	        Constructor.prototype[methodName] = null;
	      }
	    }
	
	    return Constructor;
	  },
	
	  injection: {
	    injectMixin: function injectMixin(mixin) {
	      injectedMixins.push(mixin);
	    }
	  }
	
	};
	
	module.exports = ReactClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponent
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactNoopUpdateQueue = __webpack_require__(131);
	
	var canDefineProperty = __webpack_require__(50);
	var emptyObject = __webpack_require__(65);
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactComponent(props, context, updater) {
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}
	
	ReactComponent.prototype.isReactComponent = {};
	
	/**
	 * Sets a subset of the state. Always use this to mutate
	 * state. You should treat `this.state` as immutable.
	 *
	 * There is no guarantee that `this.state` will be immediately updated, so
	 * accessing `this.state` after calling this method may return the old value.
	 *
	 * There is no guarantee that calls to `setState` will run synchronously,
	 * as they may eventually be batched together.  You can provide an optional
	 * callback that will be executed when the call to setState is actually
	 * completed.
	 *
	 * When a function is provided to setState, it will be called at some point in
	 * the future (not synchronously). It will be called with the up to date
	 * component arguments (state, props, context). These values can be different
	 * from this.* because your function may be called after receiveProps but before
	 * shouldComponentUpdate, and this new state, props, and context will not yet be
	 * assigned to this.
	 *
	 * @param {object|function} partialState Next partial state or function to
	 *        produce next partial state to be merged with current state.
	 * @param {?function} callback Called after state is updated.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.setState = function (partialState, callback) {
	  !((typeof partialState === 'undefined' ? 'undefined' : _typeof(partialState)) === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.') : invariant(false) : undefined;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : undefined;
	  }
	  this.updater.enqueueSetState(this, partialState);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback);
	  }
	};
	
	/**
	 * Forces an update. This should only be invoked when it is known with
	 * certainty that we are **not** in a DOM transaction.
	 *
	 * You may want to call this when you know that some deeper aspect of the
	 * component's state has changed but `setState` was not called.
	 *
	 * This will not invoke `shouldComponentUpdate`, but it will invoke
	 * `componentWillUpdate` and `componentDidUpdate`.
	 *
	 * @param {?function} callback Called after update is complete.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.forceUpdate = function (callback) {
	  this.updater.enqueueForceUpdate(this);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback);
	  }
	};
	
	/**
	 * Deprecated APIs. These APIs used to exist on classic React classes but since
	 * we would like to deprecate them, we're not going to move them over to this
	 * modern base class. Instead, we define a getter that warns if it's accessed.
	 */
	if (process.env.NODE_ENV !== 'production') {
	  var deprecatedAPIs = {
	    getDOMNode: ['getDOMNode', 'Use ReactDOM.findDOMNode(component) instead.'],
	    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
	    replaceProps: ['replaceProps', 'Instead, call render again at the top level.'],
	    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).'],
	    setProps: ['setProps', 'Instead, call render again at the top level.']
	  };
	  var defineDeprecationWarning = function defineDeprecationWarning(methodName, info) {
	    if (canDefineProperty) {
	      Object.defineProperty(ReactComponent.prototype, methodName, {
	        get: function get() {
	          process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : undefined;
	          return undefined;
	        }
	      });
	    }
	  };
	  for (var fnName in deprecatedAPIs) {
	    if (deprecatedAPIs.hasOwnProperty(fnName)) {
	      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
	    }
	  }
	}
	
	module.exports = ReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactNoopUpdateQueue
	 */
	
	'use strict';
	
	var warning = __webpack_require__(32);
	
	function warnTDZ(publicInstance, callerName) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor && publicInstance.constructor.displayName || '') : undefined;
	  }
	}
	
	/**
	 * This is the abstract API for an update queue.
	 */
	var ReactNoopUpdateQueue = {
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function isMounted(publicInstance) {
	    return false;
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	  enqueueCallback: function enqueueCallback(publicInstance, callback) {},
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function enqueueForceUpdate(publicInstance) {
	    warnTDZ(publicInstance, 'forceUpdate');
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState) {
	    warnTDZ(publicInstance, 'replaceState');
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function enqueueSetState(publicInstance, partialState) {
	    warnTDZ(publicInstance, 'setState');
	  },
	
	  /**
	   * Sets a subset of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialProps Subset of the next props.
	   * @internal
	   */
	  enqueueSetProps: function enqueueSetProps(publicInstance, partialProps) {
	    warnTDZ(publicInstance, 'setProps');
	  },
	
	  /**
	   * Replaces all of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} props New props.
	   * @internal
	   */
	  enqueueReplaceProps: function enqueueReplaceProps(publicInstance, props) {
	    warnTDZ(publicInstance, 'replaceProps');
	  }
	
	};
	
	module.exports = ReactNoopUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactReconcileTransaction
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var CallbackQueue = __webpack_require__(62);
	var PooledClass = __webpack_require__(63);
	var ReactBrowserEventEmitter = __webpack_require__(36);
	var ReactDOMFeatureFlags = __webpack_require__(48);
	var ReactInputSelection = __webpack_require__(133);
	var Transaction = __webpack_require__(64);
	
	var assign = __webpack_require__(46);
	
	/**
	 * Ensures that, when possible, the selection range (currently selected text
	 * input) is not disturbed by performing the transaction.
	 */
	var SELECTION_RESTORATION = {
	  /**
	   * @return {Selection} Selection information.
	   */
	  initialize: ReactInputSelection.getSelectionInformation,
	  /**
	   * @param {Selection} sel Selection information returned from `initialize`.
	   */
	  close: ReactInputSelection.restoreSelection
	};
	
	/**
	 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
	 * high level DOM manipulations (like temporarily removing a text input from the
	 * DOM).
	 */
	var EVENT_SUPPRESSION = {
	  /**
	   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
	   * the reconciliation.
	   */
	  initialize: function initialize() {
	    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
	    ReactBrowserEventEmitter.setEnabled(false);
	    return currentlyEnabled;
	  },
	
	  /**
	   * @param {boolean} previouslyEnabled Enabled status of
	   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
	   *   restores the previous value.
	   */
	  close: function close(previouslyEnabled) {
	    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
	  }
	};
	
	/**
	 * Provides a queue for collecting `componentDidMount` and
	 * `componentDidUpdate` callbacks during the the transaction.
	 */
	var ON_DOM_READY_QUEUEING = {
	  /**
	   * Initializes the internal `onDOMReady` queue.
	   */
	  initialize: function initialize() {
	    this.reactMountReady.reset();
	  },
	
	  /**
	   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
	   */
	  close: function close() {
	    this.reactMountReady.notifyAll();
	  }
	};
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];
	
	/**
	 * Currently:
	 * - The order that these are listed in the transaction is critical:
	 * - Suppresses events.
	 * - Restores selection range.
	 *
	 * Future:
	 * - Restore document/overflow scroll positions that were unintentionally
	 *   modified via DOM insertions above the top viewport boundary.
	 * - Implement/integrate with customized constraint based layout system and keep
	 *   track of which dimensions must be remeasured.
	 *
	 * @class ReactReconcileTransaction
	 */
	function ReactReconcileTransaction(forceHTML) {
	  this.reinitializeTransaction();
	  // Only server-side rendering really needs this option (see
	  // `ReactServerRendering`), but server-side uses
	  // `ReactServerRenderingTransaction` instead. This option is here so that it's
	  // accessible and defaults to false when `ReactDOMComponent` and
	  // `ReactTextComponent` checks it in `mountComponent`.`
	  this.renderToStaticMarkup = false;
	  this.reactMountReady = CallbackQueue.getPooled(null);
	  this.useCreateElement = !forceHTML && ReactDOMFeatureFlags.useCreateElement;
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array<object>} List of operation wrap procedures.
	   *   TODO: convert to array<TransactionWrapper>
	   */
	  getTransactionWrappers: function getTransactionWrappers() {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function getReactMountReady() {
	    return this.reactMountReady;
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function destructor() {
	    CallbackQueue.release(this.reactMountReady);
	    this.reactMountReady = null;
	  }
	};
	
	assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);
	
	PooledClass.addPoolingTo(ReactReconcileTransaction);
	
	module.exports = ReactReconcileTransaction;

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInputSelection
	 */
	
	'use strict';
	
	var ReactDOMSelection = __webpack_require__(134);
	
	var containsNode = __webpack_require__(66);
	var focusNode = __webpack_require__(102);
	var getActiveElement = __webpack_require__(136);
	
	function isInDocument(node) {
	  return containsNode(document.documentElement, node);
	}
	
	/**
	 * @ReactInputSelection: React input selection module. Based on Selection.js,
	 * but modified to be suitable for react and has a couple of bug fixes (doesn't
	 * assume buttons have range selections allowed).
	 * Input selection module for React.
	 */
	var ReactInputSelection = {
	
	  hasSelectionCapabilities: function hasSelectionCapabilities(elem) {
	    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
	  },
	
	  getSelectionInformation: function getSelectionInformation() {
	    var focusedElem = getActiveElement();
	    return {
	      focusedElem: focusedElem,
	      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
	    };
	  },
	
	  /**
	   * @restoreSelection: If any selection information was potentially lost,
	   * restore it. This is useful when performing operations that could remove dom
	   * nodes and place them back in, resulting in focus being lost.
	   */
	  restoreSelection: function restoreSelection(priorSelectionInformation) {
	    var curFocusedElem = getActiveElement();
	    var priorFocusedElem = priorSelectionInformation.focusedElem;
	    var priorSelectionRange = priorSelectionInformation.selectionRange;
	    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
	      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
	        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
	      }
	      focusNode(priorFocusedElem);
	    }
	  },
	
	  /**
	   * @getSelection: Gets the selection bounds of a focused textarea, input or
	   * contentEditable node.
	   * -@input: Look up selection bounds of this input
	   * -@return {start: selectionStart, end: selectionEnd}
	   */
	  getSelection: function getSelection(input) {
	    var selection;
	
	    if ('selectionStart' in input) {
	      // Modern browser with input or textarea.
	      selection = {
	        start: input.selectionStart,
	        end: input.selectionEnd
	      };
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      // IE8 input.
	      var range = document.selection.createRange();
	      // There can only be one selection per document in IE, so it must
	      // be in our element.
	      if (range.parentElement() === input) {
	        selection = {
	          start: -range.moveStart('character', -input.value.length),
	          end: -range.moveEnd('character', -input.value.length)
	        };
	      }
	    } else {
	      // Content editable or old IE textarea.
	      selection = ReactDOMSelection.getOffsets(input);
	    }
	
	    return selection || { start: 0, end: 0 };
	  },
	
	  /**
	   * @setSelection: Sets the selection bounds of a textarea or input and focuses
	   * the input.
	   * -@input     Set selection bounds of this input or textarea
	   * -@offsets   Object of same form that is returned from get*
	   */
	  setSelection: function setSelection(input, offsets) {
	    var start = offsets.start;
	    var end = offsets.end;
	    if (typeof end === 'undefined') {
	      end = start;
	    }
	
	    if ('selectionStart' in input) {
	      input.selectionStart = start;
	      input.selectionEnd = Math.min(end, input.value.length);
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      var range = input.createTextRange();
	      range.collapse(true);
	      range.moveStart('character', start);
	      range.moveEnd('character', end - start);
	      range.select();
	    } else {
	      ReactDOMSelection.setOffsets(input, offsets);
	    }
	  }
	};
	
	module.exports = ReactInputSelection;

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMSelection
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(16);
	
	var getNodeForCharacterOffset = __webpack_require__(135);
	var getTextContentAccessor = __webpack_require__(82);
	
	/**
	 * While `isCollapsed` is available on the Selection object and `collapsed`
	 * is available on the Range object, IE11 sometimes gets them wrong.
	 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
	 */
	function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
	  return anchorNode === focusNode && anchorOffset === focusOffset;
	}
	
	/**
	 * Get the appropriate anchor and focus node/offset pairs for IE.
	 *
	 * The catch here is that IE's selection API doesn't provide information
	 * about whether the selection is forward or backward, so we have to
	 * behave as though it's always forward.
	 *
	 * IE text differs from modern selection in that it behaves as though
	 * block elements end with a new line. This means character offsets will
	 * differ between the two APIs.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getIEOffsets(node) {
	  var selection = document.selection;
	  var selectedRange = selection.createRange();
	  var selectedLength = selectedRange.text.length;
	
	  // Duplicate selection so we can move range without breaking user selection.
	  var fromStart = selectedRange.duplicate();
	  fromStart.moveToElementText(node);
	  fromStart.setEndPoint('EndToStart', selectedRange);
	
	  var startOffset = fromStart.text.length;
	  var endOffset = startOffset + selectedLength;
	
	  return {
	    start: startOffset,
	    end: endOffset
	  };
	}
	
	/**
	 * @param {DOMElement} node
	 * @return {?object}
	 */
	function getModernOffsets(node) {
	  var selection = window.getSelection && window.getSelection();
	
	  if (!selection || selection.rangeCount === 0) {
	    return null;
	  }
	
	  var anchorNode = selection.anchorNode;
	  var anchorOffset = selection.anchorOffset;
	  var focusNode = selection.focusNode;
	  var focusOffset = selection.focusOffset;
	
	  var currentRange = selection.getRangeAt(0);
	
	  // In Firefox, range.startContainer and range.endContainer can be "anonymous
	  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
	  // divs do not seem to expose properties, triggering a "Permission denied
	  // error" if any of its properties are accessed. The only seemingly possible
	  // way to avoid erroring is to access a property that typically works for
	  // non-anonymous divs and catch any error that may otherwise arise. See
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
	  try {
	    /* eslint-disable no-unused-expressions */
	    currentRange.startContainer.nodeType;
	    currentRange.endContainer.nodeType;
	    /* eslint-enable no-unused-expressions */
	  } catch (e) {
	    return null;
	  }
	
	  // If the node and offset values are the same, the selection is collapsed.
	  // `Selection.isCollapsed` is available natively, but IE sometimes gets
	  // this value wrong.
	  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
	
	  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;
	
	  var tempRange = currentRange.cloneRange();
	  tempRange.selectNodeContents(node);
	  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);
	
	  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);
	
	  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
	  var end = start + rangeLength;
	
	  // Detect whether the selection is backward.
	  var detectionRange = document.createRange();
	  detectionRange.setStart(anchorNode, anchorOffset);
	  detectionRange.setEnd(focusNode, focusOffset);
	  var isBackward = detectionRange.collapsed;
	
	  return {
	    start: isBackward ? end : start,
	    end: isBackward ? start : end
	  };
	}
	
	/**
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setIEOffsets(node, offsets) {
	  var range = document.selection.createRange().duplicate();
	  var start, end;
	
	  if (typeof offsets.end === 'undefined') {
	    start = offsets.start;
	    end = start;
	  } else if (offsets.start > offsets.end) {
	    start = offsets.end;
	    end = offsets.start;
	  } else {
	    start = offsets.start;
	    end = offsets.end;
	  }
	
	  range.moveToElementText(node);
	  range.moveStart('character', start);
	  range.setEndPoint('EndToStart', range);
	  range.moveEnd('character', end - start);
	  range.select();
	}
	
	/**
	 * In modern non-IE browsers, we can support both forward and backward
	 * selections.
	 *
	 * Note: IE10+ supports the Selection object, but it does not support
	 * the `extend` method, which means that even in modern IE, it's not possible
	 * to programatically create a backward selection. Thus, for all IE
	 * versions, we use the old IE API to create our selections.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setModernOffsets(node, offsets) {
	  if (!window.getSelection) {
	    return;
	  }
	
	  var selection = window.getSelection();
	  var length = node[getTextContentAccessor()].length;
	  var start = Math.min(offsets.start, length);
	  var end = typeof offsets.end === 'undefined' ? start : Math.min(offsets.end, length);
	
	  // IE 11 uses modern selection, but doesn't support the extend method.
	  // Flip backward selections, so we can set with a single range.
	  if (!selection.extend && start > end) {
	    var temp = end;
	    end = start;
	    start = temp;
	  }
	
	  var startMarker = getNodeForCharacterOffset(node, start);
	  var endMarker = getNodeForCharacterOffset(node, end);
	
	  if (startMarker && endMarker) {
	    var range = document.createRange();
	    range.setStart(startMarker.node, startMarker.offset);
	    selection.removeAllRanges();
	
	    if (start > end) {
	      selection.addRange(range);
	      selection.extend(endMarker.node, endMarker.offset);
	    } else {
	      range.setEnd(endMarker.node, endMarker.offset);
	      selection.addRange(range);
	    }
	  }
	}
	
	var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);
	
	var ReactDOMSelection = {
	  /**
	   * @param {DOMElement} node
	   */
	  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,
	
	  /**
	   * @param {DOMElement|DOMTextNode} node
	   * @param {object} offsets
	   */
	  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
	};
	
	module.exports = ReactDOMSelection;

/***/ },
/* 135 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getNodeForCharacterOffset
	 */
	
	'use strict';
	
	/**
	 * Given any node return the first leaf node without children.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {DOMElement|DOMTextNode}
	 */
	
	function getLeafNode(node) {
	  while (node && node.firstChild) {
	    node = node.firstChild;
	  }
	  return node;
	}
	
	/**
	 * Get the next sibling within a container. This will walk up the
	 * DOM if a node's siblings have been exhausted.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {?DOMElement|DOMTextNode}
	 */
	function getSiblingNode(node) {
	  while (node) {
	    if (node.nextSibling) {
	      return node.nextSibling;
	    }
	    node = node.parentNode;
	  }
	}
	
	/**
	 * Get object describing the nodes which contain characters at offset.
	 *
	 * @param {DOMElement|DOMTextNode} root
	 * @param {number} offset
	 * @return {?object}
	 */
	function getNodeForCharacterOffset(root, offset) {
	  var node = getLeafNode(root);
	  var nodeStart = 0;
	  var nodeEnd = 0;
	
	  while (node) {
	    if (node.nodeType === 3) {
	      nodeEnd = nodeStart + node.textContent.length;
	
	      if (nodeStart <= offset && nodeEnd >= offset) {
	        return {
	          node: node,
	          offset: offset - nodeStart
	        };
	      }
	
	      nodeStart = nodeEnd;
	    }
	
	    node = getLeafNode(getSiblingNode(node));
	  }
	}
	
	module.exports = getNodeForCharacterOffset;

/***/ },
/* 136 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getActiveElement
	 * @typechecks
	 */
	
	/* eslint-disable fb-www/typeof-undefined */
	
	/**
	 * Same as document.activeElement but wraps in a try-catch block. In IE it is
	 * not safe to call document.activeElement if there is nothing focused.
	 *
	 * The activeElement will be null only if the document or document body is not
	 * yet defined.
	 */
	'use strict';
	
	function getActiveElement() /*?DOMElement*/{
	  if (typeof document === 'undefined') {
	    return null;
	  }
	  try {
	    return document.activeElement || document.body;
	  } catch (e) {
	    return document.body;
	  }
	}
	
	module.exports = getActiveElement;

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SelectEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(37);
	var EventPropagators = __webpack_require__(80);
	var ExecutionEnvironment = __webpack_require__(16);
	var ReactInputSelection = __webpack_require__(133);
	var SyntheticEvent = __webpack_require__(84);
	
	var getActiveElement = __webpack_require__(136);
	var isTextInputElement = __webpack_require__(89);
	var keyOf = __webpack_require__(86);
	var shallowEqual = __webpack_require__(124);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;
	
	var eventTypes = {
	  select: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSelect: null }),
	      captured: keyOf({ onSelectCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topContextMenu, topLevelTypes.topFocus, topLevelTypes.topKeyDown, topLevelTypes.topMouseDown, topLevelTypes.topMouseUp, topLevelTypes.topSelectionChange]
	  }
	};
	
	var activeElement = null;
	var activeElementID = null;
	var lastSelection = null;
	var mouseDown = false;
	
	// Track whether a listener exists for this plugin. If none exist, we do
	// not extract events.
	var hasListener = false;
	var ON_SELECT_KEY = keyOf({ onSelect: null });
	
	/**
	 * Get an object which is a unique representation of the current selection.
	 *
	 * The return value will not be consistent across nodes or browsers, but
	 * two identical selections on the same node will return identical objects.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getSelection(node) {
	  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
	    return {
	      start: node.selectionStart,
	      end: node.selectionEnd
	    };
	  } else if (window.getSelection) {
	    var selection = window.getSelection();
	    return {
	      anchorNode: selection.anchorNode,
	      anchorOffset: selection.anchorOffset,
	      focusNode: selection.focusNode,
	      focusOffset: selection.focusOffset
	    };
	  } else if (document.selection) {
	    var range = document.selection.createRange();
	    return {
	      parentElement: range.parentElement(),
	      text: range.text,
	      top: range.boundingTop,
	      left: range.boundingLeft
	    };
	  }
	}
	
	/**
	 * Poll selection to see whether it's changed.
	 *
	 * @param {object} nativeEvent
	 * @return {?SyntheticEvent}
	 */
	function constructSelectEvent(nativeEvent, nativeEventTarget) {
	  // Ensure we have the right element, and that the user is not dragging a
	  // selection (this matches native `select` event behavior). In HTML5, select
	  // fires only on input and textarea thus if there's no focused element we
	  // won't dispatch.
	  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
	    return null;
	  }
	
	  // Only fire when selection has actually changed.
	  var currentSelection = getSelection(activeElement);
	  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
	    lastSelection = currentSelection;
	
	    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementID, nativeEvent, nativeEventTarget);
	
	    syntheticEvent.type = 'select';
	    syntheticEvent.target = activeElement;
	
	    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);
	
	    return syntheticEvent;
	  }
	
	  return null;
	}
	
	/**
	 * This plugin creates an `onSelect` event that normalizes select events
	 * across form elements.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - contentEditable
	 *
	 * This differs from native browser implementations in the following ways:
	 * - Fires on contentEditable fields as well as inputs.
	 * - Fires for collapsed selection.
	 * - Fires after user input.
	 */
	var SelectEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    if (!hasListener) {
	      return null;
	    }
	
	    switch (topLevelType) {
	      // Track the input node that has focus.
	      case topLevelTypes.topFocus:
	        if (isTextInputElement(topLevelTarget) || topLevelTarget.contentEditable === 'true') {
	          activeElement = topLevelTarget;
	          activeElementID = topLevelTargetID;
	          lastSelection = null;
	        }
	        break;
	      case topLevelTypes.topBlur:
	        activeElement = null;
	        activeElementID = null;
	        lastSelection = null;
	        break;
	
	      // Don't fire the event while the user is dragging. This matches the
	      // semantics of the native select event.
	      case topLevelTypes.topMouseDown:
	        mouseDown = true;
	        break;
	      case topLevelTypes.topContextMenu:
	      case topLevelTypes.topMouseUp:
	        mouseDown = false;
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	
	      // Chrome and IE fire non-standard event when selection is changed (and
	      // sometimes when it hasn't). IE's event fires out of order with respect
	      // to key and input events on deletion, so we discard it.
	      //
	      // Firefox doesn't support selectionchange, so check selection status
	      // after each key entry. The selection changes after keydown and before
	      // keyup, but we check on keydown as well in the case of holding down a
	      // key, when multiple keydown events are fired but only one keyup is.
	      // This is also our approach for IE handling, for the reason above.
	      case topLevelTypes.topSelectionChange:
	        if (skipSelectionChangeEvent) {
	          break;
	        }
	      // falls through
	      case topLevelTypes.topKeyDown:
	      case topLevelTypes.topKeyUp:
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	    }
	
	    return null;
	  },
	
	  didPutListener: function didPutListener(id, registrationName, listener) {
	    if (registrationName === ON_SELECT_KEY) {
	      hasListener = true;
	    }
	  }
	};
	
	module.exports = SelectEventPlugin;

/***/ },
/* 138 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ServerReactRootIndex
	 * @typechecks
	 */
	
	'use strict';
	
	/**
	 * Size of the reactRoot ID space. We generate random numbers for React root
	 * IDs and if there's a collision the events and DOM update system will
	 * get confused. In the future we need a way to generate GUIDs but for
	 * now this will work on a smaller scale.
	 */
	
	var GLOBAL_MOUNT_POINT_MAX = Math.pow(2, 53);
	
	var ServerReactRootIndex = {
	  createReactRootIndex: function createReactRootIndex() {
	    return Math.ceil(Math.random() * GLOBAL_MOUNT_POINT_MAX);
	  }
	};
	
	module.exports = ServerReactRootIndex;

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SimpleEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(37);
	var EventListener = __webpack_require__(126);
	var EventPropagators = __webpack_require__(80);
	var ReactMount = __webpack_require__(35);
	var SyntheticClipboardEvent = __webpack_require__(140);
	var SyntheticEvent = __webpack_require__(84);
	var SyntheticFocusEvent = __webpack_require__(141);
	var SyntheticKeyboardEvent = __webpack_require__(142);
	var SyntheticMouseEvent = __webpack_require__(93);
	var SyntheticDragEvent = __webpack_require__(145);
	var SyntheticTouchEvent = __webpack_require__(146);
	var SyntheticUIEvent = __webpack_require__(94);
	var SyntheticWheelEvent = __webpack_require__(147);
	
	var emptyFunction = __webpack_require__(22);
	var getEventCharCode = __webpack_require__(143);
	var invariant = __webpack_require__(20);
	var keyOf = __webpack_require__(86);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var eventTypes = {
	  abort: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onAbort: true }),
	      captured: keyOf({ onAbortCapture: true })
	    }
	  },
	  blur: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onBlur: true }),
	      captured: keyOf({ onBlurCapture: true })
	    }
	  },
	  canPlay: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCanPlay: true }),
	      captured: keyOf({ onCanPlayCapture: true })
	    }
	  },
	  canPlayThrough: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCanPlayThrough: true }),
	      captured: keyOf({ onCanPlayThroughCapture: true })
	    }
	  },
	  click: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onClick: true }),
	      captured: keyOf({ onClickCapture: true })
	    }
	  },
	  contextMenu: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onContextMenu: true }),
	      captured: keyOf({ onContextMenuCapture: true })
	    }
	  },
	  copy: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCopy: true }),
	      captured: keyOf({ onCopyCapture: true })
	    }
	  },
	  cut: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCut: true }),
	      captured: keyOf({ onCutCapture: true })
	    }
	  },
	  doubleClick: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDoubleClick: true }),
	      captured: keyOf({ onDoubleClickCapture: true })
	    }
	  },
	  drag: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDrag: true }),
	      captured: keyOf({ onDragCapture: true })
	    }
	  },
	  dragEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragEnd: true }),
	      captured: keyOf({ onDragEndCapture: true })
	    }
	  },
	  dragEnter: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragEnter: true }),
	      captured: keyOf({ onDragEnterCapture: true })
	    }
	  },
	  dragExit: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragExit: true }),
	      captured: keyOf({ onDragExitCapture: true })
	    }
	  },
	  dragLeave: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragLeave: true }),
	      captured: keyOf({ onDragLeaveCapture: true })
	    }
	  },
	  dragOver: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragOver: true }),
	      captured: keyOf({ onDragOverCapture: true })
	    }
	  },
	  dragStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragStart: true }),
	      captured: keyOf({ onDragStartCapture: true })
	    }
	  },
	  drop: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDrop: true }),
	      captured: keyOf({ onDropCapture: true })
	    }
	  },
	  durationChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDurationChange: true }),
	      captured: keyOf({ onDurationChangeCapture: true })
	    }
	  },
	  emptied: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEmptied: true }),
	      captured: keyOf({ onEmptiedCapture: true })
	    }
	  },
	  encrypted: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEncrypted: true }),
	      captured: keyOf({ onEncryptedCapture: true })
	    }
	  },
	  ended: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEnded: true }),
	      captured: keyOf({ onEndedCapture: true })
	    }
	  },
	  error: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onError: true }),
	      captured: keyOf({ onErrorCapture: true })
	    }
	  },
	  focus: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onFocus: true }),
	      captured: keyOf({ onFocusCapture: true })
	    }
	  },
	  input: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onInput: true }),
	      captured: keyOf({ onInputCapture: true })
	    }
	  },
	  keyDown: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyDown: true }),
	      captured: keyOf({ onKeyDownCapture: true })
	    }
	  },
	  keyPress: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyPress: true }),
	      captured: keyOf({ onKeyPressCapture: true })
	    }
	  },
	  keyUp: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyUp: true }),
	      captured: keyOf({ onKeyUpCapture: true })
	    }
	  },
	  load: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoad: true }),
	      captured: keyOf({ onLoadCapture: true })
	    }
	  },
	  loadedData: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadedData: true }),
	      captured: keyOf({ onLoadedDataCapture: true })
	    }
	  },
	  loadedMetadata: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadedMetadata: true }),
	      captured: keyOf({ onLoadedMetadataCapture: true })
	    }
	  },
	  loadStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadStart: true }),
	      captured: keyOf({ onLoadStartCapture: true })
	    }
	  },
	  // Note: We do not allow listening to mouseOver events. Instead, use the
	  // onMouseEnter/onMouseLeave created by `EnterLeaveEventPlugin`.
	  mouseDown: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseDown: true }),
	      captured: keyOf({ onMouseDownCapture: true })
	    }
	  },
	  mouseMove: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseMove: true }),
	      captured: keyOf({ onMouseMoveCapture: true })
	    }
	  },
	  mouseOut: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseOut: true }),
	      captured: keyOf({ onMouseOutCapture: true })
	    }
	  },
	  mouseOver: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseOver: true }),
	      captured: keyOf({ onMouseOverCapture: true })
	    }
	  },
	  mouseUp: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseUp: true }),
	      captured: keyOf({ onMouseUpCapture: true })
	    }
	  },
	  paste: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPaste: true }),
	      captured: keyOf({ onPasteCapture: true })
	    }
	  },
	  pause: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPause: true }),
	      captured: keyOf({ onPauseCapture: true })
	    }
	  },
	  play: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPlay: true }),
	      captured: keyOf({ onPlayCapture: true })
	    }
	  },
	  playing: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPlaying: true }),
	      captured: keyOf({ onPlayingCapture: true })
	    }
	  },
	  progress: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onProgress: true }),
	      captured: keyOf({ onProgressCapture: true })
	    }
	  },
	  rateChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onRateChange: true }),
	      captured: keyOf({ onRateChangeCapture: true })
	    }
	  },
	  reset: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onReset: true }),
	      captured: keyOf({ onResetCapture: true })
	    }
	  },
	  scroll: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onScroll: true }),
	      captured: keyOf({ onScrollCapture: true })
	    }
	  },
	  seeked: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSeeked: true }),
	      captured: keyOf({ onSeekedCapture: true })
	    }
	  },
	  seeking: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSeeking: true }),
	      captured: keyOf({ onSeekingCapture: true })
	    }
	  },
	  stalled: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onStalled: true }),
	      captured: keyOf({ onStalledCapture: true })
	    }
	  },
	  submit: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSubmit: true }),
	      captured: keyOf({ onSubmitCapture: true })
	    }
	  },
	  suspend: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSuspend: true }),
	      captured: keyOf({ onSuspendCapture: true })
	    }
	  },
	  timeUpdate: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTimeUpdate: true }),
	      captured: keyOf({ onTimeUpdateCapture: true })
	    }
	  },
	  touchCancel: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchCancel: true }),
	      captured: keyOf({ onTouchCancelCapture: true })
	    }
	  },
	  touchEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchEnd: true }),
	      captured: keyOf({ onTouchEndCapture: true })
	    }
	  },
	  touchMove: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchMove: true }),
	      captured: keyOf({ onTouchMoveCapture: true })
	    }
	  },
	  touchStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchStart: true }),
	      captured: keyOf({ onTouchStartCapture: true })
	    }
	  },
	  volumeChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onVolumeChange: true }),
	      captured: keyOf({ onVolumeChangeCapture: true })
	    }
	  },
	  waiting: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onWaiting: true }),
	      captured: keyOf({ onWaitingCapture: true })
	    }
	  },
	  wheel: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onWheel: true }),
	      captured: keyOf({ onWheelCapture: true })
	    }
	  }
	};
	
	var topLevelEventsToDispatchConfig = {
	  topAbort: eventTypes.abort,
	  topBlur: eventTypes.blur,
	  topCanPlay: eventTypes.canPlay,
	  topCanPlayThrough: eventTypes.canPlayThrough,
	  topClick: eventTypes.click,
	  topContextMenu: eventTypes.contextMenu,
	  topCopy: eventTypes.copy,
	  topCut: eventTypes.cut,
	  topDoubleClick: eventTypes.doubleClick,
	  topDrag: eventTypes.drag,
	  topDragEnd: eventTypes.dragEnd,
	  topDragEnter: eventTypes.dragEnter,
	  topDragExit: eventTypes.dragExit,
	  topDragLeave: eventTypes.dragLeave,
	  topDragOver: eventTypes.dragOver,
	  topDragStart: eventTypes.dragStart,
	  topDrop: eventTypes.drop,
	  topDurationChange: eventTypes.durationChange,
	  topEmptied: eventTypes.emptied,
	  topEncrypted: eventTypes.encrypted,
	  topEnded: eventTypes.ended,
	  topError: eventTypes.error,
	  topFocus: eventTypes.focus,
	  topInput: eventTypes.input,
	  topKeyDown: eventTypes.keyDown,
	  topKeyPress: eventTypes.keyPress,
	  topKeyUp: eventTypes.keyUp,
	  topLoad: eventTypes.load,
	  topLoadedData: eventTypes.loadedData,
	  topLoadedMetadata: eventTypes.loadedMetadata,
	  topLoadStart: eventTypes.loadStart,
	  topMouseDown: eventTypes.mouseDown,
	  topMouseMove: eventTypes.mouseMove,
	  topMouseOut: eventTypes.mouseOut,
	  topMouseOver: eventTypes.mouseOver,
	  topMouseUp: eventTypes.mouseUp,
	  topPaste: eventTypes.paste,
	  topPause: eventTypes.pause,
	  topPlay: eventTypes.play,
	  topPlaying: eventTypes.playing,
	  topProgress: eventTypes.progress,
	  topRateChange: eventTypes.rateChange,
	  topReset: eventTypes.reset,
	  topScroll: eventTypes.scroll,
	  topSeeked: eventTypes.seeked,
	  topSeeking: eventTypes.seeking,
	  topStalled: eventTypes.stalled,
	  topSubmit: eventTypes.submit,
	  topSuspend: eventTypes.suspend,
	  topTimeUpdate: eventTypes.timeUpdate,
	  topTouchCancel: eventTypes.touchCancel,
	  topTouchEnd: eventTypes.touchEnd,
	  topTouchMove: eventTypes.touchMove,
	  topTouchStart: eventTypes.touchStart,
	  topVolumeChange: eventTypes.volumeChange,
	  topWaiting: eventTypes.waiting,
	  topWheel: eventTypes.wheel
	};
	
	for (var type in topLevelEventsToDispatchConfig) {
	  topLevelEventsToDispatchConfig[type].dependencies = [type];
	}
	
	var ON_CLICK_KEY = keyOf({ onClick: null });
	var onClickListeners = {};
	
	var SimpleEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
	    if (!dispatchConfig) {
	      return null;
	    }
	    var EventConstructor;
	    switch (topLevelType) {
	      case topLevelTypes.topAbort:
	      case topLevelTypes.topCanPlay:
	      case topLevelTypes.topCanPlayThrough:
	      case topLevelTypes.topDurationChange:
	      case topLevelTypes.topEmptied:
	      case topLevelTypes.topEncrypted:
	      case topLevelTypes.topEnded:
	      case topLevelTypes.topError:
	      case topLevelTypes.topInput:
	      case topLevelTypes.topLoad:
	      case topLevelTypes.topLoadedData:
	      case topLevelTypes.topLoadedMetadata:
	      case topLevelTypes.topLoadStart:
	      case topLevelTypes.topPause:
	      case topLevelTypes.topPlay:
	      case topLevelTypes.topPlaying:
	      case topLevelTypes.topProgress:
	      case topLevelTypes.topRateChange:
	      case topLevelTypes.topReset:
	      case topLevelTypes.topSeeked:
	      case topLevelTypes.topSeeking:
	      case topLevelTypes.topStalled:
	      case topLevelTypes.topSubmit:
	      case topLevelTypes.topSuspend:
	      case topLevelTypes.topTimeUpdate:
	      case topLevelTypes.topVolumeChange:
	      case topLevelTypes.topWaiting:
	        // HTML Events
	        // @see http://www.w3.org/TR/html5/index.html#events-0
	        EventConstructor = SyntheticEvent;
	        break;
	      case topLevelTypes.topKeyPress:
	        // FireFox creates a keypress event for function keys too. This removes
	        // the unwanted keypress events. Enter is however both printable and
	        // non-printable. One would expect Tab to be as well (but it isn't).
	        if (getEventCharCode(nativeEvent) === 0) {
	          return null;
	        }
	      /* falls through */
	      case topLevelTypes.topKeyDown:
	      case topLevelTypes.topKeyUp:
	        EventConstructor = SyntheticKeyboardEvent;
	        break;
	      case topLevelTypes.topBlur:
	      case topLevelTypes.topFocus:
	        EventConstructor = SyntheticFocusEvent;
	        break;
	      case topLevelTypes.topClick:
	        // Firefox creates a click event on right mouse clicks. This removes the
	        // unwanted click events.
	        if (nativeEvent.button === 2) {
	          return null;
	        }
	      /* falls through */
	      case topLevelTypes.topContextMenu:
	      case topLevelTypes.topDoubleClick:
	      case topLevelTypes.topMouseDown:
	      case topLevelTypes.topMouseMove:
	      case topLevelTypes.topMouseOut:
	      case topLevelTypes.topMouseOver:
	      case topLevelTypes.topMouseUp:
	        EventConstructor = SyntheticMouseEvent;
	        break;
	      case topLevelTypes.topDrag:
	      case topLevelTypes.topDragEnd:
	      case topLevelTypes.topDragEnter:
	      case topLevelTypes.topDragExit:
	      case topLevelTypes.topDragLeave:
	      case topLevelTypes.topDragOver:
	      case topLevelTypes.topDragStart:
	      case topLevelTypes.topDrop:
	        EventConstructor = SyntheticDragEvent;
	        break;
	      case topLevelTypes.topTouchCancel:
	      case topLevelTypes.topTouchEnd:
	      case topLevelTypes.topTouchMove:
	      case topLevelTypes.topTouchStart:
	        EventConstructor = SyntheticTouchEvent;
	        break;
	      case topLevelTypes.topScroll:
	        EventConstructor = SyntheticUIEvent;
	        break;
	      case topLevelTypes.topWheel:
	        EventConstructor = SyntheticWheelEvent;
	        break;
	      case topLevelTypes.topCopy:
	      case topLevelTypes.topCut:
	      case topLevelTypes.topPaste:
	        EventConstructor = SyntheticClipboardEvent;
	        break;
	    }
	    !EventConstructor ? process.env.NODE_ENV !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : invariant(false) : undefined;
	    var event = EventConstructor.getPooled(dispatchConfig, topLevelTargetID, nativeEvent, nativeEventTarget);
	    EventPropagators.accumulateTwoPhaseDispatches(event);
	    return event;
	  },
	
	  didPutListener: function didPutListener(id, registrationName, listener) {
	    // Mobile Safari does not fire properly bubble click events on
	    // non-interactive elements, which means delegated click listeners do not
	    // fire. The workaround for this bug involves attaching an empty click
	    // listener on the target node.
	    if (registrationName === ON_CLICK_KEY) {
	      var node = ReactMount.getNode(id);
	      if (!onClickListeners[id]) {
	        onClickListeners[id] = EventListener.listen(node, 'click', emptyFunction);
	      }
	    }
	  },
	
	  willDeleteListener: function willDeleteListener(id, registrationName) {
	    if (registrationName === ON_CLICK_KEY) {
	      onClickListeners[id].remove();
	      delete onClickListeners[id];
	    }
	  }
	
	};
	
	module.exports = SimpleEventPlugin;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticClipboardEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(84);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/clipboard-apis/
	 */
	var ClipboardEventInterface = {
	  clipboardData: function clipboardData(event) {
	    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);
	
	module.exports = SyntheticClipboardEvent;

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticFocusEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(94);
	
	/**
	 * @interface FocusEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var FocusEventInterface = {
	  relatedTarget: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);
	
	module.exports = SyntheticFocusEvent;

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticKeyboardEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(94);
	
	var getEventCharCode = __webpack_require__(143);
	var getEventKey = __webpack_require__(144);
	var getEventModifierState = __webpack_require__(95);
	
	/**
	 * @interface KeyboardEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var KeyboardEventInterface = {
	  key: getEventKey,
	  location: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  repeat: null,
	  locale: null,
	  getModifierState: getEventModifierState,
	  // Legacy Interface
	  charCode: function charCode(event) {
	    // `charCode` is the result of a KeyPress event and represents the value of
	    // the actual printable character.
	
	    // KeyPress is deprecated, but its replacement is not yet final and not
	    // implemented in any major browser. Only KeyPress has charCode.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    return 0;
	  },
	  keyCode: function keyCode(event) {
	    // `keyCode` is the result of a KeyDown/Up event and represents the value of
	    // physical keyboard key.
	
	    // The actual meaning of the value depends on the users' keyboard layout
	    // which cannot be detected. Assuming that it is a US keyboard layout
	    // provides a surprisingly accurate mapping for US and European users.
	    // Due to this, it is left to the user to implement at this time.
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  },
	  which: function which(event) {
	    // `which` is an alias for either `keyCode` or `charCode` depending on the
	    // type of the event.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);
	
	module.exports = SyntheticKeyboardEvent;

/***/ },
/* 143 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventCharCode
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * `charCode` represents the actual "character code" and is safe to use with
	 * `String.fromCharCode`. As such, only keys that correspond to printable
	 * characters produce a valid `charCode`, the only exception to this is Enter.
	 * The Tab-key is considered non-printable and does not have a `charCode`,
	 * presumably because it does not produce a tab-character in browsers.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {number} Normalized `charCode` property.
	 */
	
	function getEventCharCode(nativeEvent) {
	  var charCode;
	  var keyCode = nativeEvent.keyCode;
	
	  if ('charCode' in nativeEvent) {
	    charCode = nativeEvent.charCode;
	
	    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
	    if (charCode === 0 && keyCode === 13) {
	      charCode = 13;
	    }
	  } else {
	    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
	    charCode = keyCode;
	  }
	
	  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
	  // Must not discard the (non-)printable Enter-key.
	  if (charCode >= 32 || charCode === 13) {
	    return charCode;
	  }
	
	  return 0;
	}
	
	module.exports = getEventCharCode;

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventKey
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var getEventCharCode = __webpack_require__(143);
	
	/**
	 * Normalization of deprecated HTML5 `key` values
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var normalizeKey = {
	  'Esc': 'Escape',
	  'Spacebar': ' ',
	  'Left': 'ArrowLeft',
	  'Up': 'ArrowUp',
	  'Right': 'ArrowRight',
	  'Down': 'ArrowDown',
	  'Del': 'Delete',
	  'Win': 'OS',
	  'Menu': 'ContextMenu',
	  'Apps': 'ContextMenu',
	  'Scroll': 'ScrollLock',
	  'MozPrintableKey': 'Unidentified'
	};
	
	/**
	 * Translation from legacy `keyCode` to HTML5 `key`
	 * Only special keys supported, all others depend on keyboard layout or browser
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var translateToKey = {
	  8: 'Backspace',
	  9: 'Tab',
	  12: 'Clear',
	  13: 'Enter',
	  16: 'Shift',
	  17: 'Control',
	  18: 'Alt',
	  19: 'Pause',
	  20: 'CapsLock',
	  27: 'Escape',
	  32: ' ',
	  33: 'PageUp',
	  34: 'PageDown',
	  35: 'End',
	  36: 'Home',
	  37: 'ArrowLeft',
	  38: 'ArrowUp',
	  39: 'ArrowRight',
	  40: 'ArrowDown',
	  45: 'Insert',
	  46: 'Delete',
	  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
	  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
	  144: 'NumLock',
	  145: 'ScrollLock',
	  224: 'Meta'
	};
	
	/**
	 * @param {object} nativeEvent Native browser event.
	 * @return {string} Normalized `key` property.
	 */
	function getEventKey(nativeEvent) {
	  if (nativeEvent.key) {
	    // Normalize inconsistent values reported by browsers due to
	    // implementations of a working draft specification.
	
	    // FireFox implements `key` but returns `MozPrintableKey` for all
	    // printable characters (normalized to `Unidentified`), ignore it.
	    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
	    if (key !== 'Unidentified') {
	      return key;
	    }
	  }
	
	  // Browser does not implement `key`, polyfill as much of it as we can.
	  if (nativeEvent.type === 'keypress') {
	    var charCode = getEventCharCode(nativeEvent);
	
	    // The enter-key is technically both printable and non-printable and can
	    // thus be captured by `keypress`, no other non-printable key should.
	    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
	  }
	  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
	    // While user keyboard layout determines the actual meaning of each
	    // `keyCode` value, almost all function keys have a universal value.
	    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
	  }
	  return '';
	}
	
	module.exports = getEventKey;

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticDragEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(93);
	
	/**
	 * @interface DragEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var DragEventInterface = {
	  dataTransfer: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);
	
	module.exports = SyntheticDragEvent;

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticTouchEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(94);
	
	var getEventModifierState = __webpack_require__(95);
	
	/**
	 * @interface TouchEvent
	 * @see http://www.w3.org/TR/touch-events/
	 */
	var TouchEventInterface = {
	  touches: null,
	  targetTouches: null,
	  changedTouches: null,
	  altKey: null,
	  metaKey: null,
	  ctrlKey: null,
	  shiftKey: null,
	  getModifierState: getEventModifierState
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);
	
	module.exports = SyntheticTouchEvent;

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticWheelEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(93);
	
	/**
	 * @interface WheelEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var WheelEventInterface = {
	  deltaX: function deltaX(event) {
	    return 'deltaX' in event ? event.deltaX :
	    // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
	    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
	  },
	  deltaY: function deltaY(event) {
	    return 'deltaY' in event ? event.deltaY :
	    // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
	    'wheelDeltaY' in event ? -event.wheelDeltaY :
	    // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
	    'wheelDelta' in event ? -event.wheelDelta : 0;
	  },
	  deltaZ: null,
	
	  // Browsers without "deltaMode" is reporting in raw wheel delta where one
	  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
	  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
	  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
	  deltaMode: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticMouseEvent}
	 */
	function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);
	
	module.exports = SyntheticWheelEvent;

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SVGDOMPropertyConfig
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(30);
	
	var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
	
	var NS = {
	  xlink: 'http://www.w3.org/1999/xlink',
	  xml: 'http://www.w3.org/XML/1998/namespace'
	};
	
	var SVGDOMPropertyConfig = {
	  Properties: {
	    clipPath: MUST_USE_ATTRIBUTE,
	    cx: MUST_USE_ATTRIBUTE,
	    cy: MUST_USE_ATTRIBUTE,
	    d: MUST_USE_ATTRIBUTE,
	    dx: MUST_USE_ATTRIBUTE,
	    dy: MUST_USE_ATTRIBUTE,
	    fill: MUST_USE_ATTRIBUTE,
	    fillOpacity: MUST_USE_ATTRIBUTE,
	    fontFamily: MUST_USE_ATTRIBUTE,
	    fontSize: MUST_USE_ATTRIBUTE,
	    fx: MUST_USE_ATTRIBUTE,
	    fy: MUST_USE_ATTRIBUTE,
	    gradientTransform: MUST_USE_ATTRIBUTE,
	    gradientUnits: MUST_USE_ATTRIBUTE,
	    markerEnd: MUST_USE_ATTRIBUTE,
	    markerMid: MUST_USE_ATTRIBUTE,
	    markerStart: MUST_USE_ATTRIBUTE,
	    offset: MUST_USE_ATTRIBUTE,
	    opacity: MUST_USE_ATTRIBUTE,
	    patternContentUnits: MUST_USE_ATTRIBUTE,
	    patternUnits: MUST_USE_ATTRIBUTE,
	    points: MUST_USE_ATTRIBUTE,
	    preserveAspectRatio: MUST_USE_ATTRIBUTE,
	    r: MUST_USE_ATTRIBUTE,
	    rx: MUST_USE_ATTRIBUTE,
	    ry: MUST_USE_ATTRIBUTE,
	    spreadMethod: MUST_USE_ATTRIBUTE,
	    stopColor: MUST_USE_ATTRIBUTE,
	    stopOpacity: MUST_USE_ATTRIBUTE,
	    stroke: MUST_USE_ATTRIBUTE,
	    strokeDasharray: MUST_USE_ATTRIBUTE,
	    strokeLinecap: MUST_USE_ATTRIBUTE,
	    strokeOpacity: MUST_USE_ATTRIBUTE,
	    strokeWidth: MUST_USE_ATTRIBUTE,
	    textAnchor: MUST_USE_ATTRIBUTE,
	    transform: MUST_USE_ATTRIBUTE,
	    version: MUST_USE_ATTRIBUTE,
	    viewBox: MUST_USE_ATTRIBUTE,
	    x1: MUST_USE_ATTRIBUTE,
	    x2: MUST_USE_ATTRIBUTE,
	    x: MUST_USE_ATTRIBUTE,
	    xlinkActuate: MUST_USE_ATTRIBUTE,
	    xlinkArcrole: MUST_USE_ATTRIBUTE,
	    xlinkHref: MUST_USE_ATTRIBUTE,
	    xlinkRole: MUST_USE_ATTRIBUTE,
	    xlinkShow: MUST_USE_ATTRIBUTE,
	    xlinkTitle: MUST_USE_ATTRIBUTE,
	    xlinkType: MUST_USE_ATTRIBUTE,
	    xmlBase: MUST_USE_ATTRIBUTE,
	    xmlLang: MUST_USE_ATTRIBUTE,
	    xmlSpace: MUST_USE_ATTRIBUTE,
	    y1: MUST_USE_ATTRIBUTE,
	    y2: MUST_USE_ATTRIBUTE,
	    y: MUST_USE_ATTRIBUTE
	  },
	  DOMAttributeNamespaces: {
	    xlinkActuate: NS.xlink,
	    xlinkArcrole: NS.xlink,
	    xlinkHref: NS.xlink,
	    xlinkRole: NS.xlink,
	    xlinkShow: NS.xlink,
	    xlinkTitle: NS.xlink,
	    xlinkType: NS.xlink,
	    xmlBase: NS.xml,
	    xmlLang: NS.xml,
	    xmlSpace: NS.xml
	  },
	  DOMAttributeNames: {
	    clipPath: 'clip-path',
	    fillOpacity: 'fill-opacity',
	    fontFamily: 'font-family',
	    fontSize: 'font-size',
	    gradientTransform: 'gradientTransform',
	    gradientUnits: 'gradientUnits',
	    markerEnd: 'marker-end',
	    markerMid: 'marker-mid',
	    markerStart: 'marker-start',
	    patternContentUnits: 'patternContentUnits',
	    patternUnits: 'patternUnits',
	    preserveAspectRatio: 'preserveAspectRatio',
	    spreadMethod: 'spreadMethod',
	    stopColor: 'stop-color',
	    stopOpacity: 'stop-opacity',
	    strokeDasharray: 'stroke-dasharray',
	    strokeLinecap: 'stroke-linecap',
	    strokeOpacity: 'stroke-opacity',
	    strokeWidth: 'stroke-width',
	    textAnchor: 'text-anchor',
	    viewBox: 'viewBox',
	    xlinkActuate: 'xlink:actuate',
	    xlinkArcrole: 'xlink:arcrole',
	    xlinkHref: 'xlink:href',
	    xlinkRole: 'xlink:role',
	    xlinkShow: 'xlink:show',
	    xlinkTitle: 'xlink:title',
	    xlinkType: 'xlink:type',
	    xmlBase: 'xml:base',
	    xmlLang: 'xml:lang',
	    xmlSpace: 'xml:space'
	  }
	};
	
	module.exports = SVGDOMPropertyConfig;

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultPerf
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var DOMProperty = __webpack_require__(30);
	var ReactDefaultPerfAnalysis = __webpack_require__(150);
	var ReactMount = __webpack_require__(35);
	var ReactPerf = __webpack_require__(25);
	
	var performanceNow = __webpack_require__(151);
	
	function roundFloat(val) {
	  return Math.floor(val * 100) / 100;
	}
	
	function addValue(obj, key, val) {
	  obj[key] = (obj[key] || 0) + val;
	}
	
	var ReactDefaultPerf = {
	  _allMeasurements: [], // last item in the list is the current one
	  _mountStack: [0],
	  _injected: false,
	
	  start: function start() {
	    if (!ReactDefaultPerf._injected) {
	      ReactPerf.injection.injectMeasure(ReactDefaultPerf.measure);
	    }
	
	    ReactDefaultPerf._allMeasurements.length = 0;
	    ReactPerf.enableMeasure = true;
	  },
	
	  stop: function stop() {
	    ReactPerf.enableMeasure = false;
	  },
	
	  getLastMeasurements: function getLastMeasurements() {
	    return ReactDefaultPerf._allMeasurements;
	  },
	
	  printExclusive: function printExclusive(measurements) {
	    measurements = measurements || ReactDefaultPerf._allMeasurements;
	    var summary = ReactDefaultPerfAnalysis.getExclusiveSummary(measurements);
	    console.table(summary.map(function (item) {
	      return {
	        'Component class name': item.componentName,
	        'Total inclusive time (ms)': roundFloat(item.inclusive),
	        'Exclusive mount time (ms)': roundFloat(item.exclusive),
	        'Exclusive render time (ms)': roundFloat(item.render),
	        'Mount time per instance (ms)': roundFloat(item.exclusive / item.count),
	        'Render time per instance (ms)': roundFloat(item.render / item.count),
	        'Instances': item.count
	      };
	    }));
	    // TODO: ReactDefaultPerfAnalysis.getTotalTime() does not return the correct
	    // number.
	  },
	
	  printInclusive: function printInclusive(measurements) {
	    measurements = measurements || ReactDefaultPerf._allMeasurements;
	    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements);
	    console.table(summary.map(function (item) {
	      return {
	        'Owner > component': item.componentName,
	        'Inclusive time (ms)': roundFloat(item.time),
	        'Instances': item.count
	      };
	    }));
	    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
	  },
	
	  getMeasurementsSummaryMap: function getMeasurementsSummaryMap(measurements) {
	    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements, true);
	    return summary.map(function (item) {
	      return {
	        'Owner > component': item.componentName,
	        'Wasted time (ms)': item.time,
	        'Instances': item.count
	      };
	    });
	  },
	
	  printWasted: function printWasted(measurements) {
	    measurements = measurements || ReactDefaultPerf._allMeasurements;
	    console.table(ReactDefaultPerf.getMeasurementsSummaryMap(measurements));
	    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
	  },
	
	  printDOM: function printDOM(measurements) {
	    measurements = measurements || ReactDefaultPerf._allMeasurements;
	    var summary = ReactDefaultPerfAnalysis.getDOMSummary(measurements);
	    console.table(summary.map(function (item) {
	      var result = {};
	      result[DOMProperty.ID_ATTRIBUTE_NAME] = item.id;
	      result.type = item.type;
	      result.args = JSON.stringify(item.args);
	      return result;
	    }));
	    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
	  },
	
	  _recordWrite: function _recordWrite(id, fnName, totalTime, args) {
	    // TODO: totalTime isn't that useful since it doesn't count paints/reflows
	    var writes = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].writes;
	    writes[id] = writes[id] || [];
	    writes[id].push({
	      type: fnName,
	      time: totalTime,
	      args: args
	    });
	  },
	
	  measure: function measure(moduleName, fnName, func) {
	    return function () {
	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	
	      var totalTime;
	      var rv;
	      var start;
	
	      if (fnName === '_renderNewRootComponent' || fnName === 'flushBatchedUpdates') {
	        // A "measurement" is a set of metrics recorded for each flush. We want
	        // to group the metrics for a given flush together so we can look at the
	        // components that rendered and the DOM operations that actually
	        // happened to determine the amount of "wasted work" performed.
	        ReactDefaultPerf._allMeasurements.push({
	          exclusive: {},
	          inclusive: {},
	          render: {},
	          counts: {},
	          writes: {},
	          displayNames: {},
	          totalTime: 0,
	          created: {}
	        });
	        start = performanceNow();
	        rv = func.apply(this, args);
	        ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].totalTime = performanceNow() - start;
	        return rv;
	      } else if (fnName === '_mountImageIntoNode' || moduleName === 'ReactBrowserEventEmitter' || moduleName === 'ReactDOMIDOperations' || moduleName === 'CSSPropertyOperations' || moduleName === 'DOMChildrenOperations' || moduleName === 'DOMPropertyOperations') {
	        start = performanceNow();
	        rv = func.apply(this, args);
	        totalTime = performanceNow() - start;
	
	        if (fnName === '_mountImageIntoNode') {
	          var mountID = ReactMount.getID(args[1]);
	          ReactDefaultPerf._recordWrite(mountID, fnName, totalTime, args[0]);
	        } else if (fnName === 'dangerouslyProcessChildrenUpdates') {
	          // special format
	          args[0].forEach(function (update) {
	            var writeArgs = {};
	            if (update.fromIndex !== null) {
	              writeArgs.fromIndex = update.fromIndex;
	            }
	            if (update.toIndex !== null) {
	              writeArgs.toIndex = update.toIndex;
	            }
	            if (update.textContent !== null) {
	              writeArgs.textContent = update.textContent;
	            }
	            if (update.markupIndex !== null) {
	              writeArgs.markup = args[1][update.markupIndex];
	            }
	            ReactDefaultPerf._recordWrite(update.parentID, update.type, totalTime, writeArgs);
	          });
	        } else {
	          // basic format
	          var id = args[0];
	          if ((typeof id === 'undefined' ? 'undefined' : _typeof(id)) === 'object') {
	            id = ReactMount.getID(args[0]);
	          }
	          ReactDefaultPerf._recordWrite(id, fnName, totalTime, Array.prototype.slice.call(args, 1));
	        }
	        return rv;
	      } else if (moduleName === 'ReactCompositeComponent' && (fnName === 'mountComponent' || fnName === 'updateComponent' || // TODO: receiveComponent()?
	      fnName === '_renderValidatedComponent')) {
	
	        if (this._currentElement.type === ReactMount.TopLevelWrapper) {
	          return func.apply(this, args);
	        }
	
	        var rootNodeID = fnName === 'mountComponent' ? args[0] : this._rootNodeID;
	        var isRender = fnName === '_renderValidatedComponent';
	        var isMount = fnName === 'mountComponent';
	
	        var mountStack = ReactDefaultPerf._mountStack;
	        var entry = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1];
	
	        if (isRender) {
	          addValue(entry.counts, rootNodeID, 1);
	        } else if (isMount) {
	          entry.created[rootNodeID] = true;
	          mountStack.push(0);
	        }
	
	        start = performanceNow();
	        rv = func.apply(this, args);
	        totalTime = performanceNow() - start;
	
	        if (isRender) {
	          addValue(entry.render, rootNodeID, totalTime);
	        } else if (isMount) {
	          var subMountTime = mountStack.pop();
	          mountStack[mountStack.length - 1] += totalTime;
	          addValue(entry.exclusive, rootNodeID, totalTime - subMountTime);
	          addValue(entry.inclusive, rootNodeID, totalTime);
	        } else {
	          addValue(entry.inclusive, rootNodeID, totalTime);
	        }
	
	        entry.displayNames[rootNodeID] = {
	          current: this.getName(),
	          owner: this._currentElement._owner ? this._currentElement._owner.getName() : '<root>'
	        };
	
	        return rv;
	      } else {
	        return func.apply(this, args);
	      }
	    };
	  }
	};
	
	module.exports = ReactDefaultPerf;

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultPerfAnalysis
	 */
	
	'use strict';
	
	var assign = __webpack_require__(46);
	
	// Don't try to save users less than 1.2ms (a number I made up)
	var DONT_CARE_THRESHOLD = 1.2;
	var DOM_OPERATION_TYPES = {
	  '_mountImageIntoNode': 'set innerHTML',
	  INSERT_MARKUP: 'set innerHTML',
	  MOVE_EXISTING: 'move',
	  REMOVE_NODE: 'remove',
	  SET_MARKUP: 'set innerHTML',
	  TEXT_CONTENT: 'set textContent',
	  'setValueForProperty': 'update attribute',
	  'setValueForAttribute': 'update attribute',
	  'deleteValueForProperty': 'remove attribute',
	  'setValueForStyles': 'update styles',
	  'replaceNodeWithMarkup': 'replace',
	  'updateTextContent': 'set textContent'
	};
	
	function getTotalTime(measurements) {
	  // TODO: return number of DOM ops? could be misleading.
	  // TODO: measure dropped frames after reconcile?
	  // TODO: log total time of each reconcile and the top-level component
	  // class that triggered it.
	  var totalTime = 0;
	  for (var i = 0; i < measurements.length; i++) {
	    var measurement = measurements[i];
	    totalTime += measurement.totalTime;
	  }
	  return totalTime;
	}
	
	function getDOMSummary(measurements) {
	  var items = [];
	  measurements.forEach(function (measurement) {
	    Object.keys(measurement.writes).forEach(function (id) {
	      measurement.writes[id].forEach(function (write) {
	        items.push({
	          id: id,
	          type: DOM_OPERATION_TYPES[write.type] || write.type,
	          args: write.args
	        });
	      });
	    });
	  });
	  return items;
	}
	
	function getExclusiveSummary(measurements) {
	  var candidates = {};
	  var displayName;
	
	  for (var i = 0; i < measurements.length; i++) {
	    var measurement = measurements[i];
	    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
	
	    for (var id in allIDs) {
	      displayName = measurement.displayNames[id].current;
	
	      candidates[displayName] = candidates[displayName] || {
	        componentName: displayName,
	        inclusive: 0,
	        exclusive: 0,
	        render: 0,
	        count: 0
	      };
	      if (measurement.render[id]) {
	        candidates[displayName].render += measurement.render[id];
	      }
	      if (measurement.exclusive[id]) {
	        candidates[displayName].exclusive += measurement.exclusive[id];
	      }
	      if (measurement.inclusive[id]) {
	        candidates[displayName].inclusive += measurement.inclusive[id];
	      }
	      if (measurement.counts[id]) {
	        candidates[displayName].count += measurement.counts[id];
	      }
	    }
	  }
	
	  // Now make a sorted array with the results.
	  var arr = [];
	  for (displayName in candidates) {
	    if (candidates[displayName].exclusive >= DONT_CARE_THRESHOLD) {
	      arr.push(candidates[displayName]);
	    }
	  }
	
	  arr.sort(function (a, b) {
	    return b.exclusive - a.exclusive;
	  });
	
	  return arr;
	}
	
	function getInclusiveSummary(measurements, onlyClean) {
	  var candidates = {};
	  var inclusiveKey;
	
	  for (var i = 0; i < measurements.length; i++) {
	    var measurement = measurements[i];
	    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
	    var cleanComponents;
	
	    if (onlyClean) {
	      cleanComponents = getUnchangedComponents(measurement);
	    }
	
	    for (var id in allIDs) {
	      if (onlyClean && !cleanComponents[id]) {
	        continue;
	      }
	
	      var displayName = measurement.displayNames[id];
	
	      // Inclusive time is not useful for many components without knowing where
	      // they are instantiated. So we aggregate inclusive time with both the
	      // owner and current displayName as the key.
	      inclusiveKey = displayName.owner + ' > ' + displayName.current;
	
	      candidates[inclusiveKey] = candidates[inclusiveKey] || {
	        componentName: inclusiveKey,
	        time: 0,
	        count: 0
	      };
	
	      if (measurement.inclusive[id]) {
	        candidates[inclusiveKey].time += measurement.inclusive[id];
	      }
	      if (measurement.counts[id]) {
	        candidates[inclusiveKey].count += measurement.counts[id];
	      }
	    }
	  }
	
	  // Now make a sorted array with the results.
	  var arr = [];
	  for (inclusiveKey in candidates) {
	    if (candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD) {
	      arr.push(candidates[inclusiveKey]);
	    }
	  }
	
	  arr.sort(function (a, b) {
	    return b.time - a.time;
	  });
	
	  return arr;
	}
	
	function getUnchangedComponents(measurement) {
	  // For a given reconcile, look at which components did not actually
	  // render anything to the DOM and return a mapping of their ID to
	  // the amount of time it took to render the entire subtree.
	  var cleanComponents = {};
	  var dirtyLeafIDs = Object.keys(measurement.writes);
	  var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
	
	  for (var id in allIDs) {
	    var isDirty = false;
	    // For each component that rendered, see if a component that triggered
	    // a DOM op is in its subtree.
	    for (var i = 0; i < dirtyLeafIDs.length; i++) {
	      if (dirtyLeafIDs[i].indexOf(id) === 0) {
	        isDirty = true;
	        break;
	      }
	    }
	    // check if component newly created
	    if (measurement.created[id]) {
	      isDirty = true;
	    }
	    if (!isDirty && measurement.counts[id] > 0) {
	      cleanComponents[id] = true;
	    }
	  }
	  return cleanComponents;
	}
	
	var ReactDefaultPerfAnalysis = {
	  getExclusiveSummary: getExclusiveSummary,
	  getInclusiveSummary: getInclusiveSummary,
	  getDOMSummary: getDOMSummary,
	  getTotalTime: getTotalTime
	};
	
	module.exports = ReactDefaultPerfAnalysis;

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule performanceNow
	 * @typechecks
	 */
	
	'use strict';
	
	var performance = __webpack_require__(152);
	
	var performanceNow;
	
	/**
	 * Detect if we can use `window.performance.now()` and gracefully fallback to
	 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
	 * because of Facebook's testing infrastructure.
	 */
	if (performance.now) {
	  performanceNow = function performanceNow() {
	    return performance.now();
	  };
	} else {
	  performanceNow = function performanceNow() {
	    return Date.now();
	  };
	}
	
	module.exports = performanceNow;

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule performance
	 * @typechecks
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(16);
	
	var performance;
	
	if (ExecutionEnvironment.canUseDOM) {
	  performance = window.performance || window.msPerformance || window.webkitPerformance;
	}
	
	module.exports = performance || {};

/***/ },
/* 153 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactVersion
	 */
	
	'use strict';
	
	module.exports = '0.14.8';

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	* @providesModule renderSubtreeIntoContainer
	*/
	
	'use strict';
	
	var ReactMount = __webpack_require__(35);
	
	module.exports = ReactMount.renderSubtreeIntoContainer;

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMServer
	 */
	
	'use strict';
	
	var ReactDefaultInjection = __webpack_require__(78);
	var ReactServerRendering = __webpack_require__(156);
	var ReactVersion = __webpack_require__(153);
	
	ReactDefaultInjection.inject();
	
	var ReactDOMServer = {
	  renderToString: ReactServerRendering.renderToString,
	  renderToStaticMarkup: ReactServerRendering.renderToStaticMarkup,
	  version: ReactVersion
	};
	
	module.exports = ReactDOMServer;

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks static-only
	 * @providesModule ReactServerRendering
	 */
	'use strict';
	
	var ReactDefaultBatchingStrategy = __webpack_require__(99);
	var ReactElement = __webpack_require__(49);
	var ReactInstanceHandles = __webpack_require__(52);
	var ReactMarkupChecksum = __webpack_require__(55);
	var ReactServerBatchingStrategy = __webpack_require__(157);
	var ReactServerRenderingTransaction = __webpack_require__(158);
	var ReactUpdates = __webpack_require__(61);
	
	var emptyObject = __webpack_require__(65);
	var instantiateReactComponent = __webpack_require__(69);
	var invariant = __webpack_require__(20);
	
	/**
	 * @param {ReactElement} element
	 * @return {string} the HTML markup
	 */
	function renderToString(element) {
	  !ReactElement.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToString(): You must pass a valid ReactElement.') : invariant(false) : undefined;
	
	  var transaction;
	  try {
	    ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);
	
	    var id = ReactInstanceHandles.createReactRootID();
	    transaction = ReactServerRenderingTransaction.getPooled(false);
	
	    return transaction.perform(function () {
	      var componentInstance = instantiateReactComponent(element, null);
	      var markup = componentInstance.mountComponent(id, transaction, emptyObject);
	      return ReactMarkupChecksum.addChecksumToMarkup(markup);
	    }, null);
	  } finally {
	    ReactServerRenderingTransaction.release(transaction);
	    // Revert to the DOM batching strategy since these two renderers
	    // currently share these stateful modules.
	    ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	  }
	}
	
	/**
	 * @param {ReactElement} element
	 * @return {string} the HTML markup, without the extra React ID and checksum
	 * (for generating static pages)
	 */
	function renderToStaticMarkup(element) {
	  !ReactElement.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToStaticMarkup(): You must pass a valid ReactElement.') : invariant(false) : undefined;
	
	  var transaction;
	  try {
	    ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);
	
	    var id = ReactInstanceHandles.createReactRootID();
	    transaction = ReactServerRenderingTransaction.getPooled(true);
	
	    return transaction.perform(function () {
	      var componentInstance = instantiateReactComponent(element, null);
	      return componentInstance.mountComponent(id, transaction, emptyObject);
	    }, null);
	  } finally {
	    ReactServerRenderingTransaction.release(transaction);
	    // Revert to the DOM batching strategy since these two renderers
	    // currently share these stateful modules.
	    ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	  }
	}
	
	module.exports = {
	  renderToString: renderToString,
	  renderToStaticMarkup: renderToStaticMarkup
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 157 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactServerBatchingStrategy
	 * @typechecks
	 */
	
	'use strict';
	
	var ReactServerBatchingStrategy = {
	  isBatchingUpdates: false,
	  batchedUpdates: function batchedUpdates(callback) {
	    // Don't do anything here. During the server rendering we don't want to
	    // schedule any updates. We will simply ignore them.
	  }
	};
	
	module.exports = ReactServerBatchingStrategy;

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactServerRenderingTransaction
	 * @typechecks
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(63);
	var CallbackQueue = __webpack_require__(62);
	var Transaction = __webpack_require__(64);
	
	var assign = __webpack_require__(46);
	var emptyFunction = __webpack_require__(22);
	
	/**
	 * Provides a `CallbackQueue` queue for collecting `onDOMReady` callbacks
	 * during the performing of the transaction.
	 */
	var ON_DOM_READY_QUEUEING = {
	  /**
	   * Initializes the internal `onDOMReady` queue.
	   */
	  initialize: function initialize() {
	    this.reactMountReady.reset();
	  },
	
	  close: emptyFunction
	};
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [ON_DOM_READY_QUEUEING];
	
	/**
	 * @class ReactServerRenderingTransaction
	 * @param {boolean} renderToStaticMarkup
	 */
	function ReactServerRenderingTransaction(renderToStaticMarkup) {
	  this.reinitializeTransaction();
	  this.renderToStaticMarkup = renderToStaticMarkup;
	  this.reactMountReady = CallbackQueue.getPooled(null);
	  this.useCreateElement = false;
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array} Empty list of operation wrap procedures.
	   */
	  getTransactionWrappers: function getTransactionWrappers() {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function getReactMountReady() {
	    return this.reactMountReady;
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function destructor() {
	    CallbackQueue.release(this.reactMountReady);
	    this.reactMountReady = null;
	  }
	};
	
	assign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin);
	
	PooledClass.addPoolingTo(ReactServerRenderingTransaction);
	
	module.exports = ReactServerRenderingTransaction;

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactIsomorphic
	 */
	
	'use strict';
	
	var ReactChildren = __webpack_require__(117);
	var ReactComponent = __webpack_require__(130);
	var ReactClass = __webpack_require__(129);
	var ReactDOMFactories = __webpack_require__(160);
	var ReactElement = __webpack_require__(49);
	var ReactElementValidator = __webpack_require__(161);
	var ReactPropTypes = __webpack_require__(114);
	var ReactVersion = __webpack_require__(153);
	
	var assign = __webpack_require__(46);
	var onlyChild = __webpack_require__(163);
	
	var createElement = ReactElement.createElement;
	var createFactory = ReactElement.createFactory;
	var cloneElement = ReactElement.cloneElement;
	
	if (process.env.NODE_ENV !== 'production') {
	  createElement = ReactElementValidator.createElement;
	  createFactory = ReactElementValidator.createFactory;
	  cloneElement = ReactElementValidator.cloneElement;
	}
	
	var React = {
	
	  // Modern
	
	  Children: {
	    map: ReactChildren.map,
	    forEach: ReactChildren.forEach,
	    count: ReactChildren.count,
	    toArray: ReactChildren.toArray,
	    only: onlyChild
	  },
	
	  Component: ReactComponent,
	
	  createElement: createElement,
	  cloneElement: cloneElement,
	  isValidElement: ReactElement.isValidElement,
	
	  // Classic
	
	  PropTypes: ReactPropTypes,
	  createClass: ReactClass.createClass,
	  createFactory: createFactory,
	  createMixin: function createMixin(mixin) {
	    // Currently a noop. Will be used to validate and trace mixins.
	    return mixin;
	  },
	
	  // This looks DOM specific but these are actually isomorphic helpers
	  // since they are just generating DOM strings.
	  DOM: ReactDOMFactories,
	
	  version: ReactVersion,
	
	  // Hook for JSX spread, don't use this for anything else.
	  __spread: assign
	};
	
	module.exports = React;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMFactories
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(49);
	var ReactElementValidator = __webpack_require__(161);
	
	var mapObject = __webpack_require__(162);
	
	/**
	 * Create a factory that creates HTML tag elements.
	 *
	 * @param {string} tag Tag name (e.g. `div`).
	 * @private
	 */
	function createDOMFactory(tag) {
	  if (process.env.NODE_ENV !== 'production') {
	    return ReactElementValidator.createFactory(tag);
	  }
	  return ReactElement.createFactory(tag);
	}
	
	/**
	 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
	 * This is also accessible via `React.DOM`.
	 *
	 * @public
	 */
	var ReactDOMFactories = mapObject({
	  a: 'a',
	  abbr: 'abbr',
	  address: 'address',
	  area: 'area',
	  article: 'article',
	  aside: 'aside',
	  audio: 'audio',
	  b: 'b',
	  base: 'base',
	  bdi: 'bdi',
	  bdo: 'bdo',
	  big: 'big',
	  blockquote: 'blockquote',
	  body: 'body',
	  br: 'br',
	  button: 'button',
	  canvas: 'canvas',
	  caption: 'caption',
	  cite: 'cite',
	  code: 'code',
	  col: 'col',
	  colgroup: 'colgroup',
	  data: 'data',
	  datalist: 'datalist',
	  dd: 'dd',
	  del: 'del',
	  details: 'details',
	  dfn: 'dfn',
	  dialog: 'dialog',
	  div: 'div',
	  dl: 'dl',
	  dt: 'dt',
	  em: 'em',
	  embed: 'embed',
	  fieldset: 'fieldset',
	  figcaption: 'figcaption',
	  figure: 'figure',
	  footer: 'footer',
	  form: 'form',
	  h1: 'h1',
	  h2: 'h2',
	  h3: 'h3',
	  h4: 'h4',
	  h5: 'h5',
	  h6: 'h6',
	  head: 'head',
	  header: 'header',
	  hgroup: 'hgroup',
	  hr: 'hr',
	  html: 'html',
	  i: 'i',
	  iframe: 'iframe',
	  img: 'img',
	  input: 'input',
	  ins: 'ins',
	  kbd: 'kbd',
	  keygen: 'keygen',
	  label: 'label',
	  legend: 'legend',
	  li: 'li',
	  link: 'link',
	  main: 'main',
	  map: 'map',
	  mark: 'mark',
	  menu: 'menu',
	  menuitem: 'menuitem',
	  meta: 'meta',
	  meter: 'meter',
	  nav: 'nav',
	  noscript: 'noscript',
	  object: 'object',
	  ol: 'ol',
	  optgroup: 'optgroup',
	  option: 'option',
	  output: 'output',
	  p: 'p',
	  param: 'param',
	  picture: 'picture',
	  pre: 'pre',
	  progress: 'progress',
	  q: 'q',
	  rp: 'rp',
	  rt: 'rt',
	  ruby: 'ruby',
	  s: 's',
	  samp: 'samp',
	  script: 'script',
	  section: 'section',
	  select: 'select',
	  small: 'small',
	  source: 'source',
	  span: 'span',
	  strong: 'strong',
	  style: 'style',
	  sub: 'sub',
	  summary: 'summary',
	  sup: 'sup',
	  table: 'table',
	  tbody: 'tbody',
	  td: 'td',
	  textarea: 'textarea',
	  tfoot: 'tfoot',
	  th: 'th',
	  thead: 'thead',
	  time: 'time',
	  title: 'title',
	  tr: 'tr',
	  track: 'track',
	  u: 'u',
	  ul: 'ul',
	  'var': 'var',
	  video: 'video',
	  wbr: 'wbr',
	
	  // SVG
	  circle: 'circle',
	  clipPath: 'clipPath',
	  defs: 'defs',
	  ellipse: 'ellipse',
	  g: 'g',
	  image: 'image',
	  line: 'line',
	  linearGradient: 'linearGradient',
	  mask: 'mask',
	  path: 'path',
	  pattern: 'pattern',
	  polygon: 'polygon',
	  polyline: 'polyline',
	  radialGradient: 'radialGradient',
	  rect: 'rect',
	  stop: 'stop',
	  svg: 'svg',
	  text: 'text',
	  tspan: 'tspan'
	
	}, createDOMFactory);
	
	module.exports = ReactDOMFactories;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactElementValidator
	 */
	
	/**
	 * ReactElementValidator provides a wrapper around a element factory
	 * which validates the props passed to the element. This is intended to be
	 * used only in DEV and could be replaced by a static type checker for languages
	 * that support it.
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactElement = __webpack_require__(49);
	var ReactPropTypeLocations = __webpack_require__(72);
	var ReactPropTypeLocationNames = __webpack_require__(73);
	var ReactCurrentOwner = __webpack_require__(12);
	
	var canDefineProperty = __webpack_require__(50);
	var getIteratorFn = __webpack_require__(115);
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	function getDeclarationErrorAddendum() {
	  if (ReactCurrentOwner.current) {
	    var name = ReactCurrentOwner.current.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Warn if there's no key explicitly set on dynamic arrays of children or
	 * object keys are not valid. This allows us to keep track of children between
	 * updates.
	 */
	var ownerHasKeyUseWarning = {};
	
	var loggedTypeFailures = {};
	
	/**
	 * Warn if the element doesn't have an explicit key assigned to it.
	 * This element is in an array. The array could grow and shrink or be
	 * reordered. All children that haven't already been validated are required to
	 * have a "key" property assigned to it.
	 *
	 * @internal
	 * @param {ReactElement} element Element that requires a key.
	 * @param {*} parentType element's parent's type.
	 */
	function validateExplicitKey(element, parentType) {
	  if (!element._store || element._store.validated || element.key != null) {
	    return;
	  }
	  element._store.validated = true;
	
	  var addenda = getAddendaForKeyUse('uniqueKey', element, parentType);
	  if (addenda === null) {
	    // we already showed the warning
	    return;
	  }
	  process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s%s', addenda.parentOrOwner || '', addenda.childOwner || '', addenda.url || '') : undefined;
	}
	
	/**
	 * Shared warning and monitoring code for the key warnings.
	 *
	 * @internal
	 * @param {string} messageType A key used for de-duping warnings.
	 * @param {ReactElement} element Component that requires a key.
	 * @param {*} parentType element's parent's type.
	 * @returns {?object} A set of addenda to use in the warning message, or null
	 * if the warning has already been shown before (and shouldn't be shown again).
	 */
	function getAddendaForKeyUse(messageType, element, parentType) {
	  var addendum = getDeclarationErrorAddendum();
	  if (!addendum) {
	    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
	    if (parentName) {
	      addendum = ' Check the top-level render call using <' + parentName + '>.';
	    }
	  }
	
	  var memoizer = ownerHasKeyUseWarning[messageType] || (ownerHasKeyUseWarning[messageType] = {});
	  if (memoizer[addendum]) {
	    return null;
	  }
	  memoizer[addendum] = true;
	
	  var addenda = {
	    parentOrOwner: addendum,
	    url: ' See https://fb.me/react-warning-keys for more information.',
	    childOwner: null
	  };
	
	  // Usually the current owner is the offender, but if it accepts children as a
	  // property, it may be the creator of the child that's responsible for
	  // assigning it a key.
	  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
	    // Give the component that originally created this child.
	    addenda.childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
	  }
	
	  return addenda;
	}
	
	/**
	 * Ensure that every element either is passed in a static location, in an
	 * array with an explicit keys property defined, or in an object literal
	 * with valid key property.
	 *
	 * @internal
	 * @param {ReactNode} node Statically passed child of any type.
	 * @param {*} parentType node's parent's type.
	 */
	function validateChildKeys(node, parentType) {
	  if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) !== 'object') {
	    return;
	  }
	  if (Array.isArray(node)) {
	    for (var i = 0; i < node.length; i++) {
	      var child = node[i];
	      if (ReactElement.isValidElement(child)) {
	        validateExplicitKey(child, parentType);
	      }
	    }
	  } else if (ReactElement.isValidElement(node)) {
	    // This element was passed in a valid location.
	    if (node._store) {
	      node._store.validated = true;
	    }
	  } else if (node) {
	    var iteratorFn = getIteratorFn(node);
	    // Entry iterators provide implicit keys.
	    if (iteratorFn) {
	      if (iteratorFn !== node.entries) {
	        var iterator = iteratorFn.call(node);
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (ReactElement.isValidElement(step.value)) {
	            validateExplicitKey(step.value, parentType);
	          }
	        }
	      }
	    }
	  }
	}
	
	/**
	 * Assert that the props are valid
	 *
	 * @param {string} componentName Name of the component for error messages.
	 * @param {object} propTypes Map of prop name to a ReactPropType
	 * @param {object} props
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @private
	 */
	function checkPropTypes(componentName, propTypes, props, location) {
	  for (var propName in propTypes) {
	    if (propTypes.hasOwnProperty(propName)) {
	      var error;
	      // Prop type validation may throw. In case they do, we don't want to
	      // fail the render phase where it didn't fail before. So we log it.
	      // After these have been cleaned up, we'll let them throw.
	      try {
	        // This is intentionally an invariant that gets caught. It's the same
	        // behavior as without this statement except with a better message.
	        !(typeof propTypes[propName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
	        error = propTypes[propName](props, propName, componentName, location);
	      } catch (ex) {
	        error = ex;
	      }
	      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], propName, typeof error === 'undefined' ? 'undefined' : _typeof(error)) : undefined;
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var addendum = getDeclarationErrorAddendum();
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed propType: %s%s', error.message, addendum) : undefined;
	      }
	    }
	  }
	}
	
	/**
	 * Given an element, validate that its props follow the propTypes definition,
	 * provided by the type.
	 *
	 * @param {ReactElement} element
	 */
	function validatePropTypes(element) {
	  var componentClass = element.type;
	  if (typeof componentClass !== 'function') {
	    return;
	  }
	  var name = componentClass.displayName || componentClass.name;
	  if (componentClass.propTypes) {
	    checkPropTypes(name, componentClass.propTypes, element.props, ReactPropTypeLocations.prop);
	  }
	  if (typeof componentClass.getDefaultProps === 'function') {
	    process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : undefined;
	  }
	}
	
	var ReactElementValidator = {
	
	  createElement: function createElement(type, props, children) {
	    var validType = typeof type === 'string' || typeof type === 'function';
	    // We warn in this case but don't throw. We expect the element creation to
	    // succeed and there will likely be errors in render.
	    process.env.NODE_ENV !== 'production' ? warning(validType, 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : undefined;
	
	    var element = ReactElement.createElement.apply(this, arguments);
	
	    // The result can be nullish if a mock or a custom function is used.
	    // TODO: Drop this when these are no longer allowed as the type argument.
	    if (element == null) {
	      return element;
	    }
	
	    // Skip key warning if the type isn't valid since our key validation logic
	    // doesn't expect a non-string/function type and can throw confusing errors.
	    // We don't want exception behavior to differ between dev and prod.
	    // (Rendering will throw with a helpful message and as soon as the type is
	    // fixed, the key warnings will appear.)
	    if (validType) {
	      for (var i = 2; i < arguments.length; i++) {
	        validateChildKeys(arguments[i], type);
	      }
	    }
	
	    validatePropTypes(element);
	
	    return element;
	  },
	
	  createFactory: function createFactory(type) {
	    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
	    // Legacy hook TODO: Warn if this is accessed
	    validatedFactory.type = type;
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (canDefineProperty) {
	        Object.defineProperty(validatedFactory, 'type', {
	          enumerable: false,
	          get: function get() {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : undefined;
	            Object.defineProperty(this, 'type', {
	              value: type
	            });
	            return type;
	          }
	        });
	      }
	    }
	
	    return validatedFactory;
	  },
	
	  cloneElement: function cloneElement(element, props, children) {
	    var newElement = ReactElement.cloneElement.apply(this, arguments);
	    for (var i = 2; i < arguments.length; i++) {
	      validateChildKeys(arguments[i], newElement.type);
	    }
	    validatePropTypes(newElement);
	    return newElement;
	  }
	
	};
	
	module.exports = ReactElementValidator;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 162 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule mapObject
	 */
	
	'use strict';
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	/**
	 * Executes the provided `callback` once for each enumerable own property in the
	 * object and constructs a new object from the results. The `callback` is
	 * invoked with three arguments:
	 *
	 *  - the property value
	 *  - the property name
	 *  - the object being traversed
	 *
	 * Properties that are added after the call to `mapObject` will not be visited
	 * by `callback`. If the values of existing properties are changed, the value
	 * passed to `callback` will be the value at the time `mapObject` visits them.
	 * Properties that are deleted before being visited are not visited.
	 *
	 * @grep function objectMap()
	 * @grep function objMap()
	 *
	 * @param {?object} object
	 * @param {function} callback
	 * @param {*} context
	 * @return {?object}
	 */
	function mapObject(object, callback, context) {
	  if (!object) {
	    return null;
	  }
	  var result = {};
	  for (var name in object) {
	    if (hasOwnProperty.call(object, name)) {
	      result[name] = callback.call(context, object[name], name, object);
	    }
	  }
	  return result;
	}
	
	module.exports = mapObject;

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule onlyChild
	 */
	'use strict';
	
	var ReactElement = __webpack_require__(49);
	
	var invariant = __webpack_require__(20);
	
	/**
	 * Returns the first child in a collection of children and verifies that there
	 * is only one child in the collection. The current implementation of this
	 * function assumes that a single child gets passed without a wrapper, but the
	 * purpose of this helper function is to abstract away the particular structure
	 * of children.
	 *
	 * @param {?object} children Child collection structure.
	 * @return {ReactComponent} The first and only `ReactComponent` contained in the
	 * structure.
	 */
	function onlyChild(children) {
	  !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'onlyChild must be passed a children with exactly one child.') : invariant(false) : undefined;
	  return children;
	}
	
	module.exports = onlyChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule deprecated
	 */
	
	'use strict';
	
	var assign = __webpack_require__(46);
	var warning = __webpack_require__(32);
	
	/**
	 * This will log a single deprecation notice per function and forward the call
	 * on to the new API.
	 *
	 * @param {string} fnName The name of the function
	 * @param {string} newModule The module that fn will exist in
	 * @param {string} newPackage The module that fn will exist in
	 * @param {*} ctx The context this forwarded call should run in
	 * @param {function} fn The function to forward on to
	 * @return {function} The function that will warn once and then call fn
	 */
	function deprecated(fnName, newModule, newPackage, ctx, fn) {
	  var warned = false;
	  if (process.env.NODE_ENV !== 'production') {
	    var newFn = function newFn() {
	      process.env.NODE_ENV !== 'production' ? warning(warned,
	      // Require examples in this string must be split to prevent React's
	      // build tools from mistaking them for real requires.
	      // Otherwise the build tools will attempt to build a '%s' module.
	      'React.%s is deprecated. Please use %s.%s from require' + '(\'%s\') ' + 'instead.', fnName, newModule, fnName, newPackage) : undefined;
	      warned = true;
	      return fn.apply(ctx, arguments);
	    };
	    // We need to make sure all properties of the original fn are copied over.
	    // In particular, this is needed to support PropTypes
	    return assign(newFn, fn);
	  }
	
	  return fn;
	}
	
	module.exports = deprecated;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(10);

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.createMemoryHistory = exports.hashHistory = exports.browserHistory = exports.applyRouterMiddleware = exports.formatPattern = exports.useRouterHistory = exports.match = exports.routerShape = exports.locationShape = exports.PropTypes = exports.RoutingContext = exports.RouterContext = exports.createRoutes = exports.useRoutes = exports.RouteContext = exports.Lifecycle = exports.History = exports.Route = exports.Redirect = exports.IndexRoute = exports.IndexRedirect = exports.withRouter = exports.IndexLink = exports.Link = exports.Router = undefined;
	
	var _RouteUtils = __webpack_require__(167);
	
	Object.defineProperty(exports, 'createRoutes', {
	  enumerable: true,
	  get: function get() {
	    return _RouteUtils.createRoutes;
	  }
	});
	
	var _PropTypes2 = __webpack_require__(168);
	
	Object.defineProperty(exports, 'locationShape', {
	  enumerable: true,
	  get: function get() {
	    return _PropTypes2.locationShape;
	  }
	});
	Object.defineProperty(exports, 'routerShape', {
	  enumerable: true,
	  get: function get() {
	    return _PropTypes2.routerShape;
	  }
	});
	
	var _PatternUtils = __webpack_require__(173);
	
	Object.defineProperty(exports, 'formatPattern', {
	  enumerable: true,
	  get: function get() {
	    return _PatternUtils.formatPattern;
	  }
	});
	
	var _Router2 = __webpack_require__(175);
	
	var _Router3 = _interopRequireDefault(_Router2);
	
	var _Link2 = __webpack_require__(206);
	
	var _Link3 = _interopRequireDefault(_Link2);
	
	var _IndexLink2 = __webpack_require__(207);
	
	var _IndexLink3 = _interopRequireDefault(_IndexLink2);
	
	var _withRouter2 = __webpack_require__(208);
	
	var _withRouter3 = _interopRequireDefault(_withRouter2);
	
	var _IndexRedirect2 = __webpack_require__(210);
	
	var _IndexRedirect3 = _interopRequireDefault(_IndexRedirect2);
	
	var _IndexRoute2 = __webpack_require__(212);
	
	var _IndexRoute3 = _interopRequireDefault(_IndexRoute2);
	
	var _Redirect2 = __webpack_require__(211);
	
	var _Redirect3 = _interopRequireDefault(_Redirect2);
	
	var _Route2 = __webpack_require__(213);
	
	var _Route3 = _interopRequireDefault(_Route2);
	
	var _History2 = __webpack_require__(214);
	
	var _History3 = _interopRequireDefault(_History2);
	
	var _Lifecycle2 = __webpack_require__(215);
	
	var _Lifecycle3 = _interopRequireDefault(_Lifecycle2);
	
	var _RouteContext2 = __webpack_require__(216);
	
	var _RouteContext3 = _interopRequireDefault(_RouteContext2);
	
	var _useRoutes2 = __webpack_require__(217);
	
	var _useRoutes3 = _interopRequireDefault(_useRoutes2);
	
	var _RouterContext2 = __webpack_require__(203);
	
	var _RouterContext3 = _interopRequireDefault(_RouterContext2);
	
	var _RoutingContext2 = __webpack_require__(218);
	
	var _RoutingContext3 = _interopRequireDefault(_RoutingContext2);
	
	var _PropTypes3 = _interopRequireDefault(_PropTypes2);
	
	var _match2 = __webpack_require__(219);
	
	var _match3 = _interopRequireDefault(_match2);
	
	var _useRouterHistory2 = __webpack_require__(223);
	
	var _useRouterHistory3 = _interopRequireDefault(_useRouterHistory2);
	
	var _applyRouterMiddleware2 = __webpack_require__(224);
	
	var _applyRouterMiddleware3 = _interopRequireDefault(_applyRouterMiddleware2);
	
	var _browserHistory2 = __webpack_require__(225);
	
	var _browserHistory3 = _interopRequireDefault(_browserHistory2);
	
	var _hashHistory2 = __webpack_require__(228);
	
	var _hashHistory3 = _interopRequireDefault(_hashHistory2);
	
	var _createMemoryHistory2 = __webpack_require__(220);
	
	var _createMemoryHistory3 = _interopRequireDefault(_createMemoryHistory2);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	exports.Router = _Router3.default; /* components */
	
	exports.Link = _Link3.default;
	exports.IndexLink = _IndexLink3.default;
	exports.withRouter = _withRouter3.default;
	
	/* components (configuration) */
	
	exports.IndexRedirect = _IndexRedirect3.default;
	exports.IndexRoute = _IndexRoute3.default;
	exports.Redirect = _Redirect3.default;
	exports.Route = _Route3.default;
	
	/* mixins */
	
	exports.History = _History3.default;
	exports.Lifecycle = _Lifecycle3.default;
	exports.RouteContext = _RouteContext3.default;
	
	/* utils */
	
	exports.useRoutes = _useRoutes3.default;
	exports.RouterContext = _RouterContext3.default;
	exports.RoutingContext = _RoutingContext3.default;
	exports.PropTypes = _PropTypes3.default;
	exports.match = _match3.default;
	exports.useRouterHistory = _useRouterHistory3.default;
	exports.applyRouterMiddleware = _applyRouterMiddleware3.default;
	
	/* histories */
	
	exports.browserHistory = _browserHistory3.default;
	exports.hashHistory = _hashHistory3.default;
	exports.createMemoryHistory = _createMemoryHistory3.default;

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	exports.isReactChildren = isReactChildren;
	exports.createRouteFromReactElement = createRouteFromReactElement;
	exports.createRoutesFromReactChildren = createRoutesFromReactChildren;
	exports.createRoutes = createRoutes;
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function isValidChild(object) {
	  return object == null || _react2.default.isValidElement(object);
	}
	
	function isReactChildren(object) {
	  return isValidChild(object) || Array.isArray(object) && object.every(isValidChild);
	}
	
	function createRoute(defaultProps, props) {
	  return _extends({}, defaultProps, props);
	}
	
	function createRouteFromReactElement(element) {
	  var type = element.type;
	  var route = createRoute(type.defaultProps, element.props);
	
	  if (route.children) {
	    var childRoutes = createRoutesFromReactChildren(route.children, route);
	
	    if (childRoutes.length) route.childRoutes = childRoutes;
	
	    delete route.children;
	  }
	
	  return route;
	}
	
	/**
	 * Creates and returns a routes object from the given ReactChildren. JSX
	 * provides a convenient way to visualize how routes in the hierarchy are
	 * nested.
	 *
	 *   import { Route, createRoutesFromReactChildren } from 'react-router'
	 *
	 *   const routes = createRoutesFromReactChildren(
	 *     <Route component={App}>
	 *       <Route path="home" component={Dashboard}/>
	 *       <Route path="news" component={NewsFeed}/>
	 *     </Route>
	 *   )
	 *
	 * Note: This method is automatically used when you provide <Route> children
	 * to a <Router> component.
	 */
	function createRoutesFromReactChildren(children, parentRoute) {
	  var routes = [];
	
	  _react2.default.Children.forEach(children, function (element) {
	    if (_react2.default.isValidElement(element)) {
	      // Component classes may have a static create* method.
	      if (element.type.createRouteFromReactElement) {
	        var route = element.type.createRouteFromReactElement(element, parentRoute);
	
	        if (route) routes.push(route);
	      } else {
	        routes.push(createRouteFromReactElement(element));
	      }
	    }
	  });
	
	  return routes;
	}
	
	/**
	 * Creates and returns an array of routes from the given object which
	 * may be a JSX route, a plain object route, or an array of either.
	 */
	function createRoutes(routes) {
	  if (isReactChildren(routes)) {
	    routes = createRoutesFromReactChildren(routes);
	  } else if (routes && !Array.isArray(routes)) {
	    routes = [routes];
	  }
	
	  return routes;
	}

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.router = exports.routes = exports.route = exports.components = exports.component = exports.location = exports.history = exports.falsy = exports.locationShape = exports.routerShape = undefined;
	
	var _react = __webpack_require__(8);
	
	var _deprecateObjectProperties = __webpack_require__(169);
	
	var _deprecateObjectProperties2 = _interopRequireDefault(_deprecateObjectProperties);
	
	var _InternalPropTypes = __webpack_require__(172);
	
	var InternalPropTypes = _interopRequireWildcard(_InternalPropTypes);
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireWildcard(obj) {
	  if (obj && obj.__esModule) {
	    return obj;
	  } else {
	    var newObj = {};if (obj != null) {
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	      }
	    }newObj.default = obj;return newObj;
	  }
	}
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var func = _react.PropTypes.func;
	var object = _react.PropTypes.object;
	var shape = _react.PropTypes.shape;
	var string = _react.PropTypes.string;
	var routerShape = exports.routerShape = shape({
	  push: func.isRequired,
	  replace: func.isRequired,
	  go: func.isRequired,
	  goBack: func.isRequired,
	  goForward: func.isRequired,
	  setRouteLeaveHook: func.isRequired,
	  isActive: func.isRequired
	});
	
	var locationShape = exports.locationShape = shape({
	  pathname: string.isRequired,
	  search: string.isRequired,
	  state: object,
	  action: string.isRequired,
	  key: string
	});
	
	// Deprecated stuff below:
	
	var falsy = exports.falsy = InternalPropTypes.falsy;
	var history = exports.history = InternalPropTypes.history;
	var location = exports.location = locationShape;
	var component = exports.component = InternalPropTypes.component;
	var components = exports.components = InternalPropTypes.components;
	var route = exports.route = InternalPropTypes.route;
	var routes = exports.routes = InternalPropTypes.routes;
	var router = exports.router = routerShape;
	
	if (process.env.NODE_ENV !== 'production') {
	  (function () {
	    var deprecatePropType = function deprecatePropType(propType, message) {
	      return function () {
	        process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, message) : void 0;
	        return propType.apply(undefined, arguments);
	      };
	    };
	
	    var deprecateInternalPropType = function deprecateInternalPropType(propType) {
	      return deprecatePropType(propType, 'This prop type is not intended for external use, and was previously exported by mistake. These internal prop types are deprecated for external use, and will be removed in a later version.');
	    };
	
	    var deprecateRenamedPropType = function deprecateRenamedPropType(propType, name) {
	      return deprecatePropType(propType, 'The `' + name + '` prop type is now exported as `' + name + 'Shape` to avoid name conflicts. This export is deprecated and will be removed in a later version.');
	    };
	
	    exports.falsy = falsy = deprecateInternalPropType(falsy);
	    exports.history = history = deprecateInternalPropType(history);
	    exports.component = component = deprecateInternalPropType(component);
	    exports.components = components = deprecateInternalPropType(components);
	    exports.route = route = deprecateInternalPropType(route);
	    exports.routes = routes = deprecateInternalPropType(routes);
	
	    exports.location = location = deprecateRenamedPropType(location, 'location');
	    exports.router = router = deprecateRenamedPropType(router, 'router');
	  })();
	}
	
	var defaultExport = {
	  falsy: falsy,
	  history: history,
	  location: location,
	  component: component,
	  components: components,
	  route: route,
	  // For some reason, routes was never here.
	  router: router
	};
	
	if (process.env.NODE_ENV !== 'production') {
	  defaultExport = (0, _deprecateObjectProperties2.default)(defaultExport, 'The default export from `react-router/lib/PropTypes` is deprecated. Please use the named exports instead.');
	}
	
	exports.default = defaultExport;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.canUseMembrane = undefined;
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var canUseMembrane = exports.canUseMembrane = false;
	
	// No-op by default.
	var deprecateObjectProperties = function deprecateObjectProperties(object) {
	  return object;
	};
	
	if (process.env.NODE_ENV !== 'production') {
	  try {
	    if (Object.defineProperty({}, 'x', {
	      get: function get() {
	        return true;
	      }
	    }).x) {
	      exports.canUseMembrane = canUseMembrane = true;
	    }
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	
	  if (canUseMembrane) {
	    deprecateObjectProperties = function deprecateObjectProperties(object, message) {
	      // Wrap the deprecated object in a membrane to warn on property access.
	      var membrane = {};
	
	      var _loop = function _loop(prop) {
	        if (!Object.prototype.hasOwnProperty.call(object, prop)) {
	          return 'continue';
	        }
	
	        if (typeof object[prop] === 'function') {
	          // Can't use fat arrow here because of use of arguments below.
	          membrane[prop] = function () {
	            process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, message) : void 0;
	            return object[prop].apply(object, arguments);
	          };
	          return 'continue';
	        }
	
	        // These properties are non-enumerable to prevent React dev tools from
	        // seeing them and causing spurious warnings when accessing them. In
	        // principle this could be done with a proxy, but support for the
	        // ownKeys trap on proxies is not universal, even among browsers that
	        // otherwise support proxies.
	        Object.defineProperty(membrane, prop, {
	          get: function get() {
	            process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, message) : void 0;
	            return object[prop];
	          }
	        });
	      };
	
	      for (var prop in object) {
	        var _ret = _loop(prop);
	
	        if (_ret === 'continue') continue;
	      }
	
	      return membrane;
	    };
	  }
	}
	
	exports.default = deprecateObjectProperties;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.default = routerWarning;
	exports._resetWarned = _resetWarned;
	
	var _warning = __webpack_require__(171);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var warned = {};
	
	function routerWarning(falseToWarn, message) {
	  // Only issue deprecation warnings once.
	  if (message.indexOf('deprecated') !== -1) {
	    if (warned[message]) {
	      return;
	    }
	
	    warned[message] = true;
	  }
	
	  message = '[react-router] ' + message;
	
	  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	    args[_key - 2] = arguments[_key];
	  }
	
	  _warning2.default.apply(undefined, [falseToWarn, message].concat(args));
	}
	
	function _resetWarned() {
	  warned = {};
	}

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = function warning() {};
	
	if (process.env.NODE_ENV !== 'production') {
	  warning = function warning(condition, format, args) {
	    var len = arguments.length;
	    args = new Array(len > 2 ? len - 2 : 0);
	    for (var key = 2; key < len; key++) {
	      args[key - 2] = arguments[key];
	    }
	    if (format === undefined) {
	      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	    }
	
	    if (format.length < 10 || /^[s\W]*$/.test(format)) {
	      throw new Error('The warning format should be able to uniquely identify this ' + 'warning. Please, use a more descriptive format than: ' + format);
	    }
	
	    if (!condition) {
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    }
	  };
	}
	
	module.exports = warning;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.routes = exports.route = exports.components = exports.component = exports.history = undefined;
	exports.falsy = falsy;
	
	var _react = __webpack_require__(8);
	
	var func = _react.PropTypes.func;
	var object = _react.PropTypes.object;
	var arrayOf = _react.PropTypes.arrayOf;
	var oneOfType = _react.PropTypes.oneOfType;
	var element = _react.PropTypes.element;
	var shape = _react.PropTypes.shape;
	var string = _react.PropTypes.string;
	function falsy(props, propName, componentName) {
	  if (props[propName]) return new Error('<' + componentName + '> should not have a "' + propName + '" prop');
	}
	
	var history = exports.history = shape({
	  listen: func.isRequired,
	  push: func.isRequired,
	  replace: func.isRequired,
	  go: func.isRequired,
	  goBack: func.isRequired,
	  goForward: func.isRequired
	});
	
	var component = exports.component = oneOfType([func, string]);
	var components = exports.components = oneOfType([component, object]);
	var route = exports.route = oneOfType([object, element]);
	var routes = exports.routes = oneOfType([route, arrayOf(route)]);

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.compilePattern = compilePattern;
	exports.matchPattern = matchPattern;
	exports.getParamNames = getParamNames;
	exports.getParams = getParams;
	exports.formatPattern = formatPattern;
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function escapeRegExp(string) {
	  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
	}
	
	function _compilePattern(pattern) {
	  var regexpSource = '';
	  var paramNames = [];
	  var tokens = [];
	
	  var match = void 0,
	      lastIndex = 0,
	      matcher = /:([a-zA-Z_$][a-zA-Z0-9_$]*)|\*\*|\*|\(|\)/g;
	  while (match = matcher.exec(pattern)) {
	    if (match.index !== lastIndex) {
	      tokens.push(pattern.slice(lastIndex, match.index));
	      regexpSource += escapeRegExp(pattern.slice(lastIndex, match.index));
	    }
	
	    if (match[1]) {
	      regexpSource += '([^/]+)';
	      paramNames.push(match[1]);
	    } else if (match[0] === '**') {
	      regexpSource += '(.*)';
	      paramNames.push('splat');
	    } else if (match[0] === '*') {
	      regexpSource += '(.*?)';
	      paramNames.push('splat');
	    } else if (match[0] === '(') {
	      regexpSource += '(?:';
	    } else if (match[0] === ')') {
	      regexpSource += ')?';
	    }
	
	    tokens.push(match[0]);
	
	    lastIndex = matcher.lastIndex;
	  }
	
	  if (lastIndex !== pattern.length) {
	    tokens.push(pattern.slice(lastIndex, pattern.length));
	    regexpSource += escapeRegExp(pattern.slice(lastIndex, pattern.length));
	  }
	
	  return {
	    pattern: pattern,
	    regexpSource: regexpSource,
	    paramNames: paramNames,
	    tokens: tokens
	  };
	}
	
	var CompiledPatternsCache = Object.create(null);
	
	function compilePattern(pattern) {
	  if (!CompiledPatternsCache[pattern]) CompiledPatternsCache[pattern] = _compilePattern(pattern);
	
	  return CompiledPatternsCache[pattern];
	}
	
	/**
	 * Attempts to match a pattern on the given pathname. Patterns may use
	 * the following special characters:
	 *
	 * - :paramName     Matches a URL segment up to the next /, ?, or #. The
	 *                  captured string is considered a "param"
	 * - ()             Wraps a segment of the URL that is optional
	 * - *              Consumes (non-greedy) all characters up to the next
	 *                  character in the pattern, or to the end of the URL if
	 *                  there is none
	 * - **             Consumes (greedy) all characters up to the next character
	 *                  in the pattern, or to the end of the URL if there is none
	 *
	 *  The function calls callback(error, matched) when finished.
	 * The return value is an object with the following properties:
	 *
	 * - remainingPathname
	 * - paramNames
	 * - paramValues
	 */
	function matchPattern(pattern, pathname) {
	  // Ensure pattern starts with leading slash for consistency with pathname.
	  if (pattern.charAt(0) !== '/') {
	    pattern = '/' + pattern;
	  }
	
	  var _compilePattern2 = compilePattern(pattern);
	
	  var regexpSource = _compilePattern2.regexpSource;
	  var paramNames = _compilePattern2.paramNames;
	  var tokens = _compilePattern2.tokens;
	
	  if (pattern.charAt(pattern.length - 1) !== '/') {
	    regexpSource += '/?'; // Allow optional path separator at end.
	  }
	
	  // Special-case patterns like '*' for catch-all routes.
	  if (tokens[tokens.length - 1] === '*') {
	    regexpSource += '$';
	  }
	
	  var match = pathname.match(new RegExp('^' + regexpSource, 'i'));
	  if (match == null) {
	    return null;
	  }
	
	  var matchedPath = match[0];
	  var remainingPathname = pathname.substr(matchedPath.length);
	
	  if (remainingPathname) {
	    // Require that the match ends at a path separator, if we didn't match
	    // the full path, so any remaining pathname is a new path segment.
	    if (matchedPath.charAt(matchedPath.length - 1) !== '/') {
	      return null;
	    }
	
	    // If there is a remaining pathname, treat the path separator as part of
	    // the remaining pathname for properly continuing the match.
	    remainingPathname = '/' + remainingPathname;
	  }
	
	  return {
	    remainingPathname: remainingPathname,
	    paramNames: paramNames,
	    paramValues: match.slice(1).map(function (v) {
	      return v && decodeURIComponent(v);
	    })
	  };
	}
	
	function getParamNames(pattern) {
	  return compilePattern(pattern).paramNames;
	}
	
	function getParams(pattern, pathname) {
	  var match = matchPattern(pattern, pathname);
	  if (!match) {
	    return null;
	  }
	
	  var paramNames = match.paramNames;
	  var paramValues = match.paramValues;
	
	  var params = {};
	
	  paramNames.forEach(function (paramName, index) {
	    params[paramName] = paramValues[index];
	  });
	
	  return params;
	}
	
	/**
	 * Returns a version of the given pattern with params interpolated. Throws
	 * if there is a dynamic segment of the pattern for which there is no param.
	 */
	function formatPattern(pattern, params) {
	  params = params || {};
	
	  var _compilePattern3 = compilePattern(pattern);
	
	  var tokens = _compilePattern3.tokens;
	
	  var parenCount = 0,
	      pathname = '',
	      splatIndex = 0;
	
	  var token = void 0,
	      paramName = void 0,
	      paramValue = void 0;
	  for (var i = 0, len = tokens.length; i < len; ++i) {
	    token = tokens[i];
	
	    if (token === '*' || token === '**') {
	      paramValue = Array.isArray(params.splat) ? params.splat[splatIndex++] : params.splat;
	
	      !(paramValue != null || parenCount > 0) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Missing splat #%s for path "%s"', splatIndex, pattern) : (0, _invariant2.default)(false) : void 0;
	
	      if (paramValue != null) pathname += encodeURI(paramValue);
	    } else if (token === '(') {
	      parenCount += 1;
	    } else if (token === ')') {
	      parenCount -= 1;
	    } else if (token.charAt(0) === ':') {
	      paramName = token.substring(1);
	      paramValue = params[paramName];
	
	      !(paramValue != null || parenCount > 0) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Missing "%s" parameter for path "%s"', paramName, pattern) : (0, _invariant2.default)(false) : void 0;
	
	      if (paramValue != null) pathname += encodeURIComponent(paramValue);
	    } else {
	      pathname += token;
	    }
	  }
	
	  return pathname.replace(/\/+/g, '/');
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	var invariant = function invariant(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};
	
	module.exports = invariant;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _createHashHistory = __webpack_require__(176);
	
	var _createHashHistory2 = _interopRequireDefault(_createHashHistory);
	
	var _useQueries = __webpack_require__(192);
	
	var _useQueries2 = _interopRequireDefault(_useQueries);
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _createTransitionManager = __webpack_require__(195);
	
	var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);
	
	var _InternalPropTypes = __webpack_require__(172);
	
	var _RouterContext = __webpack_require__(203);
	
	var _RouterContext2 = _interopRequireDefault(_RouterContext);
	
	var _RouteUtils = __webpack_require__(167);
	
	var _RouterUtils = __webpack_require__(205);
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	  var target = {};for (var i in obj) {
	    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	  }return target;
	}
	
	function isDeprecatedHistory(history) {
	  return !history || !history.__v2_compatible__;
	}
	
	/* istanbul ignore next: sanity check */
	function isUnsupportedHistory(history) {
	  // v3 histories expose getCurrentLocation, but aren't currently supported.
	  return history && history.getCurrentLocation;
	}
	
	var _React$PropTypes = _react2.default.PropTypes;
	var func = _React$PropTypes.func;
	var object = _React$PropTypes.object;
	
	/**
	 * A <Router> is a high-level API for automatically setting up
	 * a router that renders a <RouterContext> with all the props
	 * it needs each time the URL changes.
	 */
	
	var Router = _react2.default.createClass({
	  displayName: 'Router',
	
	  propTypes: {
	    history: object,
	    children: _InternalPropTypes.routes,
	    routes: _InternalPropTypes.routes, // alias for children
	    render: func,
	    createElement: func,
	    onError: func,
	    onUpdate: func,
	
	    // Deprecated:
	    parseQueryString: func,
	    stringifyQuery: func,
	
	    // PRIVATE: For client-side rehydration of server match.
	    matchContext: object
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      render: function render(props) {
	        return _react2.default.createElement(_RouterContext2.default, props);
	      }
	    };
	  },
	  getInitialState: function getInitialState() {
	    return {
	      location: null,
	      routes: null,
	      params: null,
	      components: null
	    };
	  },
	  handleError: function handleError(error) {
	    if (this.props.onError) {
	      this.props.onError.call(this, error);
	    } else {
	      // Throw errors by default so we don't silently swallow them!
	      throw error; // This error probably occurred in getChildRoutes or getComponents.
	    }
	  },
	  componentWillMount: function componentWillMount() {
	    var _this = this;
	
	    var _props = this.props;
	    var parseQueryString = _props.parseQueryString;
	    var stringifyQuery = _props.stringifyQuery;
	
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(!(parseQueryString || stringifyQuery), '`parseQueryString` and `stringifyQuery` are deprecated. Please create a custom history. http://tiny.cc/router-customquerystring') : void 0;
	
	    var _createRouterObjects = this.createRouterObjects();
	
	    var history = _createRouterObjects.history;
	    var transitionManager = _createRouterObjects.transitionManager;
	    var router = _createRouterObjects.router;
	
	    this._unlisten = transitionManager.listen(function (error, state) {
	      if (error) {
	        _this.handleError(error);
	      } else {
	        _this.setState(state, _this.props.onUpdate);
	      }
	    });
	
	    this.history = history;
	    this.router = router;
	  },
	  createRouterObjects: function createRouterObjects() {
	    var matchContext = this.props.matchContext;
	
	    if (matchContext) {
	      return matchContext;
	    }
	
	    var history = this.props.history;
	    var _props2 = this.props;
	    var routes = _props2.routes;
	    var children = _props2.children;
	
	    !!isUnsupportedHistory(history) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'You have provided a history object created with history v3.x. ' + 'This version of React Router is not compatible with v3 history ' + 'objects. Please use history v2.x instead.') : (0, _invariant2.default)(false) : void 0;
	
	    if (isDeprecatedHistory(history)) {
	      history = this.wrapDeprecatedHistory(history);
	    }
	
	    var transitionManager = (0, _createTransitionManager2.default)(history, (0, _RouteUtils.createRoutes)(routes || children));
	    var router = (0, _RouterUtils.createRouterObject)(history, transitionManager);
	    var routingHistory = (0, _RouterUtils.createRoutingHistory)(history, transitionManager);
	
	    return { history: routingHistory, transitionManager: transitionManager, router: router };
	  },
	  wrapDeprecatedHistory: function wrapDeprecatedHistory(history) {
	    var _props3 = this.props;
	    var parseQueryString = _props3.parseQueryString;
	    var stringifyQuery = _props3.stringifyQuery;
	
	    var createHistory = void 0;
	    if (history) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'It appears you have provided a deprecated history object to `<Router/>`, please use a history provided by ' + 'React Router with `import { browserHistory } from \'react-router\'` or `import { hashHistory } from \'react-router\'`. ' + 'If you are using a custom history please create it with `useRouterHistory`, see http://tiny.cc/router-usinghistory for details.') : void 0;
	      createHistory = function createHistory() {
	        return history;
	      };
	    } else {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`Router` no longer defaults the history prop to hash history. Please use the `hashHistory` singleton instead. http://tiny.cc/router-defaulthistory') : void 0;
	      createHistory = _createHashHistory2.default;
	    }
	
	    return (0, _useQueries2.default)(createHistory)({ parseQueryString: parseQueryString, stringifyQuery: stringifyQuery });
	  },
	
	  /* istanbul ignore next: sanity check */
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(nextProps.history === this.props.history, 'You cannot change <Router history>; it will be ignored') : void 0;
	
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)((nextProps.routes || nextProps.children) === (this.props.routes || this.props.children), 'You cannot change <Router routes>; it will be ignored') : void 0;
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    if (this._unlisten) this._unlisten();
	  },
	  render: function render() {
	    var _state = this.state;
	    var location = _state.location;
	    var routes = _state.routes;
	    var params = _state.params;
	    var components = _state.components;
	    var _props4 = this.props;
	    var createElement = _props4.createElement;
	    var render = _props4.render;
	
	    var props = _objectWithoutProperties(_props4, ['createElement', 'render']);
	
	    if (location == null) return null; // Async match
	
	    // Only forward non-Router-specific props to routing context, as those are
	    // the only ones that might be custom routing context props.
	    Object.keys(Router.propTypes).forEach(function (propType) {
	      return delete props[propType];
	    });
	
	    return render(_extends({}, props, {
	      history: this.history,
	      router: this.router,
	      location: location,
	      routes: routes,
	      params: params,
	      components: components,
	      createElement: createElement
	    }));
	  }
	});
	
	exports.default = Router;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(177);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _Actions = __webpack_require__(178);
	
	var _PathUtils = __webpack_require__(179);
	
	var _ExecutionEnvironment = __webpack_require__(180);
	
	var _DOMUtils = __webpack_require__(181);
	
	var _DOMStateStorage = __webpack_require__(182);
	
	var _createDOMHistory = __webpack_require__(183);
	
	var _createDOMHistory2 = _interopRequireDefault(_createDOMHistory);
	
	function isAbsolutePath(path) {
	  return typeof path === 'string' && path.charAt(0) === '/';
	}
	
	function ensureSlash() {
	  var path = _DOMUtils.getHashPath();
	
	  if (isAbsolutePath(path)) return true;
	
	  _DOMUtils.replaceHashPath('/' + path);
	
	  return false;
	}
	
	function addQueryStringValueToPath(path, key, value) {
	  return path + (path.indexOf('?') === -1 ? '?' : '&') + (key + '=' + value);
	}
	
	function stripQueryStringValueFromPath(path, key) {
	  return path.replace(new RegExp('[?&]?' + key + '=[a-zA-Z0-9]+'), '');
	}
	
	function getQueryStringValueFromPath(path, key) {
	  var match = path.match(new RegExp('\\?.*?\\b' + key + '=(.+?)\\b'));
	  return match && match[1];
	}
	
	var DefaultQueryKey = '_k';
	
	function createHashHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Hash history needs a DOM') : _invariant2['default'](false) : undefined;
	
	  var queryKey = options.queryKey;
	
	  if (queryKey === undefined || !!queryKey) queryKey = typeof queryKey === 'string' ? queryKey : DefaultQueryKey;
	
	  function getCurrentLocation() {
	    var path = _DOMUtils.getHashPath();
	
	    var key = undefined,
	        state = undefined;
	    if (queryKey) {
	      key = getQueryStringValueFromPath(path, queryKey);
	      path = stripQueryStringValueFromPath(path, queryKey);
	
	      if (key) {
	        state = _DOMStateStorage.readState(key);
	      } else {
	        state = null;
	        key = history.createKey();
	        _DOMUtils.replaceHashPath(addQueryStringValueToPath(path, queryKey, key));
	      }
	    } else {
	      key = state = null;
	    }
	
	    var location = _PathUtils.parsePath(path);
	
	    return history.createLocation(_extends({}, location, { state: state }), undefined, key);
	  }
	
	  function startHashChangeListener(_ref) {
	    var transitionTo = _ref.transitionTo;
	
	    function hashChangeListener() {
	      if (!ensureSlash()) return; // Always make sure hashes are preceeded with a /.
	
	      transitionTo(getCurrentLocation());
	    }
	
	    ensureSlash();
	    _DOMUtils.addEventListener(window, 'hashchange', hashChangeListener);
	
	    return function () {
	      _DOMUtils.removeEventListener(window, 'hashchange', hashChangeListener);
	    };
	  }
	
	  function finishTransition(location) {
	    var basename = location.basename;
	    var pathname = location.pathname;
	    var search = location.search;
	    var state = location.state;
	    var action = location.action;
	    var key = location.key;
	
	    if (action === _Actions.POP) return; // Nothing to do.
	
	    var path = (basename || '') + pathname + search;
	
	    if (queryKey) {
	      path = addQueryStringValueToPath(path, queryKey, key);
	      _DOMStateStorage.saveState(key, state);
	    } else {
	      // Drop key and state.
	      location.key = location.state = null;
	    }
	
	    var currentHash = _DOMUtils.getHashPath();
	
	    if (action === _Actions.PUSH) {
	      if (currentHash !== path) {
	        window.location.hash = path;
	      } else {
	        process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'You cannot PUSH the same path using hash history') : undefined;
	      }
	    } else if (currentHash !== path) {
	      // REPLACE
	      _DOMUtils.replaceHashPath(path);
	    }
	  }
	
	  var history = _createDOMHistory2['default'](_extends({}, options, {
	    getCurrentLocation: getCurrentLocation,
	    finishTransition: finishTransition,
	    saveState: _DOMStateStorage.saveState
	  }));
	
	  var listenerCount = 0,
	      stopHashChangeListener = undefined;
	
	  function listenBefore(listener) {
	    if (++listenerCount === 1) stopHashChangeListener = startHashChangeListener(history);
	
	    var unlisten = history.listenBefore(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopHashChangeListener();
	    };
	  }
	
	  function listen(listener) {
	    if (++listenerCount === 1) stopHashChangeListener = startHashChangeListener(history);
	
	    var unlisten = history.listen(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopHashChangeListener();
	    };
	  }
	
	  function push(location) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || location.state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;
	
	    history.push(location);
	  }
	
	  function replace(location) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || location.state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;
	
	    history.replace(location);
	  }
	
	  var goIsSupportedWithoutReload = _DOMUtils.supportsGoWithoutReloadUsingHash();
	
	  function go(n) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](goIsSupportedWithoutReload, 'Hash history go(n) causes a full page reload in this browser') : undefined;
	
	    history.go(n);
	  }
	
	  function createHref(path) {
	    return '#' + history.createHref(path);
	  }
	
	  // deprecated
	  function registerTransitionHook(hook) {
	    if (++listenerCount === 1) stopHashChangeListener = startHashChangeListener(history);
	
	    history.registerTransitionHook(hook);
	  }
	
	  // deprecated
	  function unregisterTransitionHook(hook) {
	    history.unregisterTransitionHook(hook);
	
	    if (--listenerCount === 0) stopHashChangeListener();
	  }
	
	  // deprecated
	  function pushState(state, path) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;
	
	    history.pushState(state, path);
	  }
	
	  // deprecated
	  function replaceState(state, path) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;
	
	    history.replaceState(state, path);
	  }
	
	  return _extends({}, history, {
	    listenBefore: listenBefore,
	    listen: listen,
	    push: push,
	    replace: replace,
	    go: go,
	    createHref: createHref,
	
	    registerTransitionHook: registerTransitionHook, // deprecated - warning is in createHistory
	    unregisterTransitionHook: unregisterTransitionHook, // deprecated - warning is in createHistory
	    pushState: pushState, // deprecated - warning is in createHistory
	    replaceState: replaceState // deprecated - warning is in createHistory
	  });
	}
	
	exports['default'] = createHashHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = function warning() {};
	
	if (process.env.NODE_ENV !== 'production') {
	  warning = function warning(condition, format, args) {
	    var len = arguments.length;
	    args = new Array(len > 2 ? len - 2 : 0);
	    for (var key = 2; key < len; key++) {
	      args[key - 2] = arguments[key];
	    }
	    if (format === undefined) {
	      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	    }
	
	    if (format.length < 10 || /^[s\W]*$/.test(format)) {
	      throw new Error('The warning format should be able to uniquely identify this ' + 'warning. Please, use a more descriptive format than: ' + format);
	    }
	
	    if (!condition) {
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    }
	  };
	}
	
	module.exports = warning;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 178 */
/***/ function(module, exports) {

	/**
	 * Indicates that navigation was caused by a call to history.push.
	 */
	'use strict';
	
	exports.__esModule = true;
	var PUSH = 'PUSH';
	
	exports.PUSH = PUSH;
	/**
	 * Indicates that navigation was caused by a call to history.replace.
	 */
	var REPLACE = 'REPLACE';
	
	exports.REPLACE = REPLACE;
	/**
	 * Indicates that navigation was caused by some other action such
	 * as using a browser's back/forward buttons and/or manually manipulating
	 * the URL in a browser's location bar. This is the default.
	 *
	 * See https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate
	 * for more information.
	 */
	var POP = 'POP';
	
	exports.POP = POP;
	exports['default'] = {
	  PUSH: PUSH,
	  REPLACE: REPLACE,
	  POP: POP
	};

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.extractPath = extractPath;
	exports.parsePath = parsePath;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(177);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function extractPath(string) {
	  var match = string.match(/^https?:\/\/[^\/]*/);
	
	  if (match == null) return string;
	
	  return string.substring(match[0].length);
	}
	
	function parsePath(path) {
	  var pathname = extractPath(path);
	  var search = '';
	  var hash = '';
	
	  process.env.NODE_ENV !== 'production' ? _warning2['default'](path === pathname, 'A path must be pathname + search + hash only, not a fully qualified URL like "%s"', path) : undefined;
	
	  var hashIndex = pathname.indexOf('#');
	  if (hashIndex !== -1) {
	    hash = pathname.substring(hashIndex);
	    pathname = pathname.substring(0, hashIndex);
	  }
	
	  var searchIndex = pathname.indexOf('?');
	  if (searchIndex !== -1) {
	    search = pathname.substring(searchIndex);
	    pathname = pathname.substring(0, searchIndex);
	  }
	
	  if (pathname === '') pathname = '/';
	
	  return {
	    pathname: pathname,
	    search: search,
	    hash: hash
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 180 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	exports.canUseDOM = canUseDOM;

/***/ },
/* 181 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports.addEventListener = addEventListener;
	exports.removeEventListener = removeEventListener;
	exports.getHashPath = getHashPath;
	exports.replaceHashPath = replaceHashPath;
	exports.getWindowPath = getWindowPath;
	exports.go = go;
	exports.getUserConfirmation = getUserConfirmation;
	exports.supportsHistory = supportsHistory;
	exports.supportsGoWithoutReloadUsingHash = supportsGoWithoutReloadUsingHash;
	
	function addEventListener(node, event, listener) {
	  if (node.addEventListener) {
	    node.addEventListener(event, listener, false);
	  } else {
	    node.attachEvent('on' + event, listener);
	  }
	}
	
	function removeEventListener(node, event, listener) {
	  if (node.removeEventListener) {
	    node.removeEventListener(event, listener, false);
	  } else {
	    node.detachEvent('on' + event, listener);
	  }
	}
	
	function getHashPath() {
	  // We can't use window.location.hash here because it's not
	  // consistent across browsers - Firefox will pre-decode it!
	  return window.location.href.split('#')[1] || '';
	}
	
	function replaceHashPath(path) {
	  window.location.replace(window.location.pathname + window.location.search + '#' + path);
	}
	
	function getWindowPath() {
	  return window.location.pathname + window.location.search + window.location.hash;
	}
	
	function go(n) {
	  if (n) window.history.go(n);
	}
	
	function getUserConfirmation(message, callback) {
	  callback(window.confirm(message));
	}
	
	/**
	 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
	 *
	 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
	 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
	 * changed to avoid false negatives for Windows Phones: https://github.com/rackt/react-router/issues/586
	 */
	
	function supportsHistory() {
	  var ua = navigator.userAgent;
	  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) {
	    return false;
	  }
	  return window.history && 'pushState' in window.history;
	}
	
	/**
	 * Returns false if using go(n) with hash history causes a full page reload.
	 */
	
	function supportsGoWithoutReloadUsingHash() {
	  var ua = navigator.userAgent;
	  return ua.indexOf('Firefox') === -1;
	}

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/*eslint-disable no-empty */
	'use strict';
	
	exports.__esModule = true;
	exports.saveState = saveState;
	exports.readState = readState;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(177);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var KeyPrefix = '@@History/';
	var QuotaExceededErrors = ['QuotaExceededError', 'QUOTA_EXCEEDED_ERR'];
	
	var SecurityError = 'SecurityError';
	
	function createKey(key) {
	  return KeyPrefix + key;
	}
	
	function saveState(key, state) {
	  try {
	    if (state == null) {
	      window.sessionStorage.removeItem(createKey(key));
	    } else {
	      window.sessionStorage.setItem(createKey(key), JSON.stringify(state));
	    }
	  } catch (error) {
	    if (error.name === SecurityError) {
	      // Blocking cookies in Chrome/Firefox/Safari throws SecurityError on any
	      // attempt to access window.sessionStorage.
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] Unable to save state; sessionStorage is not available due to security settings') : undefined;
	
	      return;
	    }
	
	    if (QuotaExceededErrors.indexOf(error.name) >= 0 && window.sessionStorage.length === 0) {
	      // Safari "private mode" throws QuotaExceededError.
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] Unable to save state; sessionStorage is not available in Safari private mode') : undefined;
	
	      return;
	    }
	
	    throw error;
	  }
	}
	
	function readState(key) {
	  var json = undefined;
	  try {
	    json = window.sessionStorage.getItem(createKey(key));
	  } catch (error) {
	    if (error.name === SecurityError) {
	      // Blocking cookies in Chrome/Firefox/Safari throws SecurityError on any
	      // attempt to access window.sessionStorage.
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] Unable to read state; sessionStorage is not available due to security settings') : undefined;
	
	      return null;
	    }
	  }
	
	  if (json) {
	    try {
	      return JSON.parse(json);
	    } catch (error) {
	      // Ignore invalid JSON.
	    }
	  }
	
	  return null;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _ExecutionEnvironment = __webpack_require__(180);
	
	var _DOMUtils = __webpack_require__(181);
	
	var _createHistory = __webpack_require__(184);
	
	var _createHistory2 = _interopRequireDefault(_createHistory);
	
	function createDOMHistory(options) {
	  var history = _createHistory2['default'](_extends({
	    getUserConfirmation: _DOMUtils.getUserConfirmation
	  }, options, {
	    go: _DOMUtils.go
	  }));
	
	  function listen(listener) {
	    !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'DOM history needs a DOM') : _invariant2['default'](false) : undefined;
	
	    return history.listen(listener);
	  }
	
	  return _extends({}, history, {
	    listen: listen
	  });
	}
	
	exports['default'] = createDOMHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(177);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _deepEqual = __webpack_require__(185);
	
	var _deepEqual2 = _interopRequireDefault(_deepEqual);
	
	var _PathUtils = __webpack_require__(179);
	
	var _AsyncUtils = __webpack_require__(188);
	
	var _Actions = __webpack_require__(178);
	
	var _createLocation2 = __webpack_require__(189);
	
	var _createLocation3 = _interopRequireDefault(_createLocation2);
	
	var _runTransitionHook = __webpack_require__(190);
	
	var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);
	
	var _deprecate = __webpack_require__(191);
	
	var _deprecate2 = _interopRequireDefault(_deprecate);
	
	function createRandomKey(length) {
	  return Math.random().toString(36).substr(2, length);
	}
	
	function locationsAreEqual(a, b) {
	  return a.pathname === b.pathname && a.search === b.search &&
	  //a.action === b.action && // Different action !== location change.
	  a.key === b.key && _deepEqual2['default'](a.state, b.state);
	}
	
	var DefaultKeyLength = 6;
	
	function createHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	  var getCurrentLocation = options.getCurrentLocation;
	  var finishTransition = options.finishTransition;
	  var saveState = options.saveState;
	  var go = options.go;
	  var getUserConfirmation = options.getUserConfirmation;
	  var keyLength = options.keyLength;
	
	  if (typeof keyLength !== 'number') keyLength = DefaultKeyLength;
	
	  var transitionHooks = [];
	
	  function listenBefore(hook) {
	    transitionHooks.push(hook);
	
	    return function () {
	      transitionHooks = transitionHooks.filter(function (item) {
	        return item !== hook;
	      });
	    };
	  }
	
	  var allKeys = [];
	  var changeListeners = [];
	  var location = undefined;
	
	  function getCurrent() {
	    if (pendingLocation && pendingLocation.action === _Actions.POP) {
	      return allKeys.indexOf(pendingLocation.key);
	    } else if (location) {
	      return allKeys.indexOf(location.key);
	    } else {
	      return -1;
	    }
	  }
	
	  function updateLocation(newLocation) {
	    var current = getCurrent();
	
	    location = newLocation;
	
	    if (location.action === _Actions.PUSH) {
	      allKeys = [].concat(allKeys.slice(0, current + 1), [location.key]);
	    } else if (location.action === _Actions.REPLACE) {
	      allKeys[current] = location.key;
	    }
	
	    changeListeners.forEach(function (listener) {
	      listener(location);
	    });
	  }
	
	  function listen(listener) {
	    changeListeners.push(listener);
	
	    if (location) {
	      listener(location);
	    } else {
	      var _location = getCurrentLocation();
	      allKeys = [_location.key];
	      updateLocation(_location);
	    }
	
	    return function () {
	      changeListeners = changeListeners.filter(function (item) {
	        return item !== listener;
	      });
	    };
	  }
	
	  function confirmTransitionTo(location, callback) {
	    _AsyncUtils.loopAsync(transitionHooks.length, function (index, next, done) {
	      _runTransitionHook2['default'](transitionHooks[index], location, function (result) {
	        if (result != null) {
	          done(result);
	        } else {
	          next();
	        }
	      });
	    }, function (message) {
	      if (getUserConfirmation && typeof message === 'string') {
	        getUserConfirmation(message, function (ok) {
	          callback(ok !== false);
	        });
	      } else {
	        callback(message !== false);
	      }
	    });
	  }
	
	  var pendingLocation = undefined;
	
	  function transitionTo(nextLocation) {
	    if (location && locationsAreEqual(location, nextLocation)) return; // Nothing to do.
	
	    pendingLocation = nextLocation;
	
	    confirmTransitionTo(nextLocation, function (ok) {
	      if (pendingLocation !== nextLocation) return; // Transition was interrupted.
	
	      if (ok) {
	        // treat PUSH to current path like REPLACE to be consistent with browsers
	        if (nextLocation.action === _Actions.PUSH) {
	          var prevPath = createPath(location);
	          var nextPath = createPath(nextLocation);
	
	          if (nextPath === prevPath && _deepEqual2['default'](location.state, nextLocation.state)) nextLocation.action = _Actions.REPLACE;
	        }
	
	        if (finishTransition(nextLocation) !== false) updateLocation(nextLocation);
	      } else if (location && nextLocation.action === _Actions.POP) {
	        var prevIndex = allKeys.indexOf(location.key);
	        var nextIndex = allKeys.indexOf(nextLocation.key);
	
	        if (prevIndex !== -1 && nextIndex !== -1) go(prevIndex - nextIndex); // Restore the URL.
	      }
	    });
	  }
	
	  function push(location) {
	    transitionTo(createLocation(location, _Actions.PUSH, createKey()));
	  }
	
	  function replace(location) {
	    transitionTo(createLocation(location, _Actions.REPLACE, createKey()));
	  }
	
	  function goBack() {
	    go(-1);
	  }
	
	  function goForward() {
	    go(1);
	  }
	
	  function createKey() {
	    return createRandomKey(keyLength);
	  }
	
	  function createPath(location) {
	    if (location == null || typeof location === 'string') return location;
	
	    var pathname = location.pathname;
	    var search = location.search;
	    var hash = location.hash;
	
	    var result = pathname;
	
	    if (search) result += search;
	
	    if (hash) result += hash;
	
	    return result;
	  }
	
	  function createHref(location) {
	    return createPath(location);
	  }
	
	  function createLocation(location, action) {
	    var key = arguments.length <= 2 || arguments[2] === undefined ? createKey() : arguments[2];
	
	    if ((typeof action === 'undefined' ? 'undefined' : _typeof(action)) === 'object') {
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'The state (2nd) argument to history.createLocation is deprecated; use a ' + 'location descriptor instead') : undefined;
	
	      if (typeof location === 'string') location = _PathUtils.parsePath(location);
	
	      location = _extends({}, location, { state: action });
	
	      action = key;
	      key = arguments[3] || createKey();
	    }
	
	    return _createLocation3['default'](location, action, key);
	  }
	
	  // deprecated
	  function setState(state) {
	    if (location) {
	      updateLocationState(location, state);
	      updateLocation(location);
	    } else {
	      updateLocationState(getCurrentLocation(), state);
	    }
	  }
	
	  function updateLocationState(location, state) {
	    location.state = _extends({}, location.state, state);
	    saveState(location.key, location.state);
	  }
	
	  // deprecated
	  function registerTransitionHook(hook) {
	    if (transitionHooks.indexOf(hook) === -1) transitionHooks.push(hook);
	  }
	
	  // deprecated
	  function unregisterTransitionHook(hook) {
	    transitionHooks = transitionHooks.filter(function (item) {
	      return item !== hook;
	    });
	  }
	
	  // deprecated
	  function pushState(state, path) {
	    if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	    push(_extends({ state: state }, path));
	  }
	
	  // deprecated
	  function replaceState(state, path) {
	    if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	    replace(_extends({ state: state }, path));
	  }
	
	  return {
	    listenBefore: listenBefore,
	    listen: listen,
	    transitionTo: transitionTo,
	    push: push,
	    replace: replace,
	    go: go,
	    goBack: goBack,
	    goForward: goForward,
	    createKey: createKey,
	    createPath: createPath,
	    createHref: createHref,
	    createLocation: createLocation,
	
	    setState: _deprecate2['default'](setState, 'setState is deprecated; use location.key to save state instead'),
	    registerTransitionHook: _deprecate2['default'](registerTransitionHook, 'registerTransitionHook is deprecated; use listenBefore instead'),
	    unregisterTransitionHook: _deprecate2['default'](unregisterTransitionHook, 'unregisterTransitionHook is deprecated; use the callback returned from listenBefore instead'),
	    pushState: _deprecate2['default'](pushState, 'pushState is deprecated; use push instead'),
	    replaceState: _deprecate2['default'](replaceState, 'replaceState is deprecated; use replace instead')
	  };
	}
	
	exports['default'] = createHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var pSlice = Array.prototype.slice;
	var objectKeys = __webpack_require__(186);
	var isArguments = __webpack_require__(187);
	
	var deepEqual = module.exports = function (actual, expected, opts) {
	  if (!opts) opts = {};
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;
	  } else if (actual instanceof Date && expected instanceof Date) {
	    return actual.getTime() === expected.getTime();
	
	    // 7.3. Other pairs that do not both pass typeof value == 'object',
	    // equivalence is determined by ==.
	  } else if (!actual || !expected || (typeof actual === 'undefined' ? 'undefined' : _typeof(actual)) != 'object' && (typeof expected === 'undefined' ? 'undefined' : _typeof(expected)) != 'object') {
	    return opts.strict ? actual === expected : actual == expected;
	
	    // 7.4. For all other Object pairs, including Array objects, equivalence is
	    // determined by having the same number of owned properties (as verified
	    // with Object.prototype.hasOwnProperty.call), the same set of keys
	    // (although not necessarily the same order), equivalent values for every
	    // corresponding key, and an identical 'prototype' property. Note: this
	    // accounts for both named and indexed properties on Arrays.
	  } else {
	    return objEquiv(actual, expected, opts);
	  }
	};
	
	function isUndefinedOrNull(value) {
	  return value === null || value === undefined;
	}
	
	function isBuffer(x) {
	  if (!x || (typeof x === 'undefined' ? 'undefined' : _typeof(x)) !== 'object' || typeof x.length !== 'number') return false;
	  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
	    return false;
	  }
	  if (x.length > 0 && typeof x[0] !== 'number') return false;
	  return true;
	}
	
	function objEquiv(a, b, opts) {
	  var i, key;
	  if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) return false;
	  // an identical 'prototype' property.
	  if (a.prototype !== b.prototype) return false;
	  //~~~I've managed to break Object.keys through screwy arguments passing.
	  //   Converting to array solves the problem.
	  if (isArguments(a)) {
	    if (!isArguments(b)) {
	      return false;
	    }
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return deepEqual(a, b, opts);
	  }
	  if (isBuffer(a)) {
	    if (!isBuffer(b)) {
	      return false;
	    }
	    if (a.length !== b.length) return false;
	    for (i = 0; i < a.length; i++) {
	      if (a[i] !== b[i]) return false;
	    }
	    return true;
	  }
	  try {
	    var ka = objectKeys(a),
	        kb = objectKeys(b);
	  } catch (e) {
	    //happens when one is a string literal and the other isn't
	    return false;
	  }
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length != kb.length) return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] != kb[i]) return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!deepEqual(a[key], b[key], opts)) return false;
	  }
	  return (typeof a === 'undefined' ? 'undefined' : _typeof(a)) === (typeof b === 'undefined' ? 'undefined' : _typeof(b));
	}

/***/ },
/* 186 */
/***/ function(module, exports) {

	'use strict';
	
	exports = module.exports = typeof Object.keys === 'function' ? Object.keys : shim;
	
	exports.shim = shim;
	function shim(obj) {
	  var keys = [];
	  for (var key in obj) {
	    keys.push(key);
	  }return keys;
	}

/***/ },
/* 187 */
/***/ function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var supportsArgumentsClass = function () {
	  return Object.prototype.toString.call(arguments);
	}() == '[object Arguments]';
	
	exports = module.exports = supportsArgumentsClass ? supported : unsupported;
	
	exports.supported = supported;
	function supported(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	};
	
	exports.unsupported = unsupported;
	function unsupported(object) {
	  return object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) == 'object' && typeof object.length == 'number' && Object.prototype.hasOwnProperty.call(object, 'callee') && !Object.prototype.propertyIsEnumerable.call(object, 'callee') || false;
	};

/***/ },
/* 188 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	var _slice = Array.prototype.slice;
	exports.loopAsync = loopAsync;
	
	function loopAsync(turns, work, callback) {
	  var currentTurn = 0,
	      isDone = false;
	  var sync = false,
	      hasNext = false,
	      doneArgs = undefined;
	
	  function done() {
	    isDone = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      doneArgs = [].concat(_slice.call(arguments));
	      return;
	    }
	
	    callback.apply(this, arguments);
	  }
	
	  function next() {
	    if (isDone) {
	      return;
	    }
	
	    hasNext = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      return;
	    }
	
	    sync = true;
	
	    while (!isDone && currentTurn < turns && hasNext) {
	      hasNext = false;
	      work.call(this, currentTurn++, next, done);
	    }
	
	    sync = false;
	
	    if (isDone) {
	      // This means the loop finished synchronously.
	      callback.apply(this, doneArgs);
	      return;
	    }
	
	    if (currentTurn >= turns && hasNext) {
	      isDone = true;
	      callback();
	    }
	  }
	
	  next();
	}

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(177);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _Actions = __webpack_require__(178);
	
	var _PathUtils = __webpack_require__(179);
	
	function createLocation() {
	  var location = arguments.length <= 0 || arguments[0] === undefined ? '/' : arguments[0];
	  var action = arguments.length <= 1 || arguments[1] === undefined ? _Actions.POP : arguments[1];
	  var key = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	
	  var _fourthArg = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];
	
	  if (typeof location === 'string') location = _PathUtils.parsePath(location);
	
	  if ((typeof action === 'undefined' ? 'undefined' : _typeof(action)) === 'object') {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'The state (2nd) argument to createLocation is deprecated; use a ' + 'location descriptor instead') : undefined;
	
	    location = _extends({}, location, { state: action });
	
	    action = key || _Actions.POP;
	    key = _fourthArg;
	  }
	
	  var pathname = location.pathname || '/';
	  var search = location.search || '';
	  var hash = location.hash || '';
	  var state = location.state || null;
	
	  return {
	    pathname: pathname,
	    search: search,
	    hash: hash,
	    state: state,
	    action: action,
	    key: key
	  };
	}
	
	exports['default'] = createLocation;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(177);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function runTransitionHook(hook, location, callback) {
	  var result = hook(location, callback);
	
	  if (hook.length < 2) {
	    // Assume the hook runs synchronously and automatically
	    // call the callback with the return value.
	    callback(result);
	  } else {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](result === undefined, 'You should not "return" in a transition hook with a callback argument; call the callback instead') : undefined;
	  }
	}
	
	exports['default'] = runTransitionHook;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(177);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function deprecate(fn, message) {
	  return function () {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] ' + message) : undefined;
	    return fn.apply(this, arguments);
	  };
	}
	
	exports['default'] = deprecate;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(177);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _queryString = __webpack_require__(193);
	
	var _runTransitionHook = __webpack_require__(190);
	
	var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);
	
	var _PathUtils = __webpack_require__(179);
	
	var _deprecate = __webpack_require__(191);
	
	var _deprecate2 = _interopRequireDefault(_deprecate);
	
	var SEARCH_BASE_KEY = '$searchBase';
	
	function defaultStringifyQuery(query) {
	  return _queryString.stringify(query).replace(/%20/g, '+');
	}
	
	var defaultParseQueryString = _queryString.parse;
	
	function isNestedObject(object) {
	  for (var p in object) {
	    if (Object.prototype.hasOwnProperty.call(object, p) && _typeof(object[p]) === 'object' && !Array.isArray(object[p]) && object[p] !== null) return true;
	  }return false;
	}
	
	/**
	 * Returns a new createHistory function that may be used to create
	 * history objects that know how to handle URL queries.
	 */
	function useQueries(createHistory) {
	  return function () {
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    var history = createHistory(options);
	
	    var stringifyQuery = options.stringifyQuery;
	    var parseQueryString = options.parseQueryString;
	
	    if (typeof stringifyQuery !== 'function') stringifyQuery = defaultStringifyQuery;
	
	    if (typeof parseQueryString !== 'function') parseQueryString = defaultParseQueryString;
	
	    function addQuery(location) {
	      if (location.query == null) {
	        var search = location.search;
	
	        location.query = parseQueryString(search.substring(1));
	        location[SEARCH_BASE_KEY] = { search: search, searchBase: '' };
	      }
	
	      // TODO: Instead of all the book-keeping here, this should just strip the
	      // stringified query from the search.
	
	      return location;
	    }
	
	    function appendQuery(location, query) {
	      var _extends2;
	
	      var searchBaseSpec = location[SEARCH_BASE_KEY];
	      var queryString = query ? stringifyQuery(query) : '';
	      if (!searchBaseSpec && !queryString) {
	        return location;
	      }
	
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](stringifyQuery !== defaultStringifyQuery || !isNestedObject(query), 'useQueries does not stringify nested query objects by default; ' + 'use a custom stringifyQuery function') : undefined;
	
	      if (typeof location === 'string') location = _PathUtils.parsePath(location);
	
	      var searchBase = undefined;
	      if (searchBaseSpec && location.search === searchBaseSpec.search) {
	        searchBase = searchBaseSpec.searchBase;
	      } else {
	        searchBase = location.search || '';
	      }
	
	      var search = searchBase;
	      if (queryString) {
	        search += (search ? '&' : '?') + queryString;
	      }
	
	      return _extends({}, location, (_extends2 = {
	        search: search
	      }, _extends2[SEARCH_BASE_KEY] = { search: search, searchBase: searchBase }, _extends2));
	    }
	
	    // Override all read methods with query-aware versions.
	    function listenBefore(hook) {
	      return history.listenBefore(function (location, callback) {
	        _runTransitionHook2['default'](hook, addQuery(location), callback);
	      });
	    }
	
	    function listen(listener) {
	      return history.listen(function (location) {
	        listener(addQuery(location));
	      });
	    }
	
	    // Override all write methods with query-aware versions.
	    function push(location) {
	      history.push(appendQuery(location, location.query));
	    }
	
	    function replace(location) {
	      history.replace(appendQuery(location, location.query));
	    }
	
	    function createPath(location, query) {
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](!query, 'the query argument to createPath is deprecated; use a location descriptor instead') : undefined;
	
	      return history.createPath(appendQuery(location, query || location.query));
	    }
	
	    function createHref(location, query) {
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](!query, 'the query argument to createHref is deprecated; use a location descriptor instead') : undefined;
	
	      return history.createHref(appendQuery(location, query || location.query));
	    }
	
	    function createLocation(location) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      var fullLocation = history.createLocation.apply(history, [appendQuery(location, location.query)].concat(args));
	      if (location.query) {
	        fullLocation.query = location.query;
	      }
	      return addQuery(fullLocation);
	    }
	
	    // deprecated
	    function pushState(state, path, query) {
	      if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	      push(_extends({ state: state }, path, { query: query }));
	    }
	
	    // deprecated
	    function replaceState(state, path, query) {
	      if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	      replace(_extends({ state: state }, path, { query: query }));
	    }
	
	    return _extends({}, history, {
	      listenBefore: listenBefore,
	      listen: listen,
	      push: push,
	      replace: replace,
	      createPath: createPath,
	      createHref: createHref,
	      createLocation: createLocation,
	
	      pushState: _deprecate2['default'](pushState, 'pushState is deprecated; use push instead'),
	      replaceState: _deprecate2['default'](replaceState, 'replaceState is deprecated; use replace instead')
	    });
	  };
	}
	
	exports['default'] = useQueries;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var strictUriEncode = __webpack_require__(194);
	
	exports.extract = function (str) {
		return str.split('?')[1] || '';
	};
	
	exports.parse = function (str) {
		if (typeof str !== 'string') {
			return {};
		}
	
		str = str.trim().replace(/^(\?|#|&)/, '');
	
		if (!str) {
			return {};
		}
	
		return str.split('&').reduce(function (ret, param) {
			var parts = param.replace(/\+/g, ' ').split('=');
			// Firefox (pre 40) decodes `%3D` to `=`
			// https://github.com/sindresorhus/query-string/pull/37
			var key = parts.shift();
			var val = parts.length > 0 ? parts.join('=') : undefined;
	
			key = decodeURIComponent(key);
	
			// missing `=` should be `null`:
			// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
			val = val === undefined ? null : decodeURIComponent(val);
	
			if (!ret.hasOwnProperty(key)) {
				ret[key] = val;
			} else if (Array.isArray(ret[key])) {
				ret[key].push(val);
			} else {
				ret[key] = [ret[key], val];
			}
	
			return ret;
		}, {});
	};
	
	exports.stringify = function (obj) {
		return obj ? Object.keys(obj).sort().map(function (key) {
			var val = obj[key];
	
			if (val === undefined) {
				return '';
			}
	
			if (val === null) {
				return key;
			}
	
			if (Array.isArray(val)) {
				return val.slice().sort().map(function (val2) {
					return strictUriEncode(key) + '=' + strictUriEncode(val2);
				}).join('&');
			}
	
			return strictUriEncode(key) + '=' + strictUriEncode(val);
		}).filter(function (x) {
			return x.length > 0;
		}).join('&') : '';
	};

/***/ },
/* 194 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function (str) {
		return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
			return '%' + c.charCodeAt(0).toString(16).toUpperCase();
		});
	};

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	exports.default = createTransitionManager;
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _computeChangedRoutes2 = __webpack_require__(196);
	
	var _computeChangedRoutes3 = _interopRequireDefault(_computeChangedRoutes2);
	
	var _TransitionUtils = __webpack_require__(197);
	
	var _isActive2 = __webpack_require__(199);
	
	var _isActive3 = _interopRequireDefault(_isActive2);
	
	var _getComponents = __webpack_require__(200);
	
	var _getComponents2 = _interopRequireDefault(_getComponents);
	
	var _matchRoutes = __webpack_require__(202);
	
	var _matchRoutes2 = _interopRequireDefault(_matchRoutes);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function hasAnyProperties(object) {
	  for (var p in object) {
	    if (Object.prototype.hasOwnProperty.call(object, p)) return true;
	  }return false;
	}
	
	function createTransitionManager(history, routes) {
	  var state = {};
	
	  // Signature should be (location, indexOnly), but needs to support (path,
	  // query, indexOnly)
	  function isActive(location) {
	    var indexOnlyOrDeprecatedQuery = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	    var deprecatedIndexOnly = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	
	    var indexOnly = void 0;
	    if (indexOnlyOrDeprecatedQuery && indexOnlyOrDeprecatedQuery !== true || deprecatedIndexOnly !== null) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`isActive(pathname, query, indexOnly) is deprecated; use `isActive(location, indexOnly)` with a location descriptor instead. http://tiny.cc/router-isActivedeprecated') : void 0;
	      location = { pathname: location, query: indexOnlyOrDeprecatedQuery };
	      indexOnly = deprecatedIndexOnly || false;
	    } else {
	      location = history.createLocation(location);
	      indexOnly = indexOnlyOrDeprecatedQuery;
	    }
	
	    return (0, _isActive3.default)(location, indexOnly, state.location, state.routes, state.params);
	  }
	
	  var partialNextState = void 0;
	
	  function match(location, callback) {
	    if (partialNextState && partialNextState.location === location) {
	      // Continue from where we left off.
	      finishMatch(partialNextState, callback);
	    } else {
	      (0, _matchRoutes2.default)(routes, location, function (error, nextState) {
	        if (error) {
	          callback(error);
	        } else if (nextState) {
	          finishMatch(_extends({}, nextState, { location: location }), callback);
	        } else {
	          callback();
	        }
	      });
	    }
	  }
	
	  function finishMatch(nextState, callback) {
	    var _computeChangedRoutes = (0, _computeChangedRoutes3.default)(state, nextState);
	
	    var leaveRoutes = _computeChangedRoutes.leaveRoutes;
	    var changeRoutes = _computeChangedRoutes.changeRoutes;
	    var enterRoutes = _computeChangedRoutes.enterRoutes;
	
	    (0, _TransitionUtils.runLeaveHooks)(leaveRoutes, state);
	
	    // Tear down confirmation hooks for left routes
	    leaveRoutes.filter(function (route) {
	      return enterRoutes.indexOf(route) === -1;
	    }).forEach(removeListenBeforeHooksForRoute);
	
	    // change and enter hooks are run in series
	    (0, _TransitionUtils.runChangeHooks)(changeRoutes, state, nextState, function (error, redirectInfo) {
	      if (error || redirectInfo) return handleErrorOrRedirect(error, redirectInfo);
	
	      (0, _TransitionUtils.runEnterHooks)(enterRoutes, nextState, finishEnterHooks);
	    });
	
	    function finishEnterHooks(error, redirectInfo) {
	      if (error || redirectInfo) return handleErrorOrRedirect(error, redirectInfo);
	
	      // TODO: Fetch components after state is updated.
	      (0, _getComponents2.default)(nextState, function (error, components) {
	        if (error) {
	          callback(error);
	        } else {
	          // TODO: Make match a pure function and have some other API
	          // for "match and update state".
	          callback(null, null, state = _extends({}, nextState, { components: components }));
	        }
	      });
	    }
	
	    function handleErrorOrRedirect(error, redirectInfo) {
	      if (error) callback(error);else callback(null, redirectInfo);
	    }
	  }
	
	  var RouteGuid = 1;
	
	  function getRouteID(route) {
	    var create = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
	
	    return route.__id__ || create && (route.__id__ = RouteGuid++);
	  }
	
	  var RouteHooks = Object.create(null);
	
	  function getRouteHooksForRoutes(routes) {
	    return routes.reduce(function (hooks, route) {
	      hooks.push.apply(hooks, RouteHooks[getRouteID(route)]);
	      return hooks;
	    }, []);
	  }
	
	  function transitionHook(location, callback) {
	    (0, _matchRoutes2.default)(routes, location, function (error, nextState) {
	      if (nextState == null) {
	        // TODO: We didn't actually match anything, but hang
	        // onto error/nextState so we don't have to matchRoutes
	        // again in the listen callback.
	        callback();
	        return;
	      }
	
	      // Cache some state here so we don't have to
	      // matchRoutes() again in the listen callback.
	      partialNextState = _extends({}, nextState, { location: location });
	
	      var hooks = getRouteHooksForRoutes((0, _computeChangedRoutes3.default)(state, partialNextState).leaveRoutes);
	
	      var result = void 0;
	      for (var i = 0, len = hooks.length; result == null && i < len; ++i) {
	        // Passing the location arg here indicates to
	        // the user that this is a transition hook.
	        result = hooks[i](location);
	      }
	
	      callback(result);
	    });
	  }
	
	  /* istanbul ignore next: untestable with Karma */
	  function beforeUnloadHook() {
	    // Synchronously check to see if any route hooks want
	    // to prevent the current window/tab from closing.
	    if (state.routes) {
	      var hooks = getRouteHooksForRoutes(state.routes);
	
	      var message = void 0;
	      for (var i = 0, len = hooks.length; typeof message !== 'string' && i < len; ++i) {
	        // Passing no args indicates to the user that this is a
	        // beforeunload hook. We don't know the next location.
	        message = hooks[i]();
	      }
	
	      return message;
	    }
	  }
	
	  var unlistenBefore = void 0,
	      unlistenBeforeUnload = void 0;
	
	  function removeListenBeforeHooksForRoute(route) {
	    var routeID = getRouteID(route, false);
	    if (!routeID) {
	      return;
	    }
	
	    delete RouteHooks[routeID];
	
	    if (!hasAnyProperties(RouteHooks)) {
	      // teardown transition & beforeunload hooks
	      if (unlistenBefore) {
	        unlistenBefore();
	        unlistenBefore = null;
	      }
	
	      if (unlistenBeforeUnload) {
	        unlistenBeforeUnload();
	        unlistenBeforeUnload = null;
	      }
	    }
	  }
	
	  /**
	   * Registers the given hook function to run before leaving the given route.
	   *
	   * During a normal transition, the hook function receives the next location
	   * as its only argument and can return either a prompt message (string) to show the user,
	   * to make sure they want to leave the page; or `false`, to prevent the transition.
	   * Any other return value will have no effect.
	   *
	   * During the beforeunload event (in browsers) the hook receives no arguments.
	   * In this case it must return a prompt message to prevent the transition.
	   *
	   * Returns a function that may be used to unbind the listener.
	   */
	  function listenBeforeLeavingRoute(route, hook) {
	    // TODO: Warn if they register for a route that isn't currently
	    // active. They're probably doing something wrong, like re-creating
	    // route objects on every location change.
	    var routeID = getRouteID(route);
	    var hooks = RouteHooks[routeID];
	
	    if (!hooks) {
	      var thereWereNoRouteHooks = !hasAnyProperties(RouteHooks);
	
	      RouteHooks[routeID] = [hook];
	
	      if (thereWereNoRouteHooks) {
	        // setup transition & beforeunload hooks
	        unlistenBefore = history.listenBefore(transitionHook);
	
	        if (history.listenBeforeUnload) unlistenBeforeUnload = history.listenBeforeUnload(beforeUnloadHook);
	      }
	    } else {
	      if (hooks.indexOf(hook) === -1) {
	        process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'adding multiple leave hooks for the same route is deprecated; manage multiple confirmations in your own code instead') : void 0;
	
	        hooks.push(hook);
	      }
	    }
	
	    return function () {
	      var hooks = RouteHooks[routeID];
	
	      if (hooks) {
	        var newHooks = hooks.filter(function (item) {
	          return item !== hook;
	        });
	
	        if (newHooks.length === 0) {
	          removeListenBeforeHooksForRoute(route);
	        } else {
	          RouteHooks[routeID] = newHooks;
	        }
	      }
	    };
	  }
	
	  /**
	   * This is the API for stateful environments. As the location
	   * changes, we update state and call the listener. We can also
	   * gracefully handle errors and redirects.
	   */
	  function listen(listener) {
	    // TODO: Only use a single history listener. Otherwise we'll
	    // end up with multiple concurrent calls to match.
	    return history.listen(function (location) {
	      if (state.location === location) {
	        listener(null, state);
	      } else {
	        match(location, function (error, redirectLocation, nextState) {
	          if (error) {
	            listener(error);
	          } else if (redirectLocation) {
	            history.replace(redirectLocation);
	          } else if (nextState) {
	            listener(null, nextState);
	          } else {
	            process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'Location "%s" did not match any routes', location.pathname + location.search + location.hash) : void 0;
	          }
	        });
	      }
	    });
	  }
	
	  return {
	    isActive: isActive,
	    match: match,
	    listenBeforeLeavingRoute: listenBeforeLeavingRoute,
	    listen: listen
	  };
	}
	
	//export default useRoutes
	
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _PatternUtils = __webpack_require__(173);
	
	function routeParamsChanged(route, prevState, nextState) {
	  if (!route.path) return false;
	
	  var paramNames = (0, _PatternUtils.getParamNames)(route.path);
	
	  return paramNames.some(function (paramName) {
	    return prevState.params[paramName] !== nextState.params[paramName];
	  });
	}
	
	/**
	 * Returns an object of { leaveRoutes, changeRoutes, enterRoutes } determined by
	 * the change from prevState to nextState. We leave routes if either
	 * 1) they are not in the next state or 2) they are in the next state
	 * but their params have changed (i.e. /users/123 => /users/456).
	 *
	 * leaveRoutes are ordered starting at the leaf route of the tree
	 * we're leaving up to the common parent route. enterRoutes are ordered
	 * from the top of the tree we're entering down to the leaf route.
	 *
	 * changeRoutes are any routes that didn't leave or enter during
	 * the transition.
	 */
	function computeChangedRoutes(prevState, nextState) {
	  var prevRoutes = prevState && prevState.routes;
	  var nextRoutes = nextState.routes;
	
	  var leaveRoutes = void 0,
	      changeRoutes = void 0,
	      enterRoutes = void 0;
	  if (prevRoutes) {
	    (function () {
	      var parentIsLeaving = false;
	      leaveRoutes = prevRoutes.filter(function (route) {
	        if (parentIsLeaving) {
	          return true;
	        } else {
	          var isLeaving = nextRoutes.indexOf(route) === -1 || routeParamsChanged(route, prevState, nextState);
	          if (isLeaving) parentIsLeaving = true;
	          return isLeaving;
	        }
	      });
	
	      // onLeave hooks start at the leaf route.
	      leaveRoutes.reverse();
	
	      enterRoutes = [];
	      changeRoutes = [];
	
	      nextRoutes.forEach(function (route) {
	        var isNew = prevRoutes.indexOf(route) === -1;
	        var paramsChanged = leaveRoutes.indexOf(route) !== -1;
	
	        if (isNew || paramsChanged) enterRoutes.push(route);else changeRoutes.push(route);
	      });
	    })();
	  } else {
	    leaveRoutes = [];
	    changeRoutes = [];
	    enterRoutes = nextRoutes;
	  }
	
	  return {
	    leaveRoutes: leaveRoutes,
	    changeRoutes: changeRoutes,
	    enterRoutes: enterRoutes
	  };
	}
	
	exports.default = computeChangedRoutes;
	module.exports = exports['default'];

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.runEnterHooks = runEnterHooks;
	exports.runChangeHooks = runChangeHooks;
	exports.runLeaveHooks = runLeaveHooks;
	
	var _AsyncUtils = __webpack_require__(198);
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function createTransitionHook(hook, route, asyncArity) {
	  return function () {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    hook.apply(route, args);
	
	    if (hook.length < asyncArity) {
	      var callback = args[args.length - 1];
	      // Assume hook executes synchronously and
	      // automatically call the callback.
	      callback();
	    }
	  };
	}
	
	function getEnterHooks(routes) {
	  return routes.reduce(function (hooks, route) {
	    if (route.onEnter) hooks.push(createTransitionHook(route.onEnter, route, 3));
	
	    return hooks;
	  }, []);
	}
	
	function getChangeHooks(routes) {
	  return routes.reduce(function (hooks, route) {
	    if (route.onChange) hooks.push(createTransitionHook(route.onChange, route, 4));
	    return hooks;
	  }, []);
	}
	
	function runTransitionHooks(length, iter, callback) {
	  if (!length) {
	    callback();
	    return;
	  }
	
	  var redirectInfo = void 0;
	  function replace(location, deprecatedPathname, deprecatedQuery) {
	    if (deprecatedPathname) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`replaceState(state, pathname, query) is deprecated; use `replace(location)` with a location descriptor instead. http://tiny.cc/router-isActivedeprecated') : void 0;
	      redirectInfo = {
	        pathname: deprecatedPathname,
	        query: deprecatedQuery,
	        state: location
	      };
	
	      return;
	    }
	
	    redirectInfo = location;
	  }
	
	  (0, _AsyncUtils.loopAsync)(length, function (index, next, done) {
	    iter(index, replace, function (error) {
	      if (error || redirectInfo) {
	        done(error, redirectInfo); // No need to continue.
	      } else {
	        next();
	      }
	    });
	  }, callback);
	}
	
	/**
	 * Runs all onEnter hooks in the given array of routes in order
	 * with onEnter(nextState, replace, callback) and calls
	 * callback(error, redirectInfo) when finished. The first hook
	 * to use replace short-circuits the loop.
	 *
	 * If a hook needs to run asynchronously, it may use the callback
	 * function. However, doing so will cause the transition to pause,
	 * which could lead to a non-responsive UI if the hook is slow.
	 */
	function runEnterHooks(routes, nextState, callback) {
	  var hooks = getEnterHooks(routes);
	  return runTransitionHooks(hooks.length, function (index, replace, next) {
	    hooks[index](nextState, replace, next);
	  }, callback);
	}
	
	/**
	 * Runs all onChange hooks in the given array of routes in order
	 * with onChange(prevState, nextState, replace, callback) and calls
	 * callback(error, redirectInfo) when finished. The first hook
	 * to use replace short-circuits the loop.
	 *
	 * If a hook needs to run asynchronously, it may use the callback
	 * function. However, doing so will cause the transition to pause,
	 * which could lead to a non-responsive UI if the hook is slow.
	 */
	function runChangeHooks(routes, state, nextState, callback) {
	  var hooks = getChangeHooks(routes);
	  return runTransitionHooks(hooks.length, function (index, replace, next) {
	    hooks[index](state, nextState, replace, next);
	  }, callback);
	}
	
	/**
	 * Runs all onLeave hooks in the given array of routes in order.
	 */
	function runLeaveHooks(routes, prevState) {
	  for (var i = 0, len = routes.length; i < len; ++i) {
	    if (routes[i].onLeave) routes[i].onLeave.call(routes[i], prevState);
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 198 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports.loopAsync = loopAsync;
	exports.mapAsync = mapAsync;
	function loopAsync(turns, work, callback) {
	  var currentTurn = 0,
	      isDone = false;
	  var sync = false,
	      hasNext = false,
	      doneArgs = void 0;
	
	  function done() {
	    isDone = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      doneArgs = [].concat(Array.prototype.slice.call(arguments));
	      return;
	    }
	
	    callback.apply(this, arguments);
	  }
	
	  function next() {
	    if (isDone) {
	      return;
	    }
	
	    hasNext = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      return;
	    }
	
	    sync = true;
	
	    while (!isDone && currentTurn < turns && hasNext) {
	      hasNext = false;
	      work.call(this, currentTurn++, next, done);
	    }
	
	    sync = false;
	
	    if (isDone) {
	      // This means the loop finished synchronously.
	      callback.apply(this, doneArgs);
	      return;
	    }
	
	    if (currentTurn >= turns && hasNext) {
	      isDone = true;
	      callback();
	    }
	  }
	
	  next();
	}
	
	function mapAsync(array, work, callback) {
	  var length = array.length;
	  var values = [];
	
	  if (length === 0) return callback(null, values);
	
	  var isDone = false,
	      doneCount = 0;
	
	  function done(index, error, value) {
	    if (isDone) return;
	
	    if (error) {
	      isDone = true;
	      callback(error);
	    } else {
	      values[index] = value;
	
	      isDone = ++doneCount === length;
	
	      if (isDone) callback(null, values);
	    }
	  }
	
	  array.forEach(function (item, index) {
	    work(item, index, function (error, value) {
	      done(index, error, value);
	    });
	  });
	}

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	
	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};
	
	exports.default = isActive;
	
	var _PatternUtils = __webpack_require__(173);
	
	function deepEqual(a, b) {
	  if (a == b) return true;
	
	  if (a == null || b == null) return false;
	
	  if (Array.isArray(a)) {
	    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
	      return deepEqual(item, b[index]);
	    });
	  }
	
	  if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object') {
	    for (var p in a) {
	      if (!Object.prototype.hasOwnProperty.call(a, p)) {
	        continue;
	      }
	
	      if (a[p] === undefined) {
	        if (b[p] !== undefined) {
	          return false;
	        }
	      } else if (!Object.prototype.hasOwnProperty.call(b, p)) {
	        return false;
	      } else if (!deepEqual(a[p], b[p])) {
	        return false;
	      }
	    }
	
	    return true;
	  }
	
	  return String(a) === String(b);
	}
	
	/**
	 * Returns true if the current pathname matches the supplied one, net of
	 * leading and trailing slash normalization. This is sufficient for an
	 * indexOnly route match.
	 */
	function pathIsActive(pathname, currentPathname) {
	  // Normalize leading slash for consistency. Leading slash on pathname has
	  // already been normalized in isActive. See caveat there.
	  if (currentPathname.charAt(0) !== '/') {
	    currentPathname = '/' + currentPathname;
	  }
	
	  // Normalize the end of both path names too. Maybe `/foo/` shouldn't show
	  // `/foo` as active, but in this case, we would already have failed the
	  // match.
	  if (pathname.charAt(pathname.length - 1) !== '/') {
	    pathname += '/';
	  }
	  if (currentPathname.charAt(currentPathname.length - 1) !== '/') {
	    currentPathname += '/';
	  }
	
	  return currentPathname === pathname;
	}
	
	/**
	 * Returns true if the given pathname matches the active routes and params.
	 */
	function routeIsActive(pathname, routes, params) {
	  var remainingPathname = pathname,
	      paramNames = [],
	      paramValues = [];
	
	  // for...of would work here but it's probably slower post-transpilation.
	  for (var i = 0, len = routes.length; i < len; ++i) {
	    var route = routes[i];
	    var pattern = route.path || '';
	
	    if (pattern.charAt(0) === '/') {
	      remainingPathname = pathname;
	      paramNames = [];
	      paramValues = [];
	    }
	
	    if (remainingPathname !== null && pattern) {
	      var matched = (0, _PatternUtils.matchPattern)(pattern, remainingPathname);
	      if (matched) {
	        remainingPathname = matched.remainingPathname;
	        paramNames = [].concat(paramNames, matched.paramNames);
	        paramValues = [].concat(paramValues, matched.paramValues);
	      } else {
	        remainingPathname = null;
	      }
	
	      if (remainingPathname === '') {
	        // We have an exact match on the route. Just check that all the params
	        // match.
	        // FIXME: This doesn't work on repeated params.
	        return paramNames.every(function (paramName, index) {
	          return String(paramValues[index]) === String(params[paramName]);
	        });
	      }
	    }
	  }
	
	  return false;
	}
	
	/**
	 * Returns true if all key/value pairs in the given query are
	 * currently active.
	 */
	function queryIsActive(query, activeQuery) {
	  if (activeQuery == null) return query == null;
	
	  if (query == null) return true;
	
	  return deepEqual(query, activeQuery);
	}
	
	/**
	 * Returns true if a <Link> to the given pathname/query combination is
	 * currently active.
	 */
	function isActive(_ref, indexOnly, currentLocation, routes, params) {
	  var pathname = _ref.pathname;
	  var query = _ref.query;
	
	  if (currentLocation == null) return false;
	
	  // TODO: This is a bit ugly. It keeps around support for treating pathnames
	  // without preceding slashes as absolute paths, but possibly also works
	  // around the same quirks with basenames as in matchRoutes.
	  if (pathname.charAt(0) !== '/') {
	    pathname = '/' + pathname;
	  }
	
	  if (!pathIsActive(pathname, currentLocation.pathname)) {
	    // The path check is necessary and sufficient for indexOnly, but otherwise
	    // we still need to check the routes.
	    if (indexOnly || !routeIsActive(pathname, routes, params)) {
	      return false;
	    }
	  }
	
	  return queryIsActive(query, currentLocation.query);
	}
	module.exports = exports['default'];

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _AsyncUtils = __webpack_require__(198);
	
	var _makeStateWithLocation = __webpack_require__(201);
	
	var _makeStateWithLocation2 = _interopRequireDefault(_makeStateWithLocation);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function getComponentsForRoute(nextState, route, callback) {
	  if (route.component || route.components) {
	    callback(null, route.component || route.components);
	    return;
	  }
	
	  var getComponent = route.getComponent || route.getComponents;
	  if (!getComponent) {
	    callback();
	    return;
	  }
	
	  var location = nextState.location;
	
	  var nextStateWithLocation = (0, _makeStateWithLocation2.default)(nextState, location);
	
	  getComponent.call(route, nextStateWithLocation, callback);
	}
	
	/**
	 * Asynchronously fetches all components needed for the given router
	 * state and calls callback(error, components) when finished.
	 *
	 * Note: This operation may finish synchronously if no routes have an
	 * asynchronous getComponents method.
	 */
	function getComponents(nextState, callback) {
	  (0, _AsyncUtils.mapAsync)(nextState.routes, function (route, index, callback) {
	    getComponentsForRoute(nextState, route, callback);
	  }, callback);
	}
	
	exports.default = getComponents;
	module.exports = exports['default'];

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	exports.default = makeStateWithLocation;
	
	var _deprecateObjectProperties = __webpack_require__(169);
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function makeStateWithLocation(state, location) {
	  if (process.env.NODE_ENV !== 'production' && _deprecateObjectProperties.canUseMembrane) {
	    var stateWithLocation = _extends({}, state);
	
	    // I don't use deprecateObjectProperties here because I want to keep the
	    // same code path between development and production, in that we just
	    // assign extra properties to the copy of the state object in both cases.
	
	    var _loop = function _loop(prop) {
	      if (!Object.prototype.hasOwnProperty.call(location, prop)) {
	        return 'continue';
	      }
	
	      Object.defineProperty(stateWithLocation, prop, {
	        get: function get() {
	          process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'Accessing location properties directly from the first argument to `getComponent`, `getComponents`, `getChildRoutes`, and `getIndexRoute` is deprecated. That argument is now the router state (`nextState` or `partialNextState`) rather than the location. To access the location, use `nextState.location` or `partialNextState.location`.') : void 0;
	          return location[prop];
	        }
	      });
	    };
	
	    for (var prop in location) {
	      var _ret = _loop(prop);
	
	      if (_ret === 'continue') continue;
	    }
	
	    return stateWithLocation;
	  }
	
	  return _extends({}, state, location);
	}
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};
	
	exports.default = matchRoutes;
	
	var _AsyncUtils = __webpack_require__(198);
	
	var _makeStateWithLocation = __webpack_require__(201);
	
	var _makeStateWithLocation2 = _interopRequireDefault(_makeStateWithLocation);
	
	var _PatternUtils = __webpack_require__(173);
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _RouteUtils = __webpack_require__(167);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function getChildRoutes(route, location, paramNames, paramValues, callback) {
	  if (route.childRoutes) {
	    return [null, route.childRoutes];
	  }
	  if (!route.getChildRoutes) {
	    return [];
	  }
	
	  var sync = true,
	      result = void 0;
	
	  var partialNextState = {
	    location: location,
	    params: createParams(paramNames, paramValues)
	  };
	
	  var partialNextStateWithLocation = (0, _makeStateWithLocation2.default)(partialNextState, location);
	
	  route.getChildRoutes(partialNextStateWithLocation, function (error, childRoutes) {
	    childRoutes = !error && (0, _RouteUtils.createRoutes)(childRoutes);
	    if (sync) {
	      result = [error, childRoutes];
	      return;
	    }
	
	    callback(error, childRoutes);
	  });
	
	  sync = false;
	  return result; // Might be undefined.
	}
	
	function getIndexRoute(route, location, paramNames, paramValues, callback) {
	  if (route.indexRoute) {
	    callback(null, route.indexRoute);
	  } else if (route.getIndexRoute) {
	    var partialNextState = {
	      location: location,
	      params: createParams(paramNames, paramValues)
	    };
	
	    var partialNextStateWithLocation = (0, _makeStateWithLocation2.default)(partialNextState, location);
	
	    route.getIndexRoute(partialNextStateWithLocation, function (error, indexRoute) {
	      callback(error, !error && (0, _RouteUtils.createRoutes)(indexRoute)[0]);
	    });
	  } else if (route.childRoutes) {
	    (function () {
	      var pathless = route.childRoutes.filter(function (childRoute) {
	        return !childRoute.path;
	      });
	
	      (0, _AsyncUtils.loopAsync)(pathless.length, function (index, next, done) {
	        getIndexRoute(pathless[index], location, paramNames, paramValues, function (error, indexRoute) {
	          if (error || indexRoute) {
	            var routes = [pathless[index]].concat(Array.isArray(indexRoute) ? indexRoute : [indexRoute]);
	            done(error, routes);
	          } else {
	            next();
	          }
	        });
	      }, function (err, routes) {
	        callback(null, routes);
	      });
	    })();
	  } else {
	    callback();
	  }
	}
	
	function assignParams(params, paramNames, paramValues) {
	  return paramNames.reduce(function (params, paramName, index) {
	    var paramValue = paramValues && paramValues[index];
	
	    if (Array.isArray(params[paramName])) {
	      params[paramName].push(paramValue);
	    } else if (paramName in params) {
	      params[paramName] = [params[paramName], paramValue];
	    } else {
	      params[paramName] = paramValue;
	    }
	
	    return params;
	  }, params);
	}
	
	function createParams(paramNames, paramValues) {
	  return assignParams({}, paramNames, paramValues);
	}
	
	function matchRouteDeep(route, location, remainingPathname, paramNames, paramValues, callback) {
	  var pattern = route.path || '';
	
	  if (pattern.charAt(0) === '/') {
	    remainingPathname = location.pathname;
	    paramNames = [];
	    paramValues = [];
	  }
	
	  // Only try to match the path if the route actually has a pattern, and if
	  // we're not just searching for potential nested absolute paths.
	  if (remainingPathname !== null && pattern) {
	    try {
	      var matched = (0, _PatternUtils.matchPattern)(pattern, remainingPathname);
	      if (matched) {
	        remainingPathname = matched.remainingPathname;
	        paramNames = [].concat(paramNames, matched.paramNames);
	        paramValues = [].concat(paramValues, matched.paramValues);
	      } else {
	        remainingPathname = null;
	      }
	    } catch (error) {
	      callback(error);
	    }
	
	    // By assumption, pattern is non-empty here, which is the prerequisite for
	    // actually terminating a match.
	    if (remainingPathname === '') {
	      var _ret2 = function () {
	        var match = {
	          routes: [route],
	          params: createParams(paramNames, paramValues)
	        };
	
	        getIndexRoute(route, location, paramNames, paramValues, function (error, indexRoute) {
	          if (error) {
	            callback(error);
	          } else {
	            if (Array.isArray(indexRoute)) {
	              var _match$routes;
	
	              process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(indexRoute.every(function (route) {
	                return !route.path;
	              }), 'Index routes should not have paths') : void 0;
	              (_match$routes = match.routes).push.apply(_match$routes, indexRoute);
	            } else if (indexRoute) {
	              process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(!indexRoute.path, 'Index routes should not have paths') : void 0;
	              match.routes.push(indexRoute);
	            }
	
	            callback(null, match);
	          }
	        });
	
	        return {
	          v: void 0
	        };
	      }();
	
	      if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
	    }
	  }
	
	  if (remainingPathname != null || route.childRoutes) {
	    // Either a) this route matched at least some of the path or b)
	    // we don't have to load this route's children asynchronously. In
	    // either case continue checking for matches in the subtree.
	    var onChildRoutes = function onChildRoutes(error, childRoutes) {
	      if (error) {
	        callback(error);
	      } else if (childRoutes) {
	        // Check the child routes to see if any of them match.
	        matchRoutes(childRoutes, location, function (error, match) {
	          if (error) {
	            callback(error);
	          } else if (match) {
	            // A child route matched! Augment the match and pass it up the stack.
	            match.routes.unshift(route);
	            callback(null, match);
	          } else {
	            callback();
	          }
	        }, remainingPathname, paramNames, paramValues);
	      } else {
	        callback();
	      }
	    };
	
	    var result = getChildRoutes(route, location, paramNames, paramValues, onChildRoutes);
	    if (result) {
	      onChildRoutes.apply(undefined, result);
	    }
	  } else {
	    callback();
	  }
	}
	
	/**
	 * Asynchronously matches the given location to a set of routes and calls
	 * callback(error, state) when finished. The state object will have the
	 * following properties:
	 *
	 * - routes       An array of routes that matched, in hierarchical order
	 * - params       An object of URL parameters
	 *
	 * Note: This operation may finish synchronously if no routes have an
	 * asynchronous getChildRoutes method.
	 */
	function matchRoutes(routes, location, callback, remainingPathname) {
	  var paramNames = arguments.length <= 4 || arguments[4] === undefined ? [] : arguments[4];
	  var paramValues = arguments.length <= 5 || arguments[5] === undefined ? [] : arguments[5];
	
	  if (remainingPathname === undefined) {
	    // TODO: This is a little bit ugly, but it works around a quirk in history
	    // that strips the leading slash from pathnames when using basenames with
	    // trailing slashes.
	    if (location.pathname.charAt(0) !== '/') {
	      location = _extends({}, location, {
	        pathname: '/' + location.pathname
	      });
	    }
	    remainingPathname = location.pathname;
	  }
	
	  (0, _AsyncUtils.loopAsync)(routes.length, function (index, next, done) {
	    matchRouteDeep(routes[index], location, remainingPathname, paramNames, paramValues, function (error, match) {
	      if (error || match) {
	        done(error, match);
	      } else {
	        next();
	      }
	    });
	  }, callback);
	}
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	
	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _deprecateObjectProperties = __webpack_require__(169);
	
	var _deprecateObjectProperties2 = _interopRequireDefault(_deprecateObjectProperties);
	
	var _getRouteParams = __webpack_require__(204);
	
	var _getRouteParams2 = _interopRequireDefault(_getRouteParams);
	
	var _RouteUtils = __webpack_require__(167);
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var _React$PropTypes = _react2.default.PropTypes;
	var array = _React$PropTypes.array;
	var func = _React$PropTypes.func;
	var object = _React$PropTypes.object;
	
	/**
	 * A <RouterContext> renders the component tree for a given router state
	 * and sets the history object and the current location in context.
	 */
	
	var RouterContext = _react2.default.createClass({
	  displayName: 'RouterContext',
	
	  propTypes: {
	    history: object,
	    router: object.isRequired,
	    location: object.isRequired,
	    routes: array.isRequired,
	    params: object.isRequired,
	    components: array.isRequired,
	    createElement: func.isRequired
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      createElement: _react2.default.createElement
	    };
	  },
	
	  childContextTypes: {
	    history: object,
	    location: object.isRequired,
	    router: object.isRequired
	  },
	
	  getChildContext: function getChildContext() {
	    var _props = this.props;
	    var router = _props.router;
	    var history = _props.history;
	    var location = _props.location;
	
	    if (!router) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`<RouterContext>` expects a `router` rather than a `history`') : void 0;
	
	      router = _extends({}, history, {
	        setRouteLeaveHook: history.listenBeforeLeavingRoute
	      });
	      delete router.listenBeforeLeavingRoute;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      location = (0, _deprecateObjectProperties2.default)(location, '`context.location` is deprecated, please use a route component\'s `props.location` instead. http://tiny.cc/router-accessinglocation');
	    }
	
	    return { history: history, location: location, router: router };
	  },
	  createElement: function createElement(component, props) {
	    return component == null ? null : this.props.createElement(component, props);
	  },
	  render: function render() {
	    var _this = this;
	
	    var _props2 = this.props;
	    var history = _props2.history;
	    var location = _props2.location;
	    var routes = _props2.routes;
	    var params = _props2.params;
	    var components = _props2.components;
	
	    var element = null;
	
	    if (components) {
	      element = components.reduceRight(function (element, components, index) {
	        if (components == null) return element; // Don't create new children; use the grandchildren.
	
	        var route = routes[index];
	        var routeParams = (0, _getRouteParams2.default)(route, params);
	        var props = {
	          history: history,
	          location: location,
	          params: params,
	          route: route,
	          routeParams: routeParams,
	          routes: routes
	        };
	
	        if ((0, _RouteUtils.isReactChildren)(element)) {
	          props.children = element;
	        } else if (element) {
	          for (var prop in element) {
	            if (Object.prototype.hasOwnProperty.call(element, prop)) props[prop] = element[prop];
	          }
	        }
	
	        if ((typeof components === 'undefined' ? 'undefined' : _typeof(components)) === 'object') {
	          var elements = {};
	
	          for (var key in components) {
	            if (Object.prototype.hasOwnProperty.call(components, key)) {
	              // Pass through the key as a prop to createElement to allow
	              // custom createElement functions to know which named component
	              // they're rendering, for e.g. matching up to fetched data.
	              elements[key] = _this.createElement(components[key], _extends({
	                key: key }, props));
	            }
	          }
	
	          return elements;
	        }
	
	        return _this.createElement(components, props);
	      }, element);
	    }
	
	    !(element === null || element === false || _react2.default.isValidElement(element)) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'The root route must render a single element') : (0, _invariant2.default)(false) : void 0;
	
	    return element;
	  }
	});
	
	exports.default = RouterContext;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _PatternUtils = __webpack_require__(173);
	
	/**
	 * Extracts an object of params the given route cares about from
	 * the given params object.
	 */
	function getRouteParams(route, params) {
	  var routeParams = {};
	
	  if (!route.path) return routeParams;
	
	  (0, _PatternUtils.getParamNames)(route.path).forEach(function (p) {
	    if (Object.prototype.hasOwnProperty.call(params, p)) {
	      routeParams[p] = params[p];
	    }
	  });
	
	  return routeParams;
	}
	
	exports.default = getRouteParams;
	module.exports = exports['default'];

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	exports.createRouterObject = createRouterObject;
	exports.createRoutingHistory = createRoutingHistory;
	
	var _deprecateObjectProperties = __webpack_require__(169);
	
	var _deprecateObjectProperties2 = _interopRequireDefault(_deprecateObjectProperties);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function createRouterObject(history, transitionManager) {
	  return _extends({}, history, {
	    setRouteLeaveHook: transitionManager.listenBeforeLeavingRoute,
	    isActive: transitionManager.isActive
	  });
	}
	
	// deprecated
	function createRoutingHistory(history, transitionManager) {
	  history = _extends({}, history, transitionManager);
	
	  if (process.env.NODE_ENV !== 'production') {
	    history = (0, _deprecateObjectProperties2.default)(history, '`props.history` and `context.history` are deprecated. Please use `context.router`. http://tiny.cc/router-contextchanges');
	  }
	
	  return history;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _PropTypes = __webpack_require__(168);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	  var target = {};for (var i in obj) {
	    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	  }return target;
	}
	
	var _React$PropTypes = _react2.default.PropTypes;
	var bool = _React$PropTypes.bool;
	var object = _React$PropTypes.object;
	var string = _React$PropTypes.string;
	var func = _React$PropTypes.func;
	var oneOfType = _React$PropTypes.oneOfType;
	
	function isLeftClickEvent(event) {
	  return event.button === 0;
	}
	
	function isModifiedEvent(event) {
	  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
	}
	
	// TODO: De-duplicate against hasAnyProperties in createTransitionManager.
	function isEmptyObject(object) {
	  for (var p in object) {
	    if (Object.prototype.hasOwnProperty.call(object, p)) return false;
	  }return true;
	}
	
	function createLocationDescriptor(to, _ref) {
	  var query = _ref.query;
	  var hash = _ref.hash;
	  var state = _ref.state;
	
	  if (query || hash || state) {
	    return { pathname: to, query: query, hash: hash, state: state };
	  }
	
	  return to;
	}
	
	/**
	 * A <Link> is used to create an <a> element that links to a route.
	 * When that route is active, the link gets the value of its
	 * activeClassName prop.
	 *
	 * For example, assuming you have the following route:
	 *
	 *   <Route path="/posts/:postID" component={Post} />
	 *
	 * You could use the following component to link to that route:
	 *
	 *   <Link to={`/posts/${post.id}`} />
	 *
	 * Links may pass along location state and/or query string parameters
	 * in the state/query props, respectively.
	 *
	 *   <Link ... query={{ show: true }} state={{ the: 'state' }} />
	 */
	var Link = _react2.default.createClass({
	  displayName: 'Link',
	
	  contextTypes: {
	    router: _PropTypes.routerShape
	  },
	
	  propTypes: {
	    to: oneOfType([string, object]),
	    query: object,
	    hash: string,
	    state: object,
	    activeStyle: object,
	    activeClassName: string,
	    onlyActiveOnIndex: bool.isRequired,
	    onClick: func,
	    target: string
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      onlyActiveOnIndex: false,
	      style: {}
	    };
	  },
	  handleClick: function handleClick(event) {
	    if (this.props.onClick) this.props.onClick(event);
	
	    if (event.defaultPrevented) return;
	
	    !this.context.router ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<Link>s rendered outside of a router context cannot navigate.') : (0, _invariant2.default)(false) : void 0;
	
	    if (isModifiedEvent(event) || !isLeftClickEvent(event)) return;
	
	    // If target prop is set (e.g. to "_blank"), let browser handle link.
	    /* istanbul ignore if: untestable with Karma */
	    if (this.props.target) return;
	
	    event.preventDefault();
	
	    var _props = this.props;
	    var to = _props.to;
	    var query = _props.query;
	    var hash = _props.hash;
	    var state = _props.state;
	
	    var location = createLocationDescriptor(to, { query: query, hash: hash, state: state });
	
	    this.context.router.push(location);
	  },
	  render: function render() {
	    var _props2 = this.props;
	    var to = _props2.to;
	    var query = _props2.query;
	    var hash = _props2.hash;
	    var state = _props2.state;
	    var activeClassName = _props2.activeClassName;
	    var activeStyle = _props2.activeStyle;
	    var onlyActiveOnIndex = _props2.onlyActiveOnIndex;
	
	    var props = _objectWithoutProperties(_props2, ['to', 'query', 'hash', 'state', 'activeClassName', 'activeStyle', 'onlyActiveOnIndex']);
	
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(!(query || hash || state), 'the `query`, `hash`, and `state` props on `<Link>` are deprecated, use `<Link to={{ pathname, query, hash, state }}/>. http://tiny.cc/router-isActivedeprecated') : void 0;
	
	    // Ignore if rendered outside the context of router, simplifies unit testing.
	    var router = this.context.router;
	
	    if (router) {
	      // If user does not specify a `to` prop, return an empty anchor tag.
	      if (to == null) {
	        return _react2.default.createElement('a', props);
	      }
	
	      var location = createLocationDescriptor(to, { query: query, hash: hash, state: state });
	      props.href = router.createHref(location);
	
	      if (activeClassName || activeStyle != null && !isEmptyObject(activeStyle)) {
	        if (router.isActive(location, onlyActiveOnIndex)) {
	          if (activeClassName) {
	            if (props.className) {
	              props.className += ' ' + activeClassName;
	            } else {
	              props.className = activeClassName;
	            }
	          }
	
	          if (activeStyle) props.style = _extends({}, props.style, activeStyle);
	        }
	      }
	    }
	
	    return _react2.default.createElement('a', _extends({}, props, { onClick: this.handleClick }));
	  }
	});
	
	exports.default = Link;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Link = __webpack_require__(206);
	
	var _Link2 = _interopRequireDefault(_Link);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	/**
	 * An <IndexLink> is used to link to an <IndexRoute>.
	 */
	var IndexLink = _react2.default.createClass({
	  displayName: 'IndexLink',
	  render: function render() {
	    return _react2.default.createElement(_Link2.default, _extends({}, this.props, { onlyActiveOnIndex: true }));
	  }
	});
	
	exports.default = IndexLink;
	module.exports = exports['default'];

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	exports.default = withRouter;
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _hoistNonReactStatics = __webpack_require__(209);
	
	var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);
	
	var _PropTypes = __webpack_require__(168);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function getDisplayName(WrappedComponent) {
	  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
	}
	
	function withRouter(WrappedComponent, options) {
	  var withRef = options && options.withRef;
	
	  var WithRouter = _react2.default.createClass({
	    displayName: 'WithRouter',
	
	    contextTypes: { router: _PropTypes.routerShape },
	    propTypes: { router: _PropTypes.routerShape },
	
	    getWrappedInstance: function getWrappedInstance() {
	      !withRef ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'To access the wrapped instance, you need to specify ' + '`{ withRef: true }` as the second argument of the withRouter() call.') : (0, _invariant2.default)(false) : void 0;
	
	      return this.wrappedInstance;
	    },
	    render: function render() {
	      var _this = this;
	
	      var router = this.props.router || this.context.router;
	      var props = _extends({}, this.props, { router: router });
	
	      if (withRef) {
	        props.ref = function (c) {
	          _this.wrappedInstance = c;
	        };
	      }
	
	      return _react2.default.createElement(WrappedComponent, props);
	    }
	  });
	
	  WithRouter.displayName = 'withRouter(' + getDisplayName(WrappedComponent) + ')';
	  WithRouter.WrappedComponent = WrappedComponent;
	
	  return (0, _hoistNonReactStatics2.default)(WithRouter, WrappedComponent);
	}
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 209 */
/***/ function(module, exports) {

	/**
	 * Copyright 2015, Yahoo! Inc.
	 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
	 */
	'use strict';
	
	var REACT_STATICS = {
	    childContextTypes: true,
	    contextTypes: true,
	    defaultProps: true,
	    displayName: true,
	    getDefaultProps: true,
	    mixins: true,
	    propTypes: true,
	    type: true
	};
	
	var KNOWN_STATICS = {
	    name: true,
	    length: true,
	    prototype: true,
	    caller: true,
	    arguments: true,
	    arity: true
	};
	
	var isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';
	
	module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {
	    if (typeof sourceComponent !== 'string') {
	        // don't hoist over string (html) components
	        var keys = Object.getOwnPropertyNames(sourceComponent);
	
	        /* istanbul ignore else */
	        if (isGetOwnPropertySymbolsAvailable) {
	            keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));
	        }
	
	        for (var i = 0; i < keys.length; ++i) {
	            if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {
	                try {
	                    targetComponent[keys[i]] = sourceComponent[keys[i]];
	                } catch (error) {}
	            }
	        }
	    }
	
	    return targetComponent;
	};

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _Redirect = __webpack_require__(211);
	
	var _Redirect2 = _interopRequireDefault(_Redirect);
	
	var _InternalPropTypes = __webpack_require__(172);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var _React$PropTypes = _react2.default.PropTypes;
	var string = _React$PropTypes.string;
	var object = _React$PropTypes.object;
	
	/**
	 * An <IndexRedirect> is used to redirect from an indexRoute.
	 */
	
	var IndexRedirect = _react2.default.createClass({
	  displayName: 'IndexRedirect',
	
	  statics: {
	    createRouteFromReactElement: function createRouteFromReactElement(element, parentRoute) {
	      /* istanbul ignore else: sanity check */
	      if (parentRoute) {
	        parentRoute.indexRoute = _Redirect2.default.createRouteFromReactElement(element);
	      } else {
	        process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'An <IndexRedirect> does not make sense at the root of your route config') : void 0;
	      }
	    }
	  },
	
	  propTypes: {
	    to: string.isRequired,
	    query: object,
	    state: object,
	    onEnter: _InternalPropTypes.falsy,
	    children: _InternalPropTypes.falsy
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<IndexRedirect> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = IndexRedirect;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _RouteUtils = __webpack_require__(167);
	
	var _PatternUtils = __webpack_require__(173);
	
	var _InternalPropTypes = __webpack_require__(172);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var _React$PropTypes = _react2.default.PropTypes;
	var string = _React$PropTypes.string;
	var object = _React$PropTypes.object;
	
	/**
	 * A <Redirect> is used to declare another URL path a client should
	 * be sent to when they request a given URL.
	 *
	 * Redirects are placed alongside routes in the route configuration
	 * and are traversed in the same manner.
	 */
	
	var Redirect = _react2.default.createClass({
	  displayName: 'Redirect',
	
	  statics: {
	    createRouteFromReactElement: function createRouteFromReactElement(element) {
	      var route = (0, _RouteUtils.createRouteFromReactElement)(element);
	
	      if (route.from) route.path = route.from;
	
	      route.onEnter = function (nextState, replace) {
	        var location = nextState.location;
	        var params = nextState.params;
	
	        var pathname = void 0;
	        if (route.to.charAt(0) === '/') {
	          pathname = (0, _PatternUtils.formatPattern)(route.to, params);
	        } else if (!route.to) {
	          pathname = location.pathname;
	        } else {
	          var routeIndex = nextState.routes.indexOf(route);
	          var parentPattern = Redirect.getRoutePattern(nextState.routes, routeIndex - 1);
	          var pattern = parentPattern.replace(/\/*$/, '/') + route.to;
	          pathname = (0, _PatternUtils.formatPattern)(pattern, params);
	        }
	
	        replace({
	          pathname: pathname,
	          query: route.query || location.query,
	          state: route.state || location.state
	        });
	      };
	
	      return route;
	    },
	    getRoutePattern: function getRoutePattern(routes, routeIndex) {
	      var parentPattern = '';
	
	      for (var i = routeIndex; i >= 0; i--) {
	        var route = routes[i];
	        var pattern = route.path || '';
	
	        parentPattern = pattern.replace(/\/*$/, '/') + parentPattern;
	
	        if (pattern.indexOf('/') === 0) break;
	      }
	
	      return '/' + parentPattern;
	    }
	  },
	
	  propTypes: {
	    path: string,
	    from: string, // Alias for path
	    to: string.isRequired,
	    query: object,
	    state: object,
	    onEnter: _InternalPropTypes.falsy,
	    children: _InternalPropTypes.falsy
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<Redirect> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = Redirect;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _RouteUtils = __webpack_require__(167);
	
	var _InternalPropTypes = __webpack_require__(172);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var func = _react2.default.PropTypes.func;
	
	/**
	 * An <IndexRoute> is used to specify its parent's <Route indexRoute> in
	 * a JSX route config.
	 */
	
	var IndexRoute = _react2.default.createClass({
	  displayName: 'IndexRoute',
	
	  statics: {
	    createRouteFromReactElement: function createRouteFromReactElement(element, parentRoute) {
	      /* istanbul ignore else: sanity check */
	      if (parentRoute) {
	        parentRoute.indexRoute = (0, _RouteUtils.createRouteFromReactElement)(element);
	      } else {
	        process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'An <IndexRoute> does not make sense at the root of your route config') : void 0;
	      }
	    }
	  },
	
	  propTypes: {
	    path: _InternalPropTypes.falsy,
	    component: _InternalPropTypes.component,
	    components: _InternalPropTypes.components,
	    getComponent: func,
	    getComponents: func
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<IndexRoute> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = IndexRoute;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _RouteUtils = __webpack_require__(167);
	
	var _InternalPropTypes = __webpack_require__(172);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var _React$PropTypes = _react2.default.PropTypes;
	var string = _React$PropTypes.string;
	var func = _React$PropTypes.func;
	
	/**
	 * A <Route> is used to declare which components are rendered to the
	 * page when the URL matches a given pattern.
	 *
	 * Routes are arranged in a nested tree structure. When a new URL is
	 * requested, the tree is searched depth-first to find a route whose
	 * path matches the URL.  When one is found, all routes in the tree
	 * that lead to it are considered "active" and their components are
	 * rendered into the DOM, nested in the same order as in the tree.
	 */
	
	var Route = _react2.default.createClass({
	  displayName: 'Route',
	
	  statics: {
	    createRouteFromReactElement: _RouteUtils.createRouteFromReactElement
	  },
	
	  propTypes: {
	    path: string,
	    component: _InternalPropTypes.component,
	    components: _InternalPropTypes.components,
	    getComponent: func,
	    getComponents: func
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<Route> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = Route;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _InternalPropTypes = __webpack_require__(172);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	/**
	 * A mixin that adds the "history" instance variable to components.
	 */
	var History = {
	
	  contextTypes: {
	    history: _InternalPropTypes.history
	  },
	
	  componentWillMount: function componentWillMount() {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'the `History` mixin is deprecated, please access `context.router` with your own `contextTypes`. http://tiny.cc/router-historymixin') : void 0;
	    this.history = this.context.history;
	  }
	};
	
	exports.default = History;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var object = _react2.default.PropTypes.object;
	
	/**
	 * The Lifecycle mixin adds the routerWillLeave lifecycle method to a
	 * component that may be used to cancel a transition or prompt the user
	 * for confirmation.
	 *
	 * On standard transitions, routerWillLeave receives a single argument: the
	 * location we're transitioning to. To cancel the transition, return false.
	 * To prompt the user for confirmation, return a prompt message (string).
	 *
	 * During the beforeunload event (assuming you're using the useBeforeUnload
	 * history enhancer), routerWillLeave does not receive a location object
	 * because it isn't possible for us to know the location we're transitioning
	 * to. In this case routerWillLeave must return a prompt message to prevent
	 * the user from closing the window/tab.
	 */
	
	var Lifecycle = {
	
	  contextTypes: {
	    history: object.isRequired,
	    // Nested children receive the route as context, either
	    // set by the route component using the RouteContext mixin
	    // or by some other ancestor.
	    route: object
	  },
	
	  propTypes: {
	    // Route components receive the route object as a prop.
	    route: object
	  },
	
	  componentDidMount: function componentDidMount() {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'the `Lifecycle` mixin is deprecated, please use `context.router.setRouteLeaveHook(route, hook)`. http://tiny.cc/router-lifecyclemixin') : void 0;
	    !this.routerWillLeave ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'The Lifecycle mixin requires you to define a routerWillLeave method') : (0, _invariant2.default)(false) : void 0;
	
	    var route = this.props.route || this.context.route;
	
	    !route ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'The Lifecycle mixin must be used on either a) a <Route component> or ' + 'b) a descendant of a <Route component> that uses the RouteContext mixin') : (0, _invariant2.default)(false) : void 0;
	
	    this._unlistenBeforeLeavingRoute = this.context.history.listenBeforeLeavingRoute(route, this.routerWillLeave);
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    if (this._unlistenBeforeLeavingRoute) this._unlistenBeforeLeavingRoute();
	  }
	};
	
	exports.default = Lifecycle;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var object = _react2.default.PropTypes.object;
	
	/**
	 * The RouteContext mixin provides a convenient way for route
	 * components to set the route in context. This is needed for
	 * routes that render elements that want to use the Lifecycle
	 * mixin to prevent transitions.
	 */
	
	var RouteContext = {
	
	  propTypes: {
	    route: object.isRequired
	  },
	
	  childContextTypes: {
	    route: object.isRequired
	  },
	
	  getChildContext: function getChildContext() {
	    return {
	      route: this.props.route
	    };
	  },
	  componentWillMount: function componentWillMount() {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'The `RouteContext` mixin is deprecated. You can provide `this.props.route` on context with your own `contextTypes`. http://tiny.cc/router-routecontextmixin') : void 0;
	  }
	};
	
	exports.default = RouteContext;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _useQueries = __webpack_require__(192);
	
	var _useQueries2 = _interopRequireDefault(_useQueries);
	
	var _createTransitionManager = __webpack_require__(195);
	
	var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	  var target = {};for (var i in obj) {
	    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	  }return target;
	}
	
	/**
	 * Returns a new createHistory function that may be used to create
	 * history objects that know about routing.
	 *
	 * Enhances history objects with the following methods:
	 *
	 * - listen((error, nextState) => {})
	 * - listenBeforeLeavingRoute(route, (nextLocation) => {})
	 * - match(location, (error, redirectLocation, nextState) => {})
	 * - isActive(pathname, query, indexOnly=false)
	 */
	function useRoutes(createHistory) {
	  process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`useRoutes` is deprecated. Please use `createTransitionManager` instead.') : void 0;
	
	  return function () {
	    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    var routes = _ref.routes;
	
	    var options = _objectWithoutProperties(_ref, ['routes']);
	
	    var history = (0, _useQueries2.default)(createHistory)(options);
	    var transitionManager = (0, _createTransitionManager2.default)(history, routes);
	    return _extends({}, history, transitionManager);
	  };
	}
	
	exports.default = useRoutes;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _RouterContext = __webpack_require__(203);
	
	var _RouterContext2 = _interopRequireDefault(_RouterContext);
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var RoutingContext = _react2.default.createClass({
	  displayName: 'RoutingContext',
	  componentWillMount: function componentWillMount() {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`RoutingContext` has been renamed to `RouterContext`. Please use `import { RouterContext } from \'react-router\'`. http://tiny.cc/router-routercontext') : void 0;
	  },
	  render: function render() {
	    return _react2.default.createElement(_RouterContext2.default, this.props);
	  }
	});
	
	exports.default = RoutingContext;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _Actions = __webpack_require__(178);
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _createMemoryHistory = __webpack_require__(220);
	
	var _createMemoryHistory2 = _interopRequireDefault(_createMemoryHistory);
	
	var _createTransitionManager = __webpack_require__(195);
	
	var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);
	
	var _RouteUtils = __webpack_require__(167);
	
	var _RouterUtils = __webpack_require__(205);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	  var target = {};for (var i in obj) {
	    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	  }return target;
	}
	
	/**
	 * A high-level API to be used for server-side rendering.
	 *
	 * This function matches a location to a set of routes and calls
	 * callback(error, redirectLocation, renderProps) when finished.
	 *
	 * Note: You probably don't want to use this in a browser unless you're using
	 * server-side rendering with async routes.
	 */
	function match(_ref, callback) {
	  var history = _ref.history;
	  var routes = _ref.routes;
	  var location = _ref.location;
	
	  var options = _objectWithoutProperties(_ref, ['history', 'routes', 'location']);
	
	  !(history || location) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'match needs a history or a location') : (0, _invariant2.default)(false) : void 0;
	
	  history = history ? history : (0, _createMemoryHistory2.default)(options);
	  var transitionManager = (0, _createTransitionManager2.default)(history, (0, _RouteUtils.createRoutes)(routes));
	
	  var unlisten = void 0;
	
	  if (location) {
	    // Allow match({ location: '/the/path', ... })
	    location = history.createLocation(location);
	  } else {
	    // Pick up the location from the history via synchronous history.listen
	    // call if needed.
	    unlisten = history.listen(function (historyLocation) {
	      location = historyLocation;
	    });
	  }
	
	  var router = (0, _RouterUtils.createRouterObject)(history, transitionManager);
	  history = (0, _RouterUtils.createRoutingHistory)(history, transitionManager);
	
	  transitionManager.match(location, function (error, redirectLocation, nextState) {
	    callback(error, redirectLocation && router.createLocation(redirectLocation, _Actions.REPLACE), nextState && _extends({}, nextState, {
	      history: history,
	      router: router,
	      matchContext: { history: history, transitionManager: transitionManager, router: router }
	    }));
	
	    // Defer removing the listener to here to prevent DOM histories from having
	    // to unwind DOM event listeners unnecessarily, in case callback renders a
	    // <Router> and attaches another history listener.
	    if (unlisten) {
	      unlisten();
	    }
	  });
	}
	
	exports.default = match;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.default = createMemoryHistory;
	
	var _useQueries = __webpack_require__(192);
	
	var _useQueries2 = _interopRequireDefault(_useQueries);
	
	var _useBasename = __webpack_require__(221);
	
	var _useBasename2 = _interopRequireDefault(_useBasename);
	
	var _createMemoryHistory = __webpack_require__(222);
	
	var _createMemoryHistory2 = _interopRequireDefault(_createMemoryHistory);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function createMemoryHistory(options) {
	  // signatures and type checking differ between `useRoutes` and
	  // `createMemoryHistory`, have to create `memoryHistory` first because
	  // `useQueries` doesn't understand the signature
	  var memoryHistory = (0, _createMemoryHistory2.default)(options);
	  var createHistory = function createHistory() {
	    return memoryHistory;
	  };
	  var history = (0, _useQueries2.default)((0, _useBasename2.default)(createHistory))(options);
	  history.__v2_compatible__ = true;
	  return history;
	}
	module.exports = exports['default'];

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(177);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _ExecutionEnvironment = __webpack_require__(180);
	
	var _PathUtils = __webpack_require__(179);
	
	var _runTransitionHook = __webpack_require__(190);
	
	var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);
	
	var _deprecate = __webpack_require__(191);
	
	var _deprecate2 = _interopRequireDefault(_deprecate);
	
	function useBasename(createHistory) {
	  return function () {
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    var history = createHistory(options);
	
	    var basename = options.basename;
	
	    var checkedBaseHref = false;
	
	    function checkBaseHref() {
	      if (checkedBaseHref) {
	        return;
	      }
	
	      // Automatically use the value of <base href> in HTML
	      // documents as basename if it's not explicitly given.
	      if (basename == null && _ExecutionEnvironment.canUseDOM) {
	        var base = document.getElementsByTagName('base')[0];
	        var baseHref = base && base.getAttribute('href');
	
	        if (baseHref != null) {
	          basename = baseHref;
	
	          process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'Automatically setting basename using <base href> is deprecated and will ' + 'be removed in the next major release. The semantics of <base href> are ' + 'subtly different from basename. Please pass the basename explicitly in ' + 'the options to createHistory') : undefined;
	        }
	      }
	
	      checkedBaseHref = true;
	    }
	
	    function addBasename(location) {
	      checkBaseHref();
	
	      if (basename && location.basename == null) {
	        if (location.pathname.indexOf(basename) === 0) {
	          location.pathname = location.pathname.substring(basename.length);
	          location.basename = basename;
	
	          if (location.pathname === '') location.pathname = '/';
	        } else {
	          location.basename = '';
	        }
	      }
	
	      return location;
	    }
	
	    function prependBasename(location) {
	      checkBaseHref();
	
	      if (!basename) return location;
	
	      if (typeof location === 'string') location = _PathUtils.parsePath(location);
	
	      var pname = location.pathname;
	      var normalizedBasename = basename.slice(-1) === '/' ? basename : basename + '/';
	      var normalizedPathname = pname.charAt(0) === '/' ? pname.slice(1) : pname;
	      var pathname = normalizedBasename + normalizedPathname;
	
	      return _extends({}, location, {
	        pathname: pathname
	      });
	    }
	
	    // Override all read methods with basename-aware versions.
	    function listenBefore(hook) {
	      return history.listenBefore(function (location, callback) {
	        _runTransitionHook2['default'](hook, addBasename(location), callback);
	      });
	    }
	
	    function listen(listener) {
	      return history.listen(function (location) {
	        listener(addBasename(location));
	      });
	    }
	
	    // Override all write methods with basename-aware versions.
	    function push(location) {
	      history.push(prependBasename(location));
	    }
	
	    function replace(location) {
	      history.replace(prependBasename(location));
	    }
	
	    function createPath(location) {
	      return history.createPath(prependBasename(location));
	    }
	
	    function createHref(location) {
	      return history.createHref(prependBasename(location));
	    }
	
	    function createLocation(location) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      return addBasename(history.createLocation.apply(history, [prependBasename(location)].concat(args)));
	    }
	
	    // deprecated
	    function pushState(state, path) {
	      if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	      push(_extends({ state: state }, path));
	    }
	
	    // deprecated
	    function replaceState(state, path) {
	      if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	      replace(_extends({ state: state }, path));
	    }
	
	    return _extends({}, history, {
	      listenBefore: listenBefore,
	      listen: listen,
	      push: push,
	      replace: replace,
	      createPath: createPath,
	      createHref: createHref,
	      createLocation: createLocation,
	
	      pushState: _deprecate2['default'](pushState, 'pushState is deprecated; use push instead'),
	      replaceState: _deprecate2['default'](replaceState, 'replaceState is deprecated; use replace instead')
	    });
	  };
	}
	
	exports['default'] = useBasename;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(177);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _PathUtils = __webpack_require__(179);
	
	var _Actions = __webpack_require__(178);
	
	var _createHistory = __webpack_require__(184);
	
	var _createHistory2 = _interopRequireDefault(_createHistory);
	
	function createStateStorage(entries) {
	  return entries.filter(function (entry) {
	    return entry.state;
	  }).reduce(function (memo, entry) {
	    memo[entry.key] = entry.state;
	    return memo;
	  }, {});
	}
	
	function createMemoryHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  if (Array.isArray(options)) {
	    options = { entries: options };
	  } else if (typeof options === 'string') {
	    options = { entries: [options] };
	  }
	
	  var history = _createHistory2['default'](_extends({}, options, {
	    getCurrentLocation: getCurrentLocation,
	    finishTransition: finishTransition,
	    saveState: saveState,
	    go: go
	  }));
	
	  var _options = options;
	  var entries = _options.entries;
	  var current = _options.current;
	
	  if (typeof entries === 'string') {
	    entries = [entries];
	  } else if (!Array.isArray(entries)) {
	    entries = ['/'];
	  }
	
	  entries = entries.map(function (entry) {
	    var key = history.createKey();
	
	    if (typeof entry === 'string') return { pathname: entry, key: key };
	
	    if ((typeof entry === 'undefined' ? 'undefined' : _typeof(entry)) === 'object' && entry) return _extends({}, entry, { key: key });
	
	     true ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Unable to create history entry from %s', entry) : _invariant2['default'](false) : undefined;
	  });
	
	  if (current == null) {
	    current = entries.length - 1;
	  } else {
	    !(current >= 0 && current < entries.length) ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Current index must be >= 0 and < %s, was %s', entries.length, current) : _invariant2['default'](false) : undefined;
	  }
	
	  var storage = createStateStorage(entries);
	
	  function saveState(key, state) {
	    storage[key] = state;
	  }
	
	  function readState(key) {
	    return storage[key];
	  }
	
	  function getCurrentLocation() {
	    var entry = entries[current];
	    var basename = entry.basename;
	    var pathname = entry.pathname;
	    var search = entry.search;
	
	    var path = (basename || '') + pathname + (search || '');
	
	    var key = undefined,
	        state = undefined;
	    if (entry.key) {
	      key = entry.key;
	      state = readState(key);
	    } else {
	      key = history.createKey();
	      state = null;
	      entry.key = key;
	    }
	
	    var location = _PathUtils.parsePath(path);
	
	    return history.createLocation(_extends({}, location, { state: state }), undefined, key);
	  }
	
	  function canGo(n) {
	    var index = current + n;
	    return index >= 0 && index < entries.length;
	  }
	
	  function go(n) {
	    if (n) {
	      if (!canGo(n)) {
	        process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'Cannot go(%s) there is not enough history', n) : undefined;
	        return;
	      }
	
	      current += n;
	
	      var currentLocation = getCurrentLocation();
	
	      // change action to POP
	      history.transitionTo(_extends({}, currentLocation, { action: _Actions.POP }));
	    }
	  }
	
	  function finishTransition(location) {
	    switch (location.action) {
	      case _Actions.PUSH:
	        current += 1;
	
	        // if we are not on the top of stack
	        // remove rest and push new
	        if (current < entries.length) entries.splice(current);
	
	        entries.push(location);
	        saveState(location.key, location.state);
	        break;
	      case _Actions.REPLACE:
	        entries[current] = location;
	        saveState(location.key, location.state);
	        break;
	    }
	  }
	
	  return history;
	}
	
	exports['default'] = createMemoryHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.default = useRouterHistory;
	
	var _useQueries = __webpack_require__(192);
	
	var _useQueries2 = _interopRequireDefault(_useQueries);
	
	var _useBasename = __webpack_require__(221);
	
	var _useBasename2 = _interopRequireDefault(_useBasename);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function useRouterHistory(createHistory) {
	  return function (options) {
	    var history = (0, _useQueries2.default)((0, _useBasename2.default)(createHistory))(options);
	    history.__v2_compatible__ = true;
	    return history;
	  };
	}
	module.exports = exports['default'];

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _RouterContext = __webpack_require__(203);
	
	var _RouterContext2 = _interopRequireDefault(_RouterContext);
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	exports.default = function () {
	  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    middlewares.forEach(function (middleware, index) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(middleware.renderRouterContext || middleware.renderRouteComponent, 'The middleware specified at index ' + index + ' does not appear to be ' + 'a valid React Router middleware.') : void 0;
	    });
	  }
	
	  var withContext = middlewares.map(function (middleware) {
	    return middleware.renderRouterContext;
	  }).filter(Boolean);
	  var withComponent = middlewares.map(function (middleware) {
	    return middleware.renderRouteComponent;
	  }).filter(Boolean);
	
	  var makeCreateElement = function makeCreateElement() {
	    var baseCreateElement = arguments.length <= 0 || arguments[0] === undefined ? _react.createElement : arguments[0];
	    return function (Component, props) {
	      return withComponent.reduceRight(function (previous, renderRouteComponent) {
	        return renderRouteComponent(previous, props);
	      }, baseCreateElement(Component, props));
	    };
	  };
	
	  return function (renderProps) {
	    return withContext.reduceRight(function (previous, renderRouterContext) {
	      return renderRouterContext(previous, renderProps);
	    }, _react2.default.createElement(_RouterContext2.default, _extends({}, renderProps, {
	      createElement: makeCreateElement(renderProps.createElement)
	    })));
	  };
	};
	
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _createBrowserHistory = __webpack_require__(226);
	
	var _createBrowserHistory2 = _interopRequireDefault(_createBrowserHistory);
	
	var _createRouterHistory = __webpack_require__(227);
	
	var _createRouterHistory2 = _interopRequireDefault(_createRouterHistory);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	exports.default = (0, _createRouterHistory2.default)(_createBrowserHistory2.default);
	module.exports = exports['default'];

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _Actions = __webpack_require__(178);
	
	var _PathUtils = __webpack_require__(179);
	
	var _ExecutionEnvironment = __webpack_require__(180);
	
	var _DOMUtils = __webpack_require__(181);
	
	var _DOMStateStorage = __webpack_require__(182);
	
	var _createDOMHistory = __webpack_require__(183);
	
	var _createDOMHistory2 = _interopRequireDefault(_createDOMHistory);
	
	/**
	 * Creates and returns a history object that uses HTML5's history API
	 * (pushState, replaceState, and the popstate event) to manage history.
	 * This is the recommended method of managing history in browsers because
	 * it provides the cleanest URLs.
	 *
	 * Note: In browsers that do not support the HTML5 history API full
	 * page reloads will be used to preserve URLs.
	 */
	function createBrowserHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Browser history needs a DOM') : _invariant2['default'](false) : undefined;
	
	  var forceRefresh = options.forceRefresh;
	
	  var isSupported = _DOMUtils.supportsHistory();
	  var useRefresh = !isSupported || forceRefresh;
	
	  function getCurrentLocation(historyState) {
	    try {
	      historyState = historyState || window.history.state || {};
	    } catch (e) {
	      historyState = {};
	    }
	
	    var path = _DOMUtils.getWindowPath();
	    var _historyState = historyState;
	    var key = _historyState.key;
	
	    var state = undefined;
	    if (key) {
	      state = _DOMStateStorage.readState(key);
	    } else {
	      state = null;
	      key = history.createKey();
	
	      if (isSupported) window.history.replaceState(_extends({}, historyState, { key: key }), null);
	    }
	
	    var location = _PathUtils.parsePath(path);
	
	    return history.createLocation(_extends({}, location, { state: state }), undefined, key);
	  }
	
	  function startPopStateListener(_ref) {
	    var transitionTo = _ref.transitionTo;
	
	    function popStateListener(event) {
	      if (event.state === undefined) return; // Ignore extraneous popstate events in WebKit.
	
	      transitionTo(getCurrentLocation(event.state));
	    }
	
	    _DOMUtils.addEventListener(window, 'popstate', popStateListener);
	
	    return function () {
	      _DOMUtils.removeEventListener(window, 'popstate', popStateListener);
	    };
	  }
	
	  function finishTransition(location) {
	    var basename = location.basename;
	    var pathname = location.pathname;
	    var search = location.search;
	    var hash = location.hash;
	    var state = location.state;
	    var action = location.action;
	    var key = location.key;
	
	    if (action === _Actions.POP) return; // Nothing to do.
	
	    _DOMStateStorage.saveState(key, state);
	
	    var path = (basename || '') + pathname + search + hash;
	    var historyState = {
	      key: key
	    };
	
	    if (action === _Actions.PUSH) {
	      if (useRefresh) {
	        window.location.href = path;
	        return false; // Prevent location update.
	      } else {
	        window.history.pushState(historyState, null, path);
	      }
	    } else {
	      // REPLACE
	      if (useRefresh) {
	        window.location.replace(path);
	        return false; // Prevent location update.
	      } else {
	        window.history.replaceState(historyState, null, path);
	      }
	    }
	  }
	
	  var history = _createDOMHistory2['default'](_extends({}, options, {
	    getCurrentLocation: getCurrentLocation,
	    finishTransition: finishTransition,
	    saveState: _DOMStateStorage.saveState
	  }));
	
	  var listenerCount = 0,
	      stopPopStateListener = undefined;
	
	  function listenBefore(listener) {
	    if (++listenerCount === 1) stopPopStateListener = startPopStateListener(history);
	
	    var unlisten = history.listenBefore(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopPopStateListener();
	    };
	  }
	
	  function listen(listener) {
	    if (++listenerCount === 1) stopPopStateListener = startPopStateListener(history);
	
	    var unlisten = history.listen(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopPopStateListener();
	    };
	  }
	
	  // deprecated
	  function registerTransitionHook(hook) {
	    if (++listenerCount === 1) stopPopStateListener = startPopStateListener(history);
	
	    history.registerTransitionHook(hook);
	  }
	
	  // deprecated
	  function unregisterTransitionHook(hook) {
	    history.unregisterTransitionHook(hook);
	
	    if (--listenerCount === 0) stopPopStateListener();
	  }
	
	  return _extends({}, history, {
	    listenBefore: listenBefore,
	    listen: listen,
	    registerTransitionHook: registerTransitionHook,
	    unregisterTransitionHook: unregisterTransitionHook
	  });
	}
	
	exports['default'] = createBrowserHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	exports.default = function (createHistory) {
	  var history = void 0;
	  if (canUseDOM) history = (0, _useRouterHistory2.default)(createHistory)();
	  return history;
	};
	
	var _useRouterHistory = __webpack_require__(223);
	
	var _useRouterHistory2 = _interopRequireDefault(_useRouterHistory);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	
	module.exports = exports['default'];

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _createHashHistory = __webpack_require__(176);
	
	var _createHashHistory2 = _interopRequireDefault(_createHashHistory);
	
	var _createRouterHistory = __webpack_require__(227);
	
	var _createRouterHistory2 = _interopRequireDefault(_createRouterHistory);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	exports.default = (0, _createRouterHistory2.default)(_createHashHistory2.default);
	module.exports = exports['default'];

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(230);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(232)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./app.scss", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./app.scss");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(231)();
	// imports
	
	
	// module
	exports.push([module.id, "@charset \"UTF-8\";\n/**\n * Foundation for Sites by ZURB\n * Version 6.2.3\n * foundation.zurb.com\n * Licensed under MIT Open Source\n */\n/*! normalize.css v3.0.3 | MIT License | github.com/necolas/normalize.css */\n/**\n   * 1. Set default font family to sans-serif.\n   * 2. Prevent iOS and IE text size adjust after device orientation change,\n   *    without disabling user zoom.\n   */\nhtml {\n  font-family: sans-serif;\n  /* 1 */\n  -ms-text-size-adjust: 100%;\n  /* 2 */\n  -webkit-text-size-adjust: 100%;\n  /* 2 */ }\n\n/**\n   * Remove default margin.\n   */\nbody {\n  margin: 0; }\n\n/* HTML5 display definitions\n     ========================================================================== */\n/**\n   * Correct `block` display not defined for any HTML5 element in IE 8/9.\n   * Correct `block` display not defined for `details` or `summary` in IE 10/11\n   * and Firefox.\n   * Correct `block` display not defined for `main` in IE 11.\n   */\narticle,\naside,\ndetails,\nfigcaption,\nfigure,\nfooter,\nheader,\nhgroup,\nmain,\nmenu,\nnav,\nsection,\nsummary {\n  display: block; }\n\n/**\n   * 1. Correct `inline-block` display not defined in IE 8/9.\n   * 2. Normalize vertical alignment of `progress` in Chrome, Firefox, and Opera.\n   */\naudio,\ncanvas,\nprogress,\nvideo {\n  display: inline-block;\n  /* 1 */\n  vertical-align: baseline;\n  /* 2 */ }\n\n/**\n   * Prevent modern browsers from displaying `audio` without controls.\n   * Remove excess height in iOS 5 devices.\n   */\naudio:not([controls]) {\n  display: none;\n  height: 0; }\n\n/**\n   * Address `[hidden]` styling not present in IE 8/9/10.\n   * Hide the `template` element in IE 8/9/10/11, Safari, and Firefox < 22.\n   */\n[hidden],\ntemplate {\n  display: none; }\n\n/* Links\n     ========================================================================== */\n/**\n   * Remove the gray background color from active links in IE 10.\n   */\na {\n  background-color: transparent; }\n\n/**\n   * Improve readability of focused elements when they are also in an\n   * active/hover state.\n   */\na:active,\na:hover {\n  outline: 0; }\n\n/* Text-level semantics\n     ========================================================================== */\n/**\n   * Address styling not present in IE 8/9/10/11, Safari, and Chrome.\n   */\nabbr[title] {\n  border-bottom: 1px dotted; }\n\n/**\n   * Address style set to `bolder` in Firefox 4+, Safari, and Chrome.\n   */\nb,\nstrong {\n  font-weight: bold; }\n\n/**\n   * Address styling not present in Safari and Chrome.\n   */\ndfn {\n  font-style: italic; }\n\n/**\n   * Address variable `h1` font-size and margin within `section` and `article`\n   * contexts in Firefox 4+, Safari, and Chrome.\n   */\nh1 {\n  font-size: 2em;\n  margin: 0.67em 0; }\n\n/**\n   * Address styling not present in IE 8/9.\n   */\nmark {\n  background: #ff0;\n  color: #000; }\n\n/**\n   * Address inconsistent and variable font size in all browsers.\n   */\nsmall {\n  font-size: 80%; }\n\n/**\n   * Prevent `sub` and `sup` affecting `line-height` in all browsers.\n   */\nsub,\nsup {\n  font-size: 75%;\n  line-height: 0;\n  position: relative;\n  vertical-align: baseline; }\n\nsup {\n  top: -0.5em; }\n\nsub {\n  bottom: -0.25em; }\n\n/* Embedded content\n     ========================================================================== */\n/**\n   * Remove border when inside `a` element in IE 8/9/10.\n   */\nimg {\n  border: 0; }\n\n/**\n   * Correct overflow not hidden in IE 9/10/11.\n   */\nsvg:not(:root) {\n  overflow: hidden; }\n\n/* Grouping content\n     ========================================================================== */\n/**\n   * Address margin not present in IE 8/9 and Safari.\n   */\nfigure {\n  margin: 1em 40px; }\n\n/**\n   * Address differences between Firefox and other browsers.\n   */\nhr {\n  box-sizing: content-box;\n  height: 0; }\n\n/**\n   * Contain overflow in all browsers.\n   */\npre {\n  overflow: auto; }\n\n/**\n   * Address odd `em`-unit font size rendering in all browsers.\n   */\ncode,\nkbd,\npre,\nsamp {\n  font-family: monospace, monospace;\n  font-size: 1em; }\n\n/* Forms\n     ========================================================================== */\n/**\n   * Known limitation: by default, Chrome and Safari on OS X allow very limited\n   * styling of `select`, unless a `border` property is set.\n   */\n/**\n   * 1. Correct color not being inherited.\n   *    Known issue: affects color of disabled elements.\n   * 2. Correct font properties not being inherited.\n   * 3. Address margins set differently in Firefox 4+, Safari, and Chrome.\n   */\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n  color: inherit;\n  /* 1 */\n  font: inherit;\n  /* 2 */\n  margin: 0;\n  /* 3 */ }\n\n/**\n   * Address `overflow` set to `hidden` in IE 8/9/10/11.\n   */\nbutton {\n  overflow: visible; }\n\n/**\n   * Address inconsistent `text-transform` inheritance for `button` and `select`.\n   * All other form control elements do not inherit `text-transform` values.\n   * Correct `button` style inheritance in Firefox, IE 8/9/10/11, and Opera.\n   * Correct `select` style inheritance in Firefox.\n   */\nbutton,\nselect {\n  text-transform: none; }\n\n/**\n   * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`\n   *    and `video` controls.\n   * 2. Correct inability to style clickable `input` types in iOS.\n   * 3. Improve usability and consistency of cursor style between image-type\n   *    `input` and others.\n   */\nbutton,\nhtml input[type=\"button\"],\ninput[type=\"reset\"],\ninput[type=\"submit\"] {\n  -webkit-appearance: button;\n  /* 2 */\n  cursor: pointer;\n  /* 3 */ }\n\n/**\n   * Re-set default cursor for disabled elements.\n   */\nbutton[disabled],\nhtml input[disabled] {\n  cursor: not-allowed; }\n\n/**\n   * Remove inner padding and border in Firefox 4+.\n   */\nbutton::-moz-focus-inner,\ninput::-moz-focus-inner {\n  border: 0;\n  padding: 0; }\n\n/**\n   * Address Firefox 4+ setting `line-height` on `input` using `!important` in\n   * the UA stylesheet.\n   */\ninput {\n  line-height: normal; }\n\n/**\n   * It's recommended that you don't attempt to style these elements.\n   * Firefox's implementation doesn't respect box-sizing, padding, or width.\n   *\n   * 1. Address box sizing set to `content-box` in IE 8/9/10.\n   * 2. Remove excess padding in IE 8/9/10.\n   */\ninput[type=\"checkbox\"],\ninput[type=\"radio\"] {\n  box-sizing: border-box;\n  /* 1 */\n  padding: 0;\n  /* 2 */ }\n\n/**\n   * Fix the cursor style for Chrome's increment/decrement buttons. For certain\n   * `font-size` values of the `input`, it causes the cursor style of the\n   * decrement button to change from `default` to `text`.\n   */\ninput[type=\"number\"]::-webkit-inner-spin-button,\ninput[type=\"number\"]::-webkit-outer-spin-button {\n  height: auto; }\n\n/**\n   * 1. Address `appearance` set to `searchfield` in Safari and Chrome.\n   * 2. Address `box-sizing` set to `border-box` in Safari and Chrome.\n   */\ninput[type=\"search\"] {\n  -webkit-appearance: textfield;\n  /* 1 */\n  box-sizing: content-box;\n  /* 2 */ }\n\n/**\n   * Remove inner padding and search cancel button in Safari and Chrome on OS X.\n   * Safari (but not Chrome) clips the cancel button when the search input has\n   * padding (and `textfield` appearance).\n   */\ninput[type=\"search\"]::-webkit-search-cancel-button,\ninput[type=\"search\"]::-webkit-search-decoration {\n  -webkit-appearance: none; }\n\n/**\n   * Define consistent border, margin, and padding.\n   * [NOTE] We don't enable this ruleset in Foundation, because we want the <fieldset> element to have plain styling.\n   */\n/* fieldset {\n    border: 1px solid #c0c0c0;\n    margin: 0 2px;\n    padding: 0.35em 0.625em 0.75em;\n  } */\n/**\n   * 1. Correct `color` not being inherited in IE 8/9/10/11.\n   * 2. Remove padding so people aren't caught out if they zero out fieldsets.\n   */\nlegend {\n  border: 0;\n  /* 1 */\n  padding: 0;\n  /* 2 */ }\n\n/**\n   * Remove default vertical scrollbar in IE 8/9/10/11.\n   */\ntextarea {\n  overflow: auto; }\n\n/**\n   * Don't inherit the `font-weight` (applied by a rule above).\n   * NOTE: the default cannot safely be changed in Chrome and Safari on OS X.\n   */\noptgroup {\n  font-weight: bold; }\n\n/* Tables\n     ========================================================================== */\n/**\n   * Remove most spacing between table cells.\n   */\ntable {\n  border-collapse: collapse;\n  border-spacing: 0; }\n\ntd,\nth {\n  padding: 0; }\n\n.foundation-mq {\n  font-family: \"small=0em&medium=40em&large=64em&xlarge=75em&xxlarge=90em\"; }\n\nhtml {\n  font-size: 100%;\n  box-sizing: border-box; }\n\n*,\n*::before,\n*::after {\n  box-sizing: inherit; }\n\nbody {\n  padding: 0;\n  margin: 0;\n  font-family: \"Helvetica Neue\", Helvetica, Roboto, Arial, sans-serif;\n  font-weight: normal;\n  line-height: 1.5;\n  color: #0a0a0a;\n  background: #fefefe;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale; }\n\nimg {\n  max-width: 100%;\n  height: auto;\n  -ms-interpolation-mode: bicubic;\n  display: inline-block;\n  vertical-align: middle; }\n\ntextarea {\n  height: auto;\n  min-height: 50px;\n  border-radius: 0; }\n\nselect {\n  width: 100%;\n  border-radius: 0; }\n\n#map_canvas img,\n#map_canvas embed,\n#map_canvas object,\n.map_canvas img,\n.map_canvas embed,\n.map_canvas object,\n.mqa-display img,\n.mqa-display embed,\n.mqa-display object {\n  max-width: none !important; }\n\nbutton {\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  background: transparent;\n  padding: 0;\n  border: 0;\n  border-radius: 0;\n  line-height: 1; }\n  [data-whatinput='mouse'] button {\n    outline: 0; }\n\n.is-visible {\n  display: block !important; }\n\n.is-hidden {\n  display: none !important; }\n\n.row {\n  max-width: 75rem;\n  margin-left: auto;\n  margin-right: auto; }\n  .row::before, .row::after {\n    content: ' ';\n    display: table; }\n  .row::after {\n    clear: both; }\n  .row.collapse > .column, .row.collapse > .columns {\n    padding-left: 0;\n    padding-right: 0; }\n  .row .row {\n    max-width: none;\n    margin-left: -0.625rem;\n    margin-right: -0.625rem; }\n    @media screen and (min-width: 40em) {\n      .row .row {\n        margin-left: -0.9375rem;\n        margin-right: -0.9375rem; } }\n    .row .row.collapse {\n      margin-left: 0;\n      margin-right: 0; }\n  .row.expanded {\n    max-width: none; }\n    .row.expanded .row {\n      margin-left: auto;\n      margin-right: auto; }\n\n.column, .columns {\n  width: 100%;\n  float: left;\n  padding-left: 0.625rem;\n  padding-right: 0.625rem; }\n  @media screen and (min-width: 40em) {\n    .column, .columns {\n      padding-left: 0.9375rem;\n      padding-right: 0.9375rem; } }\n  .column:last-child:not(:first-child), .columns:last-child:not(:first-child) {\n    float: right; }\n  .column.end:last-child:last-child, .end.columns:last-child:last-child {\n    float: left; }\n\n.column.row.row, .row.row.columns {\n  float: none; }\n  .row .column.row.row, .row .row.row.columns {\n    padding-left: 0;\n    padding-right: 0;\n    margin-left: 0;\n    margin-right: 0; }\n\n.small-1 {\n  width: 8.33333%; }\n\n.small-push-1 {\n  position: relative;\n  left: 8.33333%; }\n\n.small-pull-1 {\n  position: relative;\n  left: -8.33333%; }\n\n.small-offset-0 {\n  margin-left: 0%; }\n\n.small-2 {\n  width: 16.66667%; }\n\n.small-push-2 {\n  position: relative;\n  left: 16.66667%; }\n\n.small-pull-2 {\n  position: relative;\n  left: -16.66667%; }\n\n.small-offset-1 {\n  margin-left: 8.33333%; }\n\n.small-3 {\n  width: 25%; }\n\n.small-push-3 {\n  position: relative;\n  left: 25%; }\n\n.small-pull-3 {\n  position: relative;\n  left: -25%; }\n\n.small-offset-2 {\n  margin-left: 16.66667%; }\n\n.small-4 {\n  width: 33.33333%; }\n\n.small-push-4 {\n  position: relative;\n  left: 33.33333%; }\n\n.small-pull-4 {\n  position: relative;\n  left: -33.33333%; }\n\n.small-offset-3 {\n  margin-left: 25%; }\n\n.small-5 {\n  width: 41.66667%; }\n\n.small-push-5 {\n  position: relative;\n  left: 41.66667%; }\n\n.small-pull-5 {\n  position: relative;\n  left: -41.66667%; }\n\n.small-offset-4 {\n  margin-left: 33.33333%; }\n\n.small-6 {\n  width: 50%; }\n\n.small-push-6 {\n  position: relative;\n  left: 50%; }\n\n.small-pull-6 {\n  position: relative;\n  left: -50%; }\n\n.small-offset-5 {\n  margin-left: 41.66667%; }\n\n.small-7 {\n  width: 58.33333%; }\n\n.small-push-7 {\n  position: relative;\n  left: 58.33333%; }\n\n.small-pull-7 {\n  position: relative;\n  left: -58.33333%; }\n\n.small-offset-6 {\n  margin-left: 50%; }\n\n.small-8 {\n  width: 66.66667%; }\n\n.small-push-8 {\n  position: relative;\n  left: 66.66667%; }\n\n.small-pull-8 {\n  position: relative;\n  left: -66.66667%; }\n\n.small-offset-7 {\n  margin-left: 58.33333%; }\n\n.small-9 {\n  width: 75%; }\n\n.small-push-9 {\n  position: relative;\n  left: 75%; }\n\n.small-pull-9 {\n  position: relative;\n  left: -75%; }\n\n.small-offset-8 {\n  margin-left: 66.66667%; }\n\n.small-10 {\n  width: 83.33333%; }\n\n.small-push-10 {\n  position: relative;\n  left: 83.33333%; }\n\n.small-pull-10 {\n  position: relative;\n  left: -83.33333%; }\n\n.small-offset-9 {\n  margin-left: 75%; }\n\n.small-11 {\n  width: 91.66667%; }\n\n.small-push-11 {\n  position: relative;\n  left: 91.66667%; }\n\n.small-pull-11 {\n  position: relative;\n  left: -91.66667%; }\n\n.small-offset-10 {\n  margin-left: 83.33333%; }\n\n.small-12 {\n  width: 100%; }\n\n.small-offset-11 {\n  margin-left: 91.66667%; }\n\n.small-up-1 > .column, .small-up-1 > .columns {\n  width: 100%;\n  float: left; }\n  .small-up-1 > .column:nth-of-type(1n), .small-up-1 > .columns:nth-of-type(1n) {\n    clear: none; }\n  .small-up-1 > .column:nth-of-type(1n+1), .small-up-1 > .columns:nth-of-type(1n+1) {\n    clear: both; }\n  .small-up-1 > .column:last-child, .small-up-1 > .columns:last-child {\n    float: left; }\n\n.small-up-2 > .column, .small-up-2 > .columns {\n  width: 50%;\n  float: left; }\n  .small-up-2 > .column:nth-of-type(1n), .small-up-2 > .columns:nth-of-type(1n) {\n    clear: none; }\n  .small-up-2 > .column:nth-of-type(2n+1), .small-up-2 > .columns:nth-of-type(2n+1) {\n    clear: both; }\n  .small-up-2 > .column:last-child, .small-up-2 > .columns:last-child {\n    float: left; }\n\n.small-up-3 > .column, .small-up-3 > .columns {\n  width: 33.33333%;\n  float: left; }\n  .small-up-3 > .column:nth-of-type(1n), .small-up-3 > .columns:nth-of-type(1n) {\n    clear: none; }\n  .small-up-3 > .column:nth-of-type(3n+1), .small-up-3 > .columns:nth-of-type(3n+1) {\n    clear: both; }\n  .small-up-3 > .column:last-child, .small-up-3 > .columns:last-child {\n    float: left; }\n\n.small-up-4 > .column, .small-up-4 > .columns {\n  width: 25%;\n  float: left; }\n  .small-up-4 > .column:nth-of-type(1n), .small-up-4 > .columns:nth-of-type(1n) {\n    clear: none; }\n  .small-up-4 > .column:nth-of-type(4n+1), .small-up-4 > .columns:nth-of-type(4n+1) {\n    clear: both; }\n  .small-up-4 > .column:last-child, .small-up-4 > .columns:last-child {\n    float: left; }\n\n.small-up-5 > .column, .small-up-5 > .columns {\n  width: 20%;\n  float: left; }\n  .small-up-5 > .column:nth-of-type(1n), .small-up-5 > .columns:nth-of-type(1n) {\n    clear: none; }\n  .small-up-5 > .column:nth-of-type(5n+1), .small-up-5 > .columns:nth-of-type(5n+1) {\n    clear: both; }\n  .small-up-5 > .column:last-child, .small-up-5 > .columns:last-child {\n    float: left; }\n\n.small-up-6 > .column, .small-up-6 > .columns {\n  width: 16.66667%;\n  float: left; }\n  .small-up-6 > .column:nth-of-type(1n), .small-up-6 > .columns:nth-of-type(1n) {\n    clear: none; }\n  .small-up-6 > .column:nth-of-type(6n+1), .small-up-6 > .columns:nth-of-type(6n+1) {\n    clear: both; }\n  .small-up-6 > .column:last-child, .small-up-6 > .columns:last-child {\n    float: left; }\n\n.small-up-7 > .column, .small-up-7 > .columns {\n  width: 14.28571%;\n  float: left; }\n  .small-up-7 > .column:nth-of-type(1n), .small-up-7 > .columns:nth-of-type(1n) {\n    clear: none; }\n  .small-up-7 > .column:nth-of-type(7n+1), .small-up-7 > .columns:nth-of-type(7n+1) {\n    clear: both; }\n  .small-up-7 > .column:last-child, .small-up-7 > .columns:last-child {\n    float: left; }\n\n.small-up-8 > .column, .small-up-8 > .columns {\n  width: 12.5%;\n  float: left; }\n  .small-up-8 > .column:nth-of-type(1n), .small-up-8 > .columns:nth-of-type(1n) {\n    clear: none; }\n  .small-up-8 > .column:nth-of-type(8n+1), .small-up-8 > .columns:nth-of-type(8n+1) {\n    clear: both; }\n  .small-up-8 > .column:last-child, .small-up-8 > .columns:last-child {\n    float: left; }\n\n.small-collapse > .column, .small-collapse > .columns {\n  padding-left: 0;\n  padding-right: 0; }\n\n.small-collapse .row,\n.expanded.row .small-collapse.row {\n  margin-left: 0;\n  margin-right: 0; }\n\n.small-uncollapse > .column, .small-uncollapse > .columns {\n  padding-left: 0.625rem;\n  padding-right: 0.625rem; }\n\n.small-centered {\n  float: none;\n  margin-left: auto;\n  margin-right: auto; }\n\n.small-uncentered,\n.small-push-0,\n.small-pull-0 {\n  position: static;\n  margin-left: 0;\n  margin-right: 0;\n  float: left; }\n\n@media screen and (min-width: 40em) {\n  .medium-1 {\n    width: 8.33333%; }\n  .medium-push-1 {\n    position: relative;\n    left: 8.33333%; }\n  .medium-pull-1 {\n    position: relative;\n    left: -8.33333%; }\n  .medium-offset-0 {\n    margin-left: 0%; }\n  .medium-2 {\n    width: 16.66667%; }\n  .medium-push-2 {\n    position: relative;\n    left: 16.66667%; }\n  .medium-pull-2 {\n    position: relative;\n    left: -16.66667%; }\n  .medium-offset-1 {\n    margin-left: 8.33333%; }\n  .medium-3 {\n    width: 25%; }\n  .medium-push-3 {\n    position: relative;\n    left: 25%; }\n  .medium-pull-3 {\n    position: relative;\n    left: -25%; }\n  .medium-offset-2 {\n    margin-left: 16.66667%; }\n  .medium-4 {\n    width: 33.33333%; }\n  .medium-push-4 {\n    position: relative;\n    left: 33.33333%; }\n  .medium-pull-4 {\n    position: relative;\n    left: -33.33333%; }\n  .medium-offset-3 {\n    margin-left: 25%; }\n  .medium-5 {\n    width: 41.66667%; }\n  .medium-push-5 {\n    position: relative;\n    left: 41.66667%; }\n  .medium-pull-5 {\n    position: relative;\n    left: -41.66667%; }\n  .medium-offset-4 {\n    margin-left: 33.33333%; }\n  .medium-6 {\n    width: 50%; }\n  .medium-push-6 {\n    position: relative;\n    left: 50%; }\n  .medium-pull-6 {\n    position: relative;\n    left: -50%; }\n  .medium-offset-5 {\n    margin-left: 41.66667%; }\n  .medium-7 {\n    width: 58.33333%; }\n  .medium-push-7 {\n    position: relative;\n    left: 58.33333%; }\n  .medium-pull-7 {\n    position: relative;\n    left: -58.33333%; }\n  .medium-offset-6 {\n    margin-left: 50%; }\n  .medium-8 {\n    width: 66.66667%; }\n  .medium-push-8 {\n    position: relative;\n    left: 66.66667%; }\n  .medium-pull-8 {\n    position: relative;\n    left: -66.66667%; }\n  .medium-offset-7 {\n    margin-left: 58.33333%; }\n  .medium-9 {\n    width: 75%; }\n  .medium-push-9 {\n    position: relative;\n    left: 75%; }\n  .medium-pull-9 {\n    position: relative;\n    left: -75%; }\n  .medium-offset-8 {\n    margin-left: 66.66667%; }\n  .medium-10 {\n    width: 83.33333%; }\n  .medium-push-10 {\n    position: relative;\n    left: 83.33333%; }\n  .medium-pull-10 {\n    position: relative;\n    left: -83.33333%; }\n  .medium-offset-9 {\n    margin-left: 75%; }\n  .medium-11 {\n    width: 91.66667%; }\n  .medium-push-11 {\n    position: relative;\n    left: 91.66667%; }\n  .medium-pull-11 {\n    position: relative;\n    left: -91.66667%; }\n  .medium-offset-10 {\n    margin-left: 83.33333%; }\n  .medium-12 {\n    width: 100%; }\n  .medium-offset-11 {\n    margin-left: 91.66667%; }\n  .medium-up-1 > .column, .medium-up-1 > .columns {\n    width: 100%;\n    float: left; }\n    .medium-up-1 > .column:nth-of-type(1n), .medium-up-1 > .columns:nth-of-type(1n) {\n      clear: none; }\n    .medium-up-1 > .column:nth-of-type(1n+1), .medium-up-1 > .columns:nth-of-type(1n+1) {\n      clear: both; }\n    .medium-up-1 > .column:last-child, .medium-up-1 > .columns:last-child {\n      float: left; }\n  .medium-up-2 > .column, .medium-up-2 > .columns {\n    width: 50%;\n    float: left; }\n    .medium-up-2 > .column:nth-of-type(1n), .medium-up-2 > .columns:nth-of-type(1n) {\n      clear: none; }\n    .medium-up-2 > .column:nth-of-type(2n+1), .medium-up-2 > .columns:nth-of-type(2n+1) {\n      clear: both; }\n    .medium-up-2 > .column:last-child, .medium-up-2 > .columns:last-child {\n      float: left; }\n  .medium-up-3 > .column, .medium-up-3 > .columns {\n    width: 33.33333%;\n    float: left; }\n    .medium-up-3 > .column:nth-of-type(1n), .medium-up-3 > .columns:nth-of-type(1n) {\n      clear: none; }\n    .medium-up-3 > .column:nth-of-type(3n+1), .medium-up-3 > .columns:nth-of-type(3n+1) {\n      clear: both; }\n    .medium-up-3 > .column:last-child, .medium-up-3 > .columns:last-child {\n      float: left; }\n  .medium-up-4 > .column, .medium-up-4 > .columns {\n    width: 25%;\n    float: left; }\n    .medium-up-4 > .column:nth-of-type(1n), .medium-up-4 > .columns:nth-of-type(1n) {\n      clear: none; }\n    .medium-up-4 > .column:nth-of-type(4n+1), .medium-up-4 > .columns:nth-of-type(4n+1) {\n      clear: both; }\n    .medium-up-4 > .column:last-child, .medium-up-4 > .columns:last-child {\n      float: left; }\n  .medium-up-5 > .column, .medium-up-5 > .columns {\n    width: 20%;\n    float: left; }\n    .medium-up-5 > .column:nth-of-type(1n), .medium-up-5 > .columns:nth-of-type(1n) {\n      clear: none; }\n    .medium-up-5 > .column:nth-of-type(5n+1), .medium-up-5 > .columns:nth-of-type(5n+1) {\n      clear: both; }\n    .medium-up-5 > .column:last-child, .medium-up-5 > .columns:last-child {\n      float: left; }\n  .medium-up-6 > .column, .medium-up-6 > .columns {\n    width: 16.66667%;\n    float: left; }\n    .medium-up-6 > .column:nth-of-type(1n), .medium-up-6 > .columns:nth-of-type(1n) {\n      clear: none; }\n    .medium-up-6 > .column:nth-of-type(6n+1), .medium-up-6 > .columns:nth-of-type(6n+1) {\n      clear: both; }\n    .medium-up-6 > .column:last-child, .medium-up-6 > .columns:last-child {\n      float: left; }\n  .medium-up-7 > .column, .medium-up-7 > .columns {\n    width: 14.28571%;\n    float: left; }\n    .medium-up-7 > .column:nth-of-type(1n), .medium-up-7 > .columns:nth-of-type(1n) {\n      clear: none; }\n    .medium-up-7 > .column:nth-of-type(7n+1), .medium-up-7 > .columns:nth-of-type(7n+1) {\n      clear: both; }\n    .medium-up-7 > .column:last-child, .medium-up-7 > .columns:last-child {\n      float: left; }\n  .medium-up-8 > .column, .medium-up-8 > .columns {\n    width: 12.5%;\n    float: left; }\n    .medium-up-8 > .column:nth-of-type(1n), .medium-up-8 > .columns:nth-of-type(1n) {\n      clear: none; }\n    .medium-up-8 > .column:nth-of-type(8n+1), .medium-up-8 > .columns:nth-of-type(8n+1) {\n      clear: both; }\n    .medium-up-8 > .column:last-child, .medium-up-8 > .columns:last-child {\n      float: left; }\n  .medium-collapse > .column, .medium-collapse > .columns {\n    padding-left: 0;\n    padding-right: 0; }\n  .medium-collapse .row,\n  .expanded.row .medium-collapse.row {\n    margin-left: 0;\n    margin-right: 0; }\n  .medium-uncollapse > .column, .medium-uncollapse > .columns {\n    padding-left: 0.9375rem;\n    padding-right: 0.9375rem; }\n  .medium-centered {\n    float: none;\n    margin-left: auto;\n    margin-right: auto; }\n  .medium-uncentered,\n  .medium-push-0,\n  .medium-pull-0 {\n    position: static;\n    margin-left: 0;\n    margin-right: 0;\n    float: left; } }\n\n@media screen and (min-width: 64em) {\n  .large-1 {\n    width: 8.33333%; }\n  .large-push-1 {\n    position: relative;\n    left: 8.33333%; }\n  .large-pull-1 {\n    position: relative;\n    left: -8.33333%; }\n  .large-offset-0 {\n    margin-left: 0%; }\n  .large-2 {\n    width: 16.66667%; }\n  .large-push-2 {\n    position: relative;\n    left: 16.66667%; }\n  .large-pull-2 {\n    position: relative;\n    left: -16.66667%; }\n  .large-offset-1 {\n    margin-left: 8.33333%; }\n  .large-3 {\n    width: 25%; }\n  .large-push-3 {\n    position: relative;\n    left: 25%; }\n  .large-pull-3 {\n    position: relative;\n    left: -25%; }\n  .large-offset-2 {\n    margin-left: 16.66667%; }\n  .large-4 {\n    width: 33.33333%; }\n  .large-push-4 {\n    position: relative;\n    left: 33.33333%; }\n  .large-pull-4 {\n    position: relative;\n    left: -33.33333%; }\n  .large-offset-3 {\n    margin-left: 25%; }\n  .large-5 {\n    width: 41.66667%; }\n  .large-push-5 {\n    position: relative;\n    left: 41.66667%; }\n  .large-pull-5 {\n    position: relative;\n    left: -41.66667%; }\n  .large-offset-4 {\n    margin-left: 33.33333%; }\n  .large-6 {\n    width: 50%; }\n  .large-push-6 {\n    position: relative;\n    left: 50%; }\n  .large-pull-6 {\n    position: relative;\n    left: -50%; }\n  .large-offset-5 {\n    margin-left: 41.66667%; }\n  .large-7 {\n    width: 58.33333%; }\n  .large-push-7 {\n    position: relative;\n    left: 58.33333%; }\n  .large-pull-7 {\n    position: relative;\n    left: -58.33333%; }\n  .large-offset-6 {\n    margin-left: 50%; }\n  .large-8 {\n    width: 66.66667%; }\n  .large-push-8 {\n    position: relative;\n    left: 66.66667%; }\n  .large-pull-8 {\n    position: relative;\n    left: -66.66667%; }\n  .large-offset-7 {\n    margin-left: 58.33333%; }\n  .large-9 {\n    width: 75%; }\n  .large-push-9 {\n    position: relative;\n    left: 75%; }\n  .large-pull-9 {\n    position: relative;\n    left: -75%; }\n  .large-offset-8 {\n    margin-left: 66.66667%; }\n  .large-10 {\n    width: 83.33333%; }\n  .large-push-10 {\n    position: relative;\n    left: 83.33333%; }\n  .large-pull-10 {\n    position: relative;\n    left: -83.33333%; }\n  .large-offset-9 {\n    margin-left: 75%; }\n  .large-11 {\n    width: 91.66667%; }\n  .large-push-11 {\n    position: relative;\n    left: 91.66667%; }\n  .large-pull-11 {\n    position: relative;\n    left: -91.66667%; }\n  .large-offset-10 {\n    margin-left: 83.33333%; }\n  .large-12 {\n    width: 100%; }\n  .large-offset-11 {\n    margin-left: 91.66667%; }\n  .large-up-1 > .column, .large-up-1 > .columns {\n    width: 100%;\n    float: left; }\n    .large-up-1 > .column:nth-of-type(1n), .large-up-1 > .columns:nth-of-type(1n) {\n      clear: none; }\n    .large-up-1 > .column:nth-of-type(1n+1), .large-up-1 > .columns:nth-of-type(1n+1) {\n      clear: both; }\n    .large-up-1 > .column:last-child, .large-up-1 > .columns:last-child {\n      float: left; }\n  .large-up-2 > .column, .large-up-2 > .columns {\n    width: 50%;\n    float: left; }\n    .large-up-2 > .column:nth-of-type(1n), .large-up-2 > .columns:nth-of-type(1n) {\n      clear: none; }\n    .large-up-2 > .column:nth-of-type(2n+1), .large-up-2 > .columns:nth-of-type(2n+1) {\n      clear: both; }\n    .large-up-2 > .column:last-child, .large-up-2 > .columns:last-child {\n      float: left; }\n  .large-up-3 > .column, .large-up-3 > .columns {\n    width: 33.33333%;\n    float: left; }\n    .large-up-3 > .column:nth-of-type(1n), .large-up-3 > .columns:nth-of-type(1n) {\n      clear: none; }\n    .large-up-3 > .column:nth-of-type(3n+1), .large-up-3 > .columns:nth-of-type(3n+1) {\n      clear: both; }\n    .large-up-3 > .column:last-child, .large-up-3 > .columns:last-child {\n      float: left; }\n  .large-up-4 > .column, .large-up-4 > .columns {\n    width: 25%;\n    float: left; }\n    .large-up-4 > .column:nth-of-type(1n), .large-up-4 > .columns:nth-of-type(1n) {\n      clear: none; }\n    .large-up-4 > .column:nth-of-type(4n+1), .large-up-4 > .columns:nth-of-type(4n+1) {\n      clear: both; }\n    .large-up-4 > .column:last-child, .large-up-4 > .columns:last-child {\n      float: left; }\n  .large-up-5 > .column, .large-up-5 > .columns {\n    width: 20%;\n    float: left; }\n    .large-up-5 > .column:nth-of-type(1n), .large-up-5 > .columns:nth-of-type(1n) {\n      clear: none; }\n    .large-up-5 > .column:nth-of-type(5n+1), .large-up-5 > .columns:nth-of-type(5n+1) {\n      clear: both; }\n    .large-up-5 > .column:last-child, .large-up-5 > .columns:last-child {\n      float: left; }\n  .large-up-6 > .column, .large-up-6 > .columns {\n    width: 16.66667%;\n    float: left; }\n    .large-up-6 > .column:nth-of-type(1n), .large-up-6 > .columns:nth-of-type(1n) {\n      clear: none; }\n    .large-up-6 > .column:nth-of-type(6n+1), .large-up-6 > .columns:nth-of-type(6n+1) {\n      clear: both; }\n    .large-up-6 > .column:last-child, .large-up-6 > .columns:last-child {\n      float: left; }\n  .large-up-7 > .column, .large-up-7 > .columns {\n    width: 14.28571%;\n    float: left; }\n    .large-up-7 > .column:nth-of-type(1n), .large-up-7 > .columns:nth-of-type(1n) {\n      clear: none; }\n    .large-up-7 > .column:nth-of-type(7n+1), .large-up-7 > .columns:nth-of-type(7n+1) {\n      clear: both; }\n    .large-up-7 > .column:last-child, .large-up-7 > .columns:last-child {\n      float: left; }\n  .large-up-8 > .column, .large-up-8 > .columns {\n    width: 12.5%;\n    float: left; }\n    .large-up-8 > .column:nth-of-type(1n), .large-up-8 > .columns:nth-of-type(1n) {\n      clear: none; }\n    .large-up-8 > .column:nth-of-type(8n+1), .large-up-8 > .columns:nth-of-type(8n+1) {\n      clear: both; }\n    .large-up-8 > .column:last-child, .large-up-8 > .columns:last-child {\n      float: left; }\n  .large-collapse > .column, .large-collapse > .columns {\n    padding-left: 0;\n    padding-right: 0; }\n  .large-collapse .row,\n  .expanded.row .large-collapse.row {\n    margin-left: 0;\n    margin-right: 0; }\n  .large-uncollapse > .column, .large-uncollapse > .columns {\n    padding-left: 0.9375rem;\n    padding-right: 0.9375rem; }\n  .large-centered {\n    float: none;\n    margin-left: auto;\n    margin-right: auto; }\n  .large-uncentered,\n  .large-push-0,\n  .large-pull-0 {\n    position: static;\n    margin-left: 0;\n    margin-right: 0;\n    float: left; } }\n\ndiv,\ndl,\ndt,\ndd,\nul,\nol,\nli,\nh1,\nh2,\nh3,\nh4,\nh5,\nh6,\npre,\nform,\np,\nblockquote,\nth,\ntd {\n  margin: 0;\n  padding: 0; }\n\np {\n  font-size: inherit;\n  line-height: 1.6;\n  margin-bottom: 1rem;\n  text-rendering: optimizeLegibility; }\n\nem,\ni {\n  font-style: italic;\n  line-height: inherit; }\n\nstrong,\nb {\n  font-weight: bold;\n  line-height: inherit; }\n\nsmall {\n  font-size: 80%;\n  line-height: inherit; }\n\nh1,\nh2,\nh3,\nh4,\nh5,\nh6 {\n  font-family: \"Helvetica Neue\", Helvetica, Roboto, Arial, sans-serif;\n  font-weight: normal;\n  font-style: normal;\n  color: inherit;\n  text-rendering: optimizeLegibility;\n  margin-top: 0;\n  margin-bottom: 0.5rem;\n  line-height: 1.4; }\n  h1 small,\n  h2 small,\n  h3 small,\n  h4 small,\n  h5 small,\n  h6 small {\n    color: #cacaca;\n    line-height: 0; }\n\nh1 {\n  font-size: 1.5rem; }\n\nh2 {\n  font-size: 1.25rem; }\n\nh3 {\n  font-size: 1.1875rem; }\n\nh4 {\n  font-size: 1.125rem; }\n\nh5 {\n  font-size: 1.0625rem; }\n\nh6 {\n  font-size: 1rem; }\n\n@media screen and (min-width: 40em) {\n  h1 {\n    font-size: 3rem; }\n  h2 {\n    font-size: 2.5rem; }\n  h3 {\n    font-size: 1.9375rem; }\n  h4 {\n    font-size: 1.5625rem; }\n  h5 {\n    font-size: 1.25rem; }\n  h6 {\n    font-size: 1rem; } }\n\na {\n  color: #2199e8;\n  text-decoration: none;\n  line-height: inherit;\n  cursor: pointer; }\n  a:hover, a:focus {\n    color: #1585cf; }\n  a img {\n    border: 0; }\n\nhr {\n  max-width: 75rem;\n  height: 0;\n  border-right: 0;\n  border-top: 0;\n  border-bottom: 1px solid #cacaca;\n  border-left: 0;\n  margin: 1.25rem auto;\n  clear: both; }\n\nul,\nol,\ndl {\n  line-height: 1.6;\n  margin-bottom: 1rem;\n  list-style-position: outside; }\n\nli {\n  font-size: inherit; }\n\nul {\n  list-style-type: disc;\n  margin-left: 1.25rem; }\n\nol {\n  margin-left: 1.25rem; }\n\nul ul, ol ul, ul ol, ol ol {\n  margin-left: 1.25rem;\n  margin-bottom: 0; }\n\ndl {\n  margin-bottom: 1rem; }\n  dl dt {\n    margin-bottom: 0.3rem;\n    font-weight: bold; }\n\nblockquote {\n  margin: 0 0 1rem;\n  padding: 0.5625rem 1.25rem 0 1.1875rem;\n  border-left: 1px solid #cacaca; }\n  blockquote, blockquote p {\n    line-height: 1.6;\n    color: #8a8a8a; }\n\ncite {\n  display: block;\n  font-size: 0.8125rem;\n  color: #8a8a8a; }\n  cite:before {\n    content: '\\2014    '; }\n\nabbr {\n  color: #0a0a0a;\n  cursor: help;\n  border-bottom: 1px dotted #0a0a0a; }\n\ncode {\n  font-family: Consolas, \"Liberation Mono\", Courier, monospace;\n  font-weight: normal;\n  color: #0a0a0a;\n  background-color: #e6e6e6;\n  border: 1px solid #cacaca;\n  padding: 0.125rem 0.3125rem 0.0625rem; }\n\nkbd {\n  padding: 0.125rem 0.25rem 0;\n  margin: 0;\n  background-color: #e6e6e6;\n  color: #0a0a0a;\n  font-family: Consolas, \"Liberation Mono\", Courier, monospace; }\n\n.subheader {\n  margin-top: 0.2rem;\n  margin-bottom: 0.5rem;\n  font-weight: normal;\n  line-height: 1.4;\n  color: #8a8a8a; }\n\n.lead {\n  font-size: 125%;\n  line-height: 1.6; }\n\n.stat {\n  font-size: 2.5rem;\n  line-height: 1; }\n  p + .stat {\n    margin-top: -1rem; }\n\n.no-bullet {\n  margin-left: 0;\n  list-style: none; }\n\n.text-left {\n  text-align: left; }\n\n.text-right {\n  text-align: right; }\n\n.text-center {\n  text-align: center; }\n\n.text-justify {\n  text-align: justify; }\n\n@media screen and (min-width: 40em) {\n  .medium-text-left {\n    text-align: left; }\n  .medium-text-right {\n    text-align: right; }\n  .medium-text-center {\n    text-align: center; }\n  .medium-text-justify {\n    text-align: justify; } }\n\n@media screen and (min-width: 64em) {\n  .large-text-left {\n    text-align: left; }\n  .large-text-right {\n    text-align: right; }\n  .large-text-center {\n    text-align: center; }\n  .large-text-justify {\n    text-align: justify; } }\n\n.show-for-print {\n  display: none !important; }\n\n@media print {\n  * {\n    background: transparent !important;\n    color: black !important;\n    box-shadow: none !important;\n    text-shadow: none !important; }\n  .show-for-print {\n    display: block !important; }\n  .hide-for-print {\n    display: none !important; }\n  table.show-for-print {\n    display: table !important; }\n  thead.show-for-print {\n    display: table-header-group !important; }\n  tbody.show-for-print {\n    display: table-row-group !important; }\n  tr.show-for-print {\n    display: table-row !important; }\n  td.show-for-print {\n    display: table-cell !important; }\n  th.show-for-print {\n    display: table-cell !important; }\n  a,\n  a:visited {\n    text-decoration: underline; }\n  a[href]:after {\n    content: \" (\" attr(href) \")\"; }\n  .ir a:after,\n  a[href^='javascript:']:after,\n  a[href^='#']:after {\n    content: ''; }\n  abbr[title]:after {\n    content: \" (\" attr(title) \")\"; }\n  pre,\n  blockquote {\n    border: 1px solid #8a8a8a;\n    page-break-inside: avoid; }\n  thead {\n    display: table-header-group; }\n  tr,\n  img {\n    page-break-inside: avoid; }\n  img {\n    max-width: 100% !important; }\n  @page {\n    margin: 0.5cm; }\n  p,\n  h2,\n  h3 {\n    orphans: 3;\n    widows: 3; }\n  h2,\n  h3 {\n    page-break-after: avoid; } }\n\n[type='text'], [type='password'], [type='date'], [type='datetime'], [type='datetime-local'], [type='month'], [type='week'], [type='email'], [type='number'], [type='search'], [type='tel'], [type='time'], [type='url'], [type='color'],\ntextarea {\n  display: block;\n  box-sizing: border-box;\n  width: 100%;\n  height: 2.4375rem;\n  padding: 0.5rem;\n  border: 1px solid #cacaca;\n  margin: 0 0 1rem;\n  font-family: inherit;\n  font-size: 1rem;\n  color: #0a0a0a;\n  background-color: #fefefe;\n  box-shadow: inset 0 1px 2px rgba(10, 10, 10, 0.1);\n  border-radius: 0;\n  transition: box-shadow 0.5s, border-color 0.25s ease-in-out;\n  -webkit-appearance: none;\n  -moz-appearance: none; }\n  [type='text']:focus, [type='password']:focus, [type='date']:focus, [type='datetime']:focus, [type='datetime-local']:focus, [type='month']:focus, [type='week']:focus, [type='email']:focus, [type='number']:focus, [type='search']:focus, [type='tel']:focus, [type='time']:focus, [type='url']:focus, [type='color']:focus,\n  textarea:focus {\n    border: 1px solid #8a8a8a;\n    background-color: #fefefe;\n    outline: none;\n    box-shadow: 0 0 5px #cacaca;\n    transition: box-shadow 0.5s, border-color 0.25s ease-in-out; }\n\ntextarea {\n  max-width: 100%; }\n  textarea[rows] {\n    height: auto; }\n\ninput::placeholder,\ntextarea::placeholder {\n  color: #cacaca; }\n\ninput:disabled, input[readonly],\ntextarea:disabled,\ntextarea[readonly] {\n  background-color: #e6e6e6;\n  cursor: not-allowed; }\n\n[type='submit'],\n[type='button'] {\n  border-radius: 0;\n  -webkit-appearance: none;\n  -moz-appearance: none; }\n\ninput[type='search'] {\n  box-sizing: border-box; }\n\n[type='file'],\n[type='checkbox'],\n[type='radio'] {\n  margin: 0 0 1rem; }\n\n[type='checkbox'] + label,\n[type='radio'] + label {\n  display: inline-block;\n  margin-left: 0.5rem;\n  margin-right: 1rem;\n  margin-bottom: 0;\n  vertical-align: baseline; }\n  [type='checkbox'] + label[for],\n  [type='radio'] + label[for] {\n    cursor: pointer; }\n\nlabel > [type='checkbox'],\nlabel > [type='radio'] {\n  margin-right: 0.5rem; }\n\n[type='file'] {\n  width: 100%; }\n\nlabel {\n  display: block;\n  margin: 0;\n  font-size: 0.875rem;\n  font-weight: normal;\n  line-height: 1.8;\n  color: #0a0a0a; }\n  label.middle {\n    margin: 0 0 1rem;\n    padding: 0.5625rem 0; }\n\n.help-text {\n  margin-top: -0.5rem;\n  font-size: 0.8125rem;\n  font-style: italic;\n  color: #0a0a0a; }\n\n.input-group {\n  display: table;\n  width: 100%;\n  margin-bottom: 1rem; }\n  .input-group > :first-child {\n    border-radius: 0 0 0 0; }\n  .input-group > :last-child > * {\n    border-radius: 0 0 0 0; }\n\n.input-group-label, .input-group-field, .input-group-button {\n  margin: 0;\n  white-space: nowrap;\n  display: table-cell;\n  vertical-align: middle; }\n\n.input-group-label {\n  text-align: center;\n  padding: 0 1rem;\n  background: #e6e6e6;\n  color: #0a0a0a;\n  border: 1px solid #cacaca;\n  white-space: nowrap;\n  width: 1%;\n  height: 100%; }\n  .input-group-label:first-child {\n    border-right: 0; }\n  .input-group-label:last-child {\n    border-left: 0; }\n\n.input-group-field {\n  border-radius: 0;\n  height: 2.5rem; }\n\n.input-group-button {\n  padding-top: 0;\n  padding-bottom: 0;\n  text-align: center;\n  height: 100%;\n  width: 1%; }\n  .input-group-button a,\n  .input-group-button input,\n  .input-group-button button {\n    margin: 0; }\n\n.input-group .input-group-button {\n  display: table-cell; }\n\nfieldset {\n  border: 0;\n  padding: 0;\n  margin: 0; }\n\nlegend {\n  margin-bottom: 0.5rem;\n  max-width: 100%; }\n\n.fieldset {\n  border: 1px solid #cacaca;\n  padding: 1.25rem;\n  margin: 1.125rem 0; }\n  .fieldset legend {\n    background: #fefefe;\n    padding: 0 0.1875rem;\n    margin: 0;\n    margin-left: -0.1875rem; }\n\nselect {\n  height: 2.4375rem;\n  padding: 0.5rem;\n  border: 1px solid #cacaca;\n  margin: 0 0 1rem;\n  font-size: 1rem;\n  font-family: inherit;\n  line-height: normal;\n  color: #0a0a0a;\n  background-color: #fefefe;\n  border-radius: 0;\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  background-image: url(\"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' version='1.1' width='32' height='24' viewBox='0 0 32 24'><polygon points='0,0 32,0 16,24' style='fill: rgb%28138, 138, 138%29'></polygon></svg>\");\n  background-size: 9px 6px;\n  background-position: right -1rem center;\n  background-origin: content-box;\n  background-repeat: no-repeat;\n  padding-right: 1.5rem; }\n  @media screen and (min-width: 0\\0) {\n    select {\n      background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAYCAYAAACbU/80AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAIpJREFUeNrEkckNgDAMBBfRkEt0ObRBBdsGXUDgmQfK4XhH2m8czQAAy27R3tsw4Qfe2x8uOO6oYLb6GlOor3GF+swURAOmUJ+RwtEJs9WvTGEYxBXqI1MQAZhCfUQKRzDMVj+TwrAIV6jvSUEkYAr1LSkcyTBb/V+KYfX7xAeusq3sLDtGH3kEGACPWIflNZfhRQAAAABJRU5ErkJggg==\"); } }\n  select:disabled {\n    background-color: #e6e6e6;\n    cursor: not-allowed; }\n  select::-ms-expand {\n    display: none; }\n  select[multiple] {\n    height: auto;\n    background-image: none; }\n\n.is-invalid-input:not(:focus) {\n  background-color: rgba(236, 88, 64, 0.1);\n  border-color: #ec5840; }\n\n.is-invalid-label {\n  color: #ec5840; }\n\n.form-error {\n  display: none;\n  margin-top: -0.5rem;\n  margin-bottom: 1rem;\n  font-size: 0.75rem;\n  font-weight: bold;\n  color: #ec5840; }\n  .form-error.is-visible {\n    display: block; }\n\n.button {\n  display: inline-block;\n  text-align: center;\n  line-height: 1;\n  cursor: pointer;\n  -webkit-appearance: none;\n  transition: background-color 0.25s ease-out, color 0.25s ease-out;\n  vertical-align: middle;\n  border: 1px solid transparent;\n  border-radius: 0;\n  padding: 0.85em 1em;\n  margin: 0 0 1rem 0;\n  font-size: 0.9rem;\n  background-color: #2199e8;\n  color: #fefefe; }\n  [data-whatinput='mouse'] .button {\n    outline: 0; }\n  .button:hover, .button:focus {\n    background-color: #1583cc;\n    color: #fefefe; }\n  .button.tiny {\n    font-size: 0.6rem; }\n  .button.small {\n    font-size: 0.75rem; }\n  .button.large {\n    font-size: 1.25rem; }\n  .button.expanded {\n    display: block;\n    width: 100%;\n    margin-left: 0;\n    margin-right: 0; }\n  .button.primary {\n    background-color: #2199e8;\n    color: #fefefe; }\n    .button.primary:hover, .button.primary:focus {\n      background-color: #147cc0;\n      color: #fefefe; }\n  .button.secondary {\n    background-color: #777;\n    color: #fefefe; }\n    .button.secondary:hover, .button.secondary:focus {\n      background-color: #5f5f5f;\n      color: #fefefe; }\n  .button.success {\n    background-color: #3adb76;\n    color: #fefefe; }\n    .button.success:hover, .button.success:focus {\n      background-color: #22bb5b;\n      color: #fefefe; }\n  .button.warning {\n    background-color: #ffae00;\n    color: #fefefe; }\n    .button.warning:hover, .button.warning:focus {\n      background-color: #cc8b00;\n      color: #fefefe; }\n  .button.alert {\n    background-color: #ec5840;\n    color: #fefefe; }\n    .button.alert:hover, .button.alert:focus {\n      background-color: #da3116;\n      color: #fefefe; }\n  .button.hollow {\n    border: 1px solid #2199e8;\n    color: #2199e8; }\n    .button.hollow, .button.hollow:hover, .button.hollow:focus {\n      background-color: transparent; }\n    .button.hollow:hover, .button.hollow:focus {\n      border-color: #0c4d78;\n      color: #0c4d78; }\n    .button.hollow.primary {\n      border: 1px solid #2199e8;\n      color: #2199e8; }\n      .button.hollow.primary:hover, .button.hollow.primary:focus {\n        border-color: #0c4d78;\n        color: #0c4d78; }\n    .button.hollow.secondary {\n      border: 1px solid #777;\n      color: #777; }\n      .button.hollow.secondary:hover, .button.hollow.secondary:focus {\n        border-color: #3c3c3c;\n        color: #3c3c3c; }\n    .button.hollow.success {\n      border: 1px solid #3adb76;\n      color: #3adb76; }\n      .button.hollow.success:hover, .button.hollow.success:focus {\n        border-color: #157539;\n        color: #157539; }\n    .button.hollow.warning {\n      border: 1px solid #ffae00;\n      color: #ffae00; }\n      .button.hollow.warning:hover, .button.hollow.warning:focus {\n        border-color: #805700;\n        color: #805700; }\n    .button.hollow.alert {\n      border: 1px solid #ec5840;\n      color: #ec5840; }\n      .button.hollow.alert:hover, .button.hollow.alert:focus {\n        border-color: #881f0e;\n        color: #881f0e; }\n  .button.disabled, .button[disabled] {\n    opacity: 0.25;\n    cursor: not-allowed; }\n    .button.disabled:hover, .button.disabled:focus, .button[disabled]:hover, .button[disabled]:focus {\n      background-color: #2199e8;\n      color: #fefefe; }\n  .button.dropdown::after {\n    content: '';\n    display: block;\n    width: 0;\n    height: 0;\n    border: inset 0.4em;\n    border-color: #fefefe transparent transparent;\n    border-top-style: solid;\n    border-bottom-width: 0;\n    position: relative;\n    top: 0.4em;\n    float: right;\n    margin-left: 1em;\n    display: inline-block; }\n  .button.arrow-only::after {\n    margin-left: 0;\n    float: none;\n    top: -0.1em; }\n\n.accordion {\n  list-style-type: none;\n  background: #fefefe;\n  margin-left: 0; }\n\n.accordion-item:first-child > :first-child {\n  border-radius: 0 0 0 0; }\n\n.accordion-item:last-child > :last-child {\n  border-radius: 0 0 0 0; }\n\n.accordion-title {\n  display: block;\n  padding: 1.25rem 1rem;\n  line-height: 1;\n  font-size: 0.75rem;\n  color: #2199e8;\n  position: relative;\n  border: 1px solid #e6e6e6;\n  border-bottom: 0; }\n  :last-child:not(.is-active) > .accordion-title {\n    border-radius: 0 0 0 0;\n    border-bottom: 1px solid #e6e6e6; }\n  .accordion-title:hover, .accordion-title:focus {\n    background-color: #e6e6e6; }\n  .accordion-title::before {\n    content: '+';\n    position: absolute;\n    right: 1rem;\n    top: 50%;\n    margin-top: -0.5rem; }\n  .is-active > .accordion-title::before {\n    content: '\\2013'; }\n\n.accordion-content {\n  padding: 1rem;\n  display: none;\n  border: 1px solid #e6e6e6;\n  border-bottom: 0;\n  background-color: #fefefe;\n  color: #0a0a0a; }\n  :last-child > .accordion-content:last-child {\n    border-bottom: 1px solid #e6e6e6; }\n\n.is-accordion-submenu-parent > a {\n  position: relative; }\n  .is-accordion-submenu-parent > a::after {\n    content: '';\n    display: block;\n    width: 0;\n    height: 0;\n    border: inset 6px;\n    border-color: #2199e8 transparent transparent;\n    border-top-style: solid;\n    border-bottom-width: 0;\n    position: absolute;\n    top: 50%;\n    margin-top: -4px;\n    right: 1rem; }\n\n.is-accordion-submenu-parent[aria-expanded='true'] > a::after {\n  transform-origin: 50% 50%;\n  transform: scaleY(-1); }\n\n.badge {\n  display: inline-block;\n  padding: 0.3em;\n  min-width: 2.1em;\n  font-size: 0.6rem;\n  text-align: center;\n  border-radius: 50%;\n  background: #2199e8;\n  color: #fefefe; }\n  .badge.secondary {\n    background: #777;\n    color: #fefefe; }\n  .badge.success {\n    background: #3adb76;\n    color: #fefefe; }\n  .badge.warning {\n    background: #ffae00;\n    color: #fefefe; }\n  .badge.alert {\n    background: #ec5840;\n    color: #fefefe; }\n\n.breadcrumbs {\n  list-style: none;\n  margin: 0 0 1rem 0; }\n  .breadcrumbs::before, .breadcrumbs::after {\n    content: ' ';\n    display: table; }\n  .breadcrumbs::after {\n    clear: both; }\n  .breadcrumbs li {\n    float: left;\n    color: #0a0a0a;\n    font-size: 0.6875rem;\n    cursor: default;\n    text-transform: uppercase; }\n    .breadcrumbs li:not(:last-child)::after {\n      color: #cacaca;\n      content: \"/\";\n      margin: 0 0.75rem;\n      position: relative;\n      top: 1px;\n      opacity: 1; }\n  .breadcrumbs a {\n    color: #2199e8; }\n    .breadcrumbs a:hover {\n      text-decoration: underline; }\n  .breadcrumbs .disabled {\n    color: #cacaca;\n    cursor: not-allowed; }\n\n.button-group {\n  margin-bottom: 1rem;\n  font-size: 0; }\n  .button-group::before, .button-group::after {\n    content: ' ';\n    display: table; }\n  .button-group::after {\n    clear: both; }\n  .button-group .button {\n    margin: 0;\n    margin-right: 1px;\n    margin-bottom: 1px;\n    font-size: 0.9rem; }\n    .button-group .button:last-child {\n      margin-right: 0; }\n  .button-group.tiny .button {\n    font-size: 0.6rem; }\n  .button-group.small .button {\n    font-size: 0.75rem; }\n  .button-group.large .button {\n    font-size: 1.25rem; }\n  .button-group.expanded {\n    margin-right: -1px; }\n    .button-group.expanded::before, .button-group.expanded::after {\n      display: none; }\n    .button-group.expanded .button:first-child:nth-last-child(2), .button-group.expanded .button:first-child:nth-last-child(2):first-child:nth-last-child(2) ~ .button {\n      display: inline-block;\n      width: calc(50% - 1px);\n      margin-right: 1px; }\n      .button-group.expanded .button:first-child:nth-last-child(2):last-child, .button-group.expanded .button:first-child:nth-last-child(2):first-child:nth-last-child(2) ~ .button:last-child {\n        margin-right: -6px; }\n    .button-group.expanded .button:first-child:nth-last-child(3), .button-group.expanded .button:first-child:nth-last-child(3):first-child:nth-last-child(3) ~ .button {\n      display: inline-block;\n      width: calc(33.33333% - 1px);\n      margin-right: 1px; }\n      .button-group.expanded .button:first-child:nth-last-child(3):last-child, .button-group.expanded .button:first-child:nth-last-child(3):first-child:nth-last-child(3) ~ .button:last-child {\n        margin-right: -6px; }\n    .button-group.expanded .button:first-child:nth-last-child(4), .button-group.expanded .button:first-child:nth-last-child(4):first-child:nth-last-child(4) ~ .button {\n      display: inline-block;\n      width: calc(25% - 1px);\n      margin-right: 1px; }\n      .button-group.expanded .button:first-child:nth-last-child(4):last-child, .button-group.expanded .button:first-child:nth-last-child(4):first-child:nth-last-child(4) ~ .button:last-child {\n        margin-right: -6px; }\n    .button-group.expanded .button:first-child:nth-last-child(5), .button-group.expanded .button:first-child:nth-last-child(5):first-child:nth-last-child(5) ~ .button {\n      display: inline-block;\n      width: calc(20% - 1px);\n      margin-right: 1px; }\n      .button-group.expanded .button:first-child:nth-last-child(5):last-child, .button-group.expanded .button:first-child:nth-last-child(5):first-child:nth-last-child(5) ~ .button:last-child {\n        margin-right: -6px; }\n    .button-group.expanded .button:first-child:nth-last-child(6), .button-group.expanded .button:first-child:nth-last-child(6):first-child:nth-last-child(6) ~ .button {\n      display: inline-block;\n      width: calc(16.66667% - 1px);\n      margin-right: 1px; }\n      .button-group.expanded .button:first-child:nth-last-child(6):last-child, .button-group.expanded .button:first-child:nth-last-child(6):first-child:nth-last-child(6) ~ .button:last-child {\n        margin-right: -6px; }\n  .button-group.primary .button {\n    background-color: #2199e8;\n    color: #fefefe; }\n    .button-group.primary .button:hover, .button-group.primary .button:focus {\n      background-color: #147cc0;\n      color: #fefefe; }\n  .button-group.secondary .button {\n    background-color: #777;\n    color: #fefefe; }\n    .button-group.secondary .button:hover, .button-group.secondary .button:focus {\n      background-color: #5f5f5f;\n      color: #fefefe; }\n  .button-group.success .button {\n    background-color: #3adb76;\n    color: #fefefe; }\n    .button-group.success .button:hover, .button-group.success .button:focus {\n      background-color: #22bb5b;\n      color: #fefefe; }\n  .button-group.warning .button {\n    background-color: #ffae00;\n    color: #fefefe; }\n    .button-group.warning .button:hover, .button-group.warning .button:focus {\n      background-color: #cc8b00;\n      color: #fefefe; }\n  .button-group.alert .button {\n    background-color: #ec5840;\n    color: #fefefe; }\n    .button-group.alert .button:hover, .button-group.alert .button:focus {\n      background-color: #da3116;\n      color: #fefefe; }\n  .button-group.stacked .button, .button-group.stacked-for-small .button, .button-group.stacked-for-medium .button {\n    width: 100%; }\n    .button-group.stacked .button:last-child, .button-group.stacked-for-small .button:last-child, .button-group.stacked-for-medium .button:last-child {\n      margin-bottom: 0; }\n  @media screen and (min-width: 40em) {\n    .button-group.stacked-for-small .button {\n      width: auto;\n      margin-bottom: 0; } }\n  @media screen and (min-width: 64em) {\n    .button-group.stacked-for-medium .button {\n      width: auto;\n      margin-bottom: 0; } }\n  @media screen and (max-width: 39.9375em) {\n    .button-group.stacked-for-small.expanded {\n      display: block; }\n      .button-group.stacked-for-small.expanded .button {\n        display: block;\n        margin-right: 0; } }\n\n.callout {\n  margin: 0 0 1rem 0;\n  padding: 1rem;\n  border: 1px solid rgba(10, 10, 10, 0.25);\n  border-radius: 0;\n  position: relative;\n  color: #0a0a0a;\n  background-color: white; }\n  .callout > :first-child {\n    margin-top: 0; }\n  .callout > :last-child {\n    margin-bottom: 0; }\n  .callout.primary {\n    background-color: #def0fc; }\n  .callout.secondary {\n    background-color: #ebebeb; }\n  .callout.success {\n    background-color: #e1faea; }\n  .callout.warning {\n    background-color: #fff3d9; }\n  .callout.alert {\n    background-color: #fce6e2; }\n  .callout.small {\n    padding-top: 0.5rem;\n    padding-right: 0.5rem;\n    padding-bottom: 0.5rem;\n    padding-left: 0.5rem; }\n  .callout.large {\n    padding-top: 3rem;\n    padding-right: 3rem;\n    padding-bottom: 3rem;\n    padding-left: 3rem; }\n\n.close-button {\n  position: absolute;\n  color: #8a8a8a;\n  right: 1rem;\n  top: 0.5rem;\n  font-size: 2em;\n  line-height: 1;\n  cursor: pointer; }\n  [data-whatinput='mouse'] .close-button {\n    outline: 0; }\n  .close-button:hover, .close-button:focus {\n    color: #0a0a0a; }\n\n.menu {\n  margin: 0;\n  list-style-type: none; }\n  .menu > li {\n    display: table-cell;\n    vertical-align: middle; }\n    [data-whatinput='mouse'] .menu > li {\n      outline: 0; }\n  .menu > li > a {\n    display: block;\n    padding: 0.7rem 1rem;\n    line-height: 1; }\n  .menu input,\n  .menu a,\n  .menu button {\n    margin-bottom: 0; }\n  .menu > li > a img,\n  .menu > li > a i,\n  .menu > li > a svg {\n    vertical-align: middle; }\n    .menu > li > a img + span,\n    .menu > li > a i + span,\n    .menu > li > a svg + span {\n      vertical-align: middle; }\n  .menu > li > a img,\n  .menu > li > a i,\n  .menu > li > a svg {\n    margin-right: 0.25rem;\n    display: inline-block; }\n  .menu > li {\n    display: table-cell; }\n  .menu.vertical > li {\n    display: block; }\n  @media screen and (min-width: 40em) {\n    .menu.medium-horizontal > li {\n      display: table-cell; }\n    .menu.medium-vertical > li {\n      display: block; } }\n  @media screen and (min-width: 64em) {\n    .menu.large-horizontal > li {\n      display: table-cell; }\n    .menu.large-vertical > li {\n      display: block; } }\n  .menu.simple li {\n    line-height: 1;\n    display: inline-block;\n    margin-right: 1rem; }\n  .menu.simple a {\n    padding: 0; }\n  .menu.align-right::before, .menu.align-right::after {\n    content: ' ';\n    display: table; }\n  .menu.align-right::after {\n    clear: both; }\n  .menu.align-right > li {\n    float: right; }\n  .menu.expanded {\n    width: 100%;\n    display: table;\n    table-layout: fixed; }\n    .menu.expanded > li:first-child:last-child {\n      width: 100%; }\n  .menu.icon-top > li > a {\n    text-align: center; }\n    .menu.icon-top > li > a img,\n    .menu.icon-top > li > a i,\n    .menu.icon-top > li > a svg {\n      display: block;\n      margin: 0 auto 0.25rem; }\n  .menu.nested {\n    margin-left: 1rem; }\n  .menu .active > a {\n    color: #fefefe;\n    background: #2199e8; }\n\n.menu-text {\n  font-weight: bold;\n  color: inherit;\n  line-height: 1;\n  padding-top: 0;\n  padding-bottom: 0;\n  padding: 0.7rem 1rem; }\n\n.menu-centered {\n  text-align: center; }\n  .menu-centered > .menu {\n    display: inline-block; }\n\n.no-js [data-responsive-menu] ul {\n  display: none; }\n\n.menu-icon {\n  position: relative;\n  display: inline-block;\n  vertical-align: middle;\n  cursor: pointer;\n  width: 20px;\n  height: 16px; }\n  .menu-icon::after {\n    content: '';\n    position: absolute;\n    display: block;\n    width: 100%;\n    height: 2px;\n    background: #fefefe;\n    top: 0;\n    left: 0;\n    box-shadow: 0 7px 0 #fefefe, 0 14px 0 #fefefe; }\n  .menu-icon:hover::after {\n    background: #cacaca;\n    box-shadow: 0 7px 0 #cacaca, 0 14px 0 #cacaca; }\n\n.menu-icon.dark {\n  position: relative;\n  display: inline-block;\n  vertical-align: middle;\n  cursor: pointer;\n  width: 20px;\n  height: 16px; }\n  .menu-icon.dark::after {\n    content: '';\n    position: absolute;\n    display: block;\n    width: 100%;\n    height: 2px;\n    background: #0a0a0a;\n    top: 0;\n    left: 0;\n    box-shadow: 0 7px 0 #0a0a0a, 0 14px 0 #0a0a0a; }\n  .menu-icon.dark:hover::after {\n    background: #8a8a8a;\n    box-shadow: 0 7px 0 #8a8a8a, 0 14px 0 #8a8a8a; }\n\n.is-drilldown {\n  position: relative;\n  overflow: hidden; }\n  .is-drilldown li {\n    display: block !important; }\n\n.is-drilldown-submenu {\n  position: absolute;\n  top: 0;\n  left: 100%;\n  z-index: -1;\n  height: 100%;\n  width: 100%;\n  background: #fefefe;\n  transition: transform 0.15s linear; }\n  .is-drilldown-submenu.is-active {\n    z-index: 1;\n    display: block;\n    transform: translateX(-100%); }\n  .is-drilldown-submenu.is-closing {\n    transform: translateX(100%); }\n\n.is-drilldown-submenu-parent > a {\n  position: relative; }\n  .is-drilldown-submenu-parent > a::after {\n    content: '';\n    display: block;\n    width: 0;\n    height: 0;\n    border: inset 6px;\n    border-color: transparent transparent transparent #2199e8;\n    border-left-style: solid;\n    border-right-width: 0;\n    position: absolute;\n    top: 50%;\n    margin-top: -6px;\n    right: 1rem; }\n\n.js-drilldown-back > a::before {\n  content: '';\n  display: block;\n  width: 0;\n  height: 0;\n  border: inset 6px;\n  border-color: transparent #2199e8 transparent transparent;\n  border-right-style: solid;\n  border-left-width: 0;\n  border-left-width: 0;\n  display: inline-block;\n  vertical-align: middle;\n  margin-right: 0.75rem; }\n\n.dropdown-pane {\n  background-color: #fefefe;\n  border: 1px solid #cacaca;\n  border-radius: 0;\n  display: block;\n  font-size: 1rem;\n  padding: 1rem;\n  position: absolute;\n  visibility: hidden;\n  width: 300px;\n  z-index: 10; }\n  .dropdown-pane.is-open {\n    visibility: visible; }\n\n.dropdown-pane.tiny {\n  width: 100px; }\n\n.dropdown-pane.small {\n  width: 200px; }\n\n.dropdown-pane.large {\n  width: 400px; }\n\n.dropdown.menu > li.opens-left > .is-dropdown-submenu {\n  left: auto;\n  right: 0;\n  top: 100%; }\n\n.dropdown.menu > li.opens-right > .is-dropdown-submenu {\n  right: auto;\n  left: 0;\n  top: 100%; }\n\n.dropdown.menu > li.is-dropdown-submenu-parent > a {\n  padding-right: 1.5rem;\n  position: relative; }\n\n.dropdown.menu > li.is-dropdown-submenu-parent > a::after {\n  content: '';\n  display: block;\n  width: 0;\n  height: 0;\n  border: inset 5px;\n  border-color: #2199e8 transparent transparent;\n  border-top-style: solid;\n  border-bottom-width: 0;\n  right: 5px;\n  margin-top: -2px; }\n\n[data-whatinput='mouse'] .dropdown.menu a {\n  outline: 0; }\n\n.no-js .dropdown.menu ul {\n  display: none; }\n\n.dropdown.menu.vertical > li .is-dropdown-submenu {\n  top: 0; }\n\n.dropdown.menu.vertical > li.opens-left > .is-dropdown-submenu {\n  left: auto;\n  right: 100%; }\n\n.dropdown.menu.vertical > li.opens-right > .is-dropdown-submenu {\n  right: auto;\n  left: 100%; }\n\n.dropdown.menu.vertical > li > a::after {\n  right: 14px;\n  margin-top: -3px; }\n\n.dropdown.menu.vertical > li.opens-left > a::after {\n  content: '';\n  display: block;\n  width: 0;\n  height: 0;\n  border: inset 5px;\n  border-color: transparent #2199e8 transparent transparent;\n  border-right-style: solid;\n  border-left-width: 0; }\n\n.dropdown.menu.vertical > li.opens-right > a::after {\n  content: '';\n  display: block;\n  width: 0;\n  height: 0;\n  border: inset 5px;\n  border-color: transparent transparent transparent #2199e8;\n  border-left-style: solid;\n  border-right-width: 0; }\n\n@media screen and (min-width: 40em) {\n  .dropdown.menu.medium-horizontal > li.opens-left > .is-dropdown-submenu {\n    left: auto;\n    right: 0;\n    top: 100%; }\n  .dropdown.menu.medium-horizontal > li.opens-right > .is-dropdown-submenu {\n    right: auto;\n    left: 0;\n    top: 100%; }\n  .dropdown.menu.medium-horizontal > li.is-dropdown-submenu-parent > a {\n    padding-right: 1.5rem;\n    position: relative; }\n  .dropdown.menu.medium-horizontal > li.is-dropdown-submenu-parent > a::after {\n    content: '';\n    display: block;\n    width: 0;\n    height: 0;\n    border: inset 5px;\n    border-color: #2199e8 transparent transparent;\n    border-top-style: solid;\n    border-bottom-width: 0;\n    right: 5px;\n    margin-top: -2px; }\n  .dropdown.menu.medium-vertical > li .is-dropdown-submenu {\n    top: 0; }\n  .dropdown.menu.medium-vertical > li.opens-left > .is-dropdown-submenu {\n    left: auto;\n    right: 100%; }\n  .dropdown.menu.medium-vertical > li.opens-right > .is-dropdown-submenu {\n    right: auto;\n    left: 100%; }\n  .dropdown.menu.medium-vertical > li > a::after {\n    right: 14px;\n    margin-top: -3px; }\n  .dropdown.menu.medium-vertical > li.opens-left > a::after {\n    content: '';\n    display: block;\n    width: 0;\n    height: 0;\n    border: inset 5px;\n    border-color: transparent #2199e8 transparent transparent;\n    border-right-style: solid;\n    border-left-width: 0; }\n  .dropdown.menu.medium-vertical > li.opens-right > a::after {\n    content: '';\n    display: block;\n    width: 0;\n    height: 0;\n    border: inset 5px;\n    border-color: transparent transparent transparent #2199e8;\n    border-left-style: solid;\n    border-right-width: 0; } }\n\n@media screen and (min-width: 64em) {\n  .dropdown.menu.large-horizontal > li.opens-left > .is-dropdown-submenu {\n    left: auto;\n    right: 0;\n    top: 100%; }\n  .dropdown.menu.large-horizontal > li.opens-right > .is-dropdown-submenu {\n    right: auto;\n    left: 0;\n    top: 100%; }\n  .dropdown.menu.large-horizontal > li.is-dropdown-submenu-parent > a {\n    padding-right: 1.5rem;\n    position: relative; }\n  .dropdown.menu.large-horizontal > li.is-dropdown-submenu-parent > a::after {\n    content: '';\n    display: block;\n    width: 0;\n    height: 0;\n    border: inset 5px;\n    border-color: #2199e8 transparent transparent;\n    border-top-style: solid;\n    border-bottom-width: 0;\n    right: 5px;\n    margin-top: -2px; }\n  .dropdown.menu.large-vertical > li .is-dropdown-submenu {\n    top: 0; }\n  .dropdown.menu.large-vertical > li.opens-left > .is-dropdown-submenu {\n    left: auto;\n    right: 100%; }\n  .dropdown.menu.large-vertical > li.opens-right > .is-dropdown-submenu {\n    right: auto;\n    left: 100%; }\n  .dropdown.menu.large-vertical > li > a::after {\n    right: 14px;\n    margin-top: -3px; }\n  .dropdown.menu.large-vertical > li.opens-left > a::after {\n    content: '';\n    display: block;\n    width: 0;\n    height: 0;\n    border: inset 5px;\n    border-color: transparent #2199e8 transparent transparent;\n    border-right-style: solid;\n    border-left-width: 0; }\n  .dropdown.menu.large-vertical > li.opens-right > a::after {\n    content: '';\n    display: block;\n    width: 0;\n    height: 0;\n    border: inset 5px;\n    border-color: transparent transparent transparent #2199e8;\n    border-left-style: solid;\n    border-right-width: 0; } }\n\n.dropdown.menu.align-right .is-dropdown-submenu.first-sub {\n  top: 100%;\n  left: auto;\n  right: 0; }\n\n.is-dropdown-menu.vertical {\n  width: 100px; }\n  .is-dropdown-menu.vertical.align-right {\n    float: right; }\n\n.is-dropdown-submenu-parent {\n  position: relative; }\n  .is-dropdown-submenu-parent a::after {\n    position: absolute;\n    top: 50%;\n    right: 5px;\n    margin-top: -2px; }\n  .is-dropdown-submenu-parent.opens-inner > .is-dropdown-submenu {\n    top: 100%;\n    left: auto; }\n  .is-dropdown-submenu-parent.opens-left > .is-dropdown-submenu {\n    left: auto;\n    right: 100%; }\n  .is-dropdown-submenu-parent.opens-right > .is-dropdown-submenu {\n    right: auto;\n    left: 100%; }\n\n.is-dropdown-submenu {\n  display: none;\n  position: absolute;\n  top: 0;\n  left: 100%;\n  min-width: 200px;\n  z-index: 1;\n  background: #fefefe;\n  border: 1px solid #cacaca; }\n  .is-dropdown-submenu .is-dropdown-submenu-parent > a::after {\n    right: 14px;\n    margin-top: -3px; }\n  .is-dropdown-submenu .is-dropdown-submenu-parent.opens-left > a::after {\n    content: '';\n    display: block;\n    width: 0;\n    height: 0;\n    border: inset 5px;\n    border-color: transparent #2199e8 transparent transparent;\n    border-right-style: solid;\n    border-left-width: 0; }\n  .is-dropdown-submenu .is-dropdown-submenu-parent.opens-right > a::after {\n    content: '';\n    display: block;\n    width: 0;\n    height: 0;\n    border: inset 5px;\n    border-color: transparent transparent transparent #2199e8;\n    border-left-style: solid;\n    border-right-width: 0; }\n  .is-dropdown-submenu .is-dropdown-submenu {\n    margin-top: -1px; }\n  .is-dropdown-submenu > li {\n    width: 100%; }\n  .is-dropdown-submenu.js-dropdown-active {\n    display: block; }\n\n.flex-video {\n  position: relative;\n  height: 0;\n  padding-bottom: 75%;\n  margin-bottom: 1rem;\n  overflow: hidden; }\n  .flex-video iframe,\n  .flex-video object,\n  .flex-video embed,\n  .flex-video video {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%; }\n  .flex-video.widescreen {\n    padding-bottom: 56.25%; }\n  .flex-video.vimeo {\n    padding-top: 0; }\n\n.label {\n  display: inline-block;\n  padding: 0.33333rem 0.5rem;\n  font-size: 0.8rem;\n  line-height: 1;\n  white-space: nowrap;\n  cursor: default;\n  border-radius: 0;\n  background: #2199e8;\n  color: #fefefe; }\n  .label.secondary {\n    background: #777;\n    color: #fefefe; }\n  .label.success {\n    background: #3adb76;\n    color: #fefefe; }\n  .label.warning {\n    background: #ffae00;\n    color: #fefefe; }\n  .label.alert {\n    background: #ec5840;\n    color: #fefefe; }\n\n.media-object {\n  margin-bottom: 1rem;\n  display: block; }\n  .media-object img {\n    max-width: none; }\n  @media screen and (max-width: 39.9375em) {\n    .media-object.stack-for-small .media-object-section {\n      padding: 0;\n      padding-bottom: 1rem;\n      display: block; }\n      .media-object.stack-for-small .media-object-section img {\n        width: 100%; } }\n\n.media-object-section {\n  display: table-cell;\n  vertical-align: top; }\n  .media-object-section:first-child {\n    padding-right: 1rem; }\n  .media-object-section:last-child:not(:nth-child(2)) {\n    padding-left: 1rem; }\n  .media-object-section > :last-child {\n    margin-bottom: 0; }\n  .media-object-section.middle {\n    vertical-align: middle; }\n  .media-object-section.bottom {\n    vertical-align: bottom; }\n\nhtml,\nbody {\n  height: 100%; }\n\n.off-canvas-wrapper {\n  width: 100%;\n  overflow-x: hidden;\n  position: relative;\n  backface-visibility: hidden;\n  -webkit-overflow-scrolling: auto; }\n\n.off-canvas-wrapper-inner {\n  position: relative;\n  width: 100%;\n  transition: transform 0.5s ease; }\n  .off-canvas-wrapper-inner::before, .off-canvas-wrapper-inner::after {\n    content: ' ';\n    display: table; }\n  .off-canvas-wrapper-inner::after {\n    clear: both; }\n\n.off-canvas-content,\n.off-canvas-content {\n  min-height: 100%;\n  background: #fefefe;\n  transition: transform 0.5s ease;\n  backface-visibility: hidden;\n  z-index: 1;\n  padding-bottom: 0.1px;\n  box-shadow: 0 0 10px rgba(10, 10, 10, 0.5); }\n\n.js-off-canvas-exit {\n  display: none;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background: rgba(254, 254, 254, 0.25);\n  cursor: pointer;\n  transition: background 0.5s ease; }\n\n.off-canvas {\n  position: absolute;\n  background: #e6e6e6;\n  z-index: -1;\n  max-height: 100%;\n  overflow-y: auto;\n  transform: translateX(0); }\n  [data-whatinput='mouse'] .off-canvas {\n    outline: 0; }\n  .off-canvas.position-left {\n    left: -250px;\n    top: 0;\n    width: 250px; }\n    .is-open-left {\n      transform: translateX(250px); }\n  .off-canvas.position-right {\n    right: -250px;\n    top: 0;\n    width: 250px; }\n    .is-open-right {\n      transform: translateX(-250px); }\n\n@media screen and (min-width: 40em) {\n  .position-left.reveal-for-medium {\n    left: 0;\n    z-index: auto;\n    position: fixed; }\n    .position-left.reveal-for-medium ~ .off-canvas-content {\n      margin-left: 250px; }\n  .position-right.reveal-for-medium {\n    right: 0;\n    z-index: auto;\n    position: fixed; }\n    .position-right.reveal-for-medium ~ .off-canvas-content {\n      margin-right: 250px; } }\n\n@media screen and (min-width: 64em) {\n  .position-left.reveal-for-large {\n    left: 0;\n    z-index: auto;\n    position: fixed; }\n    .position-left.reveal-for-large ~ .off-canvas-content {\n      margin-left: 250px; }\n  .position-right.reveal-for-large {\n    right: 0;\n    z-index: auto;\n    position: fixed; }\n    .position-right.reveal-for-large ~ .off-canvas-content {\n      margin-right: 250px; } }\n\n.orbit {\n  position: relative; }\n\n.orbit-container {\n  position: relative;\n  margin: 0;\n  overflow: hidden;\n  list-style: none; }\n\n.orbit-slide {\n  width: 100%;\n  max-height: 100%; }\n  .orbit-slide.no-motionui.is-active {\n    top: 0;\n    left: 0; }\n\n.orbit-figure {\n  margin: 0; }\n\n.orbit-image {\n  margin: 0;\n  width: 100%;\n  max-width: 100%; }\n\n.orbit-caption {\n  position: absolute;\n  bottom: 0;\n  width: 100%;\n  padding: 1rem;\n  margin-bottom: 0;\n  color: #fefefe;\n  background-color: rgba(10, 10, 10, 0.5); }\n\n.orbit-previous, .orbit-next {\n  position: absolute;\n  top: 50%;\n  transform: translateY(-50%);\n  z-index: 10;\n  padding: 1rem;\n  color: #fefefe; }\n  [data-whatinput='mouse'] .orbit-previous, [data-whatinput='mouse'] .orbit-next {\n    outline: 0; }\n  .orbit-previous:hover, .orbit-next:hover, .orbit-previous:active, .orbit-next:active, .orbit-previous:focus, .orbit-next:focus {\n    background-color: rgba(10, 10, 10, 0.5); }\n\n.orbit-previous {\n  left: 0; }\n\n.orbit-next {\n  left: auto;\n  right: 0; }\n\n.orbit-bullets {\n  position: relative;\n  margin-top: 0.8rem;\n  margin-bottom: 0.8rem;\n  text-align: center; }\n  [data-whatinput='mouse'] .orbit-bullets {\n    outline: 0; }\n  .orbit-bullets button {\n    width: 1.2rem;\n    height: 1.2rem;\n    margin: 0.1rem;\n    background-color: #cacaca;\n    border-radius: 50%; }\n    .orbit-bullets button:hover {\n      background-color: #8a8a8a; }\n    .orbit-bullets button.is-active {\n      background-color: #8a8a8a; }\n\n.pagination {\n  margin-left: 0;\n  margin-bottom: 1rem; }\n  .pagination::before, .pagination::after {\n    content: ' ';\n    display: table; }\n  .pagination::after {\n    clear: both; }\n  .pagination li {\n    font-size: 0.875rem;\n    margin-right: 0.0625rem;\n    border-radius: 0;\n    display: none; }\n    .pagination li:last-child, .pagination li:first-child {\n      display: inline-block; }\n    @media screen and (min-width: 40em) {\n      .pagination li {\n        display: inline-block; } }\n  .pagination a,\n  .pagination button {\n    color: #0a0a0a;\n    display: block;\n    padding: 0.1875rem 0.625rem;\n    border-radius: 0; }\n    .pagination a:hover,\n    .pagination button:hover {\n      background: #e6e6e6; }\n  .pagination .current {\n    padding: 0.1875rem 0.625rem;\n    background: #2199e8;\n    color: #fefefe;\n    cursor: default; }\n  .pagination .disabled {\n    padding: 0.1875rem 0.625rem;\n    color: #cacaca;\n    cursor: not-allowed; }\n    .pagination .disabled:hover {\n      background: transparent; }\n  .pagination .ellipsis::after {\n    content: '\\2026';\n    padding: 0.1875rem 0.625rem;\n    color: #0a0a0a; }\n\n.pagination-previous a::before,\n.pagination-previous.disabled::before {\n  content: '\\AB';\n  display: inline-block;\n  margin-right: 0.5rem; }\n\n.pagination-next a::after,\n.pagination-next.disabled::after {\n  content: '\\BB';\n  display: inline-block;\n  margin-left: 0.5rem; }\n\n.progress {\n  background-color: #cacaca;\n  height: 1rem;\n  margin-bottom: 1rem;\n  border-radius: 0; }\n  .progress.primary .progress-meter {\n    background-color: #2199e8; }\n  .progress.secondary .progress-meter {\n    background-color: #777; }\n  .progress.success .progress-meter {\n    background-color: #3adb76; }\n  .progress.warning .progress-meter {\n    background-color: #ffae00; }\n  .progress.alert .progress-meter {\n    background-color: #ec5840; }\n\n.progress-meter {\n  position: relative;\n  display: block;\n  width: 0%;\n  height: 100%;\n  background-color: #2199e8; }\n\n.progress-meter-text {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  position: absolute;\n  margin: 0;\n  font-size: 0.75rem;\n  font-weight: bold;\n  color: #fefefe;\n  white-space: nowrap; }\n\n.slider {\n  position: relative;\n  height: 0.5rem;\n  margin-top: 1.25rem;\n  margin-bottom: 2.25rem;\n  background-color: #e6e6e6;\n  cursor: pointer;\n  user-select: none;\n  touch-action: none; }\n\n.slider-fill {\n  position: absolute;\n  top: 0;\n  left: 0;\n  display: inline-block;\n  max-width: 100%;\n  height: 0.5rem;\n  background-color: #cacaca;\n  transition: all 0.2s ease-in-out; }\n  .slider-fill.is-dragging {\n    transition: all 0s linear; }\n\n.slider-handle {\n  position: absolute;\n  top: 50%;\n  transform: translateY(-50%);\n  position: absolute;\n  left: 0;\n  z-index: 1;\n  display: inline-block;\n  width: 1.4rem;\n  height: 1.4rem;\n  background-color: #2199e8;\n  transition: all 0.2s ease-in-out;\n  touch-action: manipulation;\n  border-radius: 0; }\n  [data-whatinput='mouse'] .slider-handle {\n    outline: 0; }\n  .slider-handle:hover {\n    background-color: #1583cc; }\n  .slider-handle.is-dragging {\n    transition: all 0s linear; }\n\n.slider.disabled,\n.slider[disabled] {\n  opacity: 0.25;\n  cursor: not-allowed; }\n\n.slider.vertical {\n  display: inline-block;\n  width: 0.5rem;\n  height: 12.5rem;\n  margin: 0 1.25rem;\n  transform: scale(1, -1); }\n  .slider.vertical .slider-fill {\n    top: 0;\n    width: 0.5rem;\n    max-height: 100%; }\n  .slider.vertical .slider-handle {\n    position: absolute;\n    top: 0;\n    left: 50%;\n    width: 1.4rem;\n    height: 1.4rem;\n    transform: translateX(-50%); }\n\n.sticky-container {\n  position: relative; }\n\n.sticky {\n  position: absolute;\n  z-index: 0;\n  transform: translate3d(0, 0, 0); }\n\n.sticky.is-stuck {\n  position: fixed;\n  z-index: 5; }\n  .sticky.is-stuck.is-at-top {\n    top: 0; }\n  .sticky.is-stuck.is-at-bottom {\n    bottom: 0; }\n\n.sticky.is-anchored {\n  position: absolute;\n  left: auto;\n  right: auto; }\n  .sticky.is-anchored.is-at-bottom {\n    bottom: 0; }\n\nbody.is-reveal-open {\n  overflow: hidden; }\n\nhtml.is-reveal-open,\nhtml.is-reveal-open body {\n  height: 100%;\n  overflow: hidden;\n  user-select: none; }\n\n.reveal-overlay {\n  display: none;\n  position: fixed;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  z-index: 1005;\n  background-color: rgba(10, 10, 10, 0.45);\n  overflow-y: scroll; }\n\n.reveal {\n  display: none;\n  z-index: 1006;\n  padding: 1rem;\n  border: 1px solid #cacaca;\n  background-color: #fefefe;\n  border-radius: 0;\n  position: relative;\n  top: 100px;\n  margin-left: auto;\n  margin-right: auto;\n  overflow-y: auto; }\n  [data-whatinput='mouse'] .reveal {\n    outline: 0; }\n  @media screen and (min-width: 40em) {\n    .reveal {\n      min-height: 0; } }\n  .reveal .column, .reveal .columns,\n  .reveal .columns {\n    min-width: 0; }\n  .reveal > :last-child {\n    margin-bottom: 0; }\n  @media screen and (min-width: 40em) {\n    .reveal {\n      width: 600px;\n      max-width: 75rem; } }\n  @media screen and (min-width: 40em) {\n    .reveal .reveal {\n      left: auto;\n      right: auto;\n      margin: 0 auto; } }\n  .reveal.collapse {\n    padding: 0; }\n  @media screen and (min-width: 40em) {\n    .reveal.tiny {\n      width: 30%;\n      max-width: 75rem; } }\n  @media screen and (min-width: 40em) {\n    .reveal.small {\n      width: 50%;\n      max-width: 75rem; } }\n  @media screen and (min-width: 40em) {\n    .reveal.large {\n      width: 90%;\n      max-width: 75rem; } }\n  .reveal.full {\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    height: 100vh;\n    min-height: 100vh;\n    max-width: none;\n    margin-left: 0;\n    border: 0;\n    border-radius: 0; }\n  @media screen and (max-width: 39.9375em) {\n    .reveal {\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n      height: 100vh;\n      min-height: 100vh;\n      max-width: none;\n      margin-left: 0;\n      border: 0;\n      border-radius: 0; } }\n  .reveal.without-overlay {\n    position: fixed; }\n\n.switch {\n  margin-bottom: 1rem;\n  outline: 0;\n  position: relative;\n  user-select: none;\n  color: #fefefe;\n  font-weight: bold;\n  font-size: 0.875rem; }\n\n.switch-input {\n  opacity: 0;\n  position: absolute; }\n\n.switch-paddle {\n  background: #cacaca;\n  cursor: pointer;\n  display: block;\n  position: relative;\n  width: 4rem;\n  height: 2rem;\n  transition: all 0.25s ease-out;\n  border-radius: 0;\n  color: inherit;\n  font-weight: inherit; }\n  input + .switch-paddle {\n    margin: 0; }\n  .switch-paddle::after {\n    background: #fefefe;\n    content: '';\n    display: block;\n    position: absolute;\n    height: 1.5rem;\n    left: 0.25rem;\n    top: 0.25rem;\n    width: 1.5rem;\n    transition: all 0.25s ease-out;\n    transform: translate3d(0, 0, 0);\n    border-radius: 0; }\n  input:checked ~ .switch-paddle {\n    background: #2199e8; }\n    input:checked ~ .switch-paddle::after {\n      left: 2.25rem; }\n  [data-whatinput='mouse'] input:focus ~ .switch-paddle {\n    outline: 0; }\n\n.switch-active, .switch-inactive {\n  position: absolute;\n  top: 50%;\n  transform: translateY(-50%); }\n\n.switch-active {\n  left: 8%;\n  display: none; }\n  input:checked + label > .switch-active {\n    display: block; }\n\n.switch-inactive {\n  right: 15%; }\n  input:checked + label > .switch-inactive {\n    display: none; }\n\n.switch.tiny .switch-paddle {\n  width: 3rem;\n  height: 1.5rem;\n  font-size: 0.625rem; }\n\n.switch.tiny .switch-paddle::after {\n  width: 1rem;\n  height: 1rem; }\n\n.switch.tiny input:checked ~ .switch-paddle::after {\n  left: 1.75rem; }\n\n.switch.small .switch-paddle {\n  width: 3.5rem;\n  height: 1.75rem;\n  font-size: 0.75rem; }\n\n.switch.small .switch-paddle::after {\n  width: 1.25rem;\n  height: 1.25rem; }\n\n.switch.small input:checked ~ .switch-paddle::after {\n  left: 2rem; }\n\n.switch.large .switch-paddle {\n  width: 5rem;\n  height: 2.5rem;\n  font-size: 1rem; }\n\n.switch.large .switch-paddle::after {\n  width: 2rem;\n  height: 2rem; }\n\n.switch.large input:checked ~ .switch-paddle::after {\n  left: 2.75rem; }\n\ntable {\n  width: 100%;\n  margin-bottom: 1rem;\n  border-radius: 0; }\n  table thead,\n  table tbody,\n  table tfoot {\n    border: 1px solid #f1f1f1;\n    background-color: #fefefe; }\n  table caption {\n    font-weight: bold;\n    padding: 0.5rem 0.625rem 0.625rem; }\n  table thead,\n  table tfoot {\n    background: #f8f8f8;\n    color: #0a0a0a; }\n    table thead tr,\n    table tfoot tr {\n      background: transparent; }\n    table thead th,\n    table thead td,\n    table tfoot th,\n    table tfoot td {\n      padding: 0.5rem 0.625rem 0.625rem;\n      font-weight: bold;\n      text-align: left; }\n  table tbody tr:nth-child(even) {\n    background-color: #f1f1f1; }\n  table tbody th,\n  table tbody td {\n    padding: 0.5rem 0.625rem 0.625rem; }\n\n@media screen and (max-width: 63.9375em) {\n  table.stack thead {\n    display: none; }\n  table.stack tfoot {\n    display: none; }\n  table.stack tr,\n  table.stack th,\n  table.stack td {\n    display: block; }\n  table.stack td {\n    border-top: 0; } }\n\ntable.scroll {\n  display: block;\n  width: 100%;\n  overflow-x: auto; }\n\ntable.hover tr:hover {\n  background-color: #f9f9f9; }\n\ntable.hover tr:nth-of-type(even):hover {\n  background-color: #ececec; }\n\n.table-scroll {\n  overflow-x: auto; }\n  .table-scroll table {\n    width: auto; }\n\n.tabs {\n  margin: 0;\n  list-style-type: none;\n  background: #fefefe;\n  border: 1px solid #e6e6e6; }\n  .tabs::before, .tabs::after {\n    content: ' ';\n    display: table; }\n  .tabs::after {\n    clear: both; }\n\n.tabs.vertical > li {\n  width: auto;\n  float: none;\n  display: block; }\n\n.tabs.simple > li > a {\n  padding: 0; }\n  .tabs.simple > li > a:hover {\n    background: transparent; }\n\n.tabs.primary {\n  background: #2199e8; }\n  .tabs.primary > li > a {\n    color: #fefefe; }\n    .tabs.primary > li > a:hover, .tabs.primary > li > a:focus {\n      background: #1893e4; }\n\n.tabs-title {\n  float: left; }\n  .tabs-title > a {\n    display: block;\n    padding: 1.25rem 1.5rem;\n    line-height: 1;\n    font-size: 0.75rem; }\n    .tabs-title > a:hover {\n      background: #fefefe; }\n    .tabs-title > a:focus, .tabs-title > a[aria-selected='true'] {\n      background: #e6e6e6; }\n\n.tabs-content {\n  background: #fefefe;\n  transition: all 0.5s ease;\n  border: 1px solid #e6e6e6;\n  border-top: 0; }\n\n.tabs-content.vertical {\n  border: 1px solid #e6e6e6;\n  border-left: 0; }\n\n.tabs-panel {\n  display: none;\n  padding: 1rem; }\n  .tabs-panel.is-active {\n    display: block; }\n\n.thumbnail {\n  border: solid 4px #fefefe;\n  box-shadow: 0 0 0 1px rgba(10, 10, 10, 0.2);\n  display: inline-block;\n  line-height: 0;\n  max-width: 100%;\n  transition: box-shadow 200ms ease-out;\n  border-radius: 0;\n  margin-bottom: 1rem; }\n  .thumbnail:hover, .thumbnail:focus {\n    box-shadow: 0 0 6px 1px rgba(33, 153, 232, 0.5); }\n\n.title-bar {\n  background: #0a0a0a;\n  color: #fefefe;\n  padding: 0.5rem; }\n  .title-bar::before, .title-bar::after {\n    content: ' ';\n    display: table; }\n  .title-bar::after {\n    clear: both; }\n  .title-bar .menu-icon {\n    margin-left: 0.25rem;\n    margin-right: 0.25rem; }\n\n.title-bar-left {\n  float: left; }\n\n.title-bar-right {\n  float: right;\n  text-align: right; }\n\n.title-bar-title {\n  font-weight: bold;\n  vertical-align: middle;\n  display: inline-block; }\n\n.menu-icon.dark {\n  position: relative;\n  display: inline-block;\n  vertical-align: middle;\n  cursor: pointer;\n  width: 20px;\n  height: 16px; }\n  .menu-icon.dark::after {\n    content: '';\n    position: absolute;\n    display: block;\n    width: 100%;\n    height: 2px;\n    background: #0a0a0a;\n    top: 0;\n    left: 0;\n    box-shadow: 0 7px 0 #0a0a0a, 0 14px 0 #0a0a0a; }\n  .menu-icon.dark:hover::after {\n    background: #8a8a8a;\n    box-shadow: 0 7px 0 #8a8a8a, 0 14px 0 #8a8a8a; }\n\n.has-tip {\n  border-bottom: dotted 1px #8a8a8a;\n  font-weight: bold;\n  position: relative;\n  display: inline-block;\n  cursor: help; }\n\n.tooltip {\n  background-color: #0a0a0a;\n  color: #fefefe;\n  font-size: 80%;\n  padding: 0.75rem;\n  position: absolute;\n  z-index: 10;\n  top: calc(100% + 0.6495rem);\n  max-width: 10rem !important;\n  border-radius: 0; }\n  .tooltip::before {\n    content: '';\n    display: block;\n    width: 0;\n    height: 0;\n    border: inset 0.75rem;\n    border-color: transparent transparent #0a0a0a;\n    border-bottom-style: solid;\n    border-top-width: 0;\n    bottom: 100%;\n    position: absolute;\n    left: 50%;\n    transform: translateX(-50%); }\n  .tooltip.top::before {\n    content: '';\n    display: block;\n    width: 0;\n    height: 0;\n    border: inset 0.75rem;\n    border-color: #0a0a0a transparent transparent;\n    border-top-style: solid;\n    border-bottom-width: 0;\n    top: 100%;\n    bottom: auto; }\n  .tooltip.left::before {\n    content: '';\n    display: block;\n    width: 0;\n    height: 0;\n    border: inset 0.75rem;\n    border-color: transparent transparent transparent #0a0a0a;\n    border-left-style: solid;\n    border-right-width: 0;\n    bottom: auto;\n    left: 100%;\n    top: 50%;\n    transform: translateY(-50%); }\n  .tooltip.right::before {\n    content: '';\n    display: block;\n    width: 0;\n    height: 0;\n    border: inset 0.75rem;\n    border-color: transparent #0a0a0a transparent transparent;\n    border-right-style: solid;\n    border-left-width: 0;\n    bottom: auto;\n    left: auto;\n    right: 100%;\n    top: 50%;\n    transform: translateY(-50%); }\n\n.top-bar {\n  padding: 0.5rem; }\n  .top-bar::before, .top-bar::after {\n    content: ' ';\n    display: table; }\n  .top-bar::after {\n    clear: both; }\n  .top-bar,\n  .top-bar ul {\n    background-color: #e6e6e6; }\n  .top-bar input {\n    max-width: 200px;\n    margin-right: 1rem; }\n  .top-bar .input-group-field {\n    width: 100%;\n    margin-right: 0; }\n  .top-bar input.button {\n    width: auto; }\n  .top-bar .top-bar-left,\n  .top-bar .top-bar-right {\n    width: 100%; }\n  @media screen and (min-width: 40em) {\n    .top-bar .top-bar-left,\n    .top-bar .top-bar-right {\n      width: auto; } }\n  @media screen and (max-width: 63.9375em) {\n    .top-bar.stacked-for-medium .top-bar-left,\n    .top-bar.stacked-for-medium .top-bar-right {\n      width: 100%; } }\n  @media screen and (max-width: 74.9375em) {\n    .top-bar.stacked-for-large .top-bar-left,\n    .top-bar.stacked-for-large .top-bar-right {\n      width: 100%; } }\n\n.top-bar-title {\n  float: left;\n  margin-right: 1rem; }\n\n.top-bar-left {\n  float: left; }\n\n.top-bar-right {\n  float: right; }\n\n.hide {\n  display: none !important; }\n\n.invisible {\n  visibility: hidden; }\n\n@media screen and (max-width: 39.9375em) {\n  .hide-for-small-only {\n    display: none !important; } }\n\n@media screen and (max-width: 0em), screen and (min-width: 40em) {\n  .show-for-small-only {\n    display: none !important; } }\n\n@media screen and (min-width: 40em) {\n  .hide-for-medium {\n    display: none !important; } }\n\n@media screen and (max-width: 39.9375em) {\n  .show-for-medium {\n    display: none !important; } }\n\n@media screen and (min-width: 40em) and (max-width: 63.9375em) {\n  .hide-for-medium-only {\n    display: none !important; } }\n\n@media screen and (max-width: 39.9375em), screen and (min-width: 64em) {\n  .show-for-medium-only {\n    display: none !important; } }\n\n@media screen and (min-width: 64em) {\n  .hide-for-large {\n    display: none !important; } }\n\n@media screen and (max-width: 63.9375em) {\n  .show-for-large {\n    display: none !important; } }\n\n@media screen and (min-width: 64em) and (max-width: 74.9375em) {\n  .hide-for-large-only {\n    display: none !important; } }\n\n@media screen and (max-width: 63.9375em), screen and (min-width: 75em) {\n  .show-for-large-only {\n    display: none !important; } }\n\n.show-for-sr,\n.show-on-focus {\n  position: absolute !important;\n  width: 1px;\n  height: 1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0); }\n\n.show-on-focus:active, .show-on-focus:focus {\n  position: static !important;\n  height: auto;\n  width: auto;\n  overflow: visible;\n  clip: auto; }\n\n.show-for-landscape,\n.hide-for-portrait {\n  display: block !important; }\n  @media screen and (orientation: landscape) {\n    .show-for-landscape,\n    .hide-for-portrait {\n      display: block !important; } }\n  @media screen and (orientation: portrait) {\n    .show-for-landscape,\n    .hide-for-portrait {\n      display: none !important; } }\n\n.hide-for-landscape,\n.show-for-portrait {\n  display: none !important; }\n  @media screen and (orientation: landscape) {\n    .hide-for-landscape,\n    .show-for-portrait {\n      display: none !important; } }\n  @media screen and (orientation: portrait) {\n    .hide-for-landscape,\n    .show-for-portrait {\n      display: block !important; } }\n\n.float-left {\n  float: left !important; }\n\n.float-right {\n  float: right !important; }\n\n.float-center {\n  display: block;\n  margin-left: auto;\n  margin-right: auto; }\n\n.clearfix::before, .clearfix::after {\n  content: ' ';\n  display: table; }\n\n.clearfix::after {\n  clear: both; }\n", ""]);
	
	// exports


/***/ },
/* 231 */
/***/ function(module, exports) {

	"use strict";
	
	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function () {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for (var i = 0; i < this.length; i++) {
				var item = this[i];
				if (item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function (modules, mediaQuery) {
			if (typeof modules === "string") modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for (var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if (typeof id === "number") alreadyImportedModules[id] = true;
			}
			for (i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if (mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if (mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}
	
	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}
	
	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 233 */,
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;
	
	var _createStore = __webpack_require__(235);
	
	var _createStore2 = _interopRequireDefault(_createStore);
	
	var _combineReducers = __webpack_require__(244);
	
	var _combineReducers2 = _interopRequireDefault(_combineReducers);
	
	var _bindActionCreators = __webpack_require__(246);
	
	var _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);
	
	var _applyMiddleware = __webpack_require__(247);
	
	var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);
	
	var _compose = __webpack_require__(248);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	var _warning = __webpack_require__(245);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	/*
	* This is a dummy function to check if the function name has been altered by minification.
	* If the function has been minified and NODE_ENV !== 'production', warn the user.
	*/
	function isCrushed() {}
	
	if (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
	  (0, _warning2['default'])('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
	}
	
	exports.createStore = _createStore2['default'];
	exports.combineReducers = _combineReducers2['default'];
	exports.bindActionCreators = _bindActionCreators2['default'];
	exports.applyMiddleware = _applyMiddleware2['default'];
	exports.compose = _compose2['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	exports.ActionTypes = undefined;
	exports['default'] = createStore;
	
	var _isPlainObject = __webpack_require__(236);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _symbolObservable = __webpack_require__(240);
	
	var _symbolObservable2 = _interopRequireDefault(_symbolObservable);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	/**
	 * These are private action types reserved by Redux.
	 * For any unknown actions, you must return the current state.
	 * If the current state is undefined, you must return the initial state.
	 * Do not reference these action types directly in your code.
	 */
	var ActionTypes = exports.ActionTypes = {
	  INIT: '@@redux/INIT'
	};
	
	/**
	 * Creates a Redux store that holds the state tree.
	 * The only way to change the data in the store is to call `dispatch()` on it.
	 *
	 * There should only be a single store in your app. To specify how different
	 * parts of the state tree respond to actions, you may combine several reducers
	 * into a single reducer function by using `combineReducers`.
	 *
	 * @param {Function} reducer A function that returns the next state tree, given
	 * the current state tree and the action to handle.
	 *
	 * @param {any} [preloadedState] The initial state. You may optionally specify it
	 * to hydrate the state from the server in universal apps, or to restore a
	 * previously serialized user session.
	 * If you use `combineReducers` to produce the root reducer function, this must be
	 * an object with the same shape as `combineReducers` keys.
	 *
	 * @param {Function} enhancer The store enhancer. You may optionally specify it
	 * to enhance the store with third-party capabilities such as middleware,
	 * time travel, persistence, etc. The only store enhancer that ships with Redux
	 * is `applyMiddleware()`.
	 *
	 * @returns {Store} A Redux store that lets you read the state, dispatch actions
	 * and subscribe to changes.
	 */
	function createStore(reducer, preloadedState, enhancer) {
	  var _ref2;
	
	  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
	    enhancer = preloadedState;
	    preloadedState = undefined;
	  }
	
	  if (typeof enhancer !== 'undefined') {
	    if (typeof enhancer !== 'function') {
	      throw new Error('Expected the enhancer to be a function.');
	    }
	
	    return enhancer(createStore)(reducer, preloadedState);
	  }
	
	  if (typeof reducer !== 'function') {
	    throw new Error('Expected the reducer to be a function.');
	  }
	
	  var currentReducer = reducer;
	  var currentState = preloadedState;
	  var currentListeners = [];
	  var nextListeners = currentListeners;
	  var isDispatching = false;
	
	  function ensureCanMutateNextListeners() {
	    if (nextListeners === currentListeners) {
	      nextListeners = currentListeners.slice();
	    }
	  }
	
	  /**
	   * Reads the state tree managed by the store.
	   *
	   * @returns {any} The current state tree of your application.
	   */
	  function getState() {
	    return currentState;
	  }
	
	  /**
	   * Adds a change listener. It will be called any time an action is dispatched,
	   * and some part of the state tree may potentially have changed. You may then
	   * call `getState()` to read the current state tree inside the callback.
	   *
	   * You may call `dispatch()` from a change listener, with the following
	   * caveats:
	   *
	   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
	   * If you subscribe or unsubscribe while the listeners are being invoked, this
	   * will not have any effect on the `dispatch()` that is currently in progress.
	   * However, the next `dispatch()` call, whether nested or not, will use a more
	   * recent snapshot of the subscription list.
	   *
	   * 2. The listener should not expect to see all state changes, as the state
	   * might have been updated multiple times during a nested `dispatch()` before
	   * the listener is called. It is, however, guaranteed that all subscribers
	   * registered before the `dispatch()` started will be called with the latest
	   * state by the time it exits.
	   *
	   * @param {Function} listener A callback to be invoked on every dispatch.
	   * @returns {Function} A function to remove this change listener.
	   */
	  function subscribe(listener) {
	    if (typeof listener !== 'function') {
	      throw new Error('Expected listener to be a function.');
	    }
	
	    var isSubscribed = true;
	
	    ensureCanMutateNextListeners();
	    nextListeners.push(listener);
	
	    return function unsubscribe() {
	      if (!isSubscribed) {
	        return;
	      }
	
	      isSubscribed = false;
	
	      ensureCanMutateNextListeners();
	      var index = nextListeners.indexOf(listener);
	      nextListeners.splice(index, 1);
	    };
	  }
	
	  /**
	   * Dispatches an action. It is the only way to trigger a state change.
	   *
	   * The `reducer` function, used to create the store, will be called with the
	   * current state tree and the given `action`. Its return value will
	   * be considered the **next** state of the tree, and the change listeners
	   * will be notified.
	   *
	   * The base implementation only supports plain object actions. If you want to
	   * dispatch a Promise, an Observable, a thunk, or something else, you need to
	   * wrap your store creating function into the corresponding middleware. For
	   * example, see the documentation for the `redux-thunk` package. Even the
	   * middleware will eventually dispatch plain object actions using this method.
	   *
	   * @param {Object} action A plain object representing “what changed”. It is
	   * a good idea to keep actions serializable so you can record and replay user
	   * sessions, or use the time travelling `redux-devtools`. An action must have
	   * a `type` property which may not be `undefined`. It is a good idea to use
	   * string constants for action types.
	   *
	   * @returns {Object} For convenience, the same action object you dispatched.
	   *
	   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
	   * return something else (for example, a Promise you can await).
	   */
	  function dispatch(action) {
	    if (!(0, _isPlainObject2['default'])(action)) {
	      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
	    }
	
	    if (typeof action.type === 'undefined') {
	      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
	    }
	
	    if (isDispatching) {
	      throw new Error('Reducers may not dispatch actions.');
	    }
	
	    try {
	      isDispatching = true;
	      currentState = currentReducer(currentState, action);
	    } finally {
	      isDispatching = false;
	    }
	
	    var listeners = currentListeners = nextListeners;
	    for (var i = 0; i < listeners.length; i++) {
	      listeners[i]();
	    }
	
	    return action;
	  }
	
	  /**
	   * Replaces the reducer currently used by the store to calculate the state.
	   *
	   * You might need this if your app implements code splitting and you want to
	   * load some of the reducers dynamically. You might also need this if you
	   * implement a hot reloading mechanism for Redux.
	   *
	   * @param {Function} nextReducer The reducer for the store to use instead.
	   * @returns {void}
	   */
	  function replaceReducer(nextReducer) {
	    if (typeof nextReducer !== 'function') {
	      throw new Error('Expected the nextReducer to be a function.');
	    }
	
	    currentReducer = nextReducer;
	    dispatch({ type: ActionTypes.INIT });
	  }
	
	  /**
	   * Interoperability point for observable/reactive libraries.
	   * @returns {observable} A minimal observable of state changes.
	   * For more information, see the observable proposal:
	   * https://github.com/zenparsing/es-observable
	   */
	  function observable() {
	    var _ref;
	
	    var outerSubscribe = subscribe;
	    return _ref = {
	      /**
	       * The minimal observable subscription method.
	       * @param {Object} observer Any object that can be used as an observer.
	       * The observer object should have a `next` method.
	       * @returns {subscription} An object with an `unsubscribe` method that can
	       * be used to unsubscribe the observable from the store, and prevent further
	       * emission of values from the observable.
	       */
	      subscribe: function subscribe(observer) {
	        if ((typeof observer === 'undefined' ? 'undefined' : _typeof(observer)) !== 'object') {
	          throw new TypeError('Expected the observer to be an object.');
	        }
	
	        function observeState() {
	          if (observer.next) {
	            observer.next(getState());
	          }
	        }
	
	        observeState();
	        var unsubscribe = outerSubscribe(observeState);
	        return { unsubscribe: unsubscribe };
	      }
	    }, _ref[_symbolObservable2['default']] = function () {
	      return this;
	    }, _ref;
	  }
	
	  // When a store is created, an "INIT" action is dispatched so that every
	  // reducer returns their initial state. This effectively populates
	  // the initial state tree.
	  dispatch({ type: ActionTypes.INIT });
	
	  return _ref2 = {
	    dispatch: dispatch,
	    subscribe: subscribe,
	    getState: getState,
	    replaceReducer: replaceReducer
	  }, _ref2[_symbolObservable2['default']] = observable, _ref2;
	}

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var getPrototype = __webpack_require__(237),
	    isObjectLike = __webpack_require__(239);
	
	/** `Object#toString` result references. */
	var objectTag = '[object Object]';
	
	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) || objectToString.call(value) != objectTag) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
	}
	
	module.exports = isPlainObject;

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var overArg = __webpack_require__(238);
	
	/** Built-in value references. */
	var getPrototype = overArg(Object.getPrototypeOf, Object);
	
	module.exports = getPrototype;

/***/ },
/* 238 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function (arg) {
	    return func(transform(arg));
	  };
	}
	
	module.exports = overArg;

/***/ },
/* 239 */
/***/ function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object';
	}
	
	module.exports = isObjectLike;

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(241);

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module, global) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _ponyfill = __webpack_require__(243);
	
	var _ponyfill2 = _interopRequireDefault(_ponyfill);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var root = module; /* global window */
	
	if (typeof self !== 'undefined') {
	  root = self;
	} else if (typeof window !== 'undefined') {
	  root = window;
	} else if (typeof global !== 'undefined') {
	  root = global;
	} else {
	  root = Function('return this')();
	}
	
	var result = (0, _ponyfill2['default'])(root);
	exports['default'] = result;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(242)(module), (function() { return this; }())))

/***/ },
/* 242 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = function (module) {
		if (!module.webpackPolyfill) {
			module.deprecate = function () {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	};

/***/ },
/* 243 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports['default'] = symbolObservablePonyfill;
	function symbolObservablePonyfill(root) {
		var result;
		var _Symbol = root.Symbol;
	
		if (typeof _Symbol === 'function') {
			if (_Symbol.observable) {
				result = _Symbol.observable;
			} else {
				result = _Symbol('observable');
				_Symbol.observable = result;
			}
		} else {
			result = '@@observable';
		}
	
		return result;
	};

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports['default'] = combineReducers;
	
	var _createStore = __webpack_require__(235);
	
	var _isPlainObject = __webpack_require__(236);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _warning = __webpack_require__(245);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	function getUndefinedStateErrorMessage(key, action) {
	  var actionType = action && action.type;
	  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';
	
	  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state.';
	}
	
	function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
	  var reducerKeys = Object.keys(reducers);
	  var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';
	
	  if (reducerKeys.length === 0) {
	    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
	  }
	
	  if (!(0, _isPlainObject2['default'])(inputState)) {
	    return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
	  }
	
	  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
	    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
	  });
	
	  unexpectedKeys.forEach(function (key) {
	    unexpectedKeyCache[key] = true;
	  });
	
	  if (unexpectedKeys.length > 0) {
	    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
	  }
	}
	
	function assertReducerSanity(reducers) {
	  Object.keys(reducers).forEach(function (key) {
	    var reducer = reducers[key];
	    var initialState = reducer(undefined, { type: _createStore.ActionTypes.INIT });
	
	    if (typeof initialState === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined.');
	    }
	
	    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
	    if (typeof reducer(undefined, { type: type }) === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined.');
	    }
	  });
	}
	
	/**
	 * Turns an object whose values are different reducer functions, into a single
	 * reducer function. It will call every child reducer, and gather their results
	 * into a single state object, whose keys correspond to the keys of the passed
	 * reducer functions.
	 *
	 * @param {Object} reducers An object whose values correspond to different
	 * reducer functions that need to be combined into one. One handy way to obtain
	 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
	 * undefined for any action. Instead, they should return their initial state
	 * if the state passed to them was undefined, and the current state for any
	 * unrecognized action.
	 *
	 * @returns {Function} A reducer function that invokes every reducer inside the
	 * passed object, and builds a state object with the same shape.
	 */
	function combineReducers(reducers) {
	  var reducerKeys = Object.keys(reducers);
	  var finalReducers = {};
	  for (var i = 0; i < reducerKeys.length; i++) {
	    var key = reducerKeys[i];
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (typeof reducers[key] === 'undefined') {
	        (0, _warning2['default'])('No reducer provided for key "' + key + '"');
	      }
	    }
	
	    if (typeof reducers[key] === 'function') {
	      finalReducers[key] = reducers[key];
	    }
	  }
	  var finalReducerKeys = Object.keys(finalReducers);
	
	  if (process.env.NODE_ENV !== 'production') {
	    var unexpectedKeyCache = {};
	  }
	
	  var sanityError;
	  try {
	    assertReducerSanity(finalReducers);
	  } catch (e) {
	    sanityError = e;
	  }
	
	  return function combination() {
	    var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	    var action = arguments[1];
	
	    if (sanityError) {
	      throw sanityError;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
	      if (warningMessage) {
	        (0, _warning2['default'])(warningMessage);
	      }
	    }
	
	    var hasChanged = false;
	    var nextState = {};
	    for (var i = 0; i < finalReducerKeys.length; i++) {
	      var key = finalReducerKeys[i];
	      var reducer = finalReducers[key];
	      var previousStateForKey = state[key];
	      var nextStateForKey = reducer(previousStateForKey, action);
	      if (typeof nextStateForKey === 'undefined') {
	        var errorMessage = getUndefinedStateErrorMessage(key, action);
	        throw new Error(errorMessage);
	      }
	      nextState[key] = nextStateForKey;
	      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
	    }
	    return hasChanged ? nextState : state;
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 245 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = warning;
	/**
	 * Prints a warning in the console if it exists.
	 *
	 * @param {String} message The warning message.
	 * @returns {void}
	 */
	function warning(message) {
	  /* eslint-disable no-console */
	  if (typeof console !== 'undefined' && typeof console.error === 'function') {
	    console.error(message);
	  }
	  /* eslint-enable no-console */
	  try {
	    // This error was thrown as a convenience so that if you enable
	    // "break on all exceptions" in your console,
	    // it would pause the execution at this line.
	    throw new Error(message);
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	}

/***/ },
/* 246 */
/***/ function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	exports['default'] = bindActionCreators;
	function bindActionCreator(actionCreator, dispatch) {
	  return function () {
	    return dispatch(actionCreator.apply(undefined, arguments));
	  };
	}
	
	/**
	 * Turns an object whose values are action creators, into an object with the
	 * same keys, but with every function wrapped into a `dispatch` call so they
	 * may be invoked directly. This is just a convenience method, as you can call
	 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
	 *
	 * For convenience, you can also pass a single function as the first argument,
	 * and get a function in return.
	 *
	 * @param {Function|Object} actionCreators An object whose values are action
	 * creator functions. One handy way to obtain it is to use ES6 `import * as`
	 * syntax. You may also pass a single function.
	 *
	 * @param {Function} dispatch The `dispatch` function available on your Redux
	 * store.
	 *
	 * @returns {Function|Object} The object mimicking the original object, but with
	 * every action creator wrapped into the `dispatch` call. If you passed a
	 * function as `actionCreators`, the return value will also be a single
	 * function.
	 */
	function bindActionCreators(actionCreators, dispatch) {
	  if (typeof actionCreators === 'function') {
	    return bindActionCreator(actionCreators, dispatch);
	  }
	
	  if ((typeof actionCreators === 'undefined' ? 'undefined' : _typeof(actionCreators)) !== 'object' || actionCreators === null) {
	    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators === 'undefined' ? 'undefined' : _typeof(actionCreators)) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
	  }
	
	  var keys = Object.keys(actionCreators);
	  var boundActionCreators = {};
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    var actionCreator = actionCreators[key];
	    if (typeof actionCreator === 'function') {
	      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
	    }
	  }
	  return boundActionCreators;
	}

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	exports['default'] = applyMiddleware;
	
	var _compose = __webpack_require__(248);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	/**
	 * Creates a store enhancer that applies middleware to the dispatch method
	 * of the Redux store. This is handy for a variety of tasks, such as expressing
	 * asynchronous actions in a concise manner, or logging every action payload.
	 *
	 * See `redux-thunk` package as an example of the Redux middleware.
	 *
	 * Because middleware is potentially asynchronous, this should be the first
	 * store enhancer in the composition chain.
	 *
	 * Note that each middleware will be given the `dispatch` and `getState` functions
	 * as named arguments.
	 *
	 * @param {...Function} middlewares The middleware chain to be applied.
	 * @returns {Function} A store enhancer applying the middleware.
	 */
	function applyMiddleware() {
	  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }
	
	  return function (createStore) {
	    return function (reducer, preloadedState, enhancer) {
	      var store = createStore(reducer, preloadedState, enhancer);
	      var _dispatch = store.dispatch;
	      var chain = [];
	
	      var middlewareAPI = {
	        getState: store.getState,
	        dispatch: function dispatch(action) {
	          return _dispatch(action);
	        }
	      };
	      chain = middlewares.map(function (middleware) {
	        return middleware(middlewareAPI);
	      });
	      _dispatch = _compose2['default'].apply(undefined, chain)(store.dispatch);
	
	      return _extends({}, store, {
	        dispatch: _dispatch
	      });
	    };
	  };
	}

/***/ },
/* 248 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = compose;
	/**
	 * Composes single-argument functions from right to left. The rightmost
	 * function can take multiple arguments as it provides the signature for
	 * the resulting composite function.
	 *
	 * @param {...Function} funcs The functions to compose.
	 * @returns {Function} A function obtained by composing the argument functions
	 * from right to left. For example, compose(f, g, h) is identical to doing
	 * (...args) => f(g(h(...args))).
	 */
	
	function compose() {
	  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
	    funcs[_key] = arguments[_key];
	  }
	
	  if (funcs.length === 0) {
	    return function (arg) {
	      return arg;
	    };
	  }
	
	  if (funcs.length === 1) {
	    return funcs[0];
	  }
	
	  var last = funcs[funcs.length - 1];
	  var rest = funcs.slice(0, -1);
	  return function () {
	    return rest.reduceRight(function (composed, f) {
	      return f(composed);
	    }, last.apply(undefined, arguments));
	  };
	}

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var redux = __webpack_require__(234);
	
	console.log('starting redux todo example');
	
	var stateDefault = {
	  searchText: '',
	  showCompleted: false,
	  todos: []
	};
	var reducer = function reducer() {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : stateDefault;
	  var action = arguments[1];
	
	
	  switch (action.type) {
	    case 'CHANGE_SEARCH_TEXT':
	      return _extends({}, state, {
	        searchText: action.searchText
	      });
	    default:
	      return state;
	  };
	};
	
	var store = redux.createStore(reducer, redux.compose(window.devToolsExtension ? window.devToolsExtension() : function (f) {
	  return f;
	}));
	
	store.subscribe(function () {
	  var state = store.getState();
	  document.getElementById('app').innerHTML = state.searchText;
	});
	
	var currentState = store.getState();
	console.log('currentState', currentState);
	
	store.dispatch({
	  type: 'CHANGE_SEARCH_TEXT',
	  searchText: 'mince'
	});
	
	store.dispatch({
	  type: 'CHANGE_SEARCH_TEXT',
	  searchText: 'potatoes'
	});

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNmFhN2E1NzZlNGMwN2I1YTE0NmEiLCJ3ZWJwYWNrOi8vLy4vfi9qcXVlcnkvZGlzdC9qcXVlcnkubWluLmpzPzZlZjYiLCJ3ZWJwYWNrOi8vLy4vfi9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2pxdWVyeS9kaXN0L2pxdWVyeS5taW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9mb3VuZGF0aW9uLXNpdGVzL2Rpc3QvZm91bmRhdGlvbi5taW4uanM/YjYxYiIsIndlYnBhY2s6Ly8vLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9mb3VuZGF0aW9uLm1pbi5qcyIsIndlYnBhY2s6Ly8vLi9hcHAvYXBwLmpzeCIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJqUXVlcnlcIiIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L3JlYWN0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NLmpzIiwid2VicGFjazovLy8uL34vcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Q3VycmVudE93bmVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NVGV4dENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9ET01DaGlsZHJlbk9wZXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRGFuZ2VyLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9jcmVhdGVOb2Rlc0Zyb21NYXJrdXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9jcmVhdGVBcnJheUZyb21NaXhlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL3RvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9pbnZhcmlhbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9nZXRNYXJrdXBXcmFwLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2tleU1pcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdFBlcmYuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvc2V0SW5uZXJIVE1MLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL3NldFRleHRDb250ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRE9NUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi93YXJuaW5nLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NSURPcGVyYXRpb25zLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0TW91bnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0V2ZW50Q29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0V2ZW50UGx1Z2luSHViLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0V2ZW50UGx1Z2luUmVnaXN0cnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRXZlbnRQbHVnaW5VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEVycm9yVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvYWNjdW11bGF0ZUludG8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZm9yRWFjaEFjY3VtdWxhdGVkLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RXZlbnRFbWl0dGVyTWl4aW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvVmlld3BvcnRNZXRyaWNzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL09iamVjdC5hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvaXNFdmVudFN1cHBvcnRlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTUZlYXR1cmVGbGFncy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvY2FuRGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RFbXB0eUNvbXBvbmVudFJlZ2lzdHJ5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0SW5zdGFuY2VIYW5kbGVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Um9vdEluZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0SW5zdGFuY2VNYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RNYXJrdXBDaGVja3N1bS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9hZGxlcjMyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0UmVjb25jaWxlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdFJlZi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdE93bmVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0VXBkYXRlUXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RVcGRhdGVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0NhbGxiYWNrUXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUG9vbGVkQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvVHJhbnNhY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9lbXB0eU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2NvbnRhaW5zTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2lzVGV4dE5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9pc05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVMb2NhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RFbXB0eUNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdE5hdGl2ZUNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi92YWxpZGF0ZURPTU5lc3RpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3REZWZhdWx0SW5qZWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0JlZm9yZUlucHV0RXZlbnRQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRXZlbnRQcm9wYWdhdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9GYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZ2V0VGV4dENvbnRlbnRBY2Nlc3Nvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0V2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0lucHV0RXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9rZXlPZi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9DaGFuZ2VFdmVudFBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9nZXRFdmVudFRhcmdldC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9pc1RleHRJbnB1dEVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvQ2xpZW50UmVhY3RSb290SW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRW50ZXJMZWF2ZUV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY01vdXNlRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljVUlFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9nZXRFdmVudE1vZGlmaWVyU3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvSFRNTERPTVByb3BlcnR5Q29uZmlnLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0QnJvd3NlckNvbXBvbmVudE1peGluLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2ZpbmRET01Ob2RlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01Db21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvQXV0b0ZvY3VzVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9mb2N1c05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvQ1NTUHJvcGVydHlPcGVyYXRpb25zLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0NTU1Byb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9jYW1lbGl6ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9kYW5nZXJvdXNTdHlsZVZhbHVlLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvaHlwaGVuYXRlLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvbWVtb2l6ZVN0cmluZ09ubHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01CdXR0b24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01JbnB1dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9MaW5rZWRWYWx1ZVV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2dldEl0ZXJhdG9yRm4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01PcHRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDaGlsZHJlbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi90cmF2ZXJzZUFsbENoaWxkcmVuLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NU2VsZWN0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NVGV4dGFyZWEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RNdWx0aUNoaWxkLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Q2hpbGRSZWNvbmNpbGVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2ZsYXR0ZW5DaGlsZHJlbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL3NoYWxsb3dFcXVhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEV2ZW50TGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9FdmVudExpc3RlbmVyLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RJbmplY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdE5vb3BVcGRhdGVRdWV1ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0SW5wdXRTZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01TZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU2VsZWN0RXZlbnRQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU2VydmVyUmVhY3RSb290SW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU2ltcGxlRXZlbnRQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljQ2xpcGJvYXJkRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljRm9jdXNFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNLZXlib2FyZEV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2dldEV2ZW50Q2hhckNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZ2V0RXZlbnRLZXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljRHJhZ0V2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY1RvdWNoRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljV2hlZWxFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TVkdET01Qcm9wZXJ0eUNvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERlZmF1bHRQZXJmLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL3BlcmZvcm1hbmNlTm93LmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvcGVyZm9ybWFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RWZXJzaW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NU2VydmVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0U2VydmVyUmVuZGVyaW5nLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0U2VydmVyQmF0Y2hpbmdTdHJhdGVneS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0SXNvbW9ycGhpYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTUZhY3Rvcmllcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEVsZW1lbnRWYWxpZGF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9tYXBPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvb25seUNoaWxkLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2RlcHJlY2F0ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZVV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9Qcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL3JvdXRlcldhcm5pbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi93YXJuaW5nL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL0ludGVybmFsUHJvcFR5cGVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9QYXR0ZXJuVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9pbnZhcmlhbnQvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvUm91dGVyLmpzIiwid2VicGFjazovLy8uL34vaGlzdG9yeS9saWIvY3JlYXRlSGFzaEhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L34vd2FybmluZy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vaGlzdG9yeS9saWIvQWN0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpc3RvcnkvbGliL1BhdGhVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpc3RvcnkvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzIiwid2VicGFjazovLy8uL34vaGlzdG9yeS9saWIvRE9NVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9ET01TdGF0ZVN0b3JhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9jcmVhdGVET01IaXN0b3J5LmpzIiwid2VicGFjazovLy8uL34vaGlzdG9yeS9saWIvY3JlYXRlSGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L2RlZXAtZXF1YWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9kZWVwLWVxdWFsL2xpYi9rZXlzLmpzIiwid2VicGFjazovLy8uL34vZGVlcC1lcXVhbC9saWIvaXNfYXJndW1lbnRzLmpzIiwid2VicGFjazovLy8uL34vaGlzdG9yeS9saWIvQXN5bmNVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpc3RvcnkvbGliL2NyZWF0ZUxvY2F0aW9uLmpzIiwid2VicGFjazovLy8uL34vaGlzdG9yeS9saWIvcnVuVHJhbnNpdGlvbkhvb2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9kZXByZWNhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi91c2VRdWVyaWVzLmpzIiwid2VicGFjazovLy8uL34vcXVlcnktc3RyaW5nL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vc3RyaWN0LXVyaS1lbmNvZGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9jb21wdXRlQ2hhbmdlZFJvdXRlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvVHJhbnNpdGlvblV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9Bc3luY1V0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9pc0FjdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvZ2V0Q29tcG9uZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvbWFrZVN0YXRlV2l0aExvY2F0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9tYXRjaFJvdXRlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvUm91dGVyQ29udGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvZ2V0Um91dGVQYXJhbXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlclV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9MaW5rLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9JbmRleExpbmsuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL3dpdGhSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvSW5kZXhSZWRpcmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvUmVkaXJlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL0luZGV4Um91dGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9IaXN0b3J5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9MaWZlY3ljbGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlQ29udGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvdXNlUm91dGVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0aW5nQ29udGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvbWF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL2NyZWF0ZU1lbW9yeUhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi91c2VCYXNlbmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpc3RvcnkvbGliL2NyZWF0ZU1lbW9yeUhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL3VzZVJvdXRlckhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL2FwcGx5Um91dGVyTWlkZGxld2FyZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvYnJvd3Nlckhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9jcmVhdGVCcm93c2VySGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvY3JlYXRlUm91dGVySGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvaGFzaEhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3N0eWxlcy9hcHAuc2Nzcz9iMjlmIiwid2VicGFjazovLy8uL2FwcC9zdHlsZXMvYXBwLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC9saWIvY3JlYXRlU3RvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNQbGFpbk9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fZ2V0UHJvdG90eXBlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19vdmVyQXJnLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lzT2JqZWN0TGlrZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3N5bWJvbC1vYnNlcnZhYmxlL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vc3ltYm9sLW9ic2VydmFibGUvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zeW1ib2wtb2JzZXJ2YWJsZS9saWIvcG9ueWZpbGwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC9saWIvY29tYmluZVJlZHVjZXJzLmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvbGliL3V0aWxzL3dhcm5pbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC9saWIvYmluZEFjdGlvbkNyZWF0b3JzLmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvbGliL2FwcGx5TWlkZGxld2FyZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L2xpYi9jb21wb3NlLmpzIiwid2VicGFjazovLy8uL2FwcC9yZWR1eC10b2RvLWV4YW1wbGUuanN4Il0sIm5hbWVzIjpbIlJlYWN0IiwicmVxdWlyZSIsIlJlYWN0RE9NIiwiUm91dGUiLCJSb3V0ZXIiLCJJbmRleFJvdXRlIiwiaGFzaEhpc3RvcnkiLCIkIiwiZG9jdW1lbnQiLCJmb3VuZGF0aW9uIiwibW9kdWxlIiwiZXhwb3J0cyIsIlJlYWN0RE9NU2VydmVyIiwiUmVhY3RJc29tb3JwaGljIiwiYXNzaWduIiwiZGVwcmVjYXRlZCIsImZpbmRET01Ob2RlIiwicmVuZGVyIiwidW5tb3VudENvbXBvbmVudEF0Tm9kZSIsInJlbmRlclRvU3RyaW5nIiwicmVuZGVyVG9TdGF0aWNNYXJrdXAiLCJfX1NFQ1JFVF9ET01fRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCIsIl9fU0VDUkVUX0RPTV9TRVJWRVJfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCIsIlJlYWN0Q3VycmVudE93bmVyIiwiUmVhY3RET01UZXh0Q29tcG9uZW50IiwiUmVhY3REZWZhdWx0SW5qZWN0aW9uIiwiUmVhY3RJbnN0YW5jZUhhbmRsZXMiLCJSZWFjdE1vdW50IiwiUmVhY3RQZXJmIiwiUmVhY3RSZWNvbmNpbGVyIiwiUmVhY3RVcGRhdGVzIiwiUmVhY3RWZXJzaW9uIiwicmVuZGVyU3VidHJlZUludG9Db250YWluZXIiLCJ3YXJuaW5nIiwiaW5qZWN0IiwibWVhc3VyZSIsInZlcnNpb24iLCJ1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyIsImJhdGNoZWRVcGRhdGVzIiwidW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIiLCJfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJDdXJyZW50T3duZXIiLCJJbnN0YW5jZUhhbmRsZXMiLCJNb3VudCIsIlJlY29uY2lsZXIiLCJUZXh0Q29tcG9uZW50IiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiRXhlY3V0aW9uRW52aXJvbm1lbnQiLCJjYW5Vc2VET00iLCJ3aW5kb3ciLCJ0b3AiLCJzZWxmIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaW5kZXhPZiIsImNvbnNvbGUiLCJkZWJ1ZyIsImllQ29tcGF0aWJpbGl0eU1vZGUiLCJkb2N1bWVudE1vZGUiLCJ1bmRlZmluZWQiLCJleHBlY3RlZEZlYXR1cmVzIiwiQXJyYXkiLCJpc0FycmF5IiwicHJvdG90eXBlIiwiZXZlcnkiLCJmb3JFYWNoIiwibWFwIiwiRGF0ZSIsIm5vdyIsIkZ1bmN0aW9uIiwiYmluZCIsIk9iamVjdCIsImtleXMiLCJTdHJpbmciLCJzcGxpdCIsInRyaW0iLCJjcmVhdGUiLCJmcmVlemUiLCJpIiwibGVuZ3RoIiwiZXJyb3IiLCJjYWNoZWRTZXRUaW1lb3V0IiwiY2FjaGVkQ2xlYXJUaW1lb3V0IiwiZGVmYXVsdFNldFRpbW91dCIsIkVycm9yIiwiZGVmYXVsdENsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJlIiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImZ1biIsImNhbGwiLCJydW5DbGVhclRpbWVvdXQiLCJtYXJrZXIiLCJxdWV1ZSIsImRyYWluaW5nIiwiY3VycmVudFF1ZXVlIiwicXVldWVJbmRleCIsImNsZWFuVXBOZXh0VGljayIsImNvbmNhdCIsImRyYWluUXVldWUiLCJ0aW1lb3V0IiwibGVuIiwicnVuIiwibmV4dFRpY2siLCJhcmdzIiwiYXJndW1lbnRzIiwicHVzaCIsIkl0ZW0iLCJhcnJheSIsImFwcGx5IiwidGl0bGUiLCJicm93c2VyIiwiYXJndiIsInZlcnNpb25zIiwibm9vcCIsIm9uIiwiYWRkTGlzdGVuZXIiLCJvbmNlIiwib2ZmIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJlbWl0IiwiYmluZGluZyIsIm5hbWUiLCJjd2QiLCJjaGRpciIsImRpciIsInVtYXNrIiwiY3VycmVudCIsIkRPTUNoaWxkcmVuT3BlcmF0aW9ucyIsIkRPTVByb3BlcnR5T3BlcmF0aW9ucyIsIlJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50IiwiZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyIiwic2V0VGV4dENvbnRlbnQiLCJ2YWxpZGF0ZURPTU5lc3RpbmciLCJwcm9wcyIsImNvbnN0cnVjdCIsInRleHQiLCJfY3VycmVudEVsZW1lbnQiLCJfc3RyaW5nVGV4dCIsIl9yb290Tm9kZUlEIiwiX21vdW50SW5kZXgiLCJtb3VudENvbXBvbmVudCIsInJvb3RJRCIsInRyYW5zYWN0aW9uIiwiY29udGV4dCIsImFuY2VzdG9ySW5mb0NvbnRleHRLZXkiLCJ1c2VDcmVhdGVFbGVtZW50Iiwib3duZXJEb2N1bWVudCIsIm93bmVyRG9jdW1lbnRDb250ZXh0S2V5IiwiZWwiLCJjcmVhdGVFbGVtZW50Iiwic2V0QXR0cmlidXRlRm9ySUQiLCJnZXRJRCIsImVzY2FwZWRUZXh0IiwiY3JlYXRlTWFya3VwRm9ySUQiLCJyZWNlaXZlQ29tcG9uZW50IiwibmV4dFRleHQiLCJuZXh0U3RyaW5nVGV4dCIsIm5vZGUiLCJnZXROb2RlIiwidXBkYXRlVGV4dENvbnRlbnQiLCJ1bm1vdW50Q29tcG9uZW50IiwidW5tb3VudElERnJvbUVudmlyb25tZW50IiwiRGFuZ2VyIiwiUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMiLCJzZXRJbm5lckhUTUwiLCJpbnZhcmlhbnQiLCJpbnNlcnRDaGlsZEF0IiwicGFyZW50Tm9kZSIsImNoaWxkTm9kZSIsImluZGV4IiwiYmVmb3JlQ2hpbGQiLCJjaGlsZE5vZGVzIiwiaXRlbSIsImluc2VydEJlZm9yZSIsImRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwIiwicHJvY2Vzc1VwZGF0ZXMiLCJ1cGRhdGVzIiwibWFya3VwTGlzdCIsInVwZGF0ZSIsImluaXRpYWxDaGlsZHJlbiIsInVwZGF0ZWRDaGlsZHJlbiIsInR5cGUiLCJNT1ZFX0VYSVNUSU5HIiwiUkVNT1ZFX05PREUiLCJ1cGRhdGVkSW5kZXgiLCJmcm9tSW5kZXgiLCJ1cGRhdGVkQ2hpbGQiLCJwYXJlbnRJRCIsInJlbmRlcmVkTWFya3VwIiwiZGFuZ2Vyb3VzbHlSZW5kZXJNYXJrdXAiLCJqIiwicmVtb3ZlQ2hpbGQiLCJrIiwiSU5TRVJUX01BUktVUCIsIm1hcmt1cEluZGV4IiwidG9JbmRleCIsIlNFVF9NQVJLVVAiLCJjb250ZW50IiwiVEVYVF9DT05URU5UIiwibWVhc3VyZU1ldGhvZHMiLCJjcmVhdGVOb2Rlc0Zyb21NYXJrdXAiLCJlbXB0eUZ1bmN0aW9uIiwiZ2V0TWFya3VwV3JhcCIsIk9QRU5fVEFHX05BTUVfRVhQIiwiUkVTVUxUX0lOREVYX0FUVFIiLCJnZXROb2RlTmFtZSIsIm1hcmt1cCIsInN1YnN0cmluZyIsIm5vZGVOYW1lIiwibWFya3VwQnlOb2RlTmFtZSIsInJlc3VsdExpc3QiLCJyZXN1bHRMaXN0QXNzaWdubWVudENvdW50IiwiaGFzT3duUHJvcGVydHkiLCJtYXJrdXBMaXN0QnlOb2RlTmFtZSIsInJlc3VsdEluZGV4IiwicmVwbGFjZSIsInJlbmRlck5vZGVzIiwiam9pbiIsInJlbmRlck5vZGUiLCJoYXNBdHRyaWJ1dGUiLCJnZXRBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJvbGRDaGlsZCIsInRhZ05hbWUiLCJ0b0xvd2VyQ2FzZSIsIm5ld0NoaWxkIiwicmVwbGFjZUNoaWxkIiwiY2FuVXNlV29ya2VycyIsIldvcmtlciIsImNhblVzZUV2ZW50TGlzdGVuZXJzIiwiYWRkRXZlbnRMaXN0ZW5lciIsImF0dGFjaEV2ZW50IiwiY2FuVXNlVmlld3BvcnQiLCJzY3JlZW4iLCJpc0luV29ya2VyIiwiY3JlYXRlQXJyYXlGcm9tTWl4ZWQiLCJkdW1teU5vZGUiLCJub2RlTmFtZVBhdHRlcm4iLCJub2RlTmFtZU1hdGNoIiwibWF0Y2giLCJoYW5kbGVTY3JpcHQiLCJ3cmFwIiwiaW5uZXJIVE1MIiwid3JhcERlcHRoIiwibGFzdENoaWxkIiwic2NyaXB0cyIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwibm9kZXMiLCJ0b0FycmF5IiwiaGFzQXJyYXlOYXR1cmUiLCJvYmoiLCJub2RlVHlwZSIsInNsaWNlIiwicmV0IiwiaWkiLCJjb25kaXRpb24iLCJmb3JtYXQiLCJhIiwiYiIsImMiLCJkIiwiZiIsImFyZ0luZGV4IiwiZnJhbWVzVG9Qb3AiLCJzaG91bGRXcmFwIiwic2VsZWN0V3JhcCIsInRhYmxlV3JhcCIsInRyV3JhcCIsInN2Z1dyYXAiLCJtYXJrdXBXcmFwIiwic3ZnRWxlbWVudHMiLCJmaXJzdENoaWxkIiwibWFrZUVtcHR5RnVuY3Rpb24iLCJhcmciLCJ0aGF0UmV0dXJucyIsInRoYXRSZXR1cm5zRmFsc2UiLCJ0aGF0UmV0dXJuc1RydWUiLCJ0aGF0UmV0dXJuc051bGwiLCJ0aGF0UmV0dXJuc1RoaXMiLCJ0aGF0UmV0dXJuc0FyZ3VtZW50Iiwia2V5TWlycm9yIiwia2V5IiwiZW5hYmxlTWVhc3VyZSIsInN0b3JlZE1lYXN1cmUiLCJfbm9NZWFzdXJlIiwib2JqZWN0Iiwib2JqZWN0TmFtZSIsIm1ldGhvZE5hbWVzIiwib2JqTmFtZSIsImZuTmFtZSIsImZ1bmMiLCJtZWFzdXJlZEZ1bmMiLCJ3cmFwcGVyIiwiZGlzcGxheU5hbWUiLCJpbmplY3Rpb24iLCJpbmplY3RNZWFzdXJlIiwiV0hJVEVTUEFDRV9URVNUIiwiTk9OVklTSUJMRV9URVNUIiwiaHRtbCIsIk1TQXBwIiwiZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24iLCJ0ZXN0RWxlbWVudCIsInRlc3QiLCJmcm9tQ2hhckNvZGUiLCJ0ZXh0Tm9kZSIsImRhdGEiLCJkZWxldGVEYXRhIiwidGV4dENvbnRlbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJFU0NBUEVfTE9PS1VQIiwiRVNDQVBFX1JFR0VYIiwiZXNjYXBlciIsIkRPTVByb3BlcnR5IiwicXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIiLCJWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWCIsImlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUiLCJ2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUiLCJpc0F0dHJpYnV0ZU5hbWVTYWZlIiwiYXR0cmlidXRlTmFtZSIsInNob3VsZElnbm9yZVZhbHVlIiwicHJvcGVydHlJbmZvIiwidmFsdWUiLCJoYXNCb29sZWFuVmFsdWUiLCJoYXNOdW1lcmljVmFsdWUiLCJpc05hTiIsImhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlIiwiaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSIsInJlYWN0UHJvcHMiLCJjaGlsZHJlbiIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwicmVmIiwid2FybmVkUHJvcGVydGllcyIsIndhcm5Vbmtub3duUHJvcGVydHkiLCJsb3dlckNhc2VkTmFtZSIsInN0YW5kYXJkTmFtZSIsImlzQ3VzdG9tQXR0cmlidXRlIiwiZ2V0UG9zc2libGVTdGFuZGFyZE5hbWUiLCJpZCIsIklEX0FUVFJJQlVURV9OQU1FIiwic2V0QXR0cmlidXRlIiwiY3JlYXRlTWFya3VwRm9yUHJvcGVydHkiLCJwcm9wZXJ0aWVzIiwiY3JlYXRlTWFya3VwRm9yQ3VzdG9tQXR0cmlidXRlIiwic2V0VmFsdWVGb3JQcm9wZXJ0eSIsIm11dGF0aW9uTWV0aG9kIiwiZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eSIsIm11c3RVc2VBdHRyaWJ1dGUiLCJuYW1lc3BhY2UiLCJhdHRyaWJ1dGVOYW1lc3BhY2UiLCJzZXRBdHRyaWJ1dGVOUyIsInByb3BOYW1lIiwicHJvcGVydHlOYW1lIiwiaGFzU2lkZUVmZmVjdHMiLCJzZXRWYWx1ZUZvckF0dHJpYnV0ZSIsImRlZmF1bHRWYWx1ZSIsImdldERlZmF1bHRWYWx1ZUZvclByb3BlcnR5IiwiY2hlY2tNYXNrIiwiYml0bWFzayIsIkRPTVByb3BlcnR5SW5qZWN0aW9uIiwiTVVTVF9VU0VfQVRUUklCVVRFIiwiTVVTVF9VU0VfUFJPUEVSVFkiLCJIQVNfU0lERV9FRkZFQ1RTIiwiSEFTX0JPT0xFQU5fVkFMVUUiLCJIQVNfTlVNRVJJQ19WQUxVRSIsIkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFIiwiSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSIsImluamVjdERPTVByb3BlcnR5Q29uZmlnIiwiZG9tUHJvcGVydHlDb25maWciLCJJbmplY3Rpb24iLCJQcm9wZXJ0aWVzIiwiRE9NQXR0cmlidXRlTmFtZXNwYWNlcyIsIkRPTUF0dHJpYnV0ZU5hbWVzIiwiRE9NUHJvcGVydHlOYW1lcyIsIkRPTU11dGF0aW9uTWV0aG9kcyIsIl9pc0N1c3RvbUF0dHJpYnV0ZUZ1bmN0aW9ucyIsImxvd2VyQ2FzZWQiLCJwcm9wQ29uZmlnIiwibXVzdFVzZVByb3BlcnR5IiwiZGVmYXVsdFZhbHVlQ2FjaGUiLCJpc0N1c3RvbUF0dHJpYnV0ZUZuIiwicHJvcCIsIm5vZGVEZWZhdWx0cyIsIl9sZW4iLCJfa2V5IiwibWVzc2FnZSIsIngiLCJSZWFjdERPTUlET3BlcmF0aW9ucyIsInByb2Nlc3NDaGlsZHJlblVwZGF0ZXMiLCJkYW5nZXJvdXNseVByb2Nlc3NDaGlsZHJlblVwZGF0ZXMiLCJyZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEIiwiZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEIiwicm9vdE5vZGVJRCIsInB1cmdlSUQiLCJJTlZBTElEX1BST1BFUlRZX0VSUk9SUyIsInN0eWxlIiwidXBkYXRlUHJvcGVydHlCeUlEIiwiUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyIiwiUmVhY3RET01GZWF0dXJlRmxhZ3MiLCJSZWFjdEVsZW1lbnQiLCJSZWFjdEVtcHR5Q29tcG9uZW50UmVnaXN0cnkiLCJSZWFjdEluc3RhbmNlTWFwIiwiUmVhY3RNYXJrdXBDaGVja3N1bSIsIlJlYWN0VXBkYXRlUXVldWUiLCJlbXB0eU9iamVjdCIsImNvbnRhaW5zTm9kZSIsImluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQiLCJzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCIsIkFUVFJfTkFNRSIsIm5vZGVDYWNoZSIsIkVMRU1FTlRfTk9ERV9UWVBFIiwiRE9DX05PREVfVFlQRSIsIkRPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsImluc3RhbmNlc0J5UmVhY3RSb290SUQiLCJjb250YWluZXJzQnlSZWFjdFJvb3RJRCIsInJvb3RFbGVtZW50c0J5UmVhY3RSb290SUQiLCJmaW5kQ29tcG9uZW50Um9vdFJldXNhYmxlQXJyYXkiLCJmaXJzdERpZmZlcmVuY2VJbmRleCIsInN0cmluZzEiLCJzdHJpbmcyIiwibWluTGVuIiwibWluIiwiY2hhckF0IiwiZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyIiwiY29udGFpbmVyIiwiZ2V0UmVhY3RSb290SUQiLCJyb290RWxlbWVudCIsImludGVybmFsR2V0SUQiLCJjYWNoZWQiLCJpc1ZhbGlkIiwic2V0SUQiLCJvbGRJRCIsImZpbmRSZWFjdE5vZGVCeUlEIiwiZ2V0Tm9kZUZyb21JbnN0YW5jZSIsImluc3RhbmNlIiwiZ2V0IiwiaXNOdWxsQ29tcG9uZW50SUQiLCJmaW5kUmVhY3RDb250YWluZXJGb3JJRCIsImRlZXBlc3ROb2RlU29GYXIiLCJmaW5kRGVlcGVzdENhY2hlZEFuY2VzdG9ySW1wbCIsImFuY2VzdG9ySUQiLCJhbmNlc3RvciIsImZpbmREZWVwZXN0Q2FjaGVkQW5jZXN0b3IiLCJ0YXJnZXRJRCIsInRyYXZlcnNlQW5jZXN0b3JzIiwiZm91bmROb2RlIiwibW91bnRDb21wb25lbnRJbnRvTm9kZSIsImNvbXBvbmVudEluc3RhbmNlIiwic2hvdWxkUmV1c2VNYXJrdXAiLCJ0YWciLCJ1cGRhdGVkQW5jZXN0b3JJbmZvIiwiX3JlbmRlcmVkQ29tcG9uZW50IiwiX3RvcExldmVsV3JhcHBlciIsIl9tb3VudEltYWdlSW50b05vZGUiLCJiYXRjaGVkTW91bnRDb21wb25lbnRJbnRvTm9kZSIsIlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24iLCJnZXRQb29sZWQiLCJwZXJmb3JtIiwicmVsZWFzZSIsInVubW91bnRDb21wb25lbnRGcm9tTm9kZSIsImhhc05vblJvb3RSZWFjdENoaWxkIiwicmVhY3RSb290SUQiLCJnZXRSZWFjdFJvb3RJREZyb21Ob2RlSUQiLCJmaW5kRmlyc3RSZWFjdERPTUltcGwiLCJub2RlSUQiLCJsYXN0SUQiLCJUb3BMZXZlbFdyYXBwZXIiLCJpc1JlYWN0Q29tcG9uZW50IiwiX2luc3RhbmNlc0J5UmVhY3RSb290SUQiLCJzY3JvbGxNb25pdG9yIiwicmVuZGVyQ2FsbGJhY2siLCJfdXBkYXRlUm9vdENvbXBvbmVudCIsInByZXZDb21wb25lbnQiLCJuZXh0RWxlbWVudCIsImNhbGxiYWNrIiwiZW5xdWV1ZUVsZW1lbnRJbnRlcm5hbCIsImVucXVldWVDYWxsYmFja0ludGVybmFsIiwiX3JlZ2lzdGVyQ29tcG9uZW50IiwibmV4dENvbXBvbmVudCIsImVuc3VyZVNjcm9sbFZhbHVlTW9uaXRvcmluZyIsInJlZ2lzdGVyQ29udGFpbmVyIiwiX3JlbmRlck5ld1Jvb3RDb21wb25lbnQiLCJnZXROYW1lIiwicGFyZW50Q29tcG9uZW50IiwiX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSIsIl9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciIsImlzVmFsaWRFbGVtZW50IiwidG9VcHBlckNhc2UiLCJuZXh0V3JhcHBlZEVsZW1lbnQiLCJwcmV2V3JhcHBlZEVsZW1lbnQiLCJwcmV2RWxlbWVudCIsInB1YmxpY0luc3QiLCJnZXRQdWJsaWNJbnN0YW5jZSIsInVwZGF0ZWRDYWxsYmFjayIsInJlYWN0Um9vdEVsZW1lbnQiLCJjb250YWluZXJIYXNSZWFjdE1hcmt1cCIsImNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkIiwibmV4dFNpYmxpbmciLCJyb290RWxlbWVudFNpYmxpbmciLCJjb21wb25lbnQiLCJfcHJvY2Vzc0NoaWxkQ29udGV4dCIsIl9jb250ZXh0IiwiY3JlYXRlUmVhY3RSb290SUQiLCJjb250YWluZXJJRCIsImlzQ29udGFpbmVyUmVhY3RSb290IiwiY29udGFpbmVyQ2hpbGQiLCJyZWFjdFJvb3QiLCJmaW5kQ29tcG9uZW50Um9vdCIsImdldEZpcnN0UmVhY3RET00iLCJhbmNlc3Rvck5vZGUiLCJmaXJzdENoaWxkcmVuIiwiY2hpbGRJbmRleCIsImRlZXBlc3RBbmNlc3RvciIsImNoaWxkIiwidGFyZ2V0Q2hpbGQiLCJjaGlsZElEIiwiaXNBbmNlc3RvcklET2YiLCJjYW5SZXVzZU1hcmt1cCIsImNoZWNrc3VtIiwiQ0hFQ0tTVU1fQVRUUl9OQU1FIiwicm9vdE1hcmt1cCIsIm91dGVySFRNTCIsIm5vcm1hbGl6ZWRNYXJrdXAiLCJub3JtYWxpemVyIiwiYm9keSIsImFwcGVuZENoaWxkIiwiY29udGVudERvY3VtZW50Iiwid3JpdGUiLCJkaWZmSW5kZXgiLCJkaWZmZXJlbmNlIiwiRXZlbnRDb25zdGFudHMiLCJFdmVudFBsdWdpbkh1YiIsIkV2ZW50UGx1Z2luUmVnaXN0cnkiLCJSZWFjdEV2ZW50RW1pdHRlck1peGluIiwiVmlld3BvcnRNZXRyaWNzIiwiaXNFdmVudFN1cHBvcnRlZCIsImFscmVhZHlMaXN0ZW5pbmdUbyIsImlzTW9uaXRvcmluZ1Njcm9sbFZhbHVlIiwicmVhY3RUb3BMaXN0ZW5lcnNDb3VudGVyIiwidG9wRXZlbnRNYXBwaW5nIiwidG9wQWJvcnQiLCJ0b3BCbHVyIiwidG9wQ2FuUGxheSIsInRvcENhblBsYXlUaHJvdWdoIiwidG9wQ2hhbmdlIiwidG9wQ2xpY2siLCJ0b3BDb21wb3NpdGlvbkVuZCIsInRvcENvbXBvc2l0aW9uU3RhcnQiLCJ0b3BDb21wb3NpdGlvblVwZGF0ZSIsInRvcENvbnRleHRNZW51IiwidG9wQ29weSIsInRvcEN1dCIsInRvcERvdWJsZUNsaWNrIiwidG9wRHJhZyIsInRvcERyYWdFbmQiLCJ0b3BEcmFnRW50ZXIiLCJ0b3BEcmFnRXhpdCIsInRvcERyYWdMZWF2ZSIsInRvcERyYWdPdmVyIiwidG9wRHJhZ1N0YXJ0IiwidG9wRHJvcCIsInRvcER1cmF0aW9uQ2hhbmdlIiwidG9wRW1wdGllZCIsInRvcEVuY3J5cHRlZCIsInRvcEVuZGVkIiwidG9wRXJyb3IiLCJ0b3BGb2N1cyIsInRvcElucHV0IiwidG9wS2V5RG93biIsInRvcEtleVByZXNzIiwidG9wS2V5VXAiLCJ0b3BMb2FkZWREYXRhIiwidG9wTG9hZGVkTWV0YWRhdGEiLCJ0b3BMb2FkU3RhcnQiLCJ0b3BNb3VzZURvd24iLCJ0b3BNb3VzZU1vdmUiLCJ0b3BNb3VzZU91dCIsInRvcE1vdXNlT3ZlciIsInRvcE1vdXNlVXAiLCJ0b3BQYXN0ZSIsInRvcFBhdXNlIiwidG9wUGxheSIsInRvcFBsYXlpbmciLCJ0b3BQcm9ncmVzcyIsInRvcFJhdGVDaGFuZ2UiLCJ0b3BTY3JvbGwiLCJ0b3BTZWVrZWQiLCJ0b3BTZWVraW5nIiwidG9wU2VsZWN0aW9uQ2hhbmdlIiwidG9wU3RhbGxlZCIsInRvcFN1c3BlbmQiLCJ0b3BUZXh0SW5wdXQiLCJ0b3BUaW1lVXBkYXRlIiwidG9wVG91Y2hDYW5jZWwiLCJ0b3BUb3VjaEVuZCIsInRvcFRvdWNoTW92ZSIsInRvcFRvdWNoU3RhcnQiLCJ0b3BWb2x1bWVDaGFuZ2UiLCJ0b3BXYWl0aW5nIiwidG9wV2hlZWwiLCJ0b3BMaXN0ZW5lcnNJREtleSIsImdldExpc3RlbmluZ0ZvckRvY3VtZW50IiwibW91bnRBdCIsIlJlYWN0RXZlbnRMaXN0ZW5lciIsImluamVjdFJlYWN0RXZlbnRMaXN0ZW5lciIsInNldEhhbmRsZVRvcExldmVsIiwiaGFuZGxlVG9wTGV2ZWwiLCJzZXRFbmFibGVkIiwiZW5hYmxlZCIsImlzRW5hYmxlZCIsImxpc3RlblRvIiwicmVnaXN0cmF0aW9uTmFtZSIsImNvbnRlbnREb2N1bWVudEhhbmRsZSIsImlzTGlzdGVuaW5nIiwiZGVwZW5kZW5jaWVzIiwicmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyIsInRvcExldmVsVHlwZXMiLCJkZXBlbmRlbmN5IiwidHJhcEJ1YmJsZWRFdmVudCIsInRyYXBDYXB0dXJlZEV2ZW50IiwiV0lORE9XX0hBTkRMRSIsInRvcExldmVsVHlwZSIsImhhbmRsZXJCYXNlTmFtZSIsImhhbmRsZSIsInJlZnJlc2giLCJyZWZyZXNoU2Nyb2xsVmFsdWVzIiwibW9uaXRvclNjcm9sbFZhbHVlIiwiZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzIiwicmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMiLCJwdXRMaXN0ZW5lciIsImdldExpc3RlbmVyIiwiZGVsZXRlTGlzdGVuZXIiLCJkZWxldGVBbGxMaXN0ZW5lcnMiLCJQcm9wYWdhdGlvblBoYXNlcyIsImJ1YmJsZWQiLCJjYXB0dXJlZCIsInRvcExvYWQiLCJ0b3BSZXNldCIsInRvcFN1Ym1pdCIsIkV2ZW50UGx1Z2luVXRpbHMiLCJSZWFjdEVycm9yVXRpbHMiLCJhY2N1bXVsYXRlSW50byIsImZvckVhY2hBY2N1bXVsYXRlZCIsImxpc3RlbmVyQmFuayIsImV2ZW50UXVldWUiLCJleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UiLCJldmVudCIsInNpbXVsYXRlZCIsImV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlciIsImlzUGVyc2lzdGVudCIsImNvbnN0cnVjdG9yIiwiZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlU2ltdWxhdGVkIiwiZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlVG9wTGV2ZWwiLCJJbnN0YW5jZUhhbmRsZSIsInZhbGlkYXRlSW5zdGFuY2VIYW5kbGUiLCJ2YWxpZCIsInRyYXZlcnNlVHdvUGhhc2UiLCJ0cmF2ZXJzZUVudGVyTGVhdmUiLCJpbmplY3RNb3VudCIsImluamVjdEluc3RhbmNlSGFuZGxlIiwiSW5qZWN0ZWRJbnN0YW5jZUhhbmRsZSIsImdldEluc3RhbmNlSGFuZGxlIiwiaW5qZWN0RXZlbnRQbHVnaW5PcmRlciIsImluamVjdEV2ZW50UGx1Z2luc0J5TmFtZSIsImxpc3RlbmVyIiwiYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUiLCJQbHVnaW5Nb2R1bGUiLCJkaWRQdXRMaXN0ZW5lciIsIndpbGxEZWxldGVMaXN0ZW5lciIsImV4dHJhY3RFdmVudHMiLCJ0b3BMZXZlbFRhcmdldCIsInRvcExldmVsVGFyZ2V0SUQiLCJuYXRpdmVFdmVudCIsIm5hdGl2ZUV2ZW50VGFyZ2V0IiwiZXZlbnRzIiwicGx1Z2lucyIsInBvc3NpYmxlUGx1Z2luIiwiZXh0cmFjdGVkRXZlbnRzIiwiZW5xdWV1ZUV2ZW50cyIsInByb2Nlc3NFdmVudFF1ZXVlIiwicHJvY2Vzc2luZ0V2ZW50UXVldWUiLCJyZXRocm93Q2F1Z2h0RXJyb3IiLCJfX3B1cmdlIiwiX19nZXRMaXN0ZW5lckJhbmsiLCJFdmVudFBsdWdpbk9yZGVyIiwibmFtZXNUb1BsdWdpbnMiLCJyZWNvbXB1dGVQbHVnaW5PcmRlcmluZyIsInBsdWdpbk5hbWUiLCJwbHVnaW5JbmRleCIsInB1Ymxpc2hlZEV2ZW50cyIsImV2ZW50VHlwZXMiLCJldmVudE5hbWUiLCJwdWJsaXNoRXZlbnRGb3JQbHVnaW4iLCJkaXNwYXRjaENvbmZpZyIsInBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzIiwicGhhc2VOYW1lIiwicGhhc2VkUmVnaXN0cmF0aW9uTmFtZSIsInB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lIiwiSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyIiwiaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyIsImlzT3JkZXJpbmdEaXJ0eSIsImdldFBsdWdpbk1vZHVsZUZvckV2ZW50IiwicGhhc2UiLCJfcmVzZXRFdmVudFBsdWdpbnMiLCJJbmplY3RlZE1vdW50IiwiaXNFbmRpc2giLCJpc01vdmVpc2giLCJpc1N0YXJ0aXNoIiwidmFsaWRhdGVFdmVudERpc3BhdGNoZXMiLCJkaXNwYXRjaExpc3RlbmVycyIsIl9kaXNwYXRjaExpc3RlbmVycyIsImRpc3BhdGNoSURzIiwiX2Rpc3BhdGNoSURzIiwibGlzdGVuZXJzSXNBcnIiLCJpZHNJc0FyciIsIklEc0xlbiIsImxpc3RlbmVyc0xlbiIsImV4ZWN1dGVEaXNwYXRjaCIsImRvbUlEIiwiY3VycmVudFRhcmdldCIsImludm9rZUd1YXJkZWRDYWxsYmFja1dpdGhDYXRjaCIsImludm9rZUd1YXJkZWRDYWxsYmFjayIsImlzUHJvcGFnYXRpb25TdG9wcGVkIiwiZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGwiLCJleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlIiwiZXhlY3V0ZURpcmVjdERpc3BhdGNoIiwiZGlzcGF0Y2hMaXN0ZW5lciIsImRpc3BhdGNoSUQiLCJyZXMiLCJoYXNEaXNwYXRjaGVzIiwiY2F1Z2h0RXJyb3IiLCJkaXNwYXRjaEV2ZW50IiwiY3JlYXRlRXZlbnQiLCJmYWtlTm9kZSIsImJvdW5kRnVuYyIsImV2dFR5cGUiLCJldnQiLCJpbml0RXZlbnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibmV4dCIsImN1cnJlbnRJc0FycmF5IiwibmV4dElzQXJyYXkiLCJhcnIiLCJjYiIsInNjb3BlIiwicnVuRXZlbnRRdWV1ZUluQmF0Y2giLCJjdXJyZW50U2Nyb2xsTGVmdCIsImN1cnJlbnRTY3JvbGxUb3AiLCJzY3JvbGxQb3NpdGlvbiIsInkiLCJ0YXJnZXQiLCJzb3VyY2VzIiwiVHlwZUVycm9yIiwidG8iLCJuZXh0SW5kZXgiLCJuZXh0U291cmNlIiwiZnJvbSIsInVzZUhhc0ZlYXR1cmUiLCJpbXBsZW1lbnRhdGlvbiIsImhhc0ZlYXR1cmUiLCJldmVudE5hbWVTdWZmaXgiLCJjYXB0dXJlIiwiaXNTdXBwb3J0ZWQiLCJlbGVtZW50IiwiY2FuRGVmaW5lUHJvcGVydHkiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJSRVNFUlZFRF9QUk9QUyIsIl9fc2VsZiIsIl9fc291cmNlIiwic291cmNlIiwib3duZXIiLCIkJHR5cGVvZiIsIl9vd25lciIsIl9zdG9yZSIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwidmFsaWRhdGVkIiwiX3NlbGYiLCJfc291cmNlIiwiY29uZmlnIiwiY2hpbGRyZW5MZW5ndGgiLCJjaGlsZEFycmF5IiwiZGVmYXVsdFByb3BzIiwiY3JlYXRlRmFjdG9yeSIsImZhY3RvcnkiLCJjbG9uZUFuZFJlcGxhY2VLZXkiLCJvbGRFbGVtZW50IiwibmV3S2V5IiwibmV3RWxlbWVudCIsImNsb25lQW5kUmVwbGFjZVByb3BzIiwibmV3UHJvcHMiLCJjbG9uZUVsZW1lbnQiLCJudWxsQ29tcG9uZW50SURzUmVnaXN0cnkiLCJyZWdpc3Rlck51bGxDb21wb25lbnRJRCIsImRlcmVnaXN0ZXJOdWxsQ29tcG9uZW50SUQiLCJSZWFjdFJvb3RJbmRleCIsIlNFUEFSQVRPUiIsIlNFUEFSQVRPUl9MRU5HVEgiLCJNQVhfVFJFRV9ERVBUSCIsImdldFJlYWN0Um9vdElEU3RyaW5nIiwiaXNCb3VuZGFyeSIsImlzVmFsaWRJRCIsImRlc2NlbmRhbnRJRCIsImdldFBhcmVudElEIiwic3Vic3RyIiwibGFzdEluZGV4T2YiLCJnZXROZXh0RGVzY2VuZGFudElEIiwiZGVzdGluYXRpb25JRCIsInN0YXJ0IiwiZ2V0Rmlyc3RDb21tb25BbmNlc3RvcklEIiwib25lSUQiLCJ0d29JRCIsIm1pbkxlbmd0aCIsImxhc3RDb21tb25NYXJrZXJJbmRleCIsImxvbmdlc3RDb21tb25JRCIsInRyYXZlcnNlUGFyZW50UGF0aCIsInN0b3AiLCJza2lwRmlyc3QiLCJza2lwTGFzdCIsInRyYXZlcnNlVXAiLCJkZXB0aCIsInRyYXZlcnNlIiwiY3JlYXRlUmVhY3RSb290SW5kZXgiLCJjcmVhdGVSZWFjdElEIiwibGVhdmVJRCIsImVudGVySUQiLCJ1cEFyZyIsImRvd25BcmciLCJ0cmF2ZXJzZVR3b1BoYXNlU2tpcFRhcmdldCIsIl9nZXROZXh0RGVzY2VuZGFudElEIiwiUmVhY3RSb290SW5kZXhJbmplY3Rpb24iLCJpbmplY3RDcmVhdGVSZWFjdFJvb3RJbmRleCIsIl9jcmVhdGVSZWFjdFJvb3RJbmRleCIsInJlbW92ZSIsImhhcyIsInNldCIsImFkbGVyMzIiLCJUQUdfRU5EIiwiYWRkQ2hlY2tzdW1Ub01hcmt1cCIsImV4aXN0aW5nQ2hlY2tzdW0iLCJwYXJzZUludCIsIm1hcmt1cENoZWNrc3VtIiwiTU9EIiwibCIsIm0iLCJjaGFyQ29kZUF0IiwiUmVhY3RSZWYiLCJhdHRhY2hSZWZzIiwiaW50ZXJuYWxJbnN0YW5jZSIsImdldFJlYWN0TW91bnRSZWFkeSIsImVucXVldWUiLCJkZXRhY2hSZWZzIiwicmVmc0NoYW5nZWQiLCJzaG91bGRVcGRhdGVSZWZzIiwicGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5IiwiUmVhY3RPd25lciIsImF0dGFjaFJlZiIsImFkZENvbXBvbmVudEFzUmVmVG8iLCJkZXRhY2hSZWYiLCJyZW1vdmVDb21wb25lbnRBc1JlZkZyb20iLCJwcmV2RW1wdHkiLCJuZXh0RW1wdHkiLCJpc1ZhbGlkT3duZXIiLCJyZWZzIiwiZW5xdWV1ZVVwZGF0ZSIsImdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZSIsInB1YmxpY0luc3RhbmNlIiwiY2FsbGVyTmFtZSIsImlzTW91bnRlZCIsIl93YXJuZWRBYm91dFJlZnNJblJlbmRlciIsImVucXVldWVDYWxsYmFjayIsIl9wZW5kaW5nQ2FsbGJhY2tzIiwiZW5xdWV1ZUZvcmNlVXBkYXRlIiwiX3BlbmRpbmdGb3JjZVVwZGF0ZSIsImVucXVldWVSZXBsYWNlU3RhdGUiLCJjb21wbGV0ZVN0YXRlIiwiX3BlbmRpbmdTdGF0ZVF1ZXVlIiwiX3BlbmRpbmdSZXBsYWNlU3RhdGUiLCJlbnF1ZXVlU2V0U3RhdGUiLCJwYXJ0aWFsU3RhdGUiLCJlbnF1ZXVlU2V0UHJvcHMiLCJwYXJ0aWFsUHJvcHMiLCJlbnF1ZXVlU2V0UHJvcHNJbnRlcm5hbCIsInRvcExldmVsV3JhcHBlciIsIndyYXBFbGVtZW50IiwiX3BlbmRpbmdFbGVtZW50IiwiZW5xdWV1ZVJlcGxhY2VQcm9wcyIsImVucXVldWVSZXBsYWNlUHJvcHNJbnRlcm5hbCIsIkNhbGxiYWNrUXVldWUiLCJQb29sZWRDbGFzcyIsIlRyYW5zYWN0aW9uIiwiZGlydHlDb21wb25lbnRzIiwiYXNhcENhbGxiYWNrUXVldWUiLCJhc2FwRW5xdWV1ZWQiLCJiYXRjaGluZ1N0cmF0ZWd5IiwiZW5zdXJlSW5qZWN0ZWQiLCJORVNURURfVVBEQVRFUyIsImluaXRpYWxpemUiLCJkaXJ0eUNvbXBvbmVudHNMZW5ndGgiLCJjbG9zZSIsInNwbGljZSIsImZsdXNoQmF0Y2hlZFVwZGF0ZXMiLCJVUERBVEVfUVVFVUVJTkciLCJjYWxsYmFja1F1ZXVlIiwicmVzZXQiLCJub3RpZnlBbGwiLCJUUkFOU0FDVElPTl9XUkFQUEVSUyIsIlJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24iLCJyZWluaXRpYWxpemVUcmFuc2FjdGlvbiIsInJlY29uY2lsZVRyYW5zYWN0aW9uIiwiTWl4aW4iLCJnZXRUcmFuc2FjdGlvbldyYXBwZXJzIiwiZGVzdHJ1Y3RvciIsIm1ldGhvZCIsImFkZFBvb2xpbmdUbyIsIm1vdW50T3JkZXJDb21wYXJhdG9yIiwiYzEiLCJjMiIsIl9tb3VudE9yZGVyIiwicnVuQmF0Y2hlZFVwZGF0ZXMiLCJzb3J0IiwiY2FsbGJhY2tzIiwiaXNCYXRjaGluZ1VwZGF0ZXMiLCJhc2FwIiwiUmVhY3RVcGRhdGVzSW5qZWN0aW9uIiwiaW5qZWN0UmVjb25jaWxlVHJhbnNhY3Rpb24iLCJSZWNvbmNpbGVUcmFuc2FjdGlvbiIsImluamVjdEJhdGNoaW5nU3RyYXRlZ3kiLCJfYmF0Y2hpbmdTdHJhdGVneSIsIl9jYWxsYmFja3MiLCJfY29udGV4dHMiLCJjb250ZXh0cyIsIm9uZUFyZ3VtZW50UG9vbGVyIiwiY29weUZpZWxkc0Zyb20iLCJLbGFzcyIsImluc3RhbmNlUG9vbCIsInBvcCIsInR3b0FyZ3VtZW50UG9vbGVyIiwiYTEiLCJhMiIsInRocmVlQXJndW1lbnRQb29sZXIiLCJhMyIsImZvdXJBcmd1bWVudFBvb2xlciIsImE0IiwiZml2ZUFyZ3VtZW50UG9vbGVyIiwiYTUiLCJzdGFuZGFyZFJlbGVhc2VyIiwicG9vbFNpemUiLCJERUZBVUxUX1BPT0xfU0laRSIsIkRFRkFVTFRfUE9PTEVSIiwiQ29weUNvbnN0cnVjdG9yIiwicG9vbGVyIiwiTmV3S2xhc3MiLCJ0cmFuc2FjdGlvbldyYXBwZXJzIiwid3JhcHBlckluaXREYXRhIiwiX2lzSW5UcmFuc2FjdGlvbiIsImlzSW5UcmFuc2FjdGlvbiIsImVycm9yVGhyb3duIiwiaW5pdGlhbGl6ZUFsbCIsImNsb3NlQWxsIiwiZXJyIiwic3RhcnRJbmRleCIsIk9CU0VSVkVEX0VSUk9SIiwiaW5pdERhdGEiLCJpc1RleHROb2RlIiwiX3giLCJfeDIiLCJfYWdhaW4iLCJfZnVuY3Rpb24iLCJvdXRlck5vZGUiLCJpbm5lck5vZGUiLCJjb250YWlucyIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwiaXNOb2RlIiwiTm9kZSIsIlJlYWN0Q29tcG9zaXRlQ29tcG9uZW50IiwiUmVhY3RFbXB0eUNvbXBvbmVudCIsIlJlYWN0TmF0aXZlQ29tcG9uZW50IiwiUmVhY3RDb21wb3NpdGVDb21wb25lbnRXcmFwcGVyIiwiX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQiLCJnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0iLCJpc0ludGVybmFsQ29tcG9uZW50VHlwZSIsImNyZWF0ZUludGVybmFsQ29tcG9uZW50IiwiY3JlYXRlSW5zdGFuY2VGb3JUZXh0IiwiX21vdW50SW1hZ2UiLCJfaXNPd25lck5lY2Vzc2FyeSIsInByZXZlbnRFeHRlbnNpb25zIiwiUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCIsIlJlYWN0UHJvcFR5cGVMb2NhdGlvbnMiLCJSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyIsIlN0YXRlbGVzc0NvbXBvbmVudCIsIkNvbXBvbmVudCIsInVwZGF0ZXIiLCJuZXh0TW91bnRJRCIsIlJlYWN0Q29tcG9zaXRlQ29tcG9uZW50TWl4aW4iLCJfaW5zdGFuY2UiLCJwdWJsaWNQcm9wcyIsIl9wcm9jZXNzUHJvcHMiLCJwdWJsaWNDb250ZXh0IiwiX3Byb2Nlc3NDb250ZXh0IiwiaW5zdCIsInJlbmRlcmVkRWxlbWVudCIsImNhbkluc3RhbnRpYXRlIiwiZ2V0SW5pdGlhbFN0YXRlIiwiaXNSZWFjdENsYXNzQXBwcm92ZWQiLCJnZXREZWZhdWx0UHJvcHMiLCJwcm9wVHlwZXMiLCJjb250ZXh0VHlwZXMiLCJjb21wb25lbnRTaG91bGRVcGRhdGUiLCJjb21wb25lbnREaWRVbm1vdW50IiwiY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyIsImluaXRpYWxTdGF0ZSIsInN0YXRlIiwiY29tcG9uZW50V2lsbE1vdW50IiwiX3Byb2Nlc3NQZW5kaW5nU3RhdGUiLCJfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50IiwiY29tcG9uZW50RGlkTW91bnQiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsIl9tYXNrQ29udGV4dCIsIm1hc2tlZENvbnRleHQiLCJjb250ZXh0TmFtZSIsIl9jaGVja1Byb3BUeXBlcyIsImN1cnJlbnRDb250ZXh0IiwiY2hpbGRDb250ZXh0IiwiZ2V0Q2hpbGRDb250ZXh0IiwiY2hpbGRDb250ZXh0VHlwZXMiLCJsb2NhdGlvbiIsImNvbXBvbmVudE5hbWUiLCJleCIsImFkZGVuZHVtIiwibmV4dENvbnRleHQiLCJwcmV2Q29udGV4dCIsInVwZGF0ZUNvbXBvbmVudCIsInByZXZQYXJlbnRFbGVtZW50IiwibmV4dFBhcmVudEVsZW1lbnQiLCJwcmV2VW5tYXNrZWRDb250ZXh0IiwibmV4dFVubWFza2VkQ29udGV4dCIsIm5leHRQcm9wcyIsImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJuZXh0U3RhdGUiLCJzaG91bGRVcGRhdGUiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJfcGVyZm9ybUNvbXBvbmVudFVwZGF0ZSIsInBhcnRpYWwiLCJ1bm1hc2tlZENvbnRleHQiLCJoYXNDb21wb25lbnREaWRVcGRhdGUiLCJCb29sZWFuIiwiY29tcG9uZW50RGlkVXBkYXRlIiwicHJldlByb3BzIiwicHJldlN0YXRlIiwiY29tcG9uZW50V2lsbFVwZGF0ZSIsIl91cGRhdGVSZW5kZXJlZENvbXBvbmVudCIsInByZXZDb21wb25lbnRJbnN0YW5jZSIsInByZXZSZW5kZXJlZEVsZW1lbnQiLCJuZXh0UmVuZGVyZWRFbGVtZW50IiwidGhpc0lEIiwicHJldkNvbXBvbmVudElEIiwibmV4dE1hcmt1cCIsIl9yZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEIiwiX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudFdpdGhvdXRPd25lck9yQ29udGV4dCIsInJlbmRlcmVkQ29tcG9uZW50IiwiX2lzTW9ja0Z1bmN0aW9uIiwicHVibGljQ29tcG9uZW50SW5zdGFuY2UiLCJpbmplY3RlZCIsImluamVjdEVudmlyb25tZW50IiwiZW52aXJvbm1lbnQiLCJwcmV2VHlwZSIsIm5leHRUeXBlIiwicGxhY2Vob2xkZXJFbGVtZW50IiwiUmVhY3RFbXB0eUNvbXBvbmVudEluamVjdGlvbiIsImluamVjdEVtcHR5Q29tcG9uZW50IiwiaW5zdGFudGlhdGUiLCJhdXRvR2VuZXJhdGVXcmFwcGVyQ2xhc3MiLCJnZW5lcmljQ29tcG9uZW50Q2xhc3MiLCJ0YWdUb0NvbXBvbmVudENsYXNzIiwidGV4dENvbXBvbmVudENsYXNzIiwiUmVhY3ROYXRpdmVDb21wb25lbnRJbmplY3Rpb24iLCJpbmplY3RHZW5lcmljQ29tcG9uZW50Q2xhc3MiLCJjb21wb25lbnRDbGFzcyIsImluamVjdFRleHRDb21wb25lbnRDbGFzcyIsImluamVjdENvbXBvbmVudENsYXNzZXMiLCJjb21wb25lbnRDbGFzc2VzIiwiZ2V0Q29tcG9uZW50Q2xhc3NGb3JFbGVtZW50IiwiaXNUZXh0Q29tcG9uZW50Iiwic3BlY2lhbFRhZ3MiLCJpblNjb3BlVGFncyIsImJ1dHRvblNjb3BlVGFncyIsImltcGxpZWRFbmRUYWdzIiwiZW1wdHlBbmNlc3RvckluZm8iLCJwYXJlbnRUYWciLCJmb3JtVGFnIiwiYVRhZ0luU2NvcGUiLCJidXR0b25UYWdJblNjb3BlIiwibm9iclRhZ0luU2NvcGUiLCJwVGFnSW5CdXR0b25TY29wZSIsImxpc3RJdGVtVGFnQXV0b2Nsb3NpbmciLCJkbEl0ZW1UYWdBdXRvY2xvc2luZyIsIm9sZEluZm8iLCJhbmNlc3RvckluZm8iLCJpbmZvIiwiaXNUYWdWYWxpZFdpdGhQYXJlbnQiLCJmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnIiwiZmluZE93bmVyU3RhY2siLCJzdGFjayIsInJldmVyc2UiLCJkaWRXYXJuIiwiY2hpbGRUYWciLCJjaGlsZEluc3RhbmNlIiwicGFyZW50SW5mbyIsImludmFsaWRQYXJlbnQiLCJpbnZhbGlkQW5jZXN0b3IiLCJwcm9ibGVtYXRpYyIsImFuY2VzdG9yVGFnIiwiYW5jZXN0b3JJbnN0YW5jZSIsImNoaWxkT3duZXIiLCJhbmNlc3Rvck93bmVyIiwiY2hpbGRPd25lcnMiLCJhbmNlc3Rvck93bmVycyIsIm1pblN0YWNrTGVuIiwiZGVlcGVzdENvbW1vbiIsIlVOS05PV04iLCJjaGlsZE93bmVyTmFtZXMiLCJhbmNlc3Rvck93bmVyTmFtZXMiLCJvd25lckluZm8iLCJ3YXJuS2V5IiwiaXNUYWdWYWxpZEluQ29udGV4dCIsIkJlZm9yZUlucHV0RXZlbnRQbHVnaW4iLCJDaGFuZ2VFdmVudFBsdWdpbiIsIkNsaWVudFJlYWN0Um9vdEluZGV4IiwiRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIiLCJFbnRlckxlYXZlRXZlbnRQbHVnaW4iLCJIVE1MRE9NUHJvcGVydHlDb25maWciLCJSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbiIsIlJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kiLCJSZWFjdERPTUNvbXBvbmVudCIsIlJlYWN0SW5qZWN0aW9uIiwiU2VsZWN0RXZlbnRQbHVnaW4iLCJTZXJ2ZXJSZWFjdFJvb3RJbmRleCIsIlNpbXBsZUV2ZW50UGx1Z2luIiwiU1ZHRE9NUHJvcGVydHlDb25maWciLCJhbHJlYWR5SW5qZWN0ZWQiLCJFdmVudEVtaXR0ZXIiLCJOYXRpdmVDb21wb25lbnQiLCJDbGFzcyIsImluamVjdE1peGluIiwiRW1wdHlDb21wb25lbnQiLCJVcGRhdGVzIiwiUm9vdEluZGV4IiwidXJsIiwiaHJlZiIsIlJlYWN0RGVmYXVsdFBlcmYiLCJFdmVudFByb3BhZ2F0b3JzIiwiRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlIiwiU3ludGhldGljQ29tcG9zaXRpb25FdmVudCIsIlN5bnRoZXRpY0lucHV0RXZlbnQiLCJrZXlPZiIsIkVORF9LRVlDT0RFUyIsIlNUQVJUX0tFWUNPREUiLCJjYW5Vc2VDb21wb3NpdGlvbkV2ZW50IiwiY2FuVXNlVGV4dElucHV0RXZlbnQiLCJpc1ByZXN0byIsInVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhIiwib3BlcmEiLCJTUEFDRUJBUl9DT0RFIiwiU1BBQ0VCQVJfQ0hBUiIsImJlZm9yZUlucHV0Iiwib25CZWZvcmVJbnB1dCIsIm9uQmVmb3JlSW5wdXRDYXB0dXJlIiwiY29tcG9zaXRpb25FbmQiLCJvbkNvbXBvc2l0aW9uRW5kIiwib25Db21wb3NpdGlvbkVuZENhcHR1cmUiLCJjb21wb3NpdGlvblN0YXJ0Iiwib25Db21wb3NpdGlvblN0YXJ0Iiwib25Db21wb3NpdGlvblN0YXJ0Q2FwdHVyZSIsImNvbXBvc2l0aW9uVXBkYXRlIiwib25Db21wb3NpdGlvblVwZGF0ZSIsIm9uQ29tcG9zaXRpb25VcGRhdGVDYXB0dXJlIiwiaGFzU3BhY2VLZXlwcmVzcyIsImlzS2V5cHJlc3NDb21tYW5kIiwiY3RybEtleSIsImFsdEtleSIsIm1ldGFLZXkiLCJnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSIsImlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0Iiwia2V5Q29kZSIsImlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCIsImdldERhdGFGcm9tQ3VzdG9tRXZlbnQiLCJkZXRhaWwiLCJjdXJyZW50Q29tcG9zaXRpb24iLCJleHRyYWN0Q29tcG9zaXRpb25FdmVudCIsImV2ZW50VHlwZSIsImZhbGxiYWNrRGF0YSIsImdldERhdGEiLCJjdXN0b21EYXRhIiwiYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyIsImdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnMiLCJ3aGljaCIsImNoYXJzIiwiZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzIiwiZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQiLCJsaXN0ZW5lckF0UGhhc2UiLCJwcm9wYWdhdGlvblBoYXNlIiwiYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyIsInVwd2FyZHMiLCJhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlIiwiZGlzcGF0Y2hNYXJrZXIiLCJhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlU2tpcFRhcmdldCIsImFjY3VtdWxhdGVEaXNwYXRjaGVzIiwiaWdub3JlZERpcmVjdGlvbiIsImFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlIiwiYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQiLCJhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMiLCJsZWF2ZSIsImVudGVyIiwiZnJvbUlEIiwidG9JRCIsImFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzIiwiZ2V0VGV4dENvbnRlbnRBY2Nlc3NvciIsInJvb3QiLCJfcm9vdCIsIl9zdGFydFRleHQiLCJnZXRUZXh0IiwiX2ZhbGxiYWNrVGV4dCIsInN0YXJ0VmFsdWUiLCJzdGFydExlbmd0aCIsImVuZCIsImVuZFZhbHVlIiwiZW5kTGVuZ3RoIiwibWluRW5kIiwic2xpY2VUYWlsIiwiY29udGVudEtleSIsIlN5bnRoZXRpY0V2ZW50IiwiQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSIsImF1Z21lbnRDbGFzcyIsIkV2ZW50SW50ZXJmYWNlIiwiZXZlbnRQaGFzZSIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwidGltZVN0YW1wIiwiZGVmYXVsdFByZXZlbnRlZCIsImlzVHJ1c3RlZCIsIkludGVyZmFjZSIsIm5vcm1hbGl6ZSIsInJldHVyblZhbHVlIiwiaXNEZWZhdWx0UHJldmVudGVkIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJjYW5jZWxCdWJibGUiLCJwZXJzaXN0IiwiU3VwZXIiLCJJbnB1dEV2ZW50SW50ZXJmYWNlIiwib25lS2V5T2JqIiwiZ2V0RXZlbnRUYXJnZXQiLCJpc1RleHRJbnB1dEVsZW1lbnQiLCJjaGFuZ2UiLCJvbkNoYW5nZSIsIm9uQ2hhbmdlQ2FwdHVyZSIsImFjdGl2ZUVsZW1lbnQiLCJhY3RpdmVFbGVtZW50SUQiLCJhY3RpdmVFbGVtZW50VmFsdWUiLCJhY3RpdmVFbGVtZW50VmFsdWVQcm9wIiwic2hvdWxkVXNlQ2hhbmdlRXZlbnQiLCJlbGVtIiwiZG9lc0NoYW5nZUV2ZW50QnViYmxlIiwibWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudCIsInJ1bkV2ZW50SW5CYXRjaCIsInN0YXJ0V2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCIsInN0b3BXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4IiwiZGV0YWNoRXZlbnQiLCJnZXRUYXJnZXRJREZvckNoYW5nZUV2ZW50IiwiaGFuZGxlRXZlbnRzRm9yQ2hhbmdlRXZlbnRJRTgiLCJpc0lucHV0RXZlbnRTdXBwb3J0ZWQiLCJuZXdWYWx1ZVByb3AiLCJ2YWwiLCJzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJoYW5kbGVQcm9wZXJ0eUNoYW5nZSIsInN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlIiwic3JjRWxlbWVudCIsImdldFRhcmdldElERm9ySW5wdXRFdmVudCIsImhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRJRSIsImdldFRhcmdldElERm9ySW5wdXRFdmVudElFIiwic2hvdWxkVXNlQ2xpY2tFdmVudCIsImdldFRhcmdldElERm9yQ2xpY2tFdmVudCIsImdldFRhcmdldElERnVuYyIsImhhbmRsZUV2ZW50RnVuYyIsInN1cHBvcnRlZElucHV0VHlwZXMiLCJuZXh0UmVhY3RSb290SW5kZXgiLCJSZXNwb25kZXJFdmVudFBsdWdpbiIsIlRhcEV2ZW50UGx1Z2luIiwiU3ludGhldGljTW91c2VFdmVudCIsIm1vdXNlRW50ZXIiLCJvbk1vdXNlRW50ZXIiLCJtb3VzZUxlYXZlIiwib25Nb3VzZUxlYXZlIiwicmVsYXRlZFRhcmdldCIsImZyb21FbGVtZW50Iiwid2luIiwiZG9jIiwiZGVmYXVsdFZpZXciLCJwYXJlbnRXaW5kb3ciLCJ0b0VsZW1lbnQiLCJTeW50aGV0aWNVSUV2ZW50IiwiZ2V0RXZlbnRNb2RpZmllclN0YXRlIiwiTW91c2VFdmVudEludGVyZmFjZSIsInNjcmVlblgiLCJzY3JlZW5ZIiwiY2xpZW50WCIsImNsaWVudFkiLCJzaGlmdEtleSIsImdldE1vZGlmaWVyU3RhdGUiLCJidXR0b24iLCJidXR0b25zIiwicGFnZVgiLCJwYWdlWSIsIlVJRXZlbnRJbnRlcmZhY2UiLCJ2aWV3IiwibW9kaWZpZXJLZXlUb1Byb3AiLCJtb2RpZmllclN0YXRlR2V0dGVyIiwia2V5QXJnIiwic3ludGhldGljRXZlbnQiLCJrZXlQcm9wIiwiaGFzU1ZHIiwiUmVnRXhwIiwiYWNjZXB0IiwiYWNjZXB0Q2hhcnNldCIsImFjY2Vzc0tleSIsImFjdGlvbiIsImFsbG93RnVsbFNjcmVlbiIsImFsbG93VHJhbnNwYXJlbmN5IiwiYWx0IiwiYXN5bmMiLCJhdXRvQ29tcGxldGUiLCJhdXRvUGxheSIsImNlbGxQYWRkaW5nIiwiY2VsbFNwYWNpbmciLCJjaGFyU2V0IiwiY2hhbGxlbmdlIiwiY2hlY2tlZCIsImNsYXNzSUQiLCJjbGFzc05hbWUiLCJjb2xzIiwiY29sU3BhbiIsImNvbnRlbnRFZGl0YWJsZSIsImNvbnRleHRNZW51IiwiY29udHJvbHMiLCJjb29yZHMiLCJjcm9zc09yaWdpbiIsImRhdGVUaW1lIiwiZGVmZXIiLCJkaXNhYmxlZCIsImRvd25sb2FkIiwiZHJhZ2dhYmxlIiwiZW5jVHlwZSIsImZvcm0iLCJmb3JtQWN0aW9uIiwiZm9ybUVuY1R5cGUiLCJmb3JtTWV0aG9kIiwiZm9ybU5vVmFsaWRhdGUiLCJmb3JtVGFyZ2V0IiwiZnJhbWVCb3JkZXIiLCJoZWFkZXJzIiwiaGVpZ2h0IiwiaGlkZGVuIiwiaGlnaCIsImhyZWZMYW5nIiwiaHRtbEZvciIsImh0dHBFcXVpdiIsImljb24iLCJpbnB1dE1vZGUiLCJpbnRlZ3JpdHkiLCJpcyIsImtleVBhcmFtcyIsImtleVR5cGUiLCJraW5kIiwibGFiZWwiLCJsYW5nIiwibGlzdCIsImxvb3AiLCJsb3ciLCJtYW5pZmVzdCIsIm1hcmdpbkhlaWdodCIsIm1hcmdpbldpZHRoIiwibWF4IiwibWF4TGVuZ3RoIiwibWVkaWEiLCJtZWRpYUdyb3VwIiwibXVsdGlwbGUiLCJtdXRlZCIsIm5vbmNlIiwibm9WYWxpZGF0ZSIsIm9wZW4iLCJvcHRpbXVtIiwicGF0dGVybiIsInBsYWNlaG9sZGVyIiwicG9zdGVyIiwicHJlbG9hZCIsInJhZGlvR3JvdXAiLCJyZWFkT25seSIsInJlbCIsInJlcXVpcmVkIiwicmV2ZXJzZWQiLCJyb2xlIiwicm93cyIsInJvd1NwYW4iLCJzYW5kYm94Iiwic2NvcGVkIiwic2Nyb2xsaW5nIiwic2VhbWxlc3MiLCJzZWxlY3RlZCIsInNoYXBlIiwic2l6ZSIsInNpemVzIiwic3BhbiIsInNwZWxsQ2hlY2siLCJzcmMiLCJzcmNEb2MiLCJzcmNMYW5nIiwic3JjU2V0Iiwic3RlcCIsInN1bW1hcnkiLCJ0YWJJbmRleCIsInVzZU1hcCIsIndpZHRoIiwid21vZGUiLCJhYm91dCIsImRhdGF0eXBlIiwiaW5saXN0IiwicHJlZml4IiwicHJvcGVydHkiLCJyZXNvdXJjZSIsInZvY2FiIiwiYXV0b0NhcGl0YWxpemUiLCJhdXRvQ29ycmVjdCIsImF1dG9TYXZlIiwiY29sb3IiLCJpdGVtUHJvcCIsIml0ZW1TY29wZSIsIml0ZW1UeXBlIiwiaXRlbUlEIiwiaXRlbVJlZiIsInJlc3VsdHMiLCJzZWN1cml0eSIsInVuc2VsZWN0YWJsZSIsImF1dG9Gb2N1cyIsImRpZFdhcm5LZXkiLCJnZXRET01Ob2RlIiwiY29tcG9uZW50T3JFbGVtZW50IiwiUkVTRVRfQkFUQ0hFRF9VUERBVEVTIiwiRkxVU0hfQkFUQ0hFRF9VUERBVEVTIiwiUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVRyYW5zYWN0aW9uIiwiYWxyZWFkeUJhdGNoaW5nVXBkYXRlcyIsIkF1dG9Gb2N1c1V0aWxzIiwiQ1NTUHJvcGVydHlPcGVyYXRpb25zIiwiUmVhY3RET01CdXR0b24iLCJSZWFjdERPTUlucHV0IiwiUmVhY3RET01PcHRpb24iLCJSZWFjdERPTVNlbGVjdCIsIlJlYWN0RE9NVGV4dGFyZWEiLCJSZWFjdE11bHRpQ2hpbGQiLCJzaGFsbG93RXF1YWwiLCJDT05URU5UX1RZUEVTIiwiQ0hJTERSRU4iLCJTVFlMRSIsIkhUTUwiLCJfX2h0bWwiLCJsZWdhY3lQcm9wc0Rlc2NyaXB0b3IiLCJfcmVhY3RJbnRlcm5hbENvbXBvbmVudCIsImxlZ2FjeUdldERPTU5vZGUiLCJsZWdhY3lJc01vdW50ZWQiLCJsZWdhY3lTZXRTdGF0ZUV0YyIsImxlZ2FjeVNldFByb3BzIiwibGVnYWN5UmVwbGFjZVByb3BzIiwiZnJpZW5kbHlTdHJpbmdpZnkiLCJwYWlycyIsImtleUVzY2FwZWQiLCJKU09OIiwic3RyaW5naWZ5Iiwic3R5bGVNdXRhdGlvbldhcm5pbmciLCJjaGVja0FuZFdhcm5Gb3JNdXRhdGVkU3R5bGUiLCJzdHlsZTEiLCJzdHlsZTIiLCJfdGFnIiwib3duZXJOYW1lIiwiaGFzaCIsImFzc2VydFZhbGlkUHJvcHMiLCJ2b2lkRWxlbWVudFRhZ3MiLCJlbnF1ZXVlUHV0TGlzdGVuZXIiLCJsaXN0ZW5lclRvUHV0IiwibWVkaWFFdmVudHMiLCJ0cmFwQnViYmxlZEV2ZW50c0xvY2FsIiwiX3dyYXBwZXJTdGF0ZSIsImxpc3RlbmVycyIsIm1vdW50UmVhZHlJbnB1dFdyYXBwZXIiLCJtb3VudFJlYWR5V3JhcHBlciIsInBvc3RVcGRhdGVTZWxlY3RXcmFwcGVyIiwicG9zdFVwZGF0ZVdyYXBwZXIiLCJvbWl0dGVkQ2xvc2VUYWdzIiwibmV3bGluZUVhdGluZ1RhZ3MiLCJWQUxJRF9UQUdfUkVHRVgiLCJ2YWxpZGF0ZWRUYWdDYWNoZSIsInZhbGlkYXRlRGFuZ2Vyb3VzVGFnIiwicHJvY2Vzc0NoaWxkQ29udGV4dERldiIsImlzQ3VzdG9tQ29tcG9uZW50IiwiX3JlbmRlcmVkQ2hpbGRyZW4iLCJfcHJldmlvdXNTdHlsZSIsIl9wcmV2aW91c1N0eWxlQ29weSIsIl9ub2RlV2l0aExlZ2FjeVByb3BlcnRpZXMiLCJfdW5wcm9jZXNzZWRDb250ZXh0RGV2IiwiX3Byb2Nlc3NlZENvbnRleHREZXYiLCJnZXROYXRpdmVQcm9wcyIsIm1vdW50V3JhcHBlciIsInByb2Nlc3NDaGlsZENvbnRleHQiLCJtb3VudEltYWdlIiwiX3VwZGF0ZURPTVByb3BlcnRpZXMiLCJfY3JlYXRlSW5pdGlhbENoaWxkcmVuIiwidGFnT3BlbiIsIl9jcmVhdGVPcGVuVGFnTWFya3VwQW5kUHV0TGlzdGVuZXJzIiwidGFnQ29udGVudCIsIl9jcmVhdGVDb250ZW50TWFya3VwIiwiZm9jdXNET01Db21wb25lbnQiLCJwcm9wS2V5IiwicHJvcFZhbHVlIiwiY3JlYXRlTWFya3VwRm9yU3R5bGVzIiwibWFya3VwRm9ySUQiLCJjb250ZW50VG9Vc2UiLCJjaGlsZHJlblRvVXNlIiwibW91bnRJbWFnZXMiLCJtb3VudENoaWxkcmVuIiwibGFzdFByb3BzIiwidXBkYXRlV3JhcHBlciIsIl91cGRhdGVET01DaGlsZHJlbiIsInN0eWxlTmFtZSIsInN0eWxlVXBkYXRlcyIsImxhc3RTdHlsZSIsIm5leHRQcm9wIiwibGFzdFByb3AiLCJzZXRWYWx1ZUZvclN0eWxlcyIsImxhc3RDb250ZW50IiwibmV4dENvbnRlbnQiLCJsYXN0SHRtbCIsIm5leHRIdG1sIiwibGFzdENoaWxkcmVuIiwibmV4dENoaWxkcmVuIiwibGFzdEhhc0NvbnRlbnRPckh0bWwiLCJuZXh0SGFzQ29udGVudE9ySHRtbCIsInVwZGF0ZUNoaWxkcmVuIiwidXBkYXRlTWFya3VwIiwidW5tb3VudFdyYXBwZXIiLCJ1bm1vdW50Q2hpbGRyZW4iLCJzZXRTdGF0ZSIsInJlcGxhY2VTdGF0ZSIsImZvcmNlVXBkYXRlIiwic2V0UHJvcHMiLCJyZXBsYWNlUHJvcHMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZm9jdXNOb2RlIiwiZm9jdXMiLCJDU1NQcm9wZXJ0eSIsImNhbWVsaXplU3R5bGVOYW1lIiwiZGFuZ2Vyb3VzU3R5bGVWYWx1ZSIsImh5cGhlbmF0ZVN0eWxlTmFtZSIsIm1lbW9pemVTdHJpbmdPbmx5IiwicHJvY2Vzc1N0eWxlTmFtZSIsImhhc1Nob3J0aGFuZFByb3BlcnR5QnVnIiwic3R5bGVGbG9hdEFjY2Vzc29yIiwidGVtcFN0eWxlIiwiZm9udCIsImNzc0Zsb2F0IiwiYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuIiwiYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuIiwid2FybmVkU3R5bGVOYW1lcyIsIndhcm5lZFN0eWxlVmFsdWVzIiwid2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUiLCJ3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUiLCJ3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24iLCJ3YXJuVmFsaWRTdHlsZSIsInN0eWxlcyIsInNlcmlhbGl6ZWQiLCJzdHlsZVZhbHVlIiwiZXhwYW5zaW9uIiwic2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zIiwiaW5kaXZpZHVhbFN0eWxlTmFtZSIsImlzVW5pdGxlc3NOdW1iZXIiLCJhbmltYXRpb25JdGVyYXRpb25Db3VudCIsImJveEZsZXgiLCJib3hGbGV4R3JvdXAiLCJib3hPcmRpbmFsR3JvdXAiLCJjb2x1bW5Db3VudCIsImZsZXgiLCJmbGV4R3JvdyIsImZsZXhQb3NpdGl2ZSIsImZsZXhTaHJpbmsiLCJmbGV4TmVnYXRpdmUiLCJmbGV4T3JkZXIiLCJmb250V2VpZ2h0IiwibGluZUNsYW1wIiwibGluZUhlaWdodCIsIm9wYWNpdHkiLCJvcmRlciIsIm9ycGhhbnMiLCJ0YWJTaXplIiwid2lkb3dzIiwiekluZGV4Iiwiem9vbSIsImZpbGxPcGFjaXR5Iiwic3RvcE9wYWNpdHkiLCJzdHJva2VEYXNob2Zmc2V0Iiwic3Ryb2tlT3BhY2l0eSIsInN0cm9rZVdpZHRoIiwicHJlZml4S2V5IiwicHJlZml4ZXMiLCJiYWNrZ3JvdW5kIiwiYmFja2dyb3VuZEF0dGFjaG1lbnQiLCJiYWNrZ3JvdW5kQ29sb3IiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJiYWNrZ3JvdW5kUG9zaXRpb25YIiwiYmFja2dyb3VuZFBvc2l0aW9uWSIsImJhY2tncm91bmRSZXBlYXQiLCJiYWNrZ3JvdW5kUG9zaXRpb24iLCJib3JkZXIiLCJib3JkZXJXaWR0aCIsImJvcmRlclN0eWxlIiwiYm9yZGVyQ29sb3IiLCJib3JkZXJCb3R0b20iLCJib3JkZXJCb3R0b21XaWR0aCIsImJvcmRlckJvdHRvbVN0eWxlIiwiYm9yZGVyQm90dG9tQ29sb3IiLCJib3JkZXJMZWZ0IiwiYm9yZGVyTGVmdFdpZHRoIiwiYm9yZGVyTGVmdFN0eWxlIiwiYm9yZGVyTGVmdENvbG9yIiwiYm9yZGVyUmlnaHQiLCJib3JkZXJSaWdodFdpZHRoIiwiYm9yZGVyUmlnaHRTdHlsZSIsImJvcmRlclJpZ2h0Q29sb3IiLCJib3JkZXJUb3AiLCJib3JkZXJUb3BXaWR0aCIsImJvcmRlclRvcFN0eWxlIiwiYm9yZGVyVG9wQ29sb3IiLCJmb250U3R5bGUiLCJmb250VmFyaWFudCIsImZvbnRTaXplIiwiZm9udEZhbWlseSIsIm91dGxpbmUiLCJvdXRsaW5lV2lkdGgiLCJvdXRsaW5lU3R5bGUiLCJvdXRsaW5lQ29sb3IiLCJjYW1lbGl6ZSIsIm1zUGF0dGVybiIsInN0cmluZyIsIl9oeXBoZW5QYXR0ZXJuIiwiXyIsImNoYXJhY3RlciIsImlzRW1wdHkiLCJpc05vbk51bWVyaWMiLCJoeXBoZW5hdGUiLCJfdXBwZXJjYXNlUGF0dGVybiIsImNhY2hlIiwibW91c2VMaXN0ZW5lck5hbWVzIiwib25DbGljayIsIm9uRG91YmxlQ2xpY2siLCJvbk1vdXNlRG93biIsIm9uTW91c2VNb3ZlIiwib25Nb3VzZVVwIiwib25DbGlja0NhcHR1cmUiLCJvbkRvdWJsZUNsaWNrQ2FwdHVyZSIsIm9uTW91c2VEb3duQ2FwdHVyZSIsIm9uTW91c2VNb3ZlQ2FwdHVyZSIsIm9uTW91c2VVcENhcHR1cmUiLCJuYXRpdmVQcm9wcyIsIkxpbmtlZFZhbHVlVXRpbHMiLCJpbnN0YW5jZXNCeVJlYWN0SUQiLCJmb3JjZVVwZGF0ZUlmTW91bnRlZCIsImdldFZhbHVlIiwiZ2V0Q2hlY2tlZCIsImRlZmF1bHRDaGVja2VkIiwiaW5pdGlhbFZhbHVlIiwiaW5pdGlhbENoZWNrZWQiLCJjaGVja1Byb3BUeXBlcyIsIl9oYW5kbGVDaGFuZ2UiLCJleGVjdXRlT25DaGFuZ2UiLCJyb290Tm9kZSIsInF1ZXJ5Um9vdCIsImdyb3VwIiwicXVlcnlTZWxlY3RvckFsbCIsIm90aGVyTm9kZSIsIm90aGVySUQiLCJvdGhlckluc3RhbmNlIiwiUmVhY3RQcm9wVHlwZXMiLCJoYXNSZWFkT25seVZhbHVlIiwiX2Fzc2VydFNpbmdsZUxpbmsiLCJpbnB1dFByb3BzIiwiY2hlY2tlZExpbmsiLCJ2YWx1ZUxpbmsiLCJfYXNzZXJ0VmFsdWVMaW5rIiwiX2Fzc2VydENoZWNrZWRMaW5rIiwibG9nZ2VkVHlwZUZhaWx1cmVzIiwicmVxdWVzdENoYW5nZSIsImdldEl0ZXJhdG9yRm4iLCJBTk9OWU1PVVMiLCJjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlciIsImJvb2wiLCJudW1iZXIiLCJhbnkiLCJjcmVhdGVBbnlUeXBlQ2hlY2tlciIsImFycmF5T2YiLCJjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIiLCJjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIiLCJpbnN0YW5jZU9mIiwiY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlciIsImNyZWF0ZU5vZGVDaGVja2VyIiwib2JqZWN0T2YiLCJjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyIiwib25lT2YiLCJjcmVhdGVFbnVtVHlwZUNoZWNrZXIiLCJvbmVPZlR5cGUiLCJjcmVhdGVVbmlvblR5cGVDaGVja2VyIiwiY3JlYXRlU2hhcGVUeXBlQ2hlY2tlciIsImNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyIiwidmFsaWRhdGUiLCJjaGVja1R5cGUiLCJpc1JlcXVpcmVkIiwicHJvcEZ1bGxOYW1lIiwibG9jYXRpb25OYW1lIiwiY2hhaW5lZENoZWNrVHlwZSIsImV4cGVjdGVkVHlwZSIsInByb3BUeXBlIiwiZ2V0UHJvcFR5cGUiLCJwcmVjaXNlVHlwZSIsImdldFByZWNpc2VUeXBlIiwidHlwZUNoZWNrZXIiLCJleHBlY3RlZENsYXNzIiwiZXhwZWN0ZWRDbGFzc05hbWUiLCJhY3R1YWxDbGFzc05hbWUiLCJnZXRDbGFzc05hbWUiLCJleHBlY3RlZFZhbHVlcyIsInZhbHVlc1N0cmluZyIsImFycmF5T2ZUeXBlQ2hlY2tlcnMiLCJjaGVja2VyIiwic2hhcGVUeXBlcyIsIml0ZXJhdG9yRm4iLCJpdGVyYXRvciIsImVudHJpZXMiLCJkb25lIiwiZW50cnkiLCJJVEVSQVRPUl9TWU1CT0wiLCJGQVVYX0lURVJBVE9SX1NZTUJPTCIsIm1heWJlSXRlcmFibGUiLCJSZWFjdENoaWxkcmVuIiwidmFsdWVDb250ZXh0S2V5Iiwic2VsZWN0VmFsdWUiLCJ0cmF2ZXJzZUFsbENoaWxkcmVuIiwidXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgiLCJlc2NhcGVVc2VyUHJvdmlkZWRLZXkiLCJGb3JFYWNoQm9va0tlZXBpbmciLCJmb3JFYWNoRnVuY3Rpb24iLCJmb3JFYWNoQ29udGV4dCIsImNvdW50IiwiZm9yRWFjaFNpbmdsZUNoaWxkIiwiYm9va0tlZXBpbmciLCJmb3JFYWNoQ2hpbGRyZW4iLCJmb3JFYWNoRnVuYyIsInRyYXZlcnNlQ29udGV4dCIsIk1hcEJvb2tLZWVwaW5nIiwibWFwUmVzdWx0Iiwia2V5UHJlZml4IiwibWFwRnVuY3Rpb24iLCJtYXBDb250ZXh0IiwicmVzdWx0IiwibWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCIsImNoaWxkS2V5IiwibWFwcGVkQ2hpbGQiLCJtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsIiwiZXNjYXBlZFByZWZpeCIsIm1hcENoaWxkcmVuIiwiZm9yRWFjaFNpbmdsZUNoaWxkRHVtbXkiLCJjb3VudENoaWxkcmVuIiwiU1VCU0VQQVJBVE9SIiwidXNlclByb3ZpZGVkS2V5RXNjYXBlckxvb2t1cCIsImRpZFdhcm5BYm91dE1hcHMiLCJ1c2VyUHJvdmlkZWRLZXlFc2NhcGVyIiwiZ2V0Q29tcG9uZW50S2V5Iiwid3JhcFVzZXJQcm92aWRlZEtleSIsInRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsIiwibmFtZVNvRmFyIiwibmV4dE5hbWUiLCJzdWJ0cmVlQ291bnQiLCJuZXh0TmFtZVByZWZpeCIsIl9pc1JlYWN0RWxlbWVudCIsImNoaWxkcmVuU3RyaW5nIiwidXBkYXRlT3B0aW9uc0lmUGVuZGluZ1VwZGF0ZUFuZE1vdW50ZWQiLCJwZW5kaW5nVXBkYXRlIiwidXBkYXRlT3B0aW9ucyIsInZhbHVlUHJvcE5hbWVzIiwiY2hlY2tTZWxlY3RQcm9wVHlwZXMiLCJzZWxlY3RlZFZhbHVlIiwib3B0aW9ucyIsIndhc011bHRpcGxlIiwiUmVhY3RDaGlsZFJlY29uY2lsZXIiLCJmbGF0dGVuQ2hpbGRyZW4iLCJ1cGRhdGVEZXB0aCIsInVwZGF0ZVF1ZXVlIiwibWFya3VwUXVldWUiLCJlbnF1ZXVlSW5zZXJ0TWFya3VwIiwiZW5xdWV1ZU1vdmUiLCJlbnF1ZXVlUmVtb3ZlIiwiZW5xdWV1ZVNldE1hcmt1cCIsImVucXVldWVUZXh0Q29udGVudCIsInByb2Nlc3NRdWV1ZSIsImNsZWFyUXVldWUiLCJfcmVjb25jaWxlckluc3RhbnRpYXRlQ2hpbGRyZW4iLCJuZXN0ZWRDaGlsZHJlbiIsImluc3RhbnRpYXRlQ2hpbGRyZW4iLCJfcmVjb25jaWxlclVwZGF0ZUNoaWxkcmVuIiwicHJldkNoaWxkcmVuIiwibmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMiLCJfdW5tb3VudENoaWxkIiwiX3VubW91bnRDaGlsZEJ5TmFtZSIsInNldE1hcmt1cCIsIl91cGRhdGVDaGlsZHJlbiIsImxhc3RJbmRleCIsInByZXZDaGlsZCIsIm5leHRDaGlsZCIsIm1vdmVDaGlsZCIsIl9tb3VudENoaWxkQnlOYW1lQXRJbmRleCIsInJlbmRlcmVkQ2hpbGRyZW4iLCJjcmVhdGVDaGlsZCIsImluc3RhbnRpYXRlQ2hpbGQiLCJjaGlsZEluc3RhbmNlcyIsImtleVVuaXF1ZSIsIm5lc3RlZENoaWxkTm9kZXMiLCJuZXh0Q2hpbGRJbnN0YW5jZSIsInJlbmRlcmVkQ2hpbGQiLCJmbGF0dGVuU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCIsIm9iakEiLCJvYmpCIiwia2V5c0EiLCJrZXlzQiIsImJIYXNPd25Qcm9wZXJ0eSIsIkV2ZW50TGlzdGVuZXIiLCJnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbiIsImZpbmRQYXJlbnQiLCJwYXJlbnQiLCJUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmciLCJhbmNlc3RvcnMiLCJoYW5kbGVUb3BMZXZlbEltcGwiLCJoYW5kbGVUb3BMZXZlbFdpdGhQYXRoIiwiaGFuZGxlVG9wTGV2ZWxXaXRob3V0UGF0aCIsIl9oYW5kbGVUb3BMZXZlbCIsInBhdGgiLCJjdXJyZW50TmF0aXZlVGFyZ2V0IiwiZXZlbnRzRmlyZWQiLCJjdXJyZW50UGF0aEVsZW1lbnQiLCJyZWFjdFBhcmVudCIsImN1cnJlbnRQYXRoRWxlbWVudElEIiwibmV3Um9vdElEIiwic2Nyb2xsVmFsdWVNb25pdG9yIiwiX2VuYWJsZWQiLCJsaXN0ZW4iLCJyZWdpc3RlckRlZmF1bHQiLCJzY3JvbGxhYmxlIiwicGFnZVhPZmZzZXQiLCJzY3JvbGxMZWZ0IiwicGFnZVlPZmZzZXQiLCJzY3JvbGxUb3AiLCJSZWFjdENsYXNzIiwiUGVyZiIsIlJlYWN0Q29tcG9uZW50IiwiUmVhY3ROb29wVXBkYXRlUXVldWUiLCJNSVhJTlNfS0VZIiwibWl4aW5zIiwiU3BlY1BvbGljeSIsIkRFRklORV9PTkNFIiwiREVGSU5FX01BTlkiLCJPVkVSUklERV9CQVNFIiwiREVGSU5FX01BTllfTUVSR0VEIiwiaW5qZWN0ZWRNaXhpbnMiLCJ3YXJuZWRTZXRQcm9wcyIsIndhcm5TZXRQcm9wcyIsIlJlYWN0Q2xhc3NJbnRlcmZhY2UiLCJzdGF0aWNzIiwiUkVTRVJWRURfU1BFQ19LRVlTIiwiQ29uc3RydWN0b3IiLCJtaXhTcGVjSW50b0NvbXBvbmVudCIsInZhbGlkYXRlVHlwZURlZiIsImNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uIiwibWl4U3RhdGljU3BlY0ludG9Db21wb25lbnQiLCJhdXRvYmluZCIsInR5cGVEZWYiLCJ2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlIiwicHJvdG8iLCJzcGVjUG9saWN5IiwiUmVhY3RDbGFzc01peGluIiwic3BlYyIsImlzUmVhY3RDbGFzc01ldGhvZCIsImlzQWxyZWFkeURlZmluZWQiLCJpc0Z1bmN0aW9uIiwic2hvdWxkQXV0b0JpbmQiLCJfX3JlYWN0QXV0b0JpbmRNYXAiLCJjcmVhdGVDaGFpbmVkRnVuY3Rpb24iLCJpc1Jlc2VydmVkIiwiaXNJbmhlcml0ZWQiLCJtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzIiwib25lIiwidHdvIiwibWVyZ2VkUmVzdWx0IiwiY2hhaW5lZEZ1bmN0aW9uIiwiYmluZEF1dG9CaW5kTWV0aG9kIiwiYm91bmRNZXRob2QiLCJfX3JlYWN0Qm91bmRDb250ZXh0IiwiX19yZWFjdEJvdW5kTWV0aG9kIiwiX19yZWFjdEJvdW5kQXJndW1lbnRzIiwiX2JpbmQiLCJuZXdUaGlzIiwicmVib3VuZE1ldGhvZCIsImJpbmRBdXRvQmluZE1ldGhvZHMiLCJhdXRvQmluZEtleSIsIm5ld1N0YXRlIiwiUmVhY3RDbGFzc0NvbXBvbmVudCIsImNyZWF0ZUNsYXNzIiwibWV0aG9kTmFtZSIsIm1peGluIiwiZGVwcmVjYXRlZEFQSXMiLCJkZWZpbmVEZXByZWNhdGlvbldhcm5pbmciLCJ3YXJuVERaIiwiUmVhY3RJbnB1dFNlbGVjdGlvbiIsIlNFTEVDVElPTl9SRVNUT1JBVElPTiIsImdldFNlbGVjdGlvbkluZm9ybWF0aW9uIiwicmVzdG9yZVNlbGVjdGlvbiIsIkVWRU5UX1NVUFBSRVNTSU9OIiwiY3VycmVudGx5RW5hYmxlZCIsInByZXZpb3VzbHlFbmFibGVkIiwiT05fRE9NX1JFQURZX1FVRVVFSU5HIiwicmVhY3RNb3VudFJlYWR5IiwiZm9yY2VIVE1MIiwiUmVhY3RET01TZWxlY3Rpb24iLCJnZXRBY3RpdmVFbGVtZW50IiwiaXNJbkRvY3VtZW50IiwiaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzIiwiZm9jdXNlZEVsZW0iLCJzZWxlY3Rpb25SYW5nZSIsImdldFNlbGVjdGlvbiIsInByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24iLCJjdXJGb2N1c2VkRWxlbSIsInByaW9yRm9jdXNlZEVsZW0iLCJwcmlvclNlbGVjdGlvblJhbmdlIiwic2V0U2VsZWN0aW9uIiwiaW5wdXQiLCJzZWxlY3Rpb24iLCJzZWxlY3Rpb25TdGFydCIsInNlbGVjdGlvbkVuZCIsInJhbmdlIiwiY3JlYXRlUmFuZ2UiLCJwYXJlbnRFbGVtZW50IiwibW92ZVN0YXJ0IiwibW92ZUVuZCIsImdldE9mZnNldHMiLCJvZmZzZXRzIiwiY3JlYXRlVGV4dFJhbmdlIiwiY29sbGFwc2UiLCJzZWxlY3QiLCJzZXRPZmZzZXRzIiwiZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldCIsImlzQ29sbGFwc2VkIiwiYW5jaG9yTm9kZSIsImFuY2hvck9mZnNldCIsImZvY3VzT2Zmc2V0IiwiZ2V0SUVPZmZzZXRzIiwic2VsZWN0ZWRSYW5nZSIsInNlbGVjdGVkTGVuZ3RoIiwiZnJvbVN0YXJ0IiwiZHVwbGljYXRlIiwibW92ZVRvRWxlbWVudFRleHQiLCJzZXRFbmRQb2ludCIsInN0YXJ0T2Zmc2V0IiwiZW5kT2Zmc2V0IiwiZ2V0TW9kZXJuT2Zmc2V0cyIsInJhbmdlQ291bnQiLCJjdXJyZW50UmFuZ2UiLCJnZXRSYW5nZUF0Iiwic3RhcnRDb250YWluZXIiLCJlbmRDb250YWluZXIiLCJpc1NlbGVjdGlvbkNvbGxhcHNlZCIsInJhbmdlTGVuZ3RoIiwidGVtcFJhbmdlIiwiY2xvbmVSYW5nZSIsInNlbGVjdE5vZGVDb250ZW50cyIsInNldEVuZCIsImlzVGVtcFJhbmdlQ29sbGFwc2VkIiwiZGV0ZWN0aW9uUmFuZ2UiLCJzZXRTdGFydCIsImlzQmFja3dhcmQiLCJjb2xsYXBzZWQiLCJzZXRJRU9mZnNldHMiLCJzZXRNb2Rlcm5PZmZzZXRzIiwiZXh0ZW5kIiwidGVtcCIsInN0YXJ0TWFya2VyIiwiZW5kTWFya2VyIiwib2Zmc2V0IiwicmVtb3ZlQWxsUmFuZ2VzIiwiYWRkUmFuZ2UiLCJ1c2VJRU9mZnNldHMiLCJnZXRMZWFmTm9kZSIsImdldFNpYmxpbmdOb2RlIiwibm9kZVN0YXJ0Iiwibm9kZUVuZCIsInNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCIsIm9uU2VsZWN0Iiwib25TZWxlY3RDYXB0dXJlIiwibGFzdFNlbGVjdGlvbiIsIm1vdXNlRG93biIsImhhc0xpc3RlbmVyIiwiT05fU0VMRUNUX0tFWSIsImJvdW5kaW5nVG9wIiwibGVmdCIsImJvdW5kaW5nTGVmdCIsImNvbnN0cnVjdFNlbGVjdEV2ZW50IiwiY3VycmVudFNlbGVjdGlvbiIsIkdMT0JBTF9NT1VOVF9QT0lOVF9NQVgiLCJwb3ciLCJjZWlsIiwiU3ludGhldGljQ2xpcGJvYXJkRXZlbnQiLCJTeW50aGV0aWNGb2N1c0V2ZW50IiwiU3ludGhldGljS2V5Ym9hcmRFdmVudCIsIlN5bnRoZXRpY0RyYWdFdmVudCIsIlN5bnRoZXRpY1RvdWNoRXZlbnQiLCJTeW50aGV0aWNXaGVlbEV2ZW50IiwiZ2V0RXZlbnRDaGFyQ29kZSIsImFib3J0Iiwib25BYm9ydCIsIm9uQWJvcnRDYXB0dXJlIiwiYmx1ciIsIm9uQmx1ciIsIm9uQmx1ckNhcHR1cmUiLCJjYW5QbGF5Iiwib25DYW5QbGF5Iiwib25DYW5QbGF5Q2FwdHVyZSIsImNhblBsYXlUaHJvdWdoIiwib25DYW5QbGF5VGhyb3VnaCIsIm9uQ2FuUGxheVRocm91Z2hDYXB0dXJlIiwiY2xpY2siLCJvbkNvbnRleHRNZW51Iiwib25Db250ZXh0TWVudUNhcHR1cmUiLCJjb3B5Iiwib25Db3B5Iiwib25Db3B5Q2FwdHVyZSIsImN1dCIsIm9uQ3V0Iiwib25DdXRDYXB0dXJlIiwiZG91YmxlQ2xpY2siLCJkcmFnIiwib25EcmFnIiwib25EcmFnQ2FwdHVyZSIsImRyYWdFbmQiLCJvbkRyYWdFbmQiLCJvbkRyYWdFbmRDYXB0dXJlIiwiZHJhZ0VudGVyIiwib25EcmFnRW50ZXIiLCJvbkRyYWdFbnRlckNhcHR1cmUiLCJkcmFnRXhpdCIsIm9uRHJhZ0V4aXQiLCJvbkRyYWdFeGl0Q2FwdHVyZSIsImRyYWdMZWF2ZSIsIm9uRHJhZ0xlYXZlIiwib25EcmFnTGVhdmVDYXB0dXJlIiwiZHJhZ092ZXIiLCJvbkRyYWdPdmVyIiwib25EcmFnT3ZlckNhcHR1cmUiLCJkcmFnU3RhcnQiLCJvbkRyYWdTdGFydCIsIm9uRHJhZ1N0YXJ0Q2FwdHVyZSIsImRyb3AiLCJvbkRyb3AiLCJvbkRyb3BDYXB0dXJlIiwiZHVyYXRpb25DaGFuZ2UiLCJvbkR1cmF0aW9uQ2hhbmdlIiwib25EdXJhdGlvbkNoYW5nZUNhcHR1cmUiLCJlbXB0aWVkIiwib25FbXB0aWVkIiwib25FbXB0aWVkQ2FwdHVyZSIsImVuY3J5cHRlZCIsIm9uRW5jcnlwdGVkIiwib25FbmNyeXB0ZWRDYXB0dXJlIiwiZW5kZWQiLCJvbkVuZGVkIiwib25FbmRlZENhcHR1cmUiLCJvbkVycm9yIiwib25FcnJvckNhcHR1cmUiLCJvbkZvY3VzIiwib25Gb2N1c0NhcHR1cmUiLCJvbklucHV0Iiwib25JbnB1dENhcHR1cmUiLCJrZXlEb3duIiwib25LZXlEb3duIiwib25LZXlEb3duQ2FwdHVyZSIsImtleVByZXNzIiwib25LZXlQcmVzcyIsIm9uS2V5UHJlc3NDYXB0dXJlIiwia2V5VXAiLCJvbktleVVwIiwib25LZXlVcENhcHR1cmUiLCJsb2FkIiwib25Mb2FkIiwib25Mb2FkQ2FwdHVyZSIsImxvYWRlZERhdGEiLCJvbkxvYWRlZERhdGEiLCJvbkxvYWRlZERhdGFDYXB0dXJlIiwibG9hZGVkTWV0YWRhdGEiLCJvbkxvYWRlZE1ldGFkYXRhIiwib25Mb2FkZWRNZXRhZGF0YUNhcHR1cmUiLCJsb2FkU3RhcnQiLCJvbkxvYWRTdGFydCIsIm9uTG9hZFN0YXJ0Q2FwdHVyZSIsIm1vdXNlTW92ZSIsIm1vdXNlT3V0Iiwib25Nb3VzZU91dCIsIm9uTW91c2VPdXRDYXB0dXJlIiwibW91c2VPdmVyIiwib25Nb3VzZU92ZXIiLCJvbk1vdXNlT3ZlckNhcHR1cmUiLCJtb3VzZVVwIiwicGFzdGUiLCJvblBhc3RlIiwib25QYXN0ZUNhcHR1cmUiLCJwYXVzZSIsIm9uUGF1c2UiLCJvblBhdXNlQ2FwdHVyZSIsInBsYXkiLCJvblBsYXkiLCJvblBsYXlDYXB0dXJlIiwicGxheWluZyIsIm9uUGxheWluZyIsIm9uUGxheWluZ0NhcHR1cmUiLCJwcm9ncmVzcyIsIm9uUHJvZ3Jlc3MiLCJvblByb2dyZXNzQ2FwdHVyZSIsInJhdGVDaGFuZ2UiLCJvblJhdGVDaGFuZ2UiLCJvblJhdGVDaGFuZ2VDYXB0dXJlIiwib25SZXNldCIsIm9uUmVzZXRDYXB0dXJlIiwic2Nyb2xsIiwib25TY3JvbGwiLCJvblNjcm9sbENhcHR1cmUiLCJzZWVrZWQiLCJvblNlZWtlZCIsIm9uU2Vla2VkQ2FwdHVyZSIsInNlZWtpbmciLCJvblNlZWtpbmciLCJvblNlZWtpbmdDYXB0dXJlIiwic3RhbGxlZCIsIm9uU3RhbGxlZCIsIm9uU3RhbGxlZENhcHR1cmUiLCJzdWJtaXQiLCJvblN1Ym1pdCIsIm9uU3VibWl0Q2FwdHVyZSIsInN1c3BlbmQiLCJvblN1c3BlbmQiLCJvblN1c3BlbmRDYXB0dXJlIiwidGltZVVwZGF0ZSIsIm9uVGltZVVwZGF0ZSIsIm9uVGltZVVwZGF0ZUNhcHR1cmUiLCJ0b3VjaENhbmNlbCIsIm9uVG91Y2hDYW5jZWwiLCJvblRvdWNoQ2FuY2VsQ2FwdHVyZSIsInRvdWNoRW5kIiwib25Ub3VjaEVuZCIsIm9uVG91Y2hFbmRDYXB0dXJlIiwidG91Y2hNb3ZlIiwib25Ub3VjaE1vdmUiLCJvblRvdWNoTW92ZUNhcHR1cmUiLCJ0b3VjaFN0YXJ0Iiwib25Ub3VjaFN0YXJ0Iiwib25Ub3VjaFN0YXJ0Q2FwdHVyZSIsInZvbHVtZUNoYW5nZSIsIm9uVm9sdW1lQ2hhbmdlIiwib25Wb2x1bWVDaGFuZ2VDYXB0dXJlIiwid2FpdGluZyIsIm9uV2FpdGluZyIsIm9uV2FpdGluZ0NhcHR1cmUiLCJ3aGVlbCIsIm9uV2hlZWwiLCJvbldoZWVsQ2FwdHVyZSIsInRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZyIsIk9OX0NMSUNLX0tFWSIsIm9uQ2xpY2tMaXN0ZW5lcnMiLCJFdmVudENvbnN0cnVjdG9yIiwiQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UiLCJjbGlwYm9hcmREYXRhIiwiRm9jdXNFdmVudEludGVyZmFjZSIsImdldEV2ZW50S2V5IiwiS2V5Ym9hcmRFdmVudEludGVyZmFjZSIsInJlcGVhdCIsImxvY2FsZSIsImNoYXJDb2RlIiwibm9ybWFsaXplS2V5IiwidHJhbnNsYXRlVG9LZXkiLCJEcmFnRXZlbnRJbnRlcmZhY2UiLCJkYXRhVHJhbnNmZXIiLCJUb3VjaEV2ZW50SW50ZXJmYWNlIiwidG91Y2hlcyIsInRhcmdldFRvdWNoZXMiLCJjaGFuZ2VkVG91Y2hlcyIsIldoZWVsRXZlbnRJbnRlcmZhY2UiLCJkZWx0YVgiLCJ3aGVlbERlbHRhWCIsImRlbHRhWSIsIndoZWVsRGVsdGFZIiwid2hlZWxEZWx0YSIsImRlbHRhWiIsImRlbHRhTW9kZSIsIk5TIiwieGxpbmsiLCJ4bWwiLCJjbGlwUGF0aCIsImN4IiwiY3kiLCJkeCIsImR5IiwiZmlsbCIsImZ4IiwiZnkiLCJncmFkaWVudFRyYW5zZm9ybSIsImdyYWRpZW50VW5pdHMiLCJtYXJrZXJFbmQiLCJtYXJrZXJNaWQiLCJtYXJrZXJTdGFydCIsInBhdHRlcm5Db250ZW50VW5pdHMiLCJwYXR0ZXJuVW5pdHMiLCJwb2ludHMiLCJwcmVzZXJ2ZUFzcGVjdFJhdGlvIiwiciIsInJ4IiwicnkiLCJzcHJlYWRNZXRob2QiLCJzdG9wQ29sb3IiLCJzdHJva2UiLCJzdHJva2VEYXNoYXJyYXkiLCJzdHJva2VMaW5lY2FwIiwidGV4dEFuY2hvciIsInRyYW5zZm9ybSIsInZpZXdCb3giLCJ4MSIsIngyIiwieGxpbmtBY3R1YXRlIiwieGxpbmtBcmNyb2xlIiwieGxpbmtIcmVmIiwieGxpbmtSb2xlIiwieGxpbmtTaG93IiwieGxpbmtUaXRsZSIsInhsaW5rVHlwZSIsInhtbEJhc2UiLCJ4bWxMYW5nIiwieG1sU3BhY2UiLCJ5MSIsInkyIiwiUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzIiwicGVyZm9ybWFuY2VOb3ciLCJyb3VuZEZsb2F0IiwiZmxvb3IiLCJhZGRWYWx1ZSIsIl9hbGxNZWFzdXJlbWVudHMiLCJfbW91bnRTdGFjayIsIl9pbmplY3RlZCIsImdldExhc3RNZWFzdXJlbWVudHMiLCJwcmludEV4Y2x1c2l2ZSIsIm1lYXN1cmVtZW50cyIsImdldEV4Y2x1c2l2ZVN1bW1hcnkiLCJ0YWJsZSIsImluY2x1c2l2ZSIsImV4Y2x1c2l2ZSIsInByaW50SW5jbHVzaXZlIiwiZ2V0SW5jbHVzaXZlU3VtbWFyeSIsInRpbWUiLCJsb2ciLCJnZXRUb3RhbFRpbWUiLCJ0b0ZpeGVkIiwiZ2V0TWVhc3VyZW1lbnRzU3VtbWFyeU1hcCIsInByaW50V2FzdGVkIiwicHJpbnRET00iLCJnZXRET01TdW1tYXJ5IiwiX3JlY29yZFdyaXRlIiwidG90YWxUaW1lIiwid3JpdGVzIiwibW9kdWxlTmFtZSIsInJ2IiwiY291bnRzIiwiZGlzcGxheU5hbWVzIiwiY3JlYXRlZCIsIm1vdW50SUQiLCJ3cml0ZUFyZ3MiLCJpc1JlbmRlciIsImlzTW91bnQiLCJtb3VudFN0YWNrIiwic3ViTW91bnRUaW1lIiwiRE9OVF9DQVJFX1RIUkVTSE9MRCIsIkRPTV9PUEVSQVRJT05fVFlQRVMiLCJtZWFzdXJlbWVudCIsIml0ZW1zIiwiY2FuZGlkYXRlcyIsImFsbElEcyIsIm9ubHlDbGVhbiIsImluY2x1c2l2ZUtleSIsImNsZWFuQ29tcG9uZW50cyIsImdldFVuY2hhbmdlZENvbXBvbmVudHMiLCJkaXJ0eUxlYWZJRHMiLCJpc0RpcnR5IiwicGVyZm9ybWFuY2UiLCJtc1BlcmZvcm1hbmNlIiwid2Via2l0UGVyZm9ybWFuY2UiLCJSZWFjdFNlcnZlclJlbmRlcmluZyIsIlJlYWN0U2VydmVyQmF0Y2hpbmdTdHJhdGVneSIsIlJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24iLCJSZWFjdERPTUZhY3RvcmllcyIsIlJlYWN0RWxlbWVudFZhbGlkYXRvciIsIm9ubHlDaGlsZCIsIkNoaWxkcmVuIiwib25seSIsIlByb3BUeXBlcyIsImNyZWF0ZU1peGluIiwiRE9NIiwiX19zcHJlYWQiLCJtYXBPYmplY3QiLCJjcmVhdGVET01GYWN0b3J5IiwiYWJiciIsImFkZHJlc3MiLCJhcmVhIiwiYXJ0aWNsZSIsImFzaWRlIiwiYXVkaW8iLCJiYXNlIiwiYmRpIiwiYmRvIiwiYmlnIiwiYmxvY2txdW90ZSIsImJyIiwiY2FudmFzIiwiY2FwdGlvbiIsImNpdGUiLCJjb2RlIiwiY29sIiwiY29sZ3JvdXAiLCJkYXRhbGlzdCIsImRkIiwiZGVsIiwiZGV0YWlscyIsImRmbiIsImRpYWxvZyIsImRpdiIsImRsIiwiZHQiLCJlbSIsImVtYmVkIiwiZmllbGRzZXQiLCJmaWdjYXB0aW9uIiwiZmlndXJlIiwiZm9vdGVyIiwiaDEiLCJoMiIsImgzIiwiaDQiLCJoNSIsImg2IiwiaGVhZCIsImhlYWRlciIsImhncm91cCIsImhyIiwiaWZyYW1lIiwiaW1nIiwiaW5zIiwia2JkIiwia2V5Z2VuIiwibGVnZW5kIiwibGkiLCJsaW5rIiwibWFpbiIsIm1hcmsiLCJtZW51IiwibWVudWl0ZW0iLCJtZXRhIiwibWV0ZXIiLCJuYXYiLCJub3NjcmlwdCIsIm9sIiwib3B0Z3JvdXAiLCJvcHRpb24iLCJvdXRwdXQiLCJwIiwicGFyYW0iLCJwaWN0dXJlIiwicHJlIiwicSIsInJwIiwicnQiLCJydWJ5IiwicyIsInNhbXAiLCJzY3JpcHQiLCJzZWN0aW9uIiwic21hbGwiLCJzdHJvbmciLCJzdWIiLCJzdXAiLCJ0Ym9keSIsInRkIiwidGV4dGFyZWEiLCJ0Zm9vdCIsInRoIiwidGhlYWQiLCJ0ciIsInRyYWNrIiwidSIsInVsIiwidmlkZW8iLCJ3YnIiLCJjaXJjbGUiLCJkZWZzIiwiZWxsaXBzZSIsImciLCJpbWFnZSIsImxpbmUiLCJsaW5lYXJHcmFkaWVudCIsIm1hc2siLCJwb2x5Z29uIiwicG9seWxpbmUiLCJyYWRpYWxHcmFkaWVudCIsInJlY3QiLCJzdmciLCJ0c3BhbiIsIm93bmVySGFzS2V5VXNlV2FybmluZyIsInZhbGlkYXRlRXhwbGljaXRLZXkiLCJwYXJlbnRUeXBlIiwiYWRkZW5kYSIsImdldEFkZGVuZGFGb3JLZXlVc2UiLCJwYXJlbnRPck93bmVyIiwibWVzc2FnZVR5cGUiLCJwYXJlbnROYW1lIiwibWVtb2l6ZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsInZhbGlkYXRlUHJvcFR5cGVzIiwidmFsaWRUeXBlIiwidmFsaWRhdGVkRmFjdG9yeSIsIm5ld01vZHVsZSIsIm5ld1BhY2thZ2UiLCJjdHgiLCJmbiIsIndhcm5lZCIsIm5ld0ZuIiwiX19lc01vZHVsZSIsImNyZWF0ZU1lbW9yeUhpc3RvcnkiLCJicm93c2VySGlzdG9yeSIsImFwcGx5Um91dGVyTWlkZGxld2FyZSIsImZvcm1hdFBhdHRlcm4iLCJ1c2VSb3V0ZXJIaXN0b3J5Iiwicm91dGVyU2hhcGUiLCJsb2NhdGlvblNoYXBlIiwiUm91dGluZ0NvbnRleHQiLCJSb3V0ZXJDb250ZXh0IiwiY3JlYXRlUm91dGVzIiwidXNlUm91dGVzIiwiUm91dGVDb250ZXh0IiwiTGlmZWN5Y2xlIiwiSGlzdG9yeSIsIlJlZGlyZWN0IiwiSW5kZXhSZWRpcmVjdCIsIndpdGhSb3V0ZXIiLCJJbmRleExpbmsiLCJMaW5rIiwiX1JvdXRlVXRpbHMiLCJfUHJvcFR5cGVzMiIsIl9QYXR0ZXJuVXRpbHMiLCJfUm91dGVyMiIsIl9Sb3V0ZXIzIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9MaW5rMiIsIl9MaW5rMyIsIl9JbmRleExpbmsyIiwiX0luZGV4TGluazMiLCJfd2l0aFJvdXRlcjIiLCJfd2l0aFJvdXRlcjMiLCJfSW5kZXhSZWRpcmVjdDIiLCJfSW5kZXhSZWRpcmVjdDMiLCJfSW5kZXhSb3V0ZTIiLCJfSW5kZXhSb3V0ZTMiLCJfUmVkaXJlY3QyIiwiX1JlZGlyZWN0MyIsIl9Sb3V0ZTIiLCJfUm91dGUzIiwiX0hpc3RvcnkyIiwiX0hpc3RvcnkzIiwiX0xpZmVjeWNsZTIiLCJfTGlmZWN5Y2xlMyIsIl9Sb3V0ZUNvbnRleHQyIiwiX1JvdXRlQ29udGV4dDMiLCJfdXNlUm91dGVzMiIsIl91c2VSb3V0ZXMzIiwiX1JvdXRlckNvbnRleHQyIiwiX1JvdXRlckNvbnRleHQzIiwiX1JvdXRpbmdDb250ZXh0MiIsIl9Sb3V0aW5nQ29udGV4dDMiLCJfUHJvcFR5cGVzMyIsIl9tYXRjaDIiLCJfbWF0Y2gzIiwiX3VzZVJvdXRlckhpc3RvcnkyIiwiX3VzZVJvdXRlckhpc3RvcnkzIiwiX2FwcGx5Um91dGVyTWlkZGxld2FyZTIiLCJfYXBwbHlSb3V0ZXJNaWRkbGV3YXJlMyIsIl9icm93c2VySGlzdG9yeTIiLCJfYnJvd3Nlckhpc3RvcnkzIiwiX2hhc2hIaXN0b3J5MiIsIl9oYXNoSGlzdG9yeTMiLCJfY3JlYXRlTWVtb3J5SGlzdG9yeTIiLCJfY3JlYXRlTWVtb3J5SGlzdG9yeTMiLCJkZWZhdWx0IiwiX2V4dGVuZHMiLCJpc1JlYWN0Q2hpbGRyZW4iLCJjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQiLCJjcmVhdGVSb3V0ZXNGcm9tUmVhY3RDaGlsZHJlbiIsIl9yZWFjdCIsIl9yZWFjdDIiLCJpc1ZhbGlkQ2hpbGQiLCJjcmVhdGVSb3V0ZSIsInJvdXRlIiwiY2hpbGRSb3V0ZXMiLCJwYXJlbnRSb3V0ZSIsInJvdXRlcyIsInJvdXRlciIsImNvbXBvbmVudHMiLCJoaXN0b3J5IiwiZmFsc3kiLCJfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyIsIl9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzMiIsIl9JbnRlcm5hbFByb3BUeXBlcyIsIkludGVybmFsUHJvcFR5cGVzIiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJfcm91dGVyV2FybmluZyIsIl9yb3V0ZXJXYXJuaW5nMiIsIm5ld09iaiIsImdvIiwiZ29CYWNrIiwiZ29Gb3J3YXJkIiwic2V0Um91dGVMZWF2ZUhvb2siLCJpc0FjdGl2ZSIsInBhdGhuYW1lIiwic2VhcmNoIiwiZGVwcmVjYXRlUHJvcFR5cGUiLCJkZXByZWNhdGVJbnRlcm5hbFByb3BUeXBlIiwiZGVwcmVjYXRlUmVuYW1lZFByb3BUeXBlIiwiZGVmYXVsdEV4cG9ydCIsImNhblVzZU1lbWJyYW5lIiwiZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyIsIm1lbWJyYW5lIiwiX2xvb3AiLCJfcmV0Iiwicm91dGVyV2FybmluZyIsIl9yZXNldFdhcm5lZCIsIl93YXJuaW5nIiwiX3dhcm5pbmcyIiwiZmFsc2VUb1dhcm4iLCJjb21waWxlUGF0dGVybiIsIm1hdGNoUGF0dGVybiIsImdldFBhcmFtTmFtZXMiLCJnZXRQYXJhbXMiLCJfaW52YXJpYW50IiwiX2ludmFyaWFudDIiLCJlc2NhcGVSZWdFeHAiLCJfY29tcGlsZVBhdHRlcm4iLCJyZWdleHBTb3VyY2UiLCJwYXJhbU5hbWVzIiwidG9rZW5zIiwibWF0Y2hlciIsImV4ZWMiLCJDb21waWxlZFBhdHRlcm5zQ2FjaGUiLCJfY29tcGlsZVBhdHRlcm4yIiwibWF0Y2hlZFBhdGgiLCJyZW1haW5pbmdQYXRobmFtZSIsInBhcmFtVmFsdWVzIiwidiIsImRlY29kZVVSSUNvbXBvbmVudCIsInBhcmFtcyIsInBhcmFtTmFtZSIsIl9jb21waWxlUGF0dGVybjMiLCJwYXJlbkNvdW50Iiwic3BsYXRJbmRleCIsInRva2VuIiwicGFyYW1WYWx1ZSIsInNwbGF0IiwiZW5jb2RlVVJJIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiX2NyZWF0ZUhhc2hIaXN0b3J5IiwiX2NyZWF0ZUhhc2hIaXN0b3J5MiIsIl91c2VRdWVyaWVzIiwiX3VzZVF1ZXJpZXMyIiwiX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyIiwiX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMiIsIl9Sb3V0ZXJDb250ZXh0IiwiX1JvdXRlclV0aWxzIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwiaXNEZXByZWNhdGVkSGlzdG9yeSIsIl9fdjJfY29tcGF0aWJsZV9fIiwiaXNVbnN1cHBvcnRlZEhpc3RvcnkiLCJnZXRDdXJyZW50TG9jYXRpb24iLCJfUmVhY3QkUHJvcFR5cGVzIiwib25VcGRhdGUiLCJwYXJzZVF1ZXJ5U3RyaW5nIiwic3RyaW5naWZ5UXVlcnkiLCJtYXRjaENvbnRleHQiLCJoYW5kbGVFcnJvciIsIl90aGlzIiwiX3Byb3BzIiwiX2NyZWF0ZVJvdXRlck9iamVjdHMiLCJjcmVhdGVSb3V0ZXJPYmplY3RzIiwidHJhbnNpdGlvbk1hbmFnZXIiLCJfdW5saXN0ZW4iLCJfcHJvcHMyIiwid3JhcERlcHJlY2F0ZWRIaXN0b3J5IiwiY3JlYXRlUm91dGVyT2JqZWN0Iiwicm91dGluZ0hpc3RvcnkiLCJjcmVhdGVSb3V0aW5nSGlzdG9yeSIsIl9wcm9wczMiLCJjcmVhdGVIaXN0b3J5IiwiX3N0YXRlIiwiX3Byb3BzNCIsIl9BY3Rpb25zIiwiX1BhdGhVdGlscyIsIl9FeGVjdXRpb25FbnZpcm9ubWVudCIsIl9ET01VdGlscyIsIl9ET01TdGF0ZVN0b3JhZ2UiLCJfY3JlYXRlRE9NSGlzdG9yeSIsIl9jcmVhdGVET01IaXN0b3J5MiIsImlzQWJzb2x1dGVQYXRoIiwiZW5zdXJlU2xhc2giLCJnZXRIYXNoUGF0aCIsInJlcGxhY2VIYXNoUGF0aCIsImFkZFF1ZXJ5U3RyaW5nVmFsdWVUb1BhdGgiLCJzdHJpcFF1ZXJ5U3RyaW5nVmFsdWVGcm9tUGF0aCIsImdldFF1ZXJ5U3RyaW5nVmFsdWVGcm9tUGF0aCIsIkRlZmF1bHRRdWVyeUtleSIsImNyZWF0ZUhhc2hIaXN0b3J5IiwicXVlcnlLZXkiLCJyZWFkU3RhdGUiLCJjcmVhdGVLZXkiLCJwYXJzZVBhdGgiLCJjcmVhdGVMb2NhdGlvbiIsInN0YXJ0SGFzaENoYW5nZUxpc3RlbmVyIiwiX3JlZiIsInRyYW5zaXRpb25UbyIsImhhc2hDaGFuZ2VMaXN0ZW5lciIsImZpbmlzaFRyYW5zaXRpb24iLCJiYXNlbmFtZSIsIlBPUCIsInNhdmVTdGF0ZSIsImN1cnJlbnRIYXNoIiwiUFVTSCIsImxpc3RlbmVyQ291bnQiLCJzdG9wSGFzaENoYW5nZUxpc3RlbmVyIiwibGlzdGVuQmVmb3JlIiwidW5saXN0ZW4iLCJnb0lzU3VwcG9ydGVkV2l0aG91dFJlbG9hZCIsInN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoIiwibiIsImNyZWF0ZUhyZWYiLCJyZWdpc3RlclRyYW5zaXRpb25Ib29rIiwiaG9vayIsInVucmVnaXN0ZXJUcmFuc2l0aW9uSG9vayIsInB1c2hTdGF0ZSIsIlJFUExBQ0UiLCJleHRyYWN0UGF0aCIsImhhc2hJbmRleCIsInNlYXJjaEluZGV4IiwiZ2V0V2luZG93UGF0aCIsImdldFVzZXJDb25maXJtYXRpb24iLCJzdXBwb3J0c0hpc3RvcnkiLCJjb25maXJtIiwidWEiLCJLZXlQcmVmaXgiLCJRdW90YUV4Y2VlZGVkRXJyb3JzIiwiU2VjdXJpdHlFcnJvciIsInNlc3Npb25TdG9yYWdlIiwicmVtb3ZlSXRlbSIsInNldEl0ZW0iLCJqc29uIiwiZ2V0SXRlbSIsInBhcnNlIiwiX2NyZWF0ZUhpc3RvcnkiLCJfY3JlYXRlSGlzdG9yeTIiLCJjcmVhdGVET01IaXN0b3J5IiwiX2RlZXBFcXVhbCIsIl9kZWVwRXF1YWwyIiwiX0FzeW5jVXRpbHMiLCJfY3JlYXRlTG9jYXRpb24yIiwiX2NyZWF0ZUxvY2F0aW9uMyIsIl9ydW5UcmFuc2l0aW9uSG9vayIsIl9ydW5UcmFuc2l0aW9uSG9vazIiLCJfZGVwcmVjYXRlIiwiX2RlcHJlY2F0ZTIiLCJjcmVhdGVSYW5kb21LZXkiLCJsb2NhdGlvbnNBcmVFcXVhbCIsIkRlZmF1bHRLZXlMZW5ndGgiLCJrZXlMZW5ndGgiLCJ0cmFuc2l0aW9uSG9va3MiLCJmaWx0ZXIiLCJhbGxLZXlzIiwiY2hhbmdlTGlzdGVuZXJzIiwiZ2V0Q3VycmVudCIsInBlbmRpbmdMb2NhdGlvbiIsInVwZGF0ZUxvY2F0aW9uIiwibmV3TG9jYXRpb24iLCJfbG9jYXRpb24iLCJjb25maXJtVHJhbnNpdGlvblRvIiwibG9vcEFzeW5jIiwib2siLCJuZXh0TG9jYXRpb24iLCJwcmV2UGF0aCIsImNyZWF0ZVBhdGgiLCJuZXh0UGF0aCIsInByZXZJbmRleCIsInVwZGF0ZUxvY2F0aW9uU3RhdGUiLCJwU2xpY2UiLCJvYmplY3RLZXlzIiwiaXNBcmd1bWVudHMiLCJkZWVwRXF1YWwiLCJhY3R1YWwiLCJleHBlY3RlZCIsIm9wdHMiLCJnZXRUaW1lIiwic3RyaWN0Iiwib2JqRXF1aXYiLCJpc1VuZGVmaW5lZE9yTnVsbCIsImlzQnVmZmVyIiwia2EiLCJrYiIsInNoaW0iLCJzdXBwb3J0c0FyZ3VtZW50c0NsYXNzIiwic3VwcG9ydGVkIiwidW5zdXBwb3J0ZWQiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9zbGljZSIsInR1cm5zIiwid29yayIsImN1cnJlbnRUdXJuIiwiaXNEb25lIiwic3luYyIsImhhc05leHQiLCJkb25lQXJncyIsIl9mb3VydGhBcmciLCJydW5UcmFuc2l0aW9uSG9vayIsImRlcHJlY2F0ZSIsIl9xdWVyeVN0cmluZyIsIlNFQVJDSF9CQVNFX0tFWSIsImRlZmF1bHRTdHJpbmdpZnlRdWVyeSIsInF1ZXJ5IiwiZGVmYXVsdFBhcnNlUXVlcnlTdHJpbmciLCJpc05lc3RlZE9iamVjdCIsInVzZVF1ZXJpZXMiLCJhZGRRdWVyeSIsInNlYXJjaEJhc2UiLCJhcHBlbmRRdWVyeSIsIl9leHRlbmRzMiIsInNlYXJjaEJhc2VTcGVjIiwicXVlcnlTdHJpbmciLCJmdWxsTG9jYXRpb24iLCJzdHJpY3RVcmlFbmNvZGUiLCJleHRyYWN0Iiwic3RyIiwicmVkdWNlIiwicGFydHMiLCJzaGlmdCIsInZhbDIiLCJjcmVhdGVUcmFuc2l0aW9uTWFuYWdlciIsIl9jb21wdXRlQ2hhbmdlZFJvdXRlczIiLCJfY29tcHV0ZUNoYW5nZWRSb3V0ZXMzIiwiX1RyYW5zaXRpb25VdGlscyIsIl9pc0FjdGl2ZTIiLCJfaXNBY3RpdmUzIiwiX2dldENvbXBvbmVudHMiLCJfZ2V0Q29tcG9uZW50czIiLCJfbWF0Y2hSb3V0ZXMiLCJfbWF0Y2hSb3V0ZXMyIiwiaGFzQW55UHJvcGVydGllcyIsImluZGV4T25seU9yRGVwcmVjYXRlZFF1ZXJ5IiwiZGVwcmVjYXRlZEluZGV4T25seSIsImluZGV4T25seSIsInBhcnRpYWxOZXh0U3RhdGUiLCJmaW5pc2hNYXRjaCIsIl9jb21wdXRlQ2hhbmdlZFJvdXRlcyIsImxlYXZlUm91dGVzIiwiY2hhbmdlUm91dGVzIiwiZW50ZXJSb3V0ZXMiLCJydW5MZWF2ZUhvb2tzIiwicmVtb3ZlTGlzdGVuQmVmb3JlSG9va3NGb3JSb3V0ZSIsInJ1bkNoYW5nZUhvb2tzIiwicmVkaXJlY3RJbmZvIiwiaGFuZGxlRXJyb3JPclJlZGlyZWN0IiwicnVuRW50ZXJIb29rcyIsImZpbmlzaEVudGVySG9va3MiLCJSb3V0ZUd1aWQiLCJnZXRSb3V0ZUlEIiwiX19pZF9fIiwiUm91dGVIb29rcyIsImdldFJvdXRlSG9va3NGb3JSb3V0ZXMiLCJob29rcyIsInRyYW5zaXRpb25Ib29rIiwiYmVmb3JlVW5sb2FkSG9vayIsInVubGlzdGVuQmVmb3JlIiwidW5saXN0ZW5CZWZvcmVVbmxvYWQiLCJyb3V0ZUlEIiwibGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlIiwidGhlcmVXZXJlTm9Sb3V0ZUhvb2tzIiwibGlzdGVuQmVmb3JlVW5sb2FkIiwibmV3SG9va3MiLCJyZWRpcmVjdExvY2F0aW9uIiwicm91dGVQYXJhbXNDaGFuZ2VkIiwic29tZSIsImNvbXB1dGVDaGFuZ2VkUm91dGVzIiwicHJldlJvdXRlcyIsIm5leHRSb3V0ZXMiLCJwYXJlbnRJc0xlYXZpbmciLCJpc0xlYXZpbmciLCJpc05ldyIsInBhcmFtc0NoYW5nZWQiLCJjcmVhdGVUcmFuc2l0aW9uSG9vayIsImFzeW5jQXJpdHkiLCJnZXRFbnRlckhvb2tzIiwib25FbnRlciIsImdldENoYW5nZUhvb2tzIiwicnVuVHJhbnNpdGlvbkhvb2tzIiwiaXRlciIsImRlcHJlY2F0ZWRQYXRobmFtZSIsImRlcHJlY2F0ZWRRdWVyeSIsIm9uTGVhdmUiLCJtYXBBc3luYyIsInZhbHVlcyIsImRvbmVDb3VudCIsIl90eXBlb2YiLCJwYXRoSXNBY3RpdmUiLCJjdXJyZW50UGF0aG5hbWUiLCJyb3V0ZUlzQWN0aXZlIiwibWF0Y2hlZCIsInF1ZXJ5SXNBY3RpdmUiLCJhY3RpdmVRdWVyeSIsImN1cnJlbnRMb2NhdGlvbiIsIl9tYWtlU3RhdGVXaXRoTG9jYXRpb24iLCJfbWFrZVN0YXRlV2l0aExvY2F0aW9uMiIsImdldENvbXBvbmVudHNGb3JSb3V0ZSIsImdldENvbXBvbmVudCIsImdldENvbXBvbmVudHMiLCJuZXh0U3RhdGVXaXRoTG9jYXRpb24iLCJtYWtlU3RhdGVXaXRoTG9jYXRpb24iLCJzdGF0ZVdpdGhMb2NhdGlvbiIsIm1hdGNoUm91dGVzIiwiZ2V0Q2hpbGRSb3V0ZXMiLCJjcmVhdGVQYXJhbXMiLCJwYXJ0aWFsTmV4dFN0YXRlV2l0aExvY2F0aW9uIiwiZ2V0SW5kZXhSb3V0ZSIsImluZGV4Um91dGUiLCJwYXRobGVzcyIsImNoaWxkUm91dGUiLCJhc3NpZ25QYXJhbXMiLCJtYXRjaFJvdXRlRGVlcCIsIl9yZXQyIiwiX21hdGNoJHJvdXRlcyIsIm9uQ2hpbGRSb3V0ZXMiLCJ1bnNoaWZ0IiwiX2dldFJvdXRlUGFyYW1zIiwiX2dldFJvdXRlUGFyYW1zMiIsInJlZHVjZVJpZ2h0Iiwicm91dGVQYXJhbXMiLCJlbGVtZW50cyIsImdldFJvdXRlUGFyYW1zIiwiX1Byb3BUeXBlcyIsImlzTGVmdENsaWNrRXZlbnQiLCJpc01vZGlmaWVkRXZlbnQiLCJpc0VtcHR5T2JqZWN0IiwiY3JlYXRlTG9jYXRpb25EZXNjcmlwdG9yIiwiYWN0aXZlU3R5bGUiLCJhY3RpdmVDbGFzc05hbWUiLCJvbmx5QWN0aXZlT25JbmRleCIsImhhbmRsZUNsaWNrIiwiX0xpbmsiLCJfaG9pc3ROb25SZWFjdFN0YXRpY3MiLCJfaG9pc3ROb25SZWFjdFN0YXRpY3MyIiwiZ2V0RGlzcGxheU5hbWUiLCJXcmFwcGVkQ29tcG9uZW50Iiwid2l0aFJlZiIsIldpdGhSb3V0ZXIiLCJnZXRXcmFwcGVkSW5zdGFuY2UiLCJ3cmFwcGVkSW5zdGFuY2UiLCJSRUFDVF9TVEFUSUNTIiwiS05PV05fU1RBVElDUyIsImNhbGxlciIsImFyaXR5IiwiaXNHZXRPd25Qcm9wZXJ0eVN5bWJvbHNBdmFpbGFibGUiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJob2lzdE5vblJlYWN0U3RhdGljcyIsInRhcmdldENvbXBvbmVudCIsInNvdXJjZUNvbXBvbmVudCIsImN1c3RvbVN0YXRpY3MiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiX1JlZGlyZWN0Iiwicm91dGVJbmRleCIsInBhcmVudFBhdHRlcm4iLCJnZXRSb3V0ZVBhdHRlcm4iLCJyb3V0ZXJXaWxsTGVhdmUiLCJfdW5saXN0ZW5CZWZvcmVMZWF2aW5nUm91dGUiLCJfY3JlYXRlTWVtb3J5SGlzdG9yeSIsImhpc3RvcnlMb2NhdGlvbiIsIl91c2VCYXNlbmFtZSIsIl91c2VCYXNlbmFtZTIiLCJtZW1vcnlIaXN0b3J5IiwidXNlQmFzZW5hbWUiLCJjaGVja2VkQmFzZUhyZWYiLCJjaGVja0Jhc2VIcmVmIiwiYmFzZUhyZWYiLCJhZGRCYXNlbmFtZSIsInByZXBlbmRCYXNlbmFtZSIsInBuYW1lIiwibm9ybWFsaXplZEJhc2VuYW1lIiwibm9ybWFsaXplZFBhdGhuYW1lIiwiY3JlYXRlU3RhdGVTdG9yYWdlIiwibWVtbyIsIl9vcHRpb25zIiwic3RvcmFnZSIsImNhbkdvIiwibWlkZGxld2FyZXMiLCJtaWRkbGV3YXJlIiwicmVuZGVyUm91dGVyQ29udGV4dCIsInJlbmRlclJvdXRlQ29tcG9uZW50Iiwid2l0aENvbnRleHQiLCJ3aXRoQ29tcG9uZW50IiwibWFrZUNyZWF0ZUVsZW1lbnQiLCJiYXNlQ3JlYXRlRWxlbWVudCIsInByZXZpb3VzIiwicmVuZGVyUHJvcHMiLCJfY3JlYXRlQnJvd3Nlckhpc3RvcnkiLCJfY3JlYXRlQnJvd3Nlckhpc3RvcnkyIiwiX2NyZWF0ZVJvdXRlckhpc3RvcnkiLCJfY3JlYXRlUm91dGVySGlzdG9yeTIiLCJjcmVhdGVCcm93c2VySGlzdG9yeSIsImZvcmNlUmVmcmVzaCIsInVzZVJlZnJlc2giLCJoaXN0b3J5U3RhdGUiLCJfaGlzdG9yeVN0YXRlIiwic3RhcnRQb3BTdGF0ZUxpc3RlbmVyIiwicG9wU3RhdGVMaXN0ZW5lciIsInN0b3BQb3BTdGF0ZUxpc3RlbmVyIiwiX3VzZVJvdXRlckhpc3RvcnkiLCJtb2R1bGVzIiwibWVkaWFRdWVyeSIsImFscmVhZHlJbXBvcnRlZE1vZHVsZXMiLCJjb21wb3NlIiwiYXBwbHlNaWRkbGV3YXJlIiwiYmluZEFjdGlvbkNyZWF0b3JzIiwiY29tYmluZVJlZHVjZXJzIiwiY3JlYXRlU3RvcmUiLCJfY3JlYXRlU3RvcmUiLCJfY3JlYXRlU3RvcmUyIiwiX2NvbWJpbmVSZWR1Y2VycyIsIl9jb21iaW5lUmVkdWNlcnMyIiwiX2JpbmRBY3Rpb25DcmVhdG9ycyIsIl9iaW5kQWN0aW9uQ3JlYXRvcnMyIiwiX2FwcGx5TWlkZGxld2FyZSIsIl9hcHBseU1pZGRsZXdhcmUyIiwiX2NvbXBvc2UiLCJfY29tcG9zZTIiLCJpc0NydXNoZWQiLCJBY3Rpb25UeXBlcyIsIl9pc1BsYWluT2JqZWN0IiwiX2lzUGxhaW5PYmplY3QyIiwiX3N5bWJvbE9ic2VydmFibGUiLCJfc3ltYm9sT2JzZXJ2YWJsZTIiLCJJTklUIiwicmVkdWNlciIsInByZWxvYWRlZFN0YXRlIiwiZW5oYW5jZXIiLCJfcmVmMiIsImN1cnJlbnRSZWR1Y2VyIiwiY3VycmVudFN0YXRlIiwiY3VycmVudExpc3RlbmVycyIsIm5leHRMaXN0ZW5lcnMiLCJpc0Rpc3BhdGNoaW5nIiwiZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycyIsImdldFN0YXRlIiwic3Vic2NyaWJlIiwiaXNTdWJzY3JpYmVkIiwidW5zdWJzY3JpYmUiLCJkaXNwYXRjaCIsInJlcGxhY2VSZWR1Y2VyIiwibmV4dFJlZHVjZXIiLCJvYnNlcnZhYmxlIiwib3V0ZXJTdWJzY3JpYmUiLCJvYnNlcnZlciIsIm9ic2VydmVTdGF0ZSIsImdldFByb3RvdHlwZSIsImlzT2JqZWN0TGlrZSIsIm9iamVjdFRhZyIsImZ1bmNQcm90byIsIm9iamVjdFByb3RvIiwiZnVuY1RvU3RyaW5nIiwib2JqZWN0Q3RvclN0cmluZyIsIm9iamVjdFRvU3RyaW5nIiwiaXNQbGFpbk9iamVjdCIsIkN0b3IiLCJvdmVyQXJnIiwiZ2V0UHJvdG90eXBlT2YiLCJfcG9ueWZpbGwiLCJfcG9ueWZpbGwyIiwiZ2xvYmFsIiwid2VicGFja1BvbHlmaWxsIiwicGF0aHMiLCJzeW1ib2xPYnNlcnZhYmxlUG9ueWZpbGwiLCJfU3ltYm9sIiwiZ2V0VW5kZWZpbmVkU3RhdGVFcnJvck1lc3NhZ2UiLCJhY3Rpb25UeXBlIiwiYWN0aW9uTmFtZSIsImdldFVuZXhwZWN0ZWRTdGF0ZVNoYXBlV2FybmluZ01lc3NhZ2UiLCJpbnB1dFN0YXRlIiwicmVkdWNlcnMiLCJ1bmV4cGVjdGVkS2V5Q2FjaGUiLCJyZWR1Y2VyS2V5cyIsImFyZ3VtZW50TmFtZSIsInVuZXhwZWN0ZWRLZXlzIiwiYXNzZXJ0UmVkdWNlclNhbml0eSIsImZpbmFsUmVkdWNlcnMiLCJmaW5hbFJlZHVjZXJLZXlzIiwic2FuaXR5RXJyb3IiLCJjb21iaW5hdGlvbiIsIndhcm5pbmdNZXNzYWdlIiwiaGFzQ2hhbmdlZCIsInByZXZpb3VzU3RhdGVGb3JLZXkiLCJuZXh0U3RhdGVGb3JLZXkiLCJlcnJvck1lc3NhZ2UiLCJiaW5kQWN0aW9uQ3JlYXRvciIsImFjdGlvbkNyZWF0b3IiLCJhY3Rpb25DcmVhdG9ycyIsImJvdW5kQWN0aW9uQ3JlYXRvcnMiLCJzdG9yZSIsIl9kaXNwYXRjaCIsImNoYWluIiwibWlkZGxld2FyZUFQSSIsImZ1bmNzIiwibGFzdCIsInJlc3QiLCJjb21wb3NlZCIsInJlZHV4Iiwic3RhdGVEZWZhdWx0Iiwic2VhcmNoVGV4dCIsInNob3dDb21wbGV0ZWQiLCJ0b2RvcyIsImRldlRvb2xzRXh0ZW5zaW9uIiwiZ2V0RWxlbWVudEJ5SWQiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDdENBLDZDQUFpUixFOzs7Ozs7QUNBalI7QUFDQTtBQUNBO0FB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OEYsaUJBQVAsRUFBM0IsR0FBd0Q7QUFBQSxVQUFLM3VGLENBQUw7QUFBQSxFQURuQixDQUEzQixDQUFaOztBQUlBOHRGLE9BQU1yRCxTQUFOLENBQWdCLFlBQU07QUFDcEIsT0FBSXI3RCxRQUFRMCtELE1BQU10RCxRQUFOLEVBQVo7QUFDQTE2RixZQUFTOCtGLGNBQVQsQ0FBd0IsS0FBeEIsRUFBK0IvdkYsU0FBL0IsR0FBMkN1d0IsTUFBTW8vRCxVQUFqRDtBQUNELEVBSEQ7O0FBS0EsS0FBSXJFLGVBQWUyRCxNQUFNdEQsUUFBTixFQUFuQjtBQUNBejNGLFNBQVFxckUsR0FBUixDQUFZLGNBQVosRUFBNEIrckIsWUFBNUI7O0FBRUEyRCxPQUFPbEQsUUFBUCxDQUFnQjtBQUNkNXZGLFNBQUssb0JBRFM7QUFFZHd6RixlQUFXO0FBRkcsRUFBaEI7O0FBS0FWLE9BQU9sRCxRQUFQLENBQWdCO0FBQ2Q1dkYsU0FBSyxvQkFEUztBQUVkd3pGLGVBQVc7QUFGRyxFQUFoQixFIiwiZmlsZSI6Ii4vcHVibGljL2J1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgNmFhN2E1NzZlNGMwN2I1YTE0NmFcbiAqKi8iLCJyZXF1aXJlKFwiISEvaG9tZS9zdGV3YXJ0L2NvZGUvbGVhcm4tcmVkdXgvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS9ob21lL3N0ZXdhcnQvY29kZS9sZWFybi1yZWR1eC9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvaG9tZS9zdGV3YXJ0L2NvZGUvbGVhcm4tcmVkdXgvbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9pbmRleC5qcz97XFxcInByZXNldHNcXFwiOltcXFwicmVhY3RcXFwiLFxcXCJlczIwMTVcXFwiLFxcXCJzdGFnZS0wXFxcIl19IS9ob21lL3N0ZXdhcnQvY29kZS9sZWFybi1yZWR1eC9ub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5Lm1pbi5qc1wiKSlcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zY3JpcHQtbG9hZGVyIS4vfi9qcXVlcnkvZGlzdC9qcXVlcnkubWluLmpzXG4gKiogbW9kdWxlIGlkID0gMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzcmMpIHtcclxuXHRpZiAodHlwZW9mIGV4ZWNTY3JpcHQgPT09IFwiZnVuY3Rpb25cIilcclxuXHRcdGV4ZWNTY3JpcHQoc3JjKTtcclxuXHRlbHNlXHJcblx0XHRldmFsLmNhbGwobnVsbCwgc3JjKTtcclxufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXG4gKiogbW9kdWxlIGlkID0gMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIlxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXFxcInN5bWJvbFxcXCIgOiB0eXBlb2Ygb2JqOyB9O1xcblxcbi8qISBqUXVlcnkgdjIuMi40IHwgKGMpIGpRdWVyeSBGb3VuZGF0aW9uIHwganF1ZXJ5Lm9yZy9saWNlbnNlICovXFxuIWZ1bmN0aW9uIChhLCBiKSB7XFxuICBcXFwib2JqZWN0XFxcIiA9PSAodHlwZW9mIG1vZHVsZSA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YobW9kdWxlKSkgJiYgXFxcIm9iamVjdFxcXCIgPT0gX3R5cGVvZihtb2R1bGUuZXhwb3J0cykgPyBtb2R1bGUuZXhwb3J0cyA9IGEuZG9jdW1lbnQgPyBiKGEsICEwKSA6IGZ1bmN0aW9uIChhKSB7XFxuICAgIGlmICghYS5kb2N1bWVudCkgdGhyb3cgbmV3IEVycm9yKFxcXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XFxcIik7cmV0dXJuIGIoYSk7XFxuICB9IDogYihhKTtcXG59KFxcXCJ1bmRlZmluZWRcXFwiICE9IHR5cGVvZiB3aW5kb3cgPyB3aW5kb3cgOiB1bmRlZmluZWQsIGZ1bmN0aW9uIChhLCBiKSB7XFxuICB2YXIgYyA9IFtdLFxcbiAgICAgIGQgPSBhLmRvY3VtZW50LFxcbiAgICAgIGUgPSBjLnNsaWNlLFxcbiAgICAgIGYgPSBjLmNvbmNhdCxcXG4gICAgICBnID0gYy5wdXNoLFxcbiAgICAgIGggPSBjLmluZGV4T2YsXFxuICAgICAgaSA9IHt9LFxcbiAgICAgIGogPSBpLnRvU3RyaW5nLFxcbiAgICAgIGsgPSBpLmhhc093blByb3BlcnR5LFxcbiAgICAgIGwgPSB7fSxcXG4gICAgICBtID0gXFxcIjIuMi40XFxcIixcXG4gICAgICBuID0gZnVuY3Rpb24gbihhLCBiKSB7XFxuICAgIHJldHVybiBuZXcgbi5mbi5pbml0KGEsIGIpO1xcbiAgfSxcXG4gICAgICBvID0gL15bXFxcXHNcXFxcdUZFRkZcXFxceEEwXSt8W1xcXFxzXFxcXHVGRUZGXFxcXHhBMF0rJC9nLFxcbiAgICAgIHAgPSAvXi1tcy0vLFxcbiAgICAgIHEgPSAvLShbXFxcXGRhLXpdKS9naSxcXG4gICAgICByID0gZnVuY3Rpb24gcihhLCBiKSB7XFxuICAgIHJldHVybiBiLnRvVXBwZXJDYXNlKCk7XFxuICB9O24uZm4gPSBuLnByb3RvdHlwZSA9IHsganF1ZXJ5OiBtLCBjb25zdHJ1Y3Rvcjogbiwgc2VsZWN0b3I6IFxcXCJcXFwiLCBsZW5ndGg6IDAsIHRvQXJyYXk6IGZ1bmN0aW9uIHRvQXJyYXkoKSB7XFxuICAgICAgcmV0dXJuIGUuY2FsbCh0aGlzKTtcXG4gICAgfSwgZ2V0OiBmdW5jdGlvbiBnZXQoYSkge1xcbiAgICAgIHJldHVybiBudWxsICE9IGEgPyAwID4gYSA/IHRoaXNbYSArIHRoaXMubGVuZ3RoXSA6IHRoaXNbYV0gOiBlLmNhbGwodGhpcyk7XFxuICAgIH0sIHB1c2hTdGFjazogZnVuY3Rpb24gcHVzaFN0YWNrKGEpIHtcXG4gICAgICB2YXIgYiA9IG4ubWVyZ2UodGhpcy5jb25zdHJ1Y3RvcigpLCBhKTtyZXR1cm4gYi5wcmV2T2JqZWN0ID0gdGhpcywgYi5jb250ZXh0ID0gdGhpcy5jb250ZXh0LCBiO1xcbiAgICB9LCBlYWNoOiBmdW5jdGlvbiBlYWNoKGEpIHtcXG4gICAgICByZXR1cm4gbi5lYWNoKHRoaXMsIGEpO1xcbiAgICB9LCBtYXA6IGZ1bmN0aW9uIG1hcChhKSB7XFxuICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKG4ubWFwKHRoaXMsIGZ1bmN0aW9uIChiLCBjKSB7XFxuICAgICAgICByZXR1cm4gYS5jYWxsKGIsIGMsIGIpO1xcbiAgICAgIH0pKTtcXG4gICAgfSwgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKCkge1xcbiAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xcbiAgICB9LCBmaXJzdDogZnVuY3Rpb24gZmlyc3QoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZXEoMCk7XFxuICAgIH0sIGxhc3Q6IGZ1bmN0aW9uIGxhc3QoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZXEoLTEpO1xcbiAgICB9LCBlcTogZnVuY3Rpb24gZXEoYSkge1xcbiAgICAgIHZhciBiID0gdGhpcy5sZW5ndGgsXFxuICAgICAgICAgIGMgPSArYSArICgwID4gYSA/IGIgOiAwKTtyZXR1cm4gdGhpcy5wdXNoU3RhY2soYyA+PSAwICYmIGIgPiBjID8gW3RoaXNbY11dIDogW10pO1xcbiAgICB9LCBlbmQ6IGZ1bmN0aW9uIGVuZCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IoKTtcXG4gICAgfSwgcHVzaDogZywgc29ydDogYy5zb3J0LCBzcGxpY2U6IGMuc3BsaWNlIH0sIG4uZXh0ZW5kID0gbi5mbi5leHRlbmQgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBhLFxcbiAgICAgICAgYixcXG4gICAgICAgIGMsXFxuICAgICAgICBkLFxcbiAgICAgICAgZSxcXG4gICAgICAgIGYsXFxuICAgICAgICBnID0gYXJndW1lbnRzWzBdIHx8IHt9LFxcbiAgICAgICAgaCA9IDEsXFxuICAgICAgICBpID0gYXJndW1lbnRzLmxlbmd0aCxcXG4gICAgICAgIGogPSAhMTtmb3IgKFxcXCJib29sZWFuXFxcIiA9PSB0eXBlb2YgZyAmJiAoaiA9IGcsIGcgPSBhcmd1bWVudHNbaF0gfHwge30sIGgrKyksIFxcXCJvYmplY3RcXFwiID09ICh0eXBlb2YgZyA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YoZykpIHx8IG4uaXNGdW5jdGlvbihnKSB8fCAoZyA9IHt9KSwgaCA9PT0gaSAmJiAoZyA9IHRoaXMsIGgtLSk7IGkgPiBoOyBoKyspIHtcXG4gICAgICBpZiAobnVsbCAhPSAoYSA9IGFyZ3VtZW50c1toXSkpIGZvciAoYiBpbiBhKSB7XFxuICAgICAgICBjID0gZ1tiXSwgZCA9IGFbYl0sIGcgIT09IGQgJiYgKGogJiYgZCAmJiAobi5pc1BsYWluT2JqZWN0KGQpIHx8IChlID0gbi5pc0FycmF5KGQpKSkgPyAoZSA/IChlID0gITEsIGYgPSBjICYmIG4uaXNBcnJheShjKSA/IGMgOiBbXSkgOiBmID0gYyAmJiBuLmlzUGxhaW5PYmplY3QoYykgPyBjIDoge30sIGdbYl0gPSBuLmV4dGVuZChqLCBmLCBkKSkgOiB2b2lkIDAgIT09IGQgJiYgKGdbYl0gPSBkKSk7XFxuICAgICAgfVxcbiAgICB9cmV0dXJuIGc7XFxuICB9LCBuLmV4dGVuZCh7IGV4cGFuZG86IFxcXCJqUXVlcnlcXFwiICsgKG0gKyBNYXRoLnJhbmRvbSgpKS5yZXBsYWNlKC9cXFxcRC9nLCBcXFwiXFxcIiksIGlzUmVhZHk6ICEwLCBlcnJvcjogZnVuY3Rpb24gZXJyb3IoYSkge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcihhKTtcXG4gICAgfSwgbm9vcDogZnVuY3Rpb24gbm9vcCgpIHt9LCBpc0Z1bmN0aW9uOiBmdW5jdGlvbiBpc0Z1bmN0aW9uKGEpIHtcXG4gICAgICByZXR1cm4gXFxcImZ1bmN0aW9uXFxcIiA9PT0gbi50eXBlKGEpO1xcbiAgICB9LCBpc0FycmF5OiBBcnJheS5pc0FycmF5LCBpc1dpbmRvdzogZnVuY3Rpb24gaXNXaW5kb3coYSkge1xcbiAgICAgIHJldHVybiBudWxsICE9IGEgJiYgYSA9PT0gYS53aW5kb3c7XFxuICAgIH0sIGlzTnVtZXJpYzogZnVuY3Rpb24gaXNOdW1lcmljKGEpIHtcXG4gICAgICB2YXIgYiA9IGEgJiYgYS50b1N0cmluZygpO3JldHVybiAhbi5pc0FycmF5KGEpICYmIGIgLSBwYXJzZUZsb2F0KGIpICsgMSA+PSAwO1xcbiAgICB9LCBpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KGEpIHtcXG4gICAgICB2YXIgYjtpZiAoXFxcIm9iamVjdFxcXCIgIT09IG4udHlwZShhKSB8fCBhLm5vZGVUeXBlIHx8IG4uaXNXaW5kb3coYSkpIHJldHVybiAhMTtpZiAoYS5jb25zdHJ1Y3RvciAmJiAhay5jYWxsKGEsIFxcXCJjb25zdHJ1Y3RvclxcXCIpICYmICFrLmNhbGwoYS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgfHwge30sIFxcXCJpc1Byb3RvdHlwZU9mXFxcIikpIHJldHVybiAhMTtmb3IgKGIgaW4gYSkge31yZXR1cm4gdm9pZCAwID09PSBiIHx8IGsuY2FsbChhLCBiKTtcXG4gICAgfSwgaXNFbXB0eU9iamVjdDogZnVuY3Rpb24gaXNFbXB0eU9iamVjdChhKSB7XFxuICAgICAgdmFyIGI7Zm9yIChiIGluIGEpIHtcXG4gICAgICAgIHJldHVybiAhMTtcXG4gICAgICB9cmV0dXJuICEwO1xcbiAgICB9LCB0eXBlOiBmdW5jdGlvbiB0eXBlKGEpIHtcXG4gICAgICByZXR1cm4gbnVsbCA9PSBhID8gYSArIFxcXCJcXFwiIDogXFxcIm9iamVjdFxcXCIgPT0gKHR5cGVvZiBhID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZihhKSkgfHwgXFxcImZ1bmN0aW9uXFxcIiA9PSB0eXBlb2YgYSA/IGlbai5jYWxsKGEpXSB8fCBcXFwib2JqZWN0XFxcIiA6IHR5cGVvZiBhID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZihhKTtcXG4gICAgfSwgZ2xvYmFsRXZhbDogZnVuY3Rpb24gZ2xvYmFsRXZhbChhKSB7XFxuICAgICAgdmFyIGIsXFxuICAgICAgICAgIGMgPSBldmFsO2EgPSBuLnRyaW0oYSksIGEgJiYgKDEgPT09IGEuaW5kZXhPZihcXFwidXNlIHN0cmljdFxcXCIpID8gKGIgPSBkLmNyZWF0ZUVsZW1lbnQoXFxcInNjcmlwdFxcXCIpLCBiLnRleHQgPSBhLCBkLmhlYWQuYXBwZW5kQ2hpbGQoYikucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiKSkgOiBjKGEpKTtcXG4gICAgfSwgY2FtZWxDYXNlOiBmdW5jdGlvbiBjYW1lbENhc2UoYSkge1xcbiAgICAgIHJldHVybiBhLnJlcGxhY2UocCwgXFxcIm1zLVxcXCIpLnJlcGxhY2UocSwgcik7XFxuICAgIH0sIG5vZGVOYW1lOiBmdW5jdGlvbiBub2RlTmFtZShhLCBiKSB7XFxuICAgICAgcmV0dXJuIGEubm9kZU5hbWUgJiYgYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBiLnRvTG93ZXJDYXNlKCk7XFxuICAgIH0sIGVhY2g6IGZ1bmN0aW9uIGVhY2goYSwgYikge1xcbiAgICAgIHZhciBjLFxcbiAgICAgICAgICBkID0gMDtpZiAocyhhKSkge1xcbiAgICAgICAgZm9yIChjID0gYS5sZW5ndGg7IGMgPiBkOyBkKyspIHtcXG4gICAgICAgICAgaWYgKGIuY2FsbChhW2RdLCBkLCBhW2RdKSA9PT0gITEpIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSBmb3IgKGQgaW4gYSkge1xcbiAgICAgICAgaWYgKGIuY2FsbChhW2RdLCBkLCBhW2RdKSA9PT0gITEpIGJyZWFrO1xcbiAgICAgIH1yZXR1cm4gYTtcXG4gICAgfSwgdHJpbTogZnVuY3Rpb24gdHJpbShhKSB7XFxuICAgICAgcmV0dXJuIG51bGwgPT0gYSA/IFxcXCJcXFwiIDogKGEgKyBcXFwiXFxcIikucmVwbGFjZShvLCBcXFwiXFxcIik7XFxuICAgIH0sIG1ha2VBcnJheTogZnVuY3Rpb24gbWFrZUFycmF5KGEsIGIpIHtcXG4gICAgICB2YXIgYyA9IGIgfHwgW107cmV0dXJuIG51bGwgIT0gYSAmJiAocyhPYmplY3QoYSkpID8gbi5tZXJnZShjLCBcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYSA/IFthXSA6IGEpIDogZy5jYWxsKGMsIGEpKSwgYztcXG4gICAgfSwgaW5BcnJheTogZnVuY3Rpb24gaW5BcnJheShhLCBiLCBjKSB7XFxuICAgICAgcmV0dXJuIG51bGwgPT0gYiA/IC0xIDogaC5jYWxsKGIsIGEsIGMpO1xcbiAgICB9LCBtZXJnZTogZnVuY3Rpb24gbWVyZ2UoYSwgYikge1xcbiAgICAgIGZvciAodmFyIGMgPSArYi5sZW5ndGgsIGQgPSAwLCBlID0gYS5sZW5ndGg7IGMgPiBkOyBkKyspIHtcXG4gICAgICAgIGFbZSsrXSA9IGJbZF07XFxuICAgICAgfXJldHVybiBhLmxlbmd0aCA9IGUsIGE7XFxuICAgIH0sIGdyZXA6IGZ1bmN0aW9uIGdyZXAoYSwgYiwgYykge1xcbiAgICAgIGZvciAodmFyIGQsIGUgPSBbXSwgZiA9IDAsIGcgPSBhLmxlbmd0aCwgaCA9ICFjOyBnID4gZjsgZisrKSB7XFxuICAgICAgICBkID0gIWIoYVtmXSwgZiksIGQgIT09IGggJiYgZS5wdXNoKGFbZl0pO1xcbiAgICAgIH1yZXR1cm4gZTtcXG4gICAgfSwgbWFwOiBmdW5jdGlvbiBtYXAoYSwgYiwgYykge1xcbiAgICAgIHZhciBkLFxcbiAgICAgICAgICBlLFxcbiAgICAgICAgICBnID0gMCxcXG4gICAgICAgICAgaCA9IFtdO2lmIChzKGEpKSBmb3IgKGQgPSBhLmxlbmd0aDsgZCA+IGc7IGcrKykge1xcbiAgICAgICAgZSA9IGIoYVtnXSwgZywgYyksIG51bGwgIT0gZSAmJiBoLnB1c2goZSk7XFxuICAgICAgfSBlbHNlIGZvciAoZyBpbiBhKSB7XFxuICAgICAgICBlID0gYihhW2ddLCBnLCBjKSwgbnVsbCAhPSBlICYmIGgucHVzaChlKTtcXG4gICAgICB9cmV0dXJuIGYuYXBwbHkoW10sIGgpO1xcbiAgICB9LCBndWlkOiAxLCBwcm94eTogZnVuY3Rpb24gcHJveHkoYSwgYikge1xcbiAgICAgIHZhciBjLCBkLCBmO3JldHVybiBcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYiAmJiAoYyA9IGFbYl0sIGIgPSBhLCBhID0gYyksIG4uaXNGdW5jdGlvbihhKSA/IChkID0gZS5jYWxsKGFyZ3VtZW50cywgMiksIGYgPSBmdW5jdGlvbiBmKCkge1xcbiAgICAgICAgcmV0dXJuIGEuYXBwbHkoYiB8fCB0aGlzLCBkLmNvbmNhdChlLmNhbGwoYXJndW1lbnRzKSkpO1xcbiAgICAgIH0sIGYuZ3VpZCA9IGEuZ3VpZCA9IGEuZ3VpZCB8fCBuLmd1aWQrKywgZikgOiB2b2lkIDA7XFxuICAgIH0sIG5vdzogRGF0ZS5ub3csIHN1cHBvcnQ6IGwgfSksIFxcXCJmdW5jdGlvblxcXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiAobi5mbltTeW1ib2wuaXRlcmF0b3JdID0gY1tTeW1ib2wuaXRlcmF0b3JdKSwgbi5lYWNoKFxcXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFxcXCIuc3BsaXQoXFxcIiBcXFwiKSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgaVtcXFwiW29iamVjdCBcXFwiICsgYiArIFxcXCJdXFxcIl0gPSBiLnRvTG93ZXJDYXNlKCk7XFxuICB9KTtmdW5jdGlvbiBzKGEpIHtcXG4gICAgdmFyIGIgPSAhIWEgJiYgXFxcImxlbmd0aFxcXCIgaW4gYSAmJiBhLmxlbmd0aCxcXG4gICAgICAgIGMgPSBuLnR5cGUoYSk7cmV0dXJuIFxcXCJmdW5jdGlvblxcXCIgPT09IGMgfHwgbi5pc1dpbmRvdyhhKSA/ICExIDogXFxcImFycmF5XFxcIiA9PT0gYyB8fCAwID09PSBiIHx8IFxcXCJudW1iZXJcXFwiID09IHR5cGVvZiBiICYmIGIgPiAwICYmIGIgLSAxIGluIGE7XFxuICB9dmFyIHQgPSBmdW5jdGlvbiAoYSkge1xcbiAgICB2YXIgYixcXG4gICAgICAgIGMsXFxuICAgICAgICBkLFxcbiAgICAgICAgZSxcXG4gICAgICAgIGYsXFxuICAgICAgICBnLFxcbiAgICAgICAgaCxcXG4gICAgICAgIGksXFxuICAgICAgICBqLFxcbiAgICAgICAgayxcXG4gICAgICAgIGwsXFxuICAgICAgICBtLFxcbiAgICAgICAgbixcXG4gICAgICAgIG8sXFxuICAgICAgICBwLFxcbiAgICAgICAgcSxcXG4gICAgICAgIHIsXFxuICAgICAgICBzLFxcbiAgICAgICAgdCxcXG4gICAgICAgIHUgPSBcXFwic2l6emxlXFxcIiArIDEgKiBuZXcgRGF0ZSgpLFxcbiAgICAgICAgdiA9IGEuZG9jdW1lbnQsXFxuICAgICAgICB3ID0gMCxcXG4gICAgICAgIHggPSAwLFxcbiAgICAgICAgeSA9IGdhKCksXFxuICAgICAgICB6ID0gZ2EoKSxcXG4gICAgICAgIEEgPSBnYSgpLFxcbiAgICAgICAgQiA9IGZ1bmN0aW9uIEIoYSwgYikge1xcbiAgICAgIHJldHVybiBhID09PSBiICYmIChsID0gITApLCAwO1xcbiAgICB9LFxcbiAgICAgICAgQyA9IDEgPDwgMzEsXFxuICAgICAgICBEID0ge30uaGFzT3duUHJvcGVydHksXFxuICAgICAgICBFID0gW10sXFxuICAgICAgICBGID0gRS5wb3AsXFxuICAgICAgICBHID0gRS5wdXNoLFxcbiAgICAgICAgSCA9IEUucHVzaCxcXG4gICAgICAgIEkgPSBFLnNsaWNlLFxcbiAgICAgICAgSiA9IGZ1bmN0aW9uIEooYSwgYikge1xcbiAgICAgIGZvciAodmFyIGMgPSAwLCBkID0gYS5sZW5ndGg7IGQgPiBjOyBjKyspIHtcXG4gICAgICAgIGlmIChhW2NdID09PSBiKSByZXR1cm4gYztcXG4gICAgICB9cmV0dXJuIC0xO1xcbiAgICB9LFxcbiAgICAgICAgSyA9IFxcXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFxcXCIsXFxuICAgICAgICBMID0gXFxcIltcXFxcXFxcXHgyMFxcXFxcXFxcdFxcXFxcXFxcclxcXFxcXFxcblxcXFxcXFxcZl1cXFwiLFxcbiAgICAgICAgTSA9IFxcXCIoPzpcXFxcXFxcXFxcXFxcXFxcLnxbXFxcXFxcXFx3LV18W15cXFxcXFxcXHgwMC1cXFxcXFxcXHhhMF0pK1xcXCIsXFxuICAgICAgICBOID0gXFxcIlxcXFxcXFxcW1xcXCIgKyBMICsgXFxcIiooXFxcIiArIE0gKyBcXFwiKSg/OlxcXCIgKyBMICsgXFxcIiooWypeJHwhfl0/PSlcXFwiICsgTCArIFxcXCIqKD86JygoPzpcXFxcXFxcXFxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcXFxcXFwnXSkqKSd8XFxcXFxcXCIoKD86XFxcXFxcXFxcXFxcXFxcXC58W15cXFxcXFxcXFxcXFxcXFxcXFxcXFxcXCJdKSopXFxcXFxcXCJ8KFxcXCIgKyBNICsgXFxcIikpfClcXFwiICsgTCArIFxcXCIqXFxcXFxcXFxdXFxcIixcXG4gICAgICAgIE8gPSBcXFwiOihcXFwiICsgTSArIFxcXCIpKD86XFxcXFxcXFwoKCgnKCg/OlxcXFxcXFxcXFxcXFxcXFwufFteXFxcXFxcXFxcXFxcXFxcXCddKSopJ3xcXFxcXFxcIigoPzpcXFxcXFxcXFxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcIl0pKilcXFxcXFxcIil8KCg/OlxcXFxcXFxcXFxcXFxcXFwufFteXFxcXFxcXFxcXFxcXFxcXCgpW1xcXFxcXFxcXV18XFxcIiArIE4gKyBcXFwiKSopfC4qKVxcXFxcXFxcKXwpXFxcIixcXG4gICAgICAgIFAgPSBuZXcgUmVnRXhwKEwgKyBcXFwiK1xcXCIsIFxcXCJnXFxcIiksXFxuICAgICAgICBRID0gbmV3IFJlZ0V4cChcXFwiXlxcXCIgKyBMICsgXFxcIit8KCg/Ol58W15cXFxcXFxcXFxcXFxcXFxcXSkoPzpcXFxcXFxcXFxcXFxcXFxcLikqKVxcXCIgKyBMICsgXFxcIiskXFxcIiwgXFxcImdcXFwiKSxcXG4gICAgICAgIFIgPSBuZXcgUmVnRXhwKFxcXCJeXFxcIiArIEwgKyBcXFwiKixcXFwiICsgTCArIFxcXCIqXFxcIiksXFxuICAgICAgICBTID0gbmV3IFJlZ0V4cChcXFwiXlxcXCIgKyBMICsgXFxcIiooWz4rfl18XFxcIiArIEwgKyBcXFwiKVxcXCIgKyBMICsgXFxcIipcXFwiKSxcXG4gICAgICAgIFQgPSBuZXcgUmVnRXhwKFxcXCI9XFxcIiArIEwgKyBcXFwiKihbXlxcXFxcXFxcXSdcXFxcXFxcIl0qPylcXFwiICsgTCArIFxcXCIqXFxcXFxcXFxdXFxcIiwgXFxcImdcXFwiKSxcXG4gICAgICAgIFUgPSBuZXcgUmVnRXhwKE8pLFxcbiAgICAgICAgViA9IG5ldyBSZWdFeHAoXFxcIl5cXFwiICsgTSArIFxcXCIkXFxcIiksXFxuICAgICAgICBXID0geyBJRDogbmV3IFJlZ0V4cChcXFwiXiMoXFxcIiArIE0gKyBcXFwiKVxcXCIpLCBDTEFTUzogbmV3IFJlZ0V4cChcXFwiXlxcXFxcXFxcLihcXFwiICsgTSArIFxcXCIpXFxcIiksIFRBRzogbmV3IFJlZ0V4cChcXFwiXihcXFwiICsgTSArIFxcXCJ8WypdKVxcXCIpLCBBVFRSOiBuZXcgUmVnRXhwKFxcXCJeXFxcIiArIE4pLCBQU0VVRE86IG5ldyBSZWdFeHAoXFxcIl5cXFwiICsgTyksIENISUxEOiBuZXcgUmVnRXhwKFxcXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcXFxcXChcXFwiICsgTCArIFxcXCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxcXFxcZCopbnwpXFxcIiArIEwgKyBcXFwiKig/OihbKy1dfClcXFwiICsgTCArIFxcXCIqKFxcXFxcXFxcZCspfCkpXFxcIiArIEwgKyBcXFwiKlxcXFxcXFxcKXwpXFxcIiwgXFxcImlcXFwiKSwgYm9vbDogbmV3IFJlZ0V4cChcXFwiXig/OlxcXCIgKyBLICsgXFxcIikkXFxcIiwgXFxcImlcXFwiKSwgbmVlZHNDb250ZXh0OiBuZXcgUmVnRXhwKFxcXCJeXFxcIiArIEwgKyBcXFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXFxcXFwoXFxcIiArIEwgKyBcXFwiKigoPzotXFxcXFxcXFxkKT9cXFxcXFxcXGQqKVxcXCIgKyBMICsgXFxcIipcXFxcXFxcXCl8KSg/PVteLV18JClcXFwiLCBcXFwiaVxcXCIpIH0sXFxuICAgICAgICBYID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcXG4gICAgICAgIFkgPSAvXmhcXFxcZCQvaSxcXG4gICAgICAgIFogPSAvXltee10rXFxcXHtcXFxccypcXFxcW25hdGl2ZSBcXFxcdy8sXFxuICAgICAgICAkID0gL14oPzojKFtcXFxcdy1dKyl8KFxcXFx3Kyl8XFxcXC4oW1xcXFx3LV0rKSkkLyxcXG4gICAgICAgIF8gPSAvWyt+XS8sXFxuICAgICAgICBhYSA9IC8nfFxcXFxcXFxcL2csXFxuICAgICAgICBiYSA9IG5ldyBSZWdFeHAoXFxcIlxcXFxcXFxcXFxcXFxcXFwoW1xcXFxcXFxcZGEtZl17MSw2fVxcXCIgKyBMICsgXFxcIj98KFxcXCIgKyBMICsgXFxcIil8LilcXFwiLCBcXFwiaWdcXFwiKSxcXG4gICAgICAgIGNhID0gZnVuY3Rpb24gY2EoYSwgYiwgYykge1xcbiAgICAgIHZhciBkID0gXFxcIjB4XFxcIiArIGIgLSA2NTUzNjtyZXR1cm4gZCAhPT0gZCB8fCBjID8gYiA6IDAgPiBkID8gU3RyaW5nLmZyb21DaGFyQ29kZShkICsgNjU1MzYpIDogU3RyaW5nLmZyb21DaGFyQ29kZShkID4+IDEwIHwgNTUyOTYsIDEwMjMgJiBkIHwgNTYzMjApO1xcbiAgICB9LFxcbiAgICAgICAgZGEgPSBmdW5jdGlvbiBkYSgpIHtcXG4gICAgICBtKCk7XFxuICAgIH07dHJ5IHtcXG4gICAgICBILmFwcGx5KEUgPSBJLmNhbGwodi5jaGlsZE5vZGVzKSwgdi5jaGlsZE5vZGVzKSwgRVt2LmNoaWxkTm9kZXMubGVuZ3RoXS5ub2RlVHlwZTtcXG4gICAgfSBjYXRjaCAoZWEpIHtcXG4gICAgICBIID0geyBhcHBseTogRS5sZW5ndGggPyBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgICAgICBHLmFwcGx5KGEsIEkuY2FsbChiKSk7XFxuICAgICAgICB9IDogZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgICAgdmFyIGMgPSBhLmxlbmd0aCxcXG4gICAgICAgICAgICAgIGQgPSAwO3doaWxlIChhW2MrK10gPSBiW2QrK10pIHt9YS5sZW5ndGggPSBjIC0gMTtcXG4gICAgICAgIH0gfTtcXG4gICAgfWZ1bmN0aW9uIGZhKGEsIGIsIGQsIGUpIHtcXG4gICAgICB2YXIgZixcXG4gICAgICAgICAgaCxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgayxcXG4gICAgICAgICAgbCxcXG4gICAgICAgICAgbyxcXG4gICAgICAgICAgcixcXG4gICAgICAgICAgcyxcXG4gICAgICAgICAgdyA9IGIgJiYgYi5vd25lckRvY3VtZW50LFxcbiAgICAgICAgICB4ID0gYiA/IGIubm9kZVR5cGUgOiA5O2lmIChkID0gZCB8fCBbXSwgXFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGEgfHwgIWEgfHwgMSAhPT0geCAmJiA5ICE9PSB4ICYmIDExICE9PSB4KSByZXR1cm4gZDtpZiAoIWUgJiYgKChiID8gYi5vd25lckRvY3VtZW50IHx8IGIgOiB2KSAhPT0gbiAmJiBtKGIpLCBiID0gYiB8fCBuLCBwKSkge1xcbiAgICAgICAgaWYgKDExICE9PSB4ICYmIChvID0gJC5leGVjKGEpKSkgaWYgKGYgPSBvWzFdKSB7XFxuICAgICAgICAgIGlmICg5ID09PSB4KSB7XFxuICAgICAgICAgICAgaWYgKCEoaiA9IGIuZ2V0RWxlbWVudEJ5SWQoZikpKSByZXR1cm4gZDtpZiAoai5pZCA9PT0gZikgcmV0dXJuIGQucHVzaChqKSwgZDtcXG4gICAgICAgICAgfSBlbHNlIGlmICh3ICYmIChqID0gdy5nZXRFbGVtZW50QnlJZChmKSkgJiYgdChiLCBqKSAmJiBqLmlkID09PSBmKSByZXR1cm4gZC5wdXNoKGopLCBkO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgaWYgKG9bMl0pIHJldHVybiBILmFwcGx5KGQsIGIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoYSkpLCBkO2lmICgoZiA9IG9bM10pICYmIGMuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBiLmdldEVsZW1lbnRzQnlDbGFzc05hbWUpIHJldHVybiBILmFwcGx5KGQsIGIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShmKSksIGQ7XFxuICAgICAgICB9aWYgKGMucXNhICYmICFBW2EgKyBcXFwiIFxcXCJdICYmICghcSB8fCAhcS50ZXN0KGEpKSkge1xcbiAgICAgICAgICBpZiAoMSAhPT0geCkgdyA9IGIsIHMgPSBhO2Vsc2UgaWYgKFxcXCJvYmplY3RcXFwiICE9PSBiLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcXG4gICAgICAgICAgICAoayA9IGIuZ2V0QXR0cmlidXRlKFxcXCJpZFxcXCIpKSA/IGsgPSBrLnJlcGxhY2UoYWEsIFxcXCJcXFxcXFxcXCQmXFxcIikgOiBiLnNldEF0dHJpYnV0ZShcXFwiaWRcXFwiLCBrID0gdSksIHIgPSBnKGEpLCBoID0gci5sZW5ndGgsIGwgPSBWLnRlc3QoaykgPyBcXFwiI1xcXCIgKyBrIDogXFxcIltpZD0nXFxcIiArIGsgKyBcXFwiJ11cXFwiO3doaWxlIChoLS0pIHtcXG4gICAgICAgICAgICAgIHJbaF0gPSBsICsgXFxcIiBcXFwiICsgcWEocltoXSk7XFxuICAgICAgICAgICAgfXMgPSByLmpvaW4oXFxcIixcXFwiKSwgdyA9IF8udGVzdChhKSAmJiBvYShiLnBhcmVudE5vZGUpIHx8IGI7XFxuICAgICAgICAgIH1pZiAocykgdHJ5IHtcXG4gICAgICAgICAgICByZXR1cm4gSC5hcHBseShkLCB3LnF1ZXJ5U2VsZWN0b3JBbGwocykpLCBkO1xcbiAgICAgICAgICB9IGNhdGNoICh5KSB7fSBmaW5hbGx5IHtcXG4gICAgICAgICAgICBrID09PSB1ICYmIGIucmVtb3ZlQXR0cmlidXRlKFxcXCJpZFxcXCIpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfXJldHVybiBpKGEucmVwbGFjZShRLCBcXFwiJDFcXFwiKSwgYiwgZCwgZSk7XFxuICAgIH1mdW5jdGlvbiBnYSgpIHtcXG4gICAgICB2YXIgYSA9IFtdO2Z1bmN0aW9uIGIoYywgZSkge1xcbiAgICAgICAgcmV0dXJuIGEucHVzaChjICsgXFxcIiBcXFwiKSA+IGQuY2FjaGVMZW5ndGggJiYgZGVsZXRlIGJbYS5zaGlmdCgpXSwgYltjICsgXFxcIiBcXFwiXSA9IGU7XFxuICAgICAgfXJldHVybiBiO1xcbiAgICB9ZnVuY3Rpb24gaGEoYSkge1xcbiAgICAgIHJldHVybiBhW3VdID0gITAsIGE7XFxuICAgIH1mdW5jdGlvbiBpYShhKSB7XFxuICAgICAgdmFyIGIgPSBuLmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpO3RyeSB7XFxuICAgICAgICByZXR1cm4gISFhKGIpO1xcbiAgICAgIH0gY2F0Y2ggKGMpIHtcXG4gICAgICAgIHJldHVybiAhMTtcXG4gICAgICB9IGZpbmFsbHkge1xcbiAgICAgICAgYi5wYXJlbnROb2RlICYmIGIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiKSwgYiA9IG51bGw7XFxuICAgICAgfVxcbiAgICB9ZnVuY3Rpb24gamEoYSwgYikge1xcbiAgICAgIHZhciBjID0gYS5zcGxpdChcXFwifFxcXCIpLFxcbiAgICAgICAgICBlID0gYy5sZW5ndGg7d2hpbGUgKGUtLSkge1xcbiAgICAgICAgZC5hdHRySGFuZGxlW2NbZV1dID0gYjtcXG4gICAgICB9XFxuICAgIH1mdW5jdGlvbiBrYShhLCBiKSB7XFxuICAgICAgdmFyIGMgPSBiICYmIGEsXFxuICAgICAgICAgIGQgPSBjICYmIDEgPT09IGEubm9kZVR5cGUgJiYgMSA9PT0gYi5ub2RlVHlwZSAmJiAofmIuc291cmNlSW5kZXggfHwgQykgLSAofmEuc291cmNlSW5kZXggfHwgQyk7aWYgKGQpIHJldHVybiBkO2lmIChjKSB3aGlsZSAoYyA9IGMubmV4dFNpYmxpbmcpIHtcXG4gICAgICAgIGlmIChjID09PSBiKSByZXR1cm4gLTE7XFxuICAgICAgfXJldHVybiBhID8gMSA6IC0xO1xcbiAgICB9ZnVuY3Rpb24gbGEoYSkge1xcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYikge1xcbiAgICAgICAgdmFyIGMgPSBiLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuIFxcXCJpbnB1dFxcXCIgPT09IGMgJiYgYi50eXBlID09PSBhO1xcbiAgICAgIH07XFxuICAgIH1mdW5jdGlvbiBtYShhKSB7XFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiKSB7XFxuICAgICAgICB2YXIgYyA9IGIubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4gKFxcXCJpbnB1dFxcXCIgPT09IGMgfHwgXFxcImJ1dHRvblxcXCIgPT09IGMpICYmIGIudHlwZSA9PT0gYTtcXG4gICAgICB9O1xcbiAgICB9ZnVuY3Rpb24gbmEoYSkge1xcbiAgICAgIHJldHVybiBoYShmdW5jdGlvbiAoYikge1xcbiAgICAgICAgcmV0dXJuIGIgPSArYiwgaGEoZnVuY3Rpb24gKGMsIGQpIHtcXG4gICAgICAgICAgdmFyIGUsXFxuICAgICAgICAgICAgICBmID0gYShbXSwgYy5sZW5ndGgsIGIpLFxcbiAgICAgICAgICAgICAgZyA9IGYubGVuZ3RoO3doaWxlIChnLS0pIHtcXG4gICAgICAgICAgICBjW2UgPSBmW2ddXSAmJiAoY1tlXSA9ICEoZFtlXSA9IGNbZV0pKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgfSk7XFxuICAgIH1mdW5jdGlvbiBvYShhKSB7XFxuICAgICAgcmV0dXJuIGEgJiYgXFxcInVuZGVmaW5lZFxcXCIgIT0gdHlwZW9mIGEuZ2V0RWxlbWVudHNCeVRhZ05hbWUgJiYgYTtcXG4gICAgfWMgPSBmYS5zdXBwb3J0ID0ge30sIGYgPSBmYS5pc1hNTCA9IGZ1bmN0aW9uIChhKSB7XFxuICAgICAgdmFyIGIgPSBhICYmIChhLm93bmVyRG9jdW1lbnQgfHwgYSkuZG9jdW1lbnRFbGVtZW50O3JldHVybiBiID8gXFxcIkhUTUxcXFwiICE9PSBiLm5vZGVOYW1lIDogITE7XFxuICAgIH0sIG0gPSBmYS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uIChhKSB7XFxuICAgICAgdmFyIGIsXFxuICAgICAgICAgIGUsXFxuICAgICAgICAgIGcgPSBhID8gYS5vd25lckRvY3VtZW50IHx8IGEgOiB2O3JldHVybiBnICE9PSBuICYmIDkgPT09IGcubm9kZVR5cGUgJiYgZy5kb2N1bWVudEVsZW1lbnQgPyAobiA9IGcsIG8gPSBuLmRvY3VtZW50RWxlbWVudCwgcCA9ICFmKG4pLCAoZSA9IG4uZGVmYXVsdFZpZXcpICYmIGUudG9wICE9PSBlICYmIChlLmFkZEV2ZW50TGlzdGVuZXIgPyBlLmFkZEV2ZW50TGlzdGVuZXIoXFxcInVubG9hZFxcXCIsIGRhLCAhMSkgOiBlLmF0dGFjaEV2ZW50ICYmIGUuYXR0YWNoRXZlbnQoXFxcIm9udW5sb2FkXFxcIiwgZGEpKSwgYy5hdHRyaWJ1dGVzID0gaWEoZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIHJldHVybiBhLmNsYXNzTmFtZSA9IFxcXCJpXFxcIiwgIWEuZ2V0QXR0cmlidXRlKFxcXCJjbGFzc05hbWVcXFwiKTtcXG4gICAgICB9KSwgYy5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGlhKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICByZXR1cm4gYS5hcHBlbmRDaGlsZChuLmNyZWF0ZUNvbW1lbnQoXFxcIlxcXCIpKSwgIWEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXFxcIipcXFwiKS5sZW5ndGg7XFxuICAgICAgfSksIGMuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IFoudGVzdChuLmdldEVsZW1lbnRzQnlDbGFzc05hbWUpLCBjLmdldEJ5SWQgPSBpYShmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgcmV0dXJuIG8uYXBwZW5kQ2hpbGQoYSkuaWQgPSB1LCAhbi5nZXRFbGVtZW50c0J5TmFtZSB8fCAhbi5nZXRFbGVtZW50c0J5TmFtZSh1KS5sZW5ndGg7XFxuICAgICAgfSksIGMuZ2V0QnlJZCA/IChkLmZpbmQuSUQgPSBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgICAgaWYgKFxcXCJ1bmRlZmluZWRcXFwiICE9IHR5cGVvZiBiLmdldEVsZW1lbnRCeUlkICYmIHApIHtcXG4gICAgICAgICAgdmFyIGMgPSBiLmdldEVsZW1lbnRCeUlkKGEpO3JldHVybiBjID8gW2NdIDogW107XFxuICAgICAgICB9XFxuICAgICAgfSwgZC5maWx0ZXIuSUQgPSBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgdmFyIGIgPSBhLnJlcGxhY2UoYmEsIGNhKTtyZXR1cm4gZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgICAgcmV0dXJuIGEuZ2V0QXR0cmlidXRlKFxcXCJpZFxcXCIpID09PSBiO1xcbiAgICAgICAgfTtcXG4gICAgICB9KSA6IChkZWxldGUgZC5maW5kLklELCBkLmZpbHRlci5JRCA9IGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICB2YXIgYiA9IGEucmVwbGFjZShiYSwgY2EpO3JldHVybiBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgICB2YXIgYyA9IFxcXCJ1bmRlZmluZWRcXFwiICE9IHR5cGVvZiBhLmdldEF0dHJpYnV0ZU5vZGUgJiYgYS5nZXRBdHRyaWJ1dGVOb2RlKFxcXCJpZFxcXCIpO3JldHVybiBjICYmIGMudmFsdWUgPT09IGI7XFxuICAgICAgICB9O1xcbiAgICAgIH0pLCBkLmZpbmQuVEFHID0gYy5nZXRFbGVtZW50c0J5VGFnTmFtZSA/IGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICByZXR1cm4gXFxcInVuZGVmaW5lZFxcXCIgIT0gdHlwZW9mIGIuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPyBiLmdldEVsZW1lbnRzQnlUYWdOYW1lKGEpIDogYy5xc2EgPyBiLnF1ZXJ5U2VsZWN0b3JBbGwoYSkgOiB2b2lkIDA7XFxuICAgICAgfSA6IGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICB2YXIgYyxcXG4gICAgICAgICAgICBkID0gW10sXFxuICAgICAgICAgICAgZSA9IDAsXFxuICAgICAgICAgICAgZiA9IGIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoYSk7aWYgKFxcXCIqXFxcIiA9PT0gYSkge1xcbiAgICAgICAgICB3aGlsZSAoYyA9IGZbZSsrXSkge1xcbiAgICAgICAgICAgIDEgPT09IGMubm9kZVR5cGUgJiYgZC5wdXNoKGMpO1xcbiAgICAgICAgICB9cmV0dXJuIGQ7XFxuICAgICAgICB9cmV0dXJuIGY7XFxuICAgICAgfSwgZC5maW5kLkNMQVNTID0gYy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICByZXR1cm4gXFxcInVuZGVmaW5lZFxcXCIgIT0gdHlwZW9mIGIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBwID8gYi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGEpIDogdm9pZCAwO1xcbiAgICAgIH0sIHIgPSBbXSwgcSA9IFtdLCAoYy5xc2EgPSBaLnRlc3Qobi5xdWVyeVNlbGVjdG9yQWxsKSkgJiYgKGlhKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICBvLmFwcGVuZENoaWxkKGEpLmlubmVySFRNTCA9IFxcXCI8YSBpZD0nXFxcIiArIHUgKyBcXFwiJz48L2E+PHNlbGVjdCBpZD0nXFxcIiArIHUgKyBcXFwiLVxcXFxyXFxcXFxcXFwnIG1zYWxsb3djYXB0dXJlPScnPjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XFxcIiwgYS5xdWVyeVNlbGVjdG9yQWxsKFxcXCJbbXNhbGxvd2NhcHR1cmVePScnXVxcXCIpLmxlbmd0aCAmJiBxLnB1c2goXFxcIlsqXiRdPVxcXCIgKyBMICsgXFxcIiooPzonJ3xcXFxcXFxcIlxcXFxcXFwiKVxcXCIpLCBhLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIltzZWxlY3RlZF1cXFwiKS5sZW5ndGggfHwgcS5wdXNoKFxcXCJcXFxcXFxcXFtcXFwiICsgTCArIFxcXCIqKD86dmFsdWV8XFxcIiArIEsgKyBcXFwiKVxcXCIpLCBhLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIltpZH49XFxcIiArIHUgKyBcXFwiLV1cXFwiKS5sZW5ndGggfHwgcS5wdXNoKFxcXCJ+PVxcXCIpLCBhLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIjpjaGVja2VkXFxcIikubGVuZ3RoIHx8IHEucHVzaChcXFwiOmNoZWNrZWRcXFwiKSwgYS5xdWVyeVNlbGVjdG9yQWxsKFxcXCJhI1xcXCIgKyB1ICsgXFxcIisqXFxcIikubGVuZ3RoIHx8IHEucHVzaChcXFwiLiMuK1srfl1cXFwiKTtcXG4gICAgICB9KSwgaWEoZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIHZhciBiID0gbi5jcmVhdGVFbGVtZW50KFxcXCJpbnB1dFxcXCIpO2Iuc2V0QXR0cmlidXRlKFxcXCJ0eXBlXFxcIiwgXFxcImhpZGRlblxcXCIpLCBhLmFwcGVuZENoaWxkKGIpLnNldEF0dHJpYnV0ZShcXFwibmFtZVxcXCIsIFxcXCJEXFxcIiksIGEucXVlcnlTZWxlY3RvckFsbChcXFwiW25hbWU9ZF1cXFwiKS5sZW5ndGggJiYgcS5wdXNoKFxcXCJuYW1lXFxcIiArIEwgKyBcXFwiKlsqXiR8IX5dPz1cXFwiKSwgYS5xdWVyeVNlbGVjdG9yQWxsKFxcXCI6ZW5hYmxlZFxcXCIpLmxlbmd0aCB8fCBxLnB1c2goXFxcIjplbmFibGVkXFxcIiwgXFxcIjpkaXNhYmxlZFxcXCIpLCBhLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIiosOnhcXFwiKSwgcS5wdXNoKFxcXCIsLio6XFxcIik7XFxuICAgICAgfSkpLCAoYy5tYXRjaGVzU2VsZWN0b3IgPSBaLnRlc3QocyA9IG8ubWF0Y2hlcyB8fCBvLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBvLm1vek1hdGNoZXNTZWxlY3RvciB8fCBvLm9NYXRjaGVzU2VsZWN0b3IgfHwgby5tc01hdGNoZXNTZWxlY3RvcikpICYmIGlhKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICBjLmRpc2Nvbm5lY3RlZE1hdGNoID0gcy5jYWxsKGEsIFxcXCJkaXZcXFwiKSwgcy5jYWxsKGEsIFxcXCJbcyE9JyddOnhcXFwiKSwgci5wdXNoKFxcXCIhPVxcXCIsIE8pO1xcbiAgICAgIH0pLCBxID0gcS5sZW5ndGggJiYgbmV3IFJlZ0V4cChxLmpvaW4oXFxcInxcXFwiKSksIHIgPSByLmxlbmd0aCAmJiBuZXcgUmVnRXhwKHIuam9pbihcXFwifFxcXCIpKSwgYiA9IFoudGVzdChvLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKSwgdCA9IGIgfHwgWi50ZXN0KG8uY29udGFpbnMpID8gZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgIHZhciBjID0gOSA9PT0gYS5ub2RlVHlwZSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcXG4gICAgICAgICAgICBkID0gYiAmJiBiLnBhcmVudE5vZGU7cmV0dXJuIGEgPT09IGQgfHwgISghZCB8fCAxICE9PSBkLm5vZGVUeXBlIHx8ICEoYy5jb250YWlucyA/IGMuY29udGFpbnMoZCkgOiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIDE2ICYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihkKSkpO1xcbiAgICAgIH0gOiBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgICAgaWYgKGIpIHdoaWxlIChiID0gYi5wYXJlbnROb2RlKSB7XFxuICAgICAgICAgIGlmIChiID09PSBhKSByZXR1cm4gITA7XFxuICAgICAgICB9cmV0dXJuICExO1xcbiAgICAgIH0sIEIgPSBiID8gZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgIGlmIChhID09PSBiKSByZXR1cm4gbCA9ICEwLCAwO3ZhciBkID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtyZXR1cm4gZCA/IGQgOiAoZCA9IChhLm93bmVyRG9jdW1lbnQgfHwgYSkgPT09IChiLm93bmVyRG9jdW1lbnQgfHwgYikgPyBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIpIDogMSwgMSAmIGQgfHwgIWMuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYSkgPT09IGQgPyBhID09PSBuIHx8IGEub3duZXJEb2N1bWVudCA9PT0gdiAmJiB0KHYsIGEpID8gLTEgOiBiID09PSBuIHx8IGIub3duZXJEb2N1bWVudCA9PT0gdiAmJiB0KHYsIGIpID8gMSA6IGsgPyBKKGssIGEpIC0gSihrLCBiKSA6IDAgOiA0ICYgZCA/IC0xIDogMSk7XFxuICAgICAgfSA6IGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICBpZiAoYSA9PT0gYikgcmV0dXJuIGwgPSAhMCwgMDt2YXIgYyxcXG4gICAgICAgICAgICBkID0gMCxcXG4gICAgICAgICAgICBlID0gYS5wYXJlbnROb2RlLFxcbiAgICAgICAgICAgIGYgPSBiLnBhcmVudE5vZGUsXFxuICAgICAgICAgICAgZyA9IFthXSxcXG4gICAgICAgICAgICBoID0gW2JdO2lmICghZSB8fCAhZikgcmV0dXJuIGEgPT09IG4gPyAtMSA6IGIgPT09IG4gPyAxIDogZSA/IC0xIDogZiA/IDEgOiBrID8gSihrLCBhKSAtIEooaywgYikgOiAwO2lmIChlID09PSBmKSByZXR1cm4ga2EoYSwgYik7YyA9IGE7d2hpbGUgKGMgPSBjLnBhcmVudE5vZGUpIHtcXG4gICAgICAgICAgZy51bnNoaWZ0KGMpO1xcbiAgICAgICAgfWMgPSBiO3doaWxlIChjID0gYy5wYXJlbnROb2RlKSB7XFxuICAgICAgICAgIGgudW5zaGlmdChjKTtcXG4gICAgICAgIH13aGlsZSAoZ1tkXSA9PT0gaFtkXSkge1xcbiAgICAgICAgICBkKys7XFxuICAgICAgICB9cmV0dXJuIGQgPyBrYShnW2RdLCBoW2RdKSA6IGdbZF0gPT09IHYgPyAtMSA6IGhbZF0gPT09IHYgPyAxIDogMDtcXG4gICAgICB9LCBuKSA6IG47XFxuICAgIH0sIGZhLm1hdGNoZXMgPSBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgIHJldHVybiBmYShhLCBudWxsLCBudWxsLCBiKTtcXG4gICAgfSwgZmEubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICBpZiAoKGEub3duZXJEb2N1bWVudCB8fCBhKSAhPT0gbiAmJiBtKGEpLCBiID0gYi5yZXBsYWNlKFQsIFxcXCI9JyQxJ11cXFwiKSwgYy5tYXRjaGVzU2VsZWN0b3IgJiYgcCAmJiAhQVtiICsgXFxcIiBcXFwiXSAmJiAoIXIgfHwgIXIudGVzdChiKSkgJiYgKCFxIHx8ICFxLnRlc3QoYikpKSB0cnkge1xcbiAgICAgICAgdmFyIGQgPSBzLmNhbGwoYSwgYik7aWYgKGQgfHwgYy5kaXNjb25uZWN0ZWRNYXRjaCB8fCBhLmRvY3VtZW50ICYmIDExICE9PSBhLmRvY3VtZW50Lm5vZGVUeXBlKSByZXR1cm4gZDtcXG4gICAgICB9IGNhdGNoIChlKSB7fXJldHVybiBmYShiLCBuLCBudWxsLCBbYV0pLmxlbmd0aCA+IDA7XFxuICAgIH0sIGZhLmNvbnRhaW5zID0gZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICByZXR1cm4gKGEub3duZXJEb2N1bWVudCB8fCBhKSAhPT0gbiAmJiBtKGEpLCB0KGEsIGIpO1xcbiAgICB9LCBmYS5hdHRyID0gZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAoYS5vd25lckRvY3VtZW50IHx8IGEpICE9PSBuICYmIG0oYSk7dmFyIGUgPSBkLmF0dHJIYW5kbGVbYi50b0xvd2VyQ2FzZSgpXSxcXG4gICAgICAgICAgZiA9IGUgJiYgRC5jYWxsKGQuYXR0ckhhbmRsZSwgYi50b0xvd2VyQ2FzZSgpKSA/IGUoYSwgYiwgIXApIDogdm9pZCAwO3JldHVybiB2b2lkIDAgIT09IGYgPyBmIDogYy5hdHRyaWJ1dGVzIHx8ICFwID8gYS5nZXRBdHRyaWJ1dGUoYikgOiAoZiA9IGEuZ2V0QXR0cmlidXRlTm9kZShiKSkgJiYgZi5zcGVjaWZpZWQgPyBmLnZhbHVlIDogbnVsbDtcXG4gICAgfSwgZmEuZXJyb3IgPSBmdW5jdGlvbiAoYSkge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXFxcIiArIGEpO1xcbiAgICB9LCBmYS51bmlxdWVTb3J0ID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgICB2YXIgYixcXG4gICAgICAgICAgZCA9IFtdLFxcbiAgICAgICAgICBlID0gMCxcXG4gICAgICAgICAgZiA9IDA7aWYgKGwgPSAhYy5kZXRlY3REdXBsaWNhdGVzLCBrID0gIWMuc29ydFN0YWJsZSAmJiBhLnNsaWNlKDApLCBhLnNvcnQoQiksIGwpIHtcXG4gICAgICAgIHdoaWxlIChiID0gYVtmKytdKSB7XFxuICAgICAgICAgIGIgPT09IGFbZl0gJiYgKGUgPSBkLnB1c2goZikpO1xcbiAgICAgICAgfXdoaWxlIChlLS0pIHtcXG4gICAgICAgICAgYS5zcGxpY2UoZFtlXSwgMSk7XFxuICAgICAgICB9XFxuICAgICAgfXJldHVybiBrID0gbnVsbCwgYTtcXG4gICAgfSwgZSA9IGZhLmdldFRleHQgPSBmdW5jdGlvbiAoYSkge1xcbiAgICAgIHZhciBiLFxcbiAgICAgICAgICBjID0gXFxcIlxcXCIsXFxuICAgICAgICAgIGQgPSAwLFxcbiAgICAgICAgICBmID0gYS5ub2RlVHlwZTtpZiAoZikge1xcbiAgICAgICAgaWYgKDEgPT09IGYgfHwgOSA9PT0gZiB8fCAxMSA9PT0gZikge1xcbiAgICAgICAgICBpZiAoXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIGEudGV4dENvbnRlbnQpIHJldHVybiBhLnRleHRDb250ZW50O2ZvciAoYSA9IGEuZmlyc3RDaGlsZDsgYTsgYSA9IGEubmV4dFNpYmxpbmcpIHtcXG4gICAgICAgICAgICBjICs9IGUoYSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSBpZiAoMyA9PT0gZiB8fCA0ID09PSBmKSByZXR1cm4gYS5ub2RlVmFsdWU7XFxuICAgICAgfSBlbHNlIHdoaWxlIChiID0gYVtkKytdKSB7XFxuICAgICAgICBjICs9IGUoYik7XFxuICAgICAgfXJldHVybiBjO1xcbiAgICB9LCBkID0gZmEuc2VsZWN0b3JzID0geyBjYWNoZUxlbmd0aDogNTAsIGNyZWF0ZVBzZXVkbzogaGEsIG1hdGNoOiBXLCBhdHRySGFuZGxlOiB7fSwgZmluZDoge30sIHJlbGF0aXZlOiB7IFxcXCI+XFxcIjogeyBkaXI6IFxcXCJwYXJlbnROb2RlXFxcIiwgZmlyc3Q6ICEwIH0sIFxcXCIgXFxcIjogeyBkaXI6IFxcXCJwYXJlbnROb2RlXFxcIiB9LCBcXFwiK1xcXCI6IHsgZGlyOiBcXFwicHJldmlvdXNTaWJsaW5nXFxcIiwgZmlyc3Q6ICEwIH0sIFxcXCJ+XFxcIjogeyBkaXI6IFxcXCJwcmV2aW91c1NpYmxpbmdcXFwiIH0gfSwgcHJlRmlsdGVyOiB7IEFUVFI6IGZ1bmN0aW9uIEFUVFIoYSkge1xcbiAgICAgICAgICByZXR1cm4gYVsxXSA9IGFbMV0ucmVwbGFjZShiYSwgY2EpLCBhWzNdID0gKGFbM10gfHwgYVs0XSB8fCBhWzVdIHx8IFxcXCJcXFwiKS5yZXBsYWNlKGJhLCBjYSksIFxcXCJ+PVxcXCIgPT09IGFbMl0gJiYgKGFbM10gPSBcXFwiIFxcXCIgKyBhWzNdICsgXFxcIiBcXFwiKSwgYS5zbGljZSgwLCA0KTtcXG4gICAgICAgIH0sIENISUxEOiBmdW5jdGlvbiBDSElMRChhKSB7XFxuICAgICAgICAgIHJldHVybiBhWzFdID0gYVsxXS50b0xvd2VyQ2FzZSgpLCBcXFwibnRoXFxcIiA9PT0gYVsxXS5zbGljZSgwLCAzKSA/IChhWzNdIHx8IGZhLmVycm9yKGFbMF0pLCBhWzRdID0gKyhhWzRdID8gYVs1XSArIChhWzZdIHx8IDEpIDogMiAqIChcXFwiZXZlblxcXCIgPT09IGFbM10gfHwgXFxcIm9kZFxcXCIgPT09IGFbM10pKSwgYVs1XSA9ICsoYVs3XSArIGFbOF0gfHwgXFxcIm9kZFxcXCIgPT09IGFbM10pKSA6IGFbM10gJiYgZmEuZXJyb3IoYVswXSksIGE7XFxuICAgICAgICB9LCBQU0VVRE86IGZ1bmN0aW9uIFBTRVVETyhhKSB7XFxuICAgICAgICAgIHZhciBiLFxcbiAgICAgICAgICAgICAgYyA9ICFhWzZdICYmIGFbMl07cmV0dXJuIFcuQ0hJTEQudGVzdChhWzBdKSA/IG51bGwgOiAoYVszXSA/IGFbMl0gPSBhWzRdIHx8IGFbNV0gfHwgXFxcIlxcXCIgOiBjICYmIFUudGVzdChjKSAmJiAoYiA9IGcoYywgITApKSAmJiAoYiA9IGMuaW5kZXhPZihcXFwiKVxcXCIsIGMubGVuZ3RoIC0gYikgLSBjLmxlbmd0aCkgJiYgKGFbMF0gPSBhWzBdLnNsaWNlKDAsIGIpLCBhWzJdID0gYy5zbGljZSgwLCBiKSksIGEuc2xpY2UoMCwgMykpO1xcbiAgICAgICAgfSB9LCBmaWx0ZXI6IHsgVEFHOiBmdW5jdGlvbiBUQUcoYSkge1xcbiAgICAgICAgICB2YXIgYiA9IGEucmVwbGFjZShiYSwgY2EpLnRvTG93ZXJDYXNlKCk7cmV0dXJuIFxcXCIqXFxcIiA9PT0gYSA/IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICByZXR1cm4gITA7XFxuICAgICAgICAgIH0gOiBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgICAgIHJldHVybiBhLm5vZGVOYW1lICYmIGEubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gYjtcXG4gICAgICAgICAgfTtcXG4gICAgICAgIH0sIENMQVNTOiBmdW5jdGlvbiBDTEFTUyhhKSB7XFxuICAgICAgICAgIHZhciBiID0geVthICsgXFxcIiBcXFwiXTtyZXR1cm4gYiB8fCAoYiA9IG5ldyBSZWdFeHAoXFxcIihefFxcXCIgKyBMICsgXFxcIilcXFwiICsgYSArIFxcXCIoXFxcIiArIEwgKyBcXFwifCQpXFxcIikpICYmIHkoYSwgZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgICAgICByZXR1cm4gYi50ZXN0KFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBhLmNsYXNzTmFtZSAmJiBhLmNsYXNzTmFtZSB8fCBcXFwidW5kZWZpbmVkXFxcIiAhPSB0eXBlb2YgYS5nZXRBdHRyaWJ1dGUgJiYgYS5nZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIikgfHwgXFxcIlxcXCIpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH0sIEFUVFI6IGZ1bmN0aW9uIEFUVFIoYSwgYiwgYykge1xcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcXG4gICAgICAgICAgICB2YXIgZSA9IGZhLmF0dHIoZCwgYSk7cmV0dXJuIG51bGwgPT0gZSA/IFxcXCIhPVxcXCIgPT09IGIgOiBiID8gKGUgKz0gXFxcIlxcXCIsIFxcXCI9XFxcIiA9PT0gYiA/IGUgPT09IGMgOiBcXFwiIT1cXFwiID09PSBiID8gZSAhPT0gYyA6IFxcXCJePVxcXCIgPT09IGIgPyBjICYmIDAgPT09IGUuaW5kZXhPZihjKSA6IFxcXCIqPVxcXCIgPT09IGIgPyBjICYmIGUuaW5kZXhPZihjKSA+IC0xIDogXFxcIiQ9XFxcIiA9PT0gYiA/IGMgJiYgZS5zbGljZSgtYy5sZW5ndGgpID09PSBjIDogXFxcIn49XFxcIiA9PT0gYiA/IChcXFwiIFxcXCIgKyBlLnJlcGxhY2UoUCwgXFxcIiBcXFwiKSArIFxcXCIgXFxcIikuaW5kZXhPZihjKSA+IC0xIDogXFxcInw9XFxcIiA9PT0gYiA/IGUgPT09IGMgfHwgZS5zbGljZSgwLCBjLmxlbmd0aCArIDEpID09PSBjICsgXFxcIi1cXFwiIDogITEpIDogITA7XFxuICAgICAgICAgIH07XFxuICAgICAgICB9LCBDSElMRDogZnVuY3Rpb24gQ0hJTEQoYSwgYiwgYywgZCwgZSkge1xcbiAgICAgICAgICB2YXIgZiA9IFxcXCJudGhcXFwiICE9PSBhLnNsaWNlKDAsIDMpLFxcbiAgICAgICAgICAgICAgZyA9IFxcXCJsYXN0XFxcIiAhPT0gYS5zbGljZSgtNCksXFxuICAgICAgICAgICAgICBoID0gXFxcIm9mLXR5cGVcXFwiID09PSBiO3JldHVybiAxID09PSBkICYmIDAgPT09IGUgPyBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgICAgIHJldHVybiAhIWEucGFyZW50Tm9kZTtcXG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChiLCBjLCBpKSB7XFxuICAgICAgICAgICAgdmFyIGosXFxuICAgICAgICAgICAgICAgIGssXFxuICAgICAgICAgICAgICAgIGwsXFxuICAgICAgICAgICAgICAgIG0sXFxuICAgICAgICAgICAgICAgIG4sXFxuICAgICAgICAgICAgICAgIG8sXFxuICAgICAgICAgICAgICAgIHAgPSBmICE9PSBnID8gXFxcIm5leHRTaWJsaW5nXFxcIiA6IFxcXCJwcmV2aW91c1NpYmxpbmdcXFwiLFxcbiAgICAgICAgICAgICAgICBxID0gYi5wYXJlbnROb2RlLFxcbiAgICAgICAgICAgICAgICByID0gaCAmJiBiLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXFxuICAgICAgICAgICAgICAgIHMgPSAhaSAmJiAhaCxcXG4gICAgICAgICAgICAgICAgdCA9ICExO2lmIChxKSB7XFxuICAgICAgICAgICAgICBpZiAoZikge1xcbiAgICAgICAgICAgICAgICB3aGlsZSAocCkge1xcbiAgICAgICAgICAgICAgICAgIG0gPSBiO3doaWxlIChtID0gbVtwXSkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKGggPyBtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHIgOiAxID09PSBtLm5vZGVUeXBlKSByZXR1cm4gITE7XFxuICAgICAgICAgICAgICAgICAgfW8gPSBwID0gXFxcIm9ubHlcXFwiID09PSBhICYmICFvICYmIFxcXCJuZXh0U2libGluZ1xcXCI7XFxuICAgICAgICAgICAgICAgIH1yZXR1cm4gITA7XFxuICAgICAgICAgICAgICB9aWYgKG8gPSBbZyA/IHEuZmlyc3RDaGlsZCA6IHEubGFzdENoaWxkXSwgZyAmJiBzKSB7XFxuICAgICAgICAgICAgICAgIG0gPSBxLCBsID0gbVt1XSB8fCAobVt1XSA9IHt9KSwgayA9IGxbbS51bmlxdWVJRF0gfHwgKGxbbS51bmlxdWVJRF0gPSB7fSksIGogPSBrW2FdIHx8IFtdLCBuID0galswXSA9PT0gdyAmJiBqWzFdLCB0ID0gbiAmJiBqWzJdLCBtID0gbiAmJiBxLmNoaWxkTm9kZXNbbl07d2hpbGUgKG0gPSArK24gJiYgbSAmJiBtW3BdIHx8ICh0ID0gbiA9IDApIHx8IG8ucG9wKCkpIHtcXG4gICAgICAgICAgICAgICAgICBpZiAoMSA9PT0gbS5ub2RlVHlwZSAmJiArK3QgJiYgbSA9PT0gYikge1xcbiAgICAgICAgICAgICAgICAgICAga1thXSA9IFt3LCBuLCB0XTticmVhaztcXG4gICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocyAmJiAobSA9IGIsIGwgPSBtW3VdIHx8IChtW3VdID0ge30pLCBrID0gbFttLnVuaXF1ZUlEXSB8fCAobFttLnVuaXF1ZUlEXSA9IHt9KSwgaiA9IGtbYV0gfHwgW10sIG4gPSBqWzBdID09PSB3ICYmIGpbMV0sIHQgPSBuKSwgdCA9PT0gITEpIHdoaWxlIChtID0gKytuICYmIG0gJiYgbVtwXSB8fCAodCA9IG4gPSAwKSB8fCBvLnBvcCgpKSB7XFxuICAgICAgICAgICAgICAgIGlmICgoaCA/IG0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gciA6IDEgPT09IG0ubm9kZVR5cGUpICYmICsrdCAmJiAocyAmJiAobCA9IG1bdV0gfHwgKG1bdV0gPSB7fSksIGsgPSBsW20udW5pcXVlSURdIHx8IChsW20udW5pcXVlSURdID0ge30pLCBrW2FdID0gW3csIHRdKSwgbSA9PT0gYikpIGJyZWFrO1xcbiAgICAgICAgICAgICAgfXJldHVybiB0IC09IGUsIHQgPT09IGQgfHwgdCAlIGQgPT09IDAgJiYgdCAvIGQgPj0gMDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH07XFxuICAgICAgICB9LCBQU0VVRE86IGZ1bmN0aW9uIFBTRVVETyhhLCBiKSB7XFxuICAgICAgICAgIHZhciBjLFxcbiAgICAgICAgICAgICAgZSA9IGQucHNldWRvc1thXSB8fCBkLnNldEZpbHRlcnNbYS50b0xvd2VyQ2FzZSgpXSB8fCBmYS5lcnJvcihcXFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcXFwiICsgYSk7cmV0dXJuIGVbdV0gPyBlKGIpIDogZS5sZW5ndGggPiAxID8gKGMgPSBbYSwgYSwgXFxcIlxcXCIsIGJdLCBkLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoYS50b0xvd2VyQ2FzZSgpKSA/IGhhKGZ1bmN0aW9uIChhLCBjKSB7XFxuICAgICAgICAgICAgdmFyIGQsXFxuICAgICAgICAgICAgICAgIGYgPSBlKGEsIGIpLFxcbiAgICAgICAgICAgICAgICBnID0gZi5sZW5ndGg7d2hpbGUgKGctLSkge1xcbiAgICAgICAgICAgICAgZCA9IEooYSwgZltnXSksIGFbZF0gPSAhKGNbZF0gPSBmW2ddKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0pIDogZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgICAgICByZXR1cm4gZShhLCAwLCBjKTtcXG4gICAgICAgICAgfSkgOiBlO1xcbiAgICAgICAgfSB9LCBwc2V1ZG9zOiB7IG5vdDogaGEoZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgICAgdmFyIGIgPSBbXSxcXG4gICAgICAgICAgICAgIGMgPSBbXSxcXG4gICAgICAgICAgICAgIGQgPSBoKGEucmVwbGFjZShRLCBcXFwiJDFcXFwiKSk7cmV0dXJuIGRbdV0gPyBoYShmdW5jdGlvbiAoYSwgYiwgYywgZSkge1xcbiAgICAgICAgICAgIHZhciBmLFxcbiAgICAgICAgICAgICAgICBnID0gZChhLCBudWxsLCBlLCBbXSksXFxuICAgICAgICAgICAgICAgIGggPSBhLmxlbmd0aDt3aGlsZSAoaC0tKSB7XFxuICAgICAgICAgICAgICAoZiA9IGdbaF0pICYmIChhW2hdID0gIShiW2hdID0gZikpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSkgOiBmdW5jdGlvbiAoYSwgZSwgZikge1xcbiAgICAgICAgICAgIHJldHVybiBiWzBdID0gYSwgZChiLCBudWxsLCBmLCBjKSwgYlswXSA9IG51bGwsICFjLnBvcCgpO1xcbiAgICAgICAgICB9O1xcbiAgICAgICAgfSksIGhhczogaGEoZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZhKGEsIGIpLmxlbmd0aCA+IDA7XFxuICAgICAgICAgIH07XFxuICAgICAgICB9KSwgY29udGFpbnM6IGhhKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICAgIHJldHVybiBhID0gYS5yZXBsYWNlKGJhLCBjYSksIGZ1bmN0aW9uIChiKSB7XFxuICAgICAgICAgICAgcmV0dXJuIChiLnRleHRDb250ZW50IHx8IGIuaW5uZXJUZXh0IHx8IGUoYikpLmluZGV4T2YoYSkgPiAtMTtcXG4gICAgICAgICAgfTtcXG4gICAgICAgIH0pLCBsYW5nOiBoYShmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgICByZXR1cm4gVi50ZXN0KGEgfHwgXFxcIlxcXCIpIHx8IGZhLmVycm9yKFxcXCJ1bnN1cHBvcnRlZCBsYW5nOiBcXFwiICsgYSksIGEgPSBhLnJlcGxhY2UoYmEsIGNhKS50b0xvd2VyQ2FzZSgpLCBmdW5jdGlvbiAoYikge1xcbiAgICAgICAgICAgIHZhciBjO2RvIHtcXG4gICAgICAgICAgICAgIGlmIChjID0gcCA/IGIubGFuZyA6IGIuZ2V0QXR0cmlidXRlKFxcXCJ4bWw6bGFuZ1xcXCIpIHx8IGIuZ2V0QXR0cmlidXRlKFxcXCJsYW5nXFxcIikpIHJldHVybiBjID0gYy50b0xvd2VyQ2FzZSgpLCBjID09PSBhIHx8IDAgPT09IGMuaW5kZXhPZihhICsgXFxcIi1cXFwiKTtcXG4gICAgICAgICAgICB9IHdoaWxlICgoYiA9IGIucGFyZW50Tm9kZSkgJiYgMSA9PT0gYi5ub2RlVHlwZSk7cmV0dXJuICExO1xcbiAgICAgICAgICB9O1xcbiAgICAgICAgfSksIHRhcmdldDogZnVuY3Rpb24gdGFyZ2V0KGIpIHtcXG4gICAgICAgICAgdmFyIGMgPSBhLmxvY2F0aW9uICYmIGEubG9jYXRpb24uaGFzaDtyZXR1cm4gYyAmJiBjLnNsaWNlKDEpID09PSBiLmlkO1xcbiAgICAgICAgfSwgcm9vdDogZnVuY3Rpb24gcm9vdChhKSB7XFxuICAgICAgICAgIHJldHVybiBhID09PSBvO1xcbiAgICAgICAgfSwgZm9jdXM6IGZ1bmN0aW9uIGZvY3VzKGEpIHtcXG4gICAgICAgICAgcmV0dXJuIGEgPT09IG4uYWN0aXZlRWxlbWVudCAmJiAoIW4uaGFzRm9jdXMgfHwgbi5oYXNGb2N1cygpKSAmJiAhIShhLnR5cGUgfHwgYS5ocmVmIHx8IH5hLnRhYkluZGV4KTtcXG4gICAgICAgIH0sIGVuYWJsZWQ6IGZ1bmN0aW9uIGVuYWJsZWQoYSkge1xcbiAgICAgICAgICByZXR1cm4gYS5kaXNhYmxlZCA9PT0gITE7XFxuICAgICAgICB9LCBkaXNhYmxlZDogZnVuY3Rpb24gZGlzYWJsZWQoYSkge1xcbiAgICAgICAgICByZXR1cm4gYS5kaXNhYmxlZCA9PT0gITA7XFxuICAgICAgICB9LCBjaGVja2VkOiBmdW5jdGlvbiBjaGVja2VkKGEpIHtcXG4gICAgICAgICAgdmFyIGIgPSBhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuIFxcXCJpbnB1dFxcXCIgPT09IGIgJiYgISFhLmNoZWNrZWQgfHwgXFxcIm9wdGlvblxcXCIgPT09IGIgJiYgISFhLnNlbGVjdGVkO1xcbiAgICAgICAgfSwgc2VsZWN0ZWQ6IGZ1bmN0aW9uIHNlbGVjdGVkKGEpIHtcXG4gICAgICAgICAgcmV0dXJuIGEucGFyZW50Tm9kZSAmJiBhLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleCwgYS5zZWxlY3RlZCA9PT0gITA7XFxuICAgICAgICB9LCBlbXB0eTogZnVuY3Rpb24gZW1wdHkoYSkge1xcbiAgICAgICAgICBmb3IgKGEgPSBhLmZpcnN0Q2hpbGQ7IGE7IGEgPSBhLm5leHRTaWJsaW5nKSB7XFxuICAgICAgICAgICAgaWYgKGEubm9kZVR5cGUgPCA2KSByZXR1cm4gITE7XFxuICAgICAgICAgIH1yZXR1cm4gITA7XFxuICAgICAgICB9LCBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudChhKSB7XFxuICAgICAgICAgIHJldHVybiAhZC5wc2V1ZG9zLmVtcHR5KGEpO1xcbiAgICAgICAgfSwgaGVhZGVyOiBmdW5jdGlvbiBoZWFkZXIoYSkge1xcbiAgICAgICAgICByZXR1cm4gWS50ZXN0KGEubm9kZU5hbWUpO1xcbiAgICAgICAgfSwgaW5wdXQ6IGZ1bmN0aW9uIGlucHV0KGEpIHtcXG4gICAgICAgICAgcmV0dXJuIFgudGVzdChhLm5vZGVOYW1lKTtcXG4gICAgICAgIH0sIGJ1dHRvbjogZnVuY3Rpb24gYnV0dG9uKGEpIHtcXG4gICAgICAgICAgdmFyIGIgPSBhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuIFxcXCJpbnB1dFxcXCIgPT09IGIgJiYgXFxcImJ1dHRvblxcXCIgPT09IGEudHlwZSB8fCBcXFwiYnV0dG9uXFxcIiA9PT0gYjtcXG4gICAgICAgIH0sIHRleHQ6IGZ1bmN0aW9uIHRleHQoYSkge1xcbiAgICAgICAgICB2YXIgYjtyZXR1cm4gXFxcImlucHV0XFxcIiA9PT0gYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICYmIFxcXCJ0ZXh0XFxcIiA9PT0gYS50eXBlICYmIChudWxsID09IChiID0gYS5nZXRBdHRyaWJ1dGUoXFxcInR5cGVcXFwiKSkgfHwgXFxcInRleHRcXFwiID09PSBiLnRvTG93ZXJDYXNlKCkpO1xcbiAgICAgICAgfSwgZmlyc3Q6IG5hKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgcmV0dXJuIFswXTtcXG4gICAgICAgIH0pLCBsYXN0OiBuYShmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgICAgICByZXR1cm4gW2IgLSAxXTtcXG4gICAgICAgIH0pLCBlcTogbmEoZnVuY3Rpb24gKGEsIGIsIGMpIHtcXG4gICAgICAgICAgcmV0dXJuIFswID4gYyA/IGMgKyBiIDogY107XFxuICAgICAgICB9KSwgZXZlbjogbmEoZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGIgPiBjOyBjICs9IDIpIHtcXG4gICAgICAgICAgICBhLnB1c2goYyk7XFxuICAgICAgICAgIH1yZXR1cm4gYTtcXG4gICAgICAgIH0pLCBvZGQ6IG5hKGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICAgIGZvciAodmFyIGMgPSAxOyBiID4gYzsgYyArPSAyKSB7XFxuICAgICAgICAgICAgYS5wdXNoKGMpO1xcbiAgICAgICAgICB9cmV0dXJuIGE7XFxuICAgICAgICB9KSwgbHQ6IG5hKGZ1bmN0aW9uIChhLCBiLCBjKSB7XFxuICAgICAgICAgIGZvciAodmFyIGQgPSAwID4gYyA/IGMgKyBiIDogYzsgLS1kID49IDA7KSB7XFxuICAgICAgICAgICAgYS5wdXNoKGQpO1xcbiAgICAgICAgICB9cmV0dXJuIGE7XFxuICAgICAgICB9KSwgZ3Q6IG5hKGZ1bmN0aW9uIChhLCBiLCBjKSB7XFxuICAgICAgICAgIGZvciAodmFyIGQgPSAwID4gYyA/IGMgKyBiIDogYzsgKytkIDwgYjspIHtcXG4gICAgICAgICAgICBhLnB1c2goZCk7XFxuICAgICAgICAgIH1yZXR1cm4gYTtcXG4gICAgICAgIH0pIH0gfSwgZC5wc2V1ZG9zLm50aCA9IGQucHNldWRvcy5lcTtmb3IgKGIgaW4geyByYWRpbzogITAsIGNoZWNrYm94OiAhMCwgZmlsZTogITAsIHBhc3N3b3JkOiAhMCwgaW1hZ2U6ICEwIH0pIHtcXG4gICAgICBkLnBzZXVkb3NbYl0gPSBsYShiKTtcXG4gICAgfWZvciAoYiBpbiB7IHN1Ym1pdDogITAsIHJlc2V0OiAhMCB9KSB7XFxuICAgICAgZC5wc2V1ZG9zW2JdID0gbWEoYik7XFxuICAgIH1mdW5jdGlvbiBwYSgpIHt9cGEucHJvdG90eXBlID0gZC5maWx0ZXJzID0gZC5wc2V1ZG9zLCBkLnNldEZpbHRlcnMgPSBuZXcgcGEoKSwgZyA9IGZhLnRva2VuaXplID0gZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICB2YXIgYyxcXG4gICAgICAgICAgZSxcXG4gICAgICAgICAgZixcXG4gICAgICAgICAgZyxcXG4gICAgICAgICAgaCxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgayA9IHpbYSArIFxcXCIgXFxcIl07aWYgKGspIHJldHVybiBiID8gMCA6IGsuc2xpY2UoMCk7aCA9IGEsIGkgPSBbXSwgaiA9IGQucHJlRmlsdGVyO3doaWxlIChoKSB7XFxuICAgICAgICBjICYmICEoZSA9IFIuZXhlYyhoKSkgfHwgKGUgJiYgKGggPSBoLnNsaWNlKGVbMF0ubGVuZ3RoKSB8fCBoKSwgaS5wdXNoKGYgPSBbXSkpLCBjID0gITEsIChlID0gUy5leGVjKGgpKSAmJiAoYyA9IGUuc2hpZnQoKSwgZi5wdXNoKHsgdmFsdWU6IGMsIHR5cGU6IGVbMF0ucmVwbGFjZShRLCBcXFwiIFxcXCIpIH0pLCBoID0gaC5zbGljZShjLmxlbmd0aCkpO2ZvciAoZyBpbiBkLmZpbHRlcikge1xcbiAgICAgICAgICAhKGUgPSBXW2ddLmV4ZWMoaCkpIHx8IGpbZ10gJiYgIShlID0galtnXShlKSkgfHwgKGMgPSBlLnNoaWZ0KCksIGYucHVzaCh7IHZhbHVlOiBjLCB0eXBlOiBnLCBtYXRjaGVzOiBlIH0pLCBoID0gaC5zbGljZShjLmxlbmd0aCkpO1xcbiAgICAgICAgfWlmICghYykgYnJlYWs7XFxuICAgICAgfXJldHVybiBiID8gaC5sZW5ndGggOiBoID8gZmEuZXJyb3IoYSkgOiB6KGEsIGkpLnNsaWNlKDApO1xcbiAgICB9O2Z1bmN0aW9uIHFhKGEpIHtcXG4gICAgICBmb3IgKHZhciBiID0gMCwgYyA9IGEubGVuZ3RoLCBkID0gXFxcIlxcXCI7IGMgPiBiOyBiKyspIHtcXG4gICAgICAgIGQgKz0gYVtiXS52YWx1ZTtcXG4gICAgICB9cmV0dXJuIGQ7XFxuICAgIH1mdW5jdGlvbiByYShhLCBiLCBjKSB7XFxuICAgICAgdmFyIGQgPSBiLmRpcixcXG4gICAgICAgICAgZSA9IGMgJiYgXFxcInBhcmVudE5vZGVcXFwiID09PSBkLFxcbiAgICAgICAgICBmID0geCsrO3JldHVybiBiLmZpcnN0ID8gZnVuY3Rpb24gKGIsIGMsIGYpIHtcXG4gICAgICAgIHdoaWxlIChiID0gYltkXSkge1xcbiAgICAgICAgICBpZiAoMSA9PT0gYi5ub2RlVHlwZSB8fCBlKSByZXR1cm4gYShiLCBjLCBmKTtcXG4gICAgICAgIH1cXG4gICAgICB9IDogZnVuY3Rpb24gKGIsIGMsIGcpIHtcXG4gICAgICAgIHZhciBoLFxcbiAgICAgICAgICAgIGksXFxuICAgICAgICAgICAgaixcXG4gICAgICAgICAgICBrID0gW3csIGZdO2lmIChnKSB7XFxuICAgICAgICAgIHdoaWxlIChiID0gYltkXSkge1xcbiAgICAgICAgICAgIGlmICgoMSA9PT0gYi5ub2RlVHlwZSB8fCBlKSAmJiBhKGIsIGMsIGcpKSByZXR1cm4gITA7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB3aGlsZSAoYiA9IGJbZF0pIHtcXG4gICAgICAgICAgaWYgKDEgPT09IGIubm9kZVR5cGUgfHwgZSkge1xcbiAgICAgICAgICAgIGlmIChqID0gYlt1XSB8fCAoYlt1XSA9IHt9KSwgaSA9IGpbYi51bmlxdWVJRF0gfHwgKGpbYi51bmlxdWVJRF0gPSB7fSksIChoID0gaVtkXSkgJiYgaFswXSA9PT0gdyAmJiBoWzFdID09PSBmKSByZXR1cm4ga1syXSA9IGhbMl07aWYgKGlbZF0gPSBrLCBrWzJdID0gYShiLCBjLCBnKSkgcmV0dXJuICEwO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgfWZ1bmN0aW9uIHNhKGEpIHtcXG4gICAgICByZXR1cm4gYS5sZW5ndGggPiAxID8gZnVuY3Rpb24gKGIsIGMsIGQpIHtcXG4gICAgICAgIHZhciBlID0gYS5sZW5ndGg7d2hpbGUgKGUtLSkge1xcbiAgICAgICAgICBpZiAoIWFbZV0oYiwgYywgZCkpIHJldHVybiAhMTtcXG4gICAgICAgIH1yZXR1cm4gITA7XFxuICAgICAgfSA6IGFbMF07XFxuICAgIH1mdW5jdGlvbiB0YShhLCBiLCBjKSB7XFxuICAgICAgZm9yICh2YXIgZCA9IDAsIGUgPSBiLmxlbmd0aDsgZSA+IGQ7IGQrKykge1xcbiAgICAgICAgZmEoYSwgYltkXSwgYyk7XFxuICAgICAgfXJldHVybiBjO1xcbiAgICB9ZnVuY3Rpb24gdWEoYSwgYiwgYywgZCwgZSkge1xcbiAgICAgIGZvciAodmFyIGYsIGcgPSBbXSwgaCA9IDAsIGkgPSBhLmxlbmd0aCwgaiA9IG51bGwgIT0gYjsgaSA+IGg7IGgrKykge1xcbiAgICAgICAgKGYgPSBhW2hdKSAmJiAoYyAmJiAhYyhmLCBkLCBlKSB8fCAoZy5wdXNoKGYpLCBqICYmIGIucHVzaChoKSkpO1xcbiAgICAgIH1yZXR1cm4gZztcXG4gICAgfWZ1bmN0aW9uIHZhKGEsIGIsIGMsIGQsIGUsIGYpIHtcXG4gICAgICByZXR1cm4gZCAmJiAhZFt1XSAmJiAoZCA9IHZhKGQpKSwgZSAmJiAhZVt1XSAmJiAoZSA9IHZhKGUsIGYpKSwgaGEoZnVuY3Rpb24gKGYsIGcsIGgsIGkpIHtcXG4gICAgICAgIHZhciBqLFxcbiAgICAgICAgICAgIGssXFxuICAgICAgICAgICAgbCxcXG4gICAgICAgICAgICBtID0gW10sXFxuICAgICAgICAgICAgbiA9IFtdLFxcbiAgICAgICAgICAgIG8gPSBnLmxlbmd0aCxcXG4gICAgICAgICAgICBwID0gZiB8fCB0YShiIHx8IFxcXCIqXFxcIiwgaC5ub2RlVHlwZSA/IFtoXSA6IGgsIFtdKSxcXG4gICAgICAgICAgICBxID0gIWEgfHwgIWYgJiYgYiA/IHAgOiB1YShwLCBtLCBhLCBoLCBpKSxcXG4gICAgICAgICAgICByID0gYyA/IGUgfHwgKGYgPyBhIDogbyB8fCBkKSA/IFtdIDogZyA6IHE7aWYgKGMgJiYgYyhxLCByLCBoLCBpKSwgZCkge1xcbiAgICAgICAgICBqID0gdWEociwgbiksIGQoaiwgW10sIGgsIGkpLCBrID0gai5sZW5ndGg7d2hpbGUgKGstLSkge1xcbiAgICAgICAgICAgIChsID0galtrXSkgJiYgKHJbbltrXV0gPSAhKHFbbltrXV0gPSBsKSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1pZiAoZikge1xcbiAgICAgICAgICBpZiAoZSB8fCBhKSB7XFxuICAgICAgICAgICAgaWYgKGUpIHtcXG4gICAgICAgICAgICAgIGogPSBbXSwgayA9IHIubGVuZ3RoO3doaWxlIChrLS0pIHtcXG4gICAgICAgICAgICAgICAgKGwgPSByW2tdKSAmJiBqLnB1c2gocVtrXSA9IGwpO1xcbiAgICAgICAgICAgICAgfWUobnVsbCwgciA9IFtdLCBqLCBpKTtcXG4gICAgICAgICAgICB9ayA9IHIubGVuZ3RoO3doaWxlIChrLS0pIHtcXG4gICAgICAgICAgICAgIChsID0gcltrXSkgJiYgKGogPSBlID8gSihmLCBsKSA6IG1ba10pID4gLTEgJiYgKGZbal0gPSAhKGdbal0gPSBsKSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2UgciA9IHVhKHIgPT09IGcgPyByLnNwbGljZShvLCByLmxlbmd0aCkgOiByKSwgZSA/IGUobnVsbCwgZywgciwgaSkgOiBILmFwcGx5KGcsIHIpO1xcbiAgICAgIH0pO1xcbiAgICB9ZnVuY3Rpb24gd2EoYSkge1xcbiAgICAgIGZvciAodmFyIGIsIGMsIGUsIGYgPSBhLmxlbmd0aCwgZyA9IGQucmVsYXRpdmVbYVswXS50eXBlXSwgaCA9IGcgfHwgZC5yZWxhdGl2ZVtcXFwiIFxcXCJdLCBpID0gZyA/IDEgOiAwLCBrID0gcmEoZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIHJldHVybiBhID09PSBiO1xcbiAgICAgIH0sIGgsICEwKSwgbCA9IHJhKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICByZXR1cm4gSihiLCBhKSA+IC0xO1xcbiAgICAgIH0sIGgsICEwKSwgbSA9IFtmdW5jdGlvbiAoYSwgYywgZCkge1xcbiAgICAgICAgdmFyIGUgPSAhZyAmJiAoZCB8fCBjICE9PSBqKSB8fCAoKGIgPSBjKS5ub2RlVHlwZSA/IGsoYSwgYywgZCkgOiBsKGEsIGMsIGQpKTtyZXR1cm4gYiA9IG51bGwsIGU7XFxuICAgICAgfV07IGYgPiBpOyBpKyspIHtcXG4gICAgICAgIGlmIChjID0gZC5yZWxhdGl2ZVthW2ldLnR5cGVdKSBtID0gW3JhKHNhKG0pLCBjKV07ZWxzZSB7XFxuICAgICAgICAgIGlmIChjID0gZC5maWx0ZXJbYVtpXS50eXBlXS5hcHBseShudWxsLCBhW2ldLm1hdGNoZXMpLCBjW3VdKSB7XFxuICAgICAgICAgICAgZm9yIChlID0gKytpOyBmID4gZTsgZSsrKSB7XFxuICAgICAgICAgICAgICBpZiAoZC5yZWxhdGl2ZVthW2VdLnR5cGVdKSBicmVhaztcXG4gICAgICAgICAgICB9cmV0dXJuIHZhKGkgPiAxICYmIHNhKG0pLCBpID4gMSAmJiBxYShhLnNsaWNlKDAsIGkgLSAxKS5jb25jYXQoeyB2YWx1ZTogXFxcIiBcXFwiID09PSBhW2kgLSAyXS50eXBlID8gXFxcIipcXFwiIDogXFxcIlxcXCIgfSkpLnJlcGxhY2UoUSwgXFxcIiQxXFxcIiksIGMsIGUgPiBpICYmIHdhKGEuc2xpY2UoaSwgZSkpLCBmID4gZSAmJiB3YShhID0gYS5zbGljZShlKSksIGYgPiBlICYmIHFhKGEpKTtcXG4gICAgICAgICAgfW0ucHVzaChjKTtcXG4gICAgICAgIH1cXG4gICAgICB9cmV0dXJuIHNhKG0pO1xcbiAgICB9ZnVuY3Rpb24geGEoYSwgYikge1xcbiAgICAgIHZhciBjID0gYi5sZW5ndGggPiAwLFxcbiAgICAgICAgICBlID0gYS5sZW5ndGggPiAwLFxcbiAgICAgICAgICBmID0gZnVuY3Rpb24gZihfZiwgZywgaCwgaSwgaykge1xcbiAgICAgICAgdmFyIGwsXFxuICAgICAgICAgICAgbyxcXG4gICAgICAgICAgICBxLFxcbiAgICAgICAgICAgIHIgPSAwLFxcbiAgICAgICAgICAgIHMgPSBcXFwiMFxcXCIsXFxuICAgICAgICAgICAgdCA9IF9mICYmIFtdLFxcbiAgICAgICAgICAgIHUgPSBbXSxcXG4gICAgICAgICAgICB2ID0gaixcXG4gICAgICAgICAgICB4ID0gX2YgfHwgZSAmJiBkLmZpbmQuVEFHKFxcXCIqXFxcIiwgayksXFxuICAgICAgICAgICAgeSA9IHcgKz0gbnVsbCA9PSB2ID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgLjEsXFxuICAgICAgICAgICAgeiA9IHgubGVuZ3RoO2ZvciAoayAmJiAoaiA9IGcgPT09IG4gfHwgZyB8fCBrKTsgcyAhPT0geiAmJiBudWxsICE9IChsID0geFtzXSk7IHMrKykge1xcbiAgICAgICAgICBpZiAoZSAmJiBsKSB7XFxuICAgICAgICAgICAgbyA9IDAsIGcgfHwgbC5vd25lckRvY3VtZW50ID09PSBuIHx8IChtKGwpLCBoID0gIXApO3doaWxlIChxID0gYVtvKytdKSB7XFxuICAgICAgICAgICAgICBpZiAocShsLCBnIHx8IG4sIGgpKSB7XFxuICAgICAgICAgICAgICAgIGkucHVzaChsKTticmVhaztcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9ayAmJiAodyA9IHkpO1xcbiAgICAgICAgICB9YyAmJiAoKGwgPSAhcSAmJiBsKSAmJiByLS0sIF9mICYmIHQucHVzaChsKSk7XFxuICAgICAgICB9aWYgKHIgKz0gcywgYyAmJiBzICE9PSByKSB7XFxuICAgICAgICAgIG8gPSAwO3doaWxlIChxID0gYltvKytdKSB7XFxuICAgICAgICAgICAgcSh0LCB1LCBnLCBoKTtcXG4gICAgICAgICAgfWlmIChfZikge1xcbiAgICAgICAgICAgIGlmIChyID4gMCkgd2hpbGUgKHMtLSkge1xcbiAgICAgICAgICAgICAgdFtzXSB8fCB1W3NdIHx8ICh1W3NdID0gRi5jYWxsKGkpKTtcXG4gICAgICAgICAgICB9dSA9IHVhKHUpO1xcbiAgICAgICAgICB9SC5hcHBseShpLCB1KSwgayAmJiAhX2YgJiYgdS5sZW5ndGggPiAwICYmIHIgKyBiLmxlbmd0aCA+IDEgJiYgZmEudW5pcXVlU29ydChpKTtcXG4gICAgICAgIH1yZXR1cm4gayAmJiAodyA9IHksIGogPSB2KSwgdDtcXG4gICAgICB9O3JldHVybiBjID8gaGEoZikgOiBmO1xcbiAgICB9cmV0dXJuIGggPSBmYS5jb21waWxlID0gZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICB2YXIgYyxcXG4gICAgICAgICAgZCA9IFtdLFxcbiAgICAgICAgICBlID0gW10sXFxuICAgICAgICAgIGYgPSBBW2EgKyBcXFwiIFxcXCJdO2lmICghZikge1xcbiAgICAgICAgYiB8fCAoYiA9IGcoYSkpLCBjID0gYi5sZW5ndGg7d2hpbGUgKGMtLSkge1xcbiAgICAgICAgICBmID0gd2EoYltjXSksIGZbdV0gPyBkLnB1c2goZikgOiBlLnB1c2goZik7XFxuICAgICAgICB9ZiA9IEEoYSwgeGEoZSwgZCkpLCBmLnNlbGVjdG9yID0gYTtcXG4gICAgICB9cmV0dXJuIGY7XFxuICAgIH0sIGkgPSBmYS5zZWxlY3QgPSBmdW5jdGlvbiAoYSwgYiwgZSwgZikge1xcbiAgICAgIHZhciBpLFxcbiAgICAgICAgICBqLFxcbiAgICAgICAgICBrLFxcbiAgICAgICAgICBsLFxcbiAgICAgICAgICBtLFxcbiAgICAgICAgICBuID0gXFxcImZ1bmN0aW9uXFxcIiA9PSB0eXBlb2YgYSAmJiBhLFxcbiAgICAgICAgICBvID0gIWYgJiYgZyhhID0gbi5zZWxlY3RvciB8fCBhKTtpZiAoZSA9IGUgfHwgW10sIDEgPT09IG8ubGVuZ3RoKSB7XFxuICAgICAgICBpZiAoaiA9IG9bMF0gPSBvWzBdLnNsaWNlKDApLCBqLmxlbmd0aCA+IDIgJiYgXFxcIklEXFxcIiA9PT0gKGsgPSBqWzBdKS50eXBlICYmIGMuZ2V0QnlJZCAmJiA5ID09PSBiLm5vZGVUeXBlICYmIHAgJiYgZC5yZWxhdGl2ZVtqWzFdLnR5cGVdKSB7XFxuICAgICAgICAgIGlmIChiID0gKGQuZmluZC5JRChrLm1hdGNoZXNbMF0ucmVwbGFjZShiYSwgY2EpLCBiKSB8fCBbXSlbMF0sICFiKSByZXR1cm4gZTtuICYmIChiID0gYi5wYXJlbnROb2RlKSwgYSA9IGEuc2xpY2Uoai5zaGlmdCgpLnZhbHVlLmxlbmd0aCk7XFxuICAgICAgICB9aSA9IFcubmVlZHNDb250ZXh0LnRlc3QoYSkgPyAwIDogai5sZW5ndGg7d2hpbGUgKGktLSkge1xcbiAgICAgICAgICBpZiAoayA9IGpbaV0sIGQucmVsYXRpdmVbbCA9IGsudHlwZV0pIGJyZWFrO2lmICgobSA9IGQuZmluZFtsXSkgJiYgKGYgPSBtKGsubWF0Y2hlc1swXS5yZXBsYWNlKGJhLCBjYSksIF8udGVzdChqWzBdLnR5cGUpICYmIG9hKGIucGFyZW50Tm9kZSkgfHwgYikpKSB7XFxuICAgICAgICAgICAgaWYgKGouc3BsaWNlKGksIDEpLCBhID0gZi5sZW5ndGggJiYgcWEoaiksICFhKSByZXR1cm4gSC5hcHBseShlLCBmKSwgZTticmVhaztcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1yZXR1cm4gKG4gfHwgaChhLCBvKSkoZiwgYiwgIXAsIGUsICFiIHx8IF8udGVzdChhKSAmJiBvYShiLnBhcmVudE5vZGUpIHx8IGIpLCBlO1xcbiAgICB9LCBjLnNvcnRTdGFibGUgPSB1LnNwbGl0KFxcXCJcXFwiKS5zb3J0KEIpLmpvaW4oXFxcIlxcXCIpID09PSB1LCBjLmRldGVjdER1cGxpY2F0ZXMgPSAhIWwsIG0oKSwgYy5zb3J0RGV0YWNoZWQgPSBpYShmdW5jdGlvbiAoYSkge1xcbiAgICAgIHJldHVybiAxICYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihuLmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpKTtcXG4gICAgfSksIGlhKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgcmV0dXJuIGEuaW5uZXJIVE1MID0gXFxcIjxhIGhyZWY9JyMnPjwvYT5cXFwiLCBcXFwiI1xcXCIgPT09IGEuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXFxcImhyZWZcXFwiKTtcXG4gICAgfSkgfHwgamEoXFxcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcXFwiLCBmdW5jdGlvbiAoYSwgYiwgYykge1xcbiAgICAgIHJldHVybiBjID8gdm9pZCAwIDogYS5nZXRBdHRyaWJ1dGUoYiwgXFxcInR5cGVcXFwiID09PSBiLnRvTG93ZXJDYXNlKCkgPyAxIDogMik7XFxuICAgIH0pLCBjLmF0dHJpYnV0ZXMgJiYgaWEoZnVuY3Rpb24gKGEpIHtcXG4gICAgICByZXR1cm4gYS5pbm5lckhUTUwgPSBcXFwiPGlucHV0Lz5cXFwiLCBhLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKFxcXCJ2YWx1ZVxcXCIsIFxcXCJcXFwiKSwgXFxcIlxcXCIgPT09IGEuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXFxcInZhbHVlXFxcIik7XFxuICAgIH0pIHx8IGphKFxcXCJ2YWx1ZVxcXCIsIGZ1bmN0aW9uIChhLCBiLCBjKSB7XFxuICAgICAgcmV0dXJuIGMgfHwgXFxcImlucHV0XFxcIiAhPT0gYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID8gdm9pZCAwIDogYS5kZWZhdWx0VmFsdWU7XFxuICAgIH0pLCBpYShmdW5jdGlvbiAoYSkge1xcbiAgICAgIHJldHVybiBudWxsID09IGEuZ2V0QXR0cmlidXRlKFxcXCJkaXNhYmxlZFxcXCIpO1xcbiAgICB9KSB8fCBqYShLLCBmdW5jdGlvbiAoYSwgYiwgYykge1xcbiAgICAgIHZhciBkO3JldHVybiBjID8gdm9pZCAwIDogYVtiXSA9PT0gITAgPyBiLnRvTG93ZXJDYXNlKCkgOiAoZCA9IGEuZ2V0QXR0cmlidXRlTm9kZShiKSkgJiYgZC5zcGVjaWZpZWQgPyBkLnZhbHVlIDogbnVsbDtcXG4gICAgfSksIGZhO1xcbiAgfShhKTtuLmZpbmQgPSB0LCBuLmV4cHIgPSB0LnNlbGVjdG9ycywgbi5leHByW1xcXCI6XFxcIl0gPSBuLmV4cHIucHNldWRvcywgbi51bmlxdWVTb3J0ID0gbi51bmlxdWUgPSB0LnVuaXF1ZVNvcnQsIG4udGV4dCA9IHQuZ2V0VGV4dCwgbi5pc1hNTERvYyA9IHQuaXNYTUwsIG4uY29udGFpbnMgPSB0LmNvbnRhaW5zO3ZhciB1ID0gZnVuY3Rpb24gdShhLCBiLCBjKSB7XFxuICAgIHZhciBkID0gW10sXFxuICAgICAgICBlID0gdm9pZCAwICE9PSBjO3doaWxlICgoYSA9IGFbYl0pICYmIDkgIT09IGEubm9kZVR5cGUpIHtcXG4gICAgICBpZiAoMSA9PT0gYS5ub2RlVHlwZSkge1xcbiAgICAgICAgaWYgKGUgJiYgbihhKS5pcyhjKSkgYnJlYWs7ZC5wdXNoKGEpO1xcbiAgICAgIH1cXG4gICAgfXJldHVybiBkO1xcbiAgfSxcXG4gICAgICB2ID0gZnVuY3Rpb24gdihhLCBiKSB7XFxuICAgIGZvciAodmFyIGMgPSBbXTsgYTsgYSA9IGEubmV4dFNpYmxpbmcpIHtcXG4gICAgICAxID09PSBhLm5vZGVUeXBlICYmIGEgIT09IGIgJiYgYy5wdXNoKGEpO1xcbiAgICB9cmV0dXJuIGM7XFxuICB9LFxcbiAgICAgIHcgPSBuLmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LFxcbiAgICAgIHggPSAvXjwoW1xcXFx3LV0rKVxcXFxzKlxcXFwvPz4oPzo8XFxcXC9cXFxcMT58KSQvLFxcbiAgICAgIHkgPSAvXi5bXjojXFxcXFtcXFxcLixdKiQvO2Z1bmN0aW9uIHooYSwgYiwgYykge1xcbiAgICBpZiAobi5pc0Z1bmN0aW9uKGIpKSByZXR1cm4gbi5ncmVwKGEsIGZ1bmN0aW9uIChhLCBkKSB7XFxuICAgICAgcmV0dXJuICEhYi5jYWxsKGEsIGQsIGEpICE9PSBjO1xcbiAgICB9KTtpZiAoYi5ub2RlVHlwZSkgcmV0dXJuIG4uZ3JlcChhLCBmdW5jdGlvbiAoYSkge1xcbiAgICAgIHJldHVybiBhID09PSBiICE9PSBjO1xcbiAgICB9KTtpZiAoXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIGIpIHtcXG4gICAgICBpZiAoeS50ZXN0KGIpKSByZXR1cm4gbi5maWx0ZXIoYiwgYSwgYyk7YiA9IG4uZmlsdGVyKGIsIGEpO1xcbiAgICB9cmV0dXJuIG4uZ3JlcChhLCBmdW5jdGlvbiAoYSkge1xcbiAgICAgIHJldHVybiBoLmNhbGwoYiwgYSkgPiAtMSAhPT0gYztcXG4gICAgfSk7XFxuICB9bi5maWx0ZXIgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xcbiAgICB2YXIgZCA9IGJbMF07cmV0dXJuIGMgJiYgKGEgPSBcXFwiOm5vdChcXFwiICsgYSArIFxcXCIpXFxcIiksIDEgPT09IGIubGVuZ3RoICYmIDEgPT09IGQubm9kZVR5cGUgPyBuLmZpbmQubWF0Y2hlc1NlbGVjdG9yKGQsIGEpID8gW2RdIDogW10gOiBuLmZpbmQubWF0Y2hlcyhhLCBuLmdyZXAoYiwgZnVuY3Rpb24gKGEpIHtcXG4gICAgICByZXR1cm4gMSA9PT0gYS5ub2RlVHlwZTtcXG4gICAgfSkpO1xcbiAgfSwgbi5mbi5leHRlbmQoeyBmaW5kOiBmdW5jdGlvbiBmaW5kKGEpIHtcXG4gICAgICB2YXIgYixcXG4gICAgICAgICAgYyA9IHRoaXMubGVuZ3RoLFxcbiAgICAgICAgICBkID0gW10sXFxuICAgICAgICAgIGUgPSB0aGlzO2lmIChcXFwic3RyaW5nXFxcIiAhPSB0eXBlb2YgYSkgcmV0dXJuIHRoaXMucHVzaFN0YWNrKG4oYSkuZmlsdGVyKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGZvciAoYiA9IDA7IGMgPiBiOyBiKyspIHtcXG4gICAgICAgICAgaWYgKG4uY29udGFpbnMoZVtiXSwgdGhpcykpIHJldHVybiAhMDtcXG4gICAgICAgIH1cXG4gICAgICB9KSk7Zm9yIChiID0gMDsgYyA+IGI7IGIrKykge1xcbiAgICAgICAgbi5maW5kKGEsIGVbYl0sIGQpO1xcbiAgICAgIH1yZXR1cm4gZCA9IHRoaXMucHVzaFN0YWNrKGMgPiAxID8gbi51bmlxdWUoZCkgOiBkKSwgZC5zZWxlY3RvciA9IHRoaXMuc2VsZWN0b3IgPyB0aGlzLnNlbGVjdG9yICsgXFxcIiBcXFwiICsgYSA6IGEsIGQ7XFxuICAgIH0sIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGEpIHtcXG4gICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soeih0aGlzLCBhIHx8IFtdLCAhMSkpO1xcbiAgICB9LCBub3Q6IGZ1bmN0aW9uIG5vdChhKSB7XFxuICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKHoodGhpcywgYSB8fCBbXSwgITApKTtcXG4gICAgfSwgaXM6IGZ1bmN0aW9uIGlzKGEpIHtcXG4gICAgICByZXR1cm4gISF6KHRoaXMsIFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBhICYmIHcudGVzdChhKSA/IG4oYSkgOiBhIHx8IFtdLCAhMSkubGVuZ3RoO1xcbiAgICB9IH0pO3ZhciBBLFxcbiAgICAgIEIgPSAvXig/OlxcXFxzKig8W1xcXFx3XFxcXFddKz4pW14+XSp8IyhbXFxcXHctXSopKSQvLFxcbiAgICAgIEMgPSBuLmZuLmluaXQgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xcbiAgICB2YXIgZSwgZjtpZiAoIWEpIHJldHVybiB0aGlzO2lmIChjID0gYyB8fCBBLCBcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYSkge1xcbiAgICAgIGlmIChlID0gXFxcIjxcXFwiID09PSBhWzBdICYmIFxcXCI+XFxcIiA9PT0gYVthLmxlbmd0aCAtIDFdICYmIGEubGVuZ3RoID49IDMgPyBbbnVsbCwgYSwgbnVsbF0gOiBCLmV4ZWMoYSksICFlIHx8ICFlWzFdICYmIGIpIHJldHVybiAhYiB8fCBiLmpxdWVyeSA/IChiIHx8IGMpLmZpbmQoYSkgOiB0aGlzLmNvbnN0cnVjdG9yKGIpLmZpbmQoYSk7aWYgKGVbMV0pIHtcXG4gICAgICAgIGlmIChiID0gYiBpbnN0YW5jZW9mIG4gPyBiWzBdIDogYiwgbi5tZXJnZSh0aGlzLCBuLnBhcnNlSFRNTChlWzFdLCBiICYmIGIubm9kZVR5cGUgPyBiLm93bmVyRG9jdW1lbnQgfHwgYiA6IGQsICEwKSksIHgudGVzdChlWzFdKSAmJiBuLmlzUGxhaW5PYmplY3QoYikpIGZvciAoZSBpbiBiKSB7XFxuICAgICAgICAgIG4uaXNGdW5jdGlvbih0aGlzW2VdKSA/IHRoaXNbZV0oYltlXSkgOiB0aGlzLmF0dHIoZSwgYltlXSk7XFxuICAgICAgICB9cmV0dXJuIHRoaXM7XFxuICAgICAgfXJldHVybiBmID0gZC5nZXRFbGVtZW50QnlJZChlWzJdKSwgZiAmJiBmLnBhcmVudE5vZGUgJiYgKHRoaXMubGVuZ3RoID0gMSwgdGhpc1swXSA9IGYpLCB0aGlzLmNvbnRleHQgPSBkLCB0aGlzLnNlbGVjdG9yID0gYSwgdGhpcztcXG4gICAgfXJldHVybiBhLm5vZGVUeXBlID8gKHRoaXMuY29udGV4dCA9IHRoaXNbMF0gPSBhLCB0aGlzLmxlbmd0aCA9IDEsIHRoaXMpIDogbi5pc0Z1bmN0aW9uKGEpID8gdm9pZCAwICE9PSBjLnJlYWR5ID8gYy5yZWFkeShhKSA6IGEobikgOiAodm9pZCAwICE9PSBhLnNlbGVjdG9yICYmICh0aGlzLnNlbGVjdG9yID0gYS5zZWxlY3RvciwgdGhpcy5jb250ZXh0ID0gYS5jb250ZXh0KSwgbi5tYWtlQXJyYXkoYSwgdGhpcykpO1xcbiAgfTtDLnByb3RvdHlwZSA9IG4uZm4sIEEgPSBuKGQpO3ZhciBEID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXFxuICAgICAgRSA9IHsgY2hpbGRyZW46ICEwLCBjb250ZW50czogITAsIG5leHQ6ICEwLCBwcmV2OiAhMCB9O24uZm4uZXh0ZW5kKHsgaGFzOiBmdW5jdGlvbiBoYXMoYSkge1xcbiAgICAgIHZhciBiID0gbihhLCB0aGlzKSxcXG4gICAgICAgICAgYyA9IGIubGVuZ3RoO3JldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbiAoKSB7XFxuICAgICAgICBmb3IgKHZhciBhID0gMDsgYyA+IGE7IGErKykge1xcbiAgICAgICAgICBpZiAobi5jb250YWlucyh0aGlzLCBiW2FdKSkgcmV0dXJuICEwO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9LCBjbG9zZXN0OiBmdW5jdGlvbiBjbG9zZXN0KGEsIGIpIHtcXG4gICAgICBmb3IgKHZhciBjLCBkID0gMCwgZSA9IHRoaXMubGVuZ3RoLCBmID0gW10sIGcgPSB3LnRlc3QoYSkgfHwgXFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGEgPyBuKGEsIGIgfHwgdGhpcy5jb250ZXh0KSA6IDA7IGUgPiBkOyBkKyspIHtcXG4gICAgICAgIGZvciAoYyA9IHRoaXNbZF07IGMgJiYgYyAhPT0gYjsgYyA9IGMucGFyZW50Tm9kZSkge1xcbiAgICAgICAgICBpZiAoYy5ub2RlVHlwZSA8IDExICYmIChnID8gZy5pbmRleChjKSA+IC0xIDogMSA9PT0gYy5ub2RlVHlwZSAmJiBuLmZpbmQubWF0Y2hlc1NlbGVjdG9yKGMsIGEpKSkge1xcbiAgICAgICAgICAgIGYucHVzaChjKTticmVhaztcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1yZXR1cm4gdGhpcy5wdXNoU3RhY2soZi5sZW5ndGggPiAxID8gbi51bmlxdWVTb3J0KGYpIDogZik7XFxuICAgIH0sIGluZGV4OiBmdW5jdGlvbiBpbmRleChhKSB7XFxuICAgICAgcmV0dXJuIGEgPyBcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYSA/IGguY2FsbChuKGEpLCB0aGlzWzBdKSA6IGguY2FsbCh0aGlzLCBhLmpxdWVyeSA/IGFbMF0gOiBhKSA6IHRoaXNbMF0gJiYgdGhpc1swXS5wYXJlbnROb2RlID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcXG4gICAgfSwgYWRkOiBmdW5jdGlvbiBhZGQoYSwgYikge1xcbiAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhuLnVuaXF1ZVNvcnQobi5tZXJnZSh0aGlzLmdldCgpLCBuKGEsIGIpKSkpO1xcbiAgICB9LCBhZGRCYWNrOiBmdW5jdGlvbiBhZGRCYWNrKGEpIHtcXG4gICAgICByZXR1cm4gdGhpcy5hZGQobnVsbCA9PSBhID8gdGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlcihhKSk7XFxuICAgIH0gfSk7ZnVuY3Rpb24gRihhLCBiKSB7XFxuICAgIHdoaWxlICgoYSA9IGFbYl0pICYmIDEgIT09IGEubm9kZVR5cGUpIHt9cmV0dXJuIGE7XFxuICB9bi5lYWNoKHsgcGFyZW50OiBmdW5jdGlvbiBwYXJlbnQoYSkge1xcbiAgICAgIHZhciBiID0gYS5wYXJlbnROb2RlO3JldHVybiBiICYmIDExICE9PSBiLm5vZGVUeXBlID8gYiA6IG51bGw7XFxuICAgIH0sIHBhcmVudHM6IGZ1bmN0aW9uIHBhcmVudHMoYSkge1xcbiAgICAgIHJldHVybiB1KGEsIFxcXCJwYXJlbnROb2RlXFxcIik7XFxuICAgIH0sIHBhcmVudHNVbnRpbDogZnVuY3Rpb24gcGFyZW50c1VudGlsKGEsIGIsIGMpIHtcXG4gICAgICByZXR1cm4gdShhLCBcXFwicGFyZW50Tm9kZVxcXCIsIGMpO1xcbiAgICB9LCBuZXh0OiBmdW5jdGlvbiBuZXh0KGEpIHtcXG4gICAgICByZXR1cm4gRihhLCBcXFwibmV4dFNpYmxpbmdcXFwiKTtcXG4gICAgfSwgcHJldjogZnVuY3Rpb24gcHJldihhKSB7XFxuICAgICAgcmV0dXJuIEYoYSwgXFxcInByZXZpb3VzU2libGluZ1xcXCIpO1xcbiAgICB9LCBuZXh0QWxsOiBmdW5jdGlvbiBuZXh0QWxsKGEpIHtcXG4gICAgICByZXR1cm4gdShhLCBcXFwibmV4dFNpYmxpbmdcXFwiKTtcXG4gICAgfSwgcHJldkFsbDogZnVuY3Rpb24gcHJldkFsbChhKSB7XFxuICAgICAgcmV0dXJuIHUoYSwgXFxcInByZXZpb3VzU2libGluZ1xcXCIpO1xcbiAgICB9LCBuZXh0VW50aWw6IGZ1bmN0aW9uIG5leHRVbnRpbChhLCBiLCBjKSB7XFxuICAgICAgcmV0dXJuIHUoYSwgXFxcIm5leHRTaWJsaW5nXFxcIiwgYyk7XFxuICAgIH0sIHByZXZVbnRpbDogZnVuY3Rpb24gcHJldlVudGlsKGEsIGIsIGMpIHtcXG4gICAgICByZXR1cm4gdShhLCBcXFwicHJldmlvdXNTaWJsaW5nXFxcIiwgYyk7XFxuICAgIH0sIHNpYmxpbmdzOiBmdW5jdGlvbiBzaWJsaW5ncyhhKSB7XFxuICAgICAgcmV0dXJuIHYoKGEucGFyZW50Tm9kZSB8fCB7fSkuZmlyc3RDaGlsZCwgYSk7XFxuICAgIH0sIGNoaWxkcmVuOiBmdW5jdGlvbiBjaGlsZHJlbihhKSB7XFxuICAgICAgcmV0dXJuIHYoYS5maXJzdENoaWxkKTtcXG4gICAgfSwgY29udGVudHM6IGZ1bmN0aW9uIGNvbnRlbnRzKGEpIHtcXG4gICAgICByZXR1cm4gYS5jb250ZW50RG9jdW1lbnQgfHwgbi5tZXJnZShbXSwgYS5jaGlsZE5vZGVzKTtcXG4gICAgfSB9LCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICBuLmZuW2FdID0gZnVuY3Rpb24gKGMsIGQpIHtcXG4gICAgICB2YXIgZSA9IG4ubWFwKHRoaXMsIGIsIGMpO3JldHVybiBcXFwiVW50aWxcXFwiICE9PSBhLnNsaWNlKC01KSAmJiAoZCA9IGMpLCBkICYmIFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBkICYmIChlID0gbi5maWx0ZXIoZCwgZSkpLCB0aGlzLmxlbmd0aCA+IDEgJiYgKEVbYV0gfHwgbi51bmlxdWVTb3J0KGUpLCBELnRlc3QoYSkgJiYgZS5yZXZlcnNlKCkpLCB0aGlzLnB1c2hTdGFjayhlKTtcXG4gICAgfTtcXG4gIH0pO3ZhciBHID0gL1xcXFxTKy9nO2Z1bmN0aW9uIEgoYSkge1xcbiAgICB2YXIgYiA9IHt9O3JldHVybiBuLmVhY2goYS5tYXRjaChHKSB8fCBbXSwgZnVuY3Rpb24gKGEsIGMpIHtcXG4gICAgICBiW2NdID0gITA7XFxuICAgIH0pLCBiO1xcbiAgfW4uQ2FsbGJhY2tzID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgYSA9IFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBhID8gSChhKSA6IG4uZXh0ZW5kKHt9LCBhKTt2YXIgYixcXG4gICAgICAgIGMsXFxuICAgICAgICBkLFxcbiAgICAgICAgZSxcXG4gICAgICAgIGYgPSBbXSxcXG4gICAgICAgIGcgPSBbXSxcXG4gICAgICAgIGggPSAtMSxcXG4gICAgICAgIGkgPSBmdW5jdGlvbiBpKCkge1xcbiAgICAgIGZvciAoZSA9IGEub25jZSwgZCA9IGIgPSAhMDsgZy5sZW5ndGg7IGggPSAtMSkge1xcbiAgICAgICAgYyA9IGcuc2hpZnQoKTt3aGlsZSAoKytoIDwgZi5sZW5ndGgpIHtcXG4gICAgICAgICAgZltoXS5hcHBseShjWzBdLCBjWzFdKSA9PT0gITEgJiYgYS5zdG9wT25GYWxzZSAmJiAoaCA9IGYubGVuZ3RoLCBjID0gITEpO1xcbiAgICAgICAgfVxcbiAgICAgIH1hLm1lbW9yeSB8fCAoYyA9ICExKSwgYiA9ICExLCBlICYmIChmID0gYyA/IFtdIDogXFxcIlxcXCIpO1xcbiAgICB9LFxcbiAgICAgICAgaiA9IHsgYWRkOiBmdW5jdGlvbiBhZGQoKSB7XFxuICAgICAgICByZXR1cm4gZiAmJiAoYyAmJiAhYiAmJiAoaCA9IGYubGVuZ3RoIC0gMSwgZy5wdXNoKGMpKSwgZnVuY3Rpb24gZChiKSB7XFxuICAgICAgICAgIG4uZWFjaChiLCBmdW5jdGlvbiAoYiwgYykge1xcbiAgICAgICAgICAgIG4uaXNGdW5jdGlvbihjKSA/IGEudW5pcXVlICYmIGouaGFzKGMpIHx8IGYucHVzaChjKSA6IGMgJiYgYy5sZW5ndGggJiYgXFxcInN0cmluZ1xcXCIgIT09IG4udHlwZShjKSAmJiBkKGMpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH0oYXJndW1lbnRzKSwgYyAmJiAhYiAmJiBpKCkpLCB0aGlzO1xcbiAgICAgIH0sIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xcbiAgICAgICAgcmV0dXJuIG4uZWFjaChhcmd1bWVudHMsIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICAgIHZhciBjO3doaWxlICgoYyA9IG4uaW5BcnJheShiLCBmLCBjKSkgPiAtMSkge1xcbiAgICAgICAgICAgIGYuc3BsaWNlKGMsIDEpLCBoID49IGMgJiYgaC0tO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KSwgdGhpcztcXG4gICAgICB9LCBoYXM6IGZ1bmN0aW9uIGhhcyhhKSB7XFxuICAgICAgICByZXR1cm4gYSA/IG4uaW5BcnJheShhLCBmKSA+IC0xIDogZi5sZW5ndGggPiAwO1xcbiAgICAgIH0sIGVtcHR5OiBmdW5jdGlvbiBlbXB0eSgpIHtcXG4gICAgICAgIHJldHVybiBmICYmIChmID0gW10pLCB0aGlzO1xcbiAgICAgIH0sIGRpc2FibGU6IGZ1bmN0aW9uIGRpc2FibGUoKSB7XFxuICAgICAgICByZXR1cm4gZSA9IGcgPSBbXSwgZiA9IGMgPSBcXFwiXFxcIiwgdGhpcztcXG4gICAgICB9LCBkaXNhYmxlZDogZnVuY3Rpb24gZGlzYWJsZWQoKSB7XFxuICAgICAgICByZXR1cm4gIWY7XFxuICAgICAgfSwgbG9jazogZnVuY3Rpb24gbG9jaygpIHtcXG4gICAgICAgIHJldHVybiBlID0gZyA9IFtdLCBjIHx8IChmID0gYyA9IFxcXCJcXFwiKSwgdGhpcztcXG4gICAgICB9LCBsb2NrZWQ6IGZ1bmN0aW9uIGxvY2tlZCgpIHtcXG4gICAgICAgIHJldHVybiAhIWU7XFxuICAgICAgfSwgZmlyZVdpdGg6IGZ1bmN0aW9uIGZpcmVXaXRoKGEsIGMpIHtcXG4gICAgICAgIHJldHVybiBlIHx8IChjID0gYyB8fCBbXSwgYyA9IFthLCBjLnNsaWNlID8gYy5zbGljZSgpIDogY10sIGcucHVzaChjKSwgYiB8fCBpKCkpLCB0aGlzO1xcbiAgICAgIH0sIGZpcmU6IGZ1bmN0aW9uIGZpcmUoKSB7XFxuICAgICAgICByZXR1cm4gai5maXJlV2l0aCh0aGlzLCBhcmd1bWVudHMpLCB0aGlzO1xcbiAgICAgIH0sIGZpcmVkOiBmdW5jdGlvbiBmaXJlZCgpIHtcXG4gICAgICAgIHJldHVybiAhIWQ7XFxuICAgICAgfSB9O3JldHVybiBqO1xcbiAgfSwgbi5leHRlbmQoeyBEZWZlcnJlZDogZnVuY3Rpb24gRGVmZXJyZWQoYSkge1xcbiAgICAgIHZhciBiID0gW1tcXFwicmVzb2x2ZVxcXCIsIFxcXCJkb25lXFxcIiwgbi5DYWxsYmFja3MoXFxcIm9uY2UgbWVtb3J5XFxcIiksIFxcXCJyZXNvbHZlZFxcXCJdLCBbXFxcInJlamVjdFxcXCIsIFxcXCJmYWlsXFxcIiwgbi5DYWxsYmFja3MoXFxcIm9uY2UgbWVtb3J5XFxcIiksIFxcXCJyZWplY3RlZFxcXCJdLCBbXFxcIm5vdGlmeVxcXCIsIFxcXCJwcm9ncmVzc1xcXCIsIG4uQ2FsbGJhY2tzKFxcXCJtZW1vcnlcXFwiKV1dLFxcbiAgICAgICAgICBjID0gXFxcInBlbmRpbmdcXFwiLFxcbiAgICAgICAgICBkID0geyBzdGF0ZTogZnVuY3Rpb24gc3RhdGUoKSB7XFxuICAgICAgICAgIHJldHVybiBjO1xcbiAgICAgICAgfSwgYWx3YXlzOiBmdW5jdGlvbiBhbHdheXMoKSB7XFxuICAgICAgICAgIHJldHVybiBlLmRvbmUoYXJndW1lbnRzKS5mYWlsKGFyZ3VtZW50cyksIHRoaXM7XFxuICAgICAgICB9LCB0aGVuOiBmdW5jdGlvbiB0aGVuKCkge1xcbiAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50cztyZXR1cm4gbi5EZWZlcnJlZChmdW5jdGlvbiAoYykge1xcbiAgICAgICAgICAgIG4uZWFjaChiLCBmdW5jdGlvbiAoYiwgZikge1xcbiAgICAgICAgICAgICAgdmFyIGcgPSBuLmlzRnVuY3Rpb24oYVtiXSkgJiYgYVtiXTtlW2ZbMV1dKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgdmFyIGEgPSBnICYmIGcuYXBwbHkodGhpcywgYXJndW1lbnRzKTthICYmIG4uaXNGdW5jdGlvbihhLnByb21pc2UpID8gYS5wcm9taXNlKCkucHJvZ3Jlc3MoYy5ub3RpZnkpLmRvbmUoYy5yZXNvbHZlKS5mYWlsKGMucmVqZWN0KSA6IGNbZlswXSArIFxcXCJXaXRoXFxcIl0odGhpcyA9PT0gZCA/IGMucHJvbWlzZSgpIDogdGhpcywgZyA/IFthXSA6IGFyZ3VtZW50cyk7XFxuICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9KSwgYSA9IG51bGw7XFxuICAgICAgICAgIH0pLnByb21pc2UoKTtcXG4gICAgICAgIH0sIHByb21pc2U6IGZ1bmN0aW9uIHByb21pc2UoYSkge1xcbiAgICAgICAgICByZXR1cm4gbnVsbCAhPSBhID8gbi5leHRlbmQoYSwgZCkgOiBkO1xcbiAgICAgICAgfSB9LFxcbiAgICAgICAgICBlID0ge307cmV0dXJuIGQucGlwZSA9IGQudGhlbiwgbi5lYWNoKGIsIGZ1bmN0aW9uIChhLCBmKSB7XFxuICAgICAgICB2YXIgZyA9IGZbMl0sXFxuICAgICAgICAgICAgaCA9IGZbM107ZFtmWzFdXSA9IGcuYWRkLCBoICYmIGcuYWRkKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgYyA9IGg7XFxuICAgICAgICB9LCBiWzEgXiBhXVsyXS5kaXNhYmxlLCBiWzJdWzJdLmxvY2spLCBlW2ZbMF1dID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICByZXR1cm4gZVtmWzBdICsgXFxcIldpdGhcXFwiXSh0aGlzID09PSBlID8gZCA6IHRoaXMsIGFyZ3VtZW50cyksIHRoaXM7XFxuICAgICAgICB9LCBlW2ZbMF0gKyBcXFwiV2l0aFxcXCJdID0gZy5maXJlV2l0aDtcXG4gICAgICB9KSwgZC5wcm9taXNlKGUpLCBhICYmIGEuY2FsbChlLCBlKSwgZTtcXG4gICAgfSwgd2hlbjogZnVuY3Rpb24gd2hlbihhKSB7XFxuICAgICAgdmFyIGIgPSAwLFxcbiAgICAgICAgICBjID0gZS5jYWxsKGFyZ3VtZW50cyksXFxuICAgICAgICAgIGQgPSBjLmxlbmd0aCxcXG4gICAgICAgICAgZiA9IDEgIT09IGQgfHwgYSAmJiBuLmlzRnVuY3Rpb24oYS5wcm9taXNlKSA/IGQgOiAwLFxcbiAgICAgICAgICBnID0gMSA9PT0gZiA/IGEgOiBuLkRlZmVycmVkKCksXFxuICAgICAgICAgIGggPSBmdW5jdGlvbiBoKGEsIGIsIGMpIHtcXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZCkge1xcbiAgICAgICAgICBiW2FdID0gdGhpcywgY1thXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gZS5jYWxsKGFyZ3VtZW50cykgOiBkLCBjID09PSBpID8gZy5ub3RpZnlXaXRoKGIsIGMpIDogLS1mIHx8IGcucmVzb2x2ZVdpdGgoYiwgYyk7XFxuICAgICAgICB9O1xcbiAgICAgIH0sXFxuICAgICAgICAgIGksXFxuICAgICAgICAgIGosXFxuICAgICAgICAgIGs7aWYgKGQgPiAxKSBmb3IgKGkgPSBuZXcgQXJyYXkoZCksIGogPSBuZXcgQXJyYXkoZCksIGsgPSBuZXcgQXJyYXkoZCk7IGQgPiBiOyBiKyspIHtcXG4gICAgICAgIGNbYl0gJiYgbi5pc0Z1bmN0aW9uKGNbYl0ucHJvbWlzZSkgPyBjW2JdLnByb21pc2UoKS5wcm9ncmVzcyhoKGIsIGosIGkpKS5kb25lKGgoYiwgaywgYykpLmZhaWwoZy5yZWplY3QpIDogLS1mO1xcbiAgICAgIH1yZXR1cm4gZiB8fCBnLnJlc29sdmVXaXRoKGssIGMpLCBnLnByb21pc2UoKTtcXG4gICAgfSB9KTt2YXIgSTtuLmZuLnJlYWR5ID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgcmV0dXJuIG4ucmVhZHkucHJvbWlzZSgpLmRvbmUoYSksIHRoaXM7XFxuICB9LCBuLmV4dGVuZCh7IGlzUmVhZHk6ICExLCByZWFkeVdhaXQ6IDEsIGhvbGRSZWFkeTogZnVuY3Rpb24gaG9sZFJlYWR5KGEpIHtcXG4gICAgICBhID8gbi5yZWFkeVdhaXQrKyA6IG4ucmVhZHkoITApO1xcbiAgICB9LCByZWFkeTogZnVuY3Rpb24gcmVhZHkoYSkge1xcbiAgICAgIChhID09PSAhMCA/IC0tbi5yZWFkeVdhaXQgOiBuLmlzUmVhZHkpIHx8IChuLmlzUmVhZHkgPSAhMCwgYSAhPT0gITAgJiYgLS1uLnJlYWR5V2FpdCA+IDAgfHwgKEkucmVzb2x2ZVdpdGgoZCwgW25dKSwgbi5mbi50cmlnZ2VySGFuZGxlciAmJiAobihkKS50cmlnZ2VySGFuZGxlcihcXFwicmVhZHlcXFwiKSwgbihkKS5vZmYoXFxcInJlYWR5XFxcIikpKSk7XFxuICAgIH0gfSk7ZnVuY3Rpb24gSigpIHtcXG4gICAgZC5yZW1vdmVFdmVudExpc3RlbmVyKFxcXCJET01Db250ZW50TG9hZGVkXFxcIiwgSiksIGEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcXFwibG9hZFxcXCIsIEopLCBuLnJlYWR5KCk7XFxuICB9bi5yZWFkeS5wcm9taXNlID0gZnVuY3Rpb24gKGIpIHtcXG4gICAgcmV0dXJuIEkgfHwgKEkgPSBuLkRlZmVycmVkKCksIFxcXCJjb21wbGV0ZVxcXCIgPT09IGQucmVhZHlTdGF0ZSB8fCBcXFwibG9hZGluZ1xcXCIgIT09IGQucmVhZHlTdGF0ZSAmJiAhZC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgPyBhLnNldFRpbWVvdXQobi5yZWFkeSkgOiAoZC5hZGRFdmVudExpc3RlbmVyKFxcXCJET01Db250ZW50TG9hZGVkXFxcIiwgSiksIGEuYWRkRXZlbnRMaXN0ZW5lcihcXFwibG9hZFxcXCIsIEopKSksIEkucHJvbWlzZShiKTtcXG4gIH0sIG4ucmVhZHkucHJvbWlzZSgpO3ZhciBLID0gZnVuY3Rpb24gSyhhLCBiLCBjLCBkLCBlLCBmLCBnKSB7XFxuICAgIHZhciBoID0gMCxcXG4gICAgICAgIGkgPSBhLmxlbmd0aCxcXG4gICAgICAgIGogPSBudWxsID09IGM7aWYgKFxcXCJvYmplY3RcXFwiID09PSBuLnR5cGUoYykpIHtcXG4gICAgICBlID0gITA7Zm9yIChoIGluIGMpIHtcXG4gICAgICAgIEsoYSwgYiwgaCwgY1toXSwgITAsIGYsIGcpO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIGlmICh2b2lkIDAgIT09IGQgJiYgKGUgPSAhMCwgbi5pc0Z1bmN0aW9uKGQpIHx8IChnID0gITApLCBqICYmIChnID8gKGIuY2FsbChhLCBkKSwgYiA9IG51bGwpIDogKGogPSBiLCBiID0gZnVuY3Rpb24gYihhLCBfYiwgYykge1xcbiAgICAgIHJldHVybiBqLmNhbGwobihhKSwgYyk7XFxuICAgIH0pKSwgYikpIGZvciAoOyBpID4gaDsgaCsrKSB7XFxuICAgICAgYihhW2hdLCBjLCBnID8gZCA6IGQuY2FsbChhW2hdLCBoLCBiKGFbaF0sIGMpKSk7XFxuICAgIH1yZXR1cm4gZSA/IGEgOiBqID8gYi5jYWxsKGEpIDogaSA/IGIoYVswXSwgYykgOiBmO1xcbiAgfSxcXG4gICAgICBMID0gZnVuY3Rpb24gTChhKSB7XFxuICAgIHJldHVybiAxID09PSBhLm5vZGVUeXBlIHx8IDkgPT09IGEubm9kZVR5cGUgfHwgISthLm5vZGVUeXBlO1xcbiAgfTtmdW5jdGlvbiBNKCkge1xcbiAgICB0aGlzLmV4cGFuZG8gPSBuLmV4cGFuZG8gKyBNLnVpZCsrO1xcbiAgfU0udWlkID0gMSwgTS5wcm90b3R5cGUgPSB7IHJlZ2lzdGVyOiBmdW5jdGlvbiByZWdpc3RlcihhLCBiKSB7XFxuICAgICAgdmFyIGMgPSBiIHx8IHt9O3JldHVybiBhLm5vZGVUeXBlID8gYVt0aGlzLmV4cGFuZG9dID0gYyA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLCB0aGlzLmV4cGFuZG8sIHsgdmFsdWU6IGMsIHdyaXRhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCB9KSwgYVt0aGlzLmV4cGFuZG9dO1xcbiAgICB9LCBjYWNoZTogZnVuY3Rpb24gY2FjaGUoYSkge1xcbiAgICAgIGlmICghTChhKSkgcmV0dXJuIHt9O3ZhciBiID0gYVt0aGlzLmV4cGFuZG9dO3JldHVybiBiIHx8IChiID0ge30sIEwoYSkgJiYgKGEubm9kZVR5cGUgPyBhW3RoaXMuZXhwYW5kb10gPSBiIDogT2JqZWN0LmRlZmluZVByb3BlcnR5KGEsIHRoaXMuZXhwYW5kbywgeyB2YWx1ZTogYiwgY29uZmlndXJhYmxlOiAhMCB9KSkpLCBiO1xcbiAgICB9LCBzZXQ6IGZ1bmN0aW9uIHNldChhLCBiLCBjKSB7XFxuICAgICAgdmFyIGQsXFxuICAgICAgICAgIGUgPSB0aGlzLmNhY2hlKGEpO2lmIChcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYikgZVtiXSA9IGM7ZWxzZSBmb3IgKGQgaW4gYikge1xcbiAgICAgICAgZVtkXSA9IGJbZF07XFxuICAgICAgfXJldHVybiBlO1xcbiAgICB9LCBnZXQ6IGZ1bmN0aW9uIGdldChhLCBiKSB7XFxuICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gYiA/IHRoaXMuY2FjaGUoYSkgOiBhW3RoaXMuZXhwYW5kb10gJiYgYVt0aGlzLmV4cGFuZG9dW2JdO1xcbiAgICB9LCBhY2Nlc3M6IGZ1bmN0aW9uIGFjY2VzcyhhLCBiLCBjKSB7XFxuICAgICAgdmFyIGQ7cmV0dXJuIHZvaWQgMCA9PT0gYiB8fCBiICYmIFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBiICYmIHZvaWQgMCA9PT0gYyA/IChkID0gdGhpcy5nZXQoYSwgYiksIHZvaWQgMCAhPT0gZCA/IGQgOiB0aGlzLmdldChhLCBuLmNhbWVsQ2FzZShiKSkpIDogKHRoaXMuc2V0KGEsIGIsIGMpLCB2b2lkIDAgIT09IGMgPyBjIDogYik7XFxuICAgIH0sIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGEsIGIpIHtcXG4gICAgICB2YXIgYyxcXG4gICAgICAgICAgZCxcXG4gICAgICAgICAgZSxcXG4gICAgICAgICAgZiA9IGFbdGhpcy5leHBhbmRvXTtpZiAodm9pZCAwICE9PSBmKSB7XFxuICAgICAgICBpZiAodm9pZCAwID09PSBiKSB0aGlzLnJlZ2lzdGVyKGEpO2Vsc2Uge1xcbiAgICAgICAgICBuLmlzQXJyYXkoYikgPyBkID0gYi5jb25jYXQoYi5tYXAobi5jYW1lbENhc2UpKSA6IChlID0gbi5jYW1lbENhc2UoYiksIGIgaW4gZiA/IGQgPSBbYiwgZV0gOiAoZCA9IGUsIGQgPSBkIGluIGYgPyBbZF0gOiBkLm1hdGNoKEcpIHx8IFtdKSksIGMgPSBkLmxlbmd0aDt3aGlsZSAoYy0tKSB7XFxuICAgICAgICAgICAgZGVsZXRlIGZbZFtjXV07XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0odm9pZCAwID09PSBiIHx8IG4uaXNFbXB0eU9iamVjdChmKSkgJiYgKGEubm9kZVR5cGUgPyBhW3RoaXMuZXhwYW5kb10gPSB2b2lkIDAgOiBkZWxldGUgYVt0aGlzLmV4cGFuZG9dKTtcXG4gICAgICB9XFxuICAgIH0sIGhhc0RhdGE6IGZ1bmN0aW9uIGhhc0RhdGEoYSkge1xcbiAgICAgIHZhciBiID0gYVt0aGlzLmV4cGFuZG9dO3JldHVybiB2b2lkIDAgIT09IGIgJiYgIW4uaXNFbXB0eU9iamVjdChiKTtcXG4gICAgfSB9O3ZhciBOID0gbmV3IE0oKSxcXG4gICAgICBPID0gbmV3IE0oKSxcXG4gICAgICBQID0gL14oPzpcXFxce1tcXFxcd1xcXFxXXSpcXFxcfXxcXFxcW1tcXFxcd1xcXFxXXSpcXFxcXSkkLyxcXG4gICAgICBRID0gL1tBLVpdL2c7ZnVuY3Rpb24gUihhLCBiLCBjKSB7XFxuICAgIHZhciBkO2lmICh2b2lkIDAgPT09IGMgJiYgMSA9PT0gYS5ub2RlVHlwZSkgaWYgKGQgPSBcXFwiZGF0YS1cXFwiICsgYi5yZXBsYWNlKFEsIFxcXCItJCZcXFwiKS50b0xvd2VyQ2FzZSgpLCBjID0gYS5nZXRBdHRyaWJ1dGUoZCksIFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBjKSB7XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIGMgPSBcXFwidHJ1ZVxcXCIgPT09IGMgPyAhMCA6IFxcXCJmYWxzZVxcXCIgPT09IGMgPyAhMSA6IFxcXCJudWxsXFxcIiA9PT0gYyA/IG51bGwgOiArYyArIFxcXCJcXFwiID09PSBjID8gK2MgOiBQLnRlc3QoYykgPyBuLnBhcnNlSlNPTihjKSA6IGM7XFxuICAgICAgfSBjYXRjaCAoZSkge31PLnNldChhLCBiLCBjKTtcXG4gICAgfSBlbHNlIGMgPSB2b2lkIDA7cmV0dXJuIGM7XFxuICB9bi5leHRlbmQoeyBoYXNEYXRhOiBmdW5jdGlvbiBoYXNEYXRhKGEpIHtcXG4gICAgICByZXR1cm4gTy5oYXNEYXRhKGEpIHx8IE4uaGFzRGF0YShhKTtcXG4gICAgfSwgZGF0YTogZnVuY3Rpb24gZGF0YShhLCBiLCBjKSB7XFxuICAgICAgcmV0dXJuIE8uYWNjZXNzKGEsIGIsIGMpO1xcbiAgICB9LCByZW1vdmVEYXRhOiBmdW5jdGlvbiByZW1vdmVEYXRhKGEsIGIpIHtcXG4gICAgICBPLnJlbW92ZShhLCBiKTtcXG4gICAgfSwgX2RhdGE6IGZ1bmN0aW9uIF9kYXRhKGEsIGIsIGMpIHtcXG4gICAgICByZXR1cm4gTi5hY2Nlc3MoYSwgYiwgYyk7XFxuICAgIH0sIF9yZW1vdmVEYXRhOiBmdW5jdGlvbiBfcmVtb3ZlRGF0YShhLCBiKSB7XFxuICAgICAgTi5yZW1vdmUoYSwgYik7XFxuICAgIH0gfSksIG4uZm4uZXh0ZW5kKHsgZGF0YTogZnVuY3Rpb24gZGF0YShhLCBiKSB7XFxuICAgICAgdmFyIGMsXFxuICAgICAgICAgIGQsXFxuICAgICAgICAgIGUsXFxuICAgICAgICAgIGYgPSB0aGlzWzBdLFxcbiAgICAgICAgICBnID0gZiAmJiBmLmF0dHJpYnV0ZXM7aWYgKHZvaWQgMCA9PT0gYSkge1xcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoICYmIChlID0gTy5nZXQoZiksIDEgPT09IGYubm9kZVR5cGUgJiYgIU4uZ2V0KGYsIFxcXCJoYXNEYXRhQXR0cnNcXFwiKSkpIHtcXG4gICAgICAgICAgYyA9IGcubGVuZ3RoO3doaWxlIChjLS0pIHtcXG4gICAgICAgICAgICBnW2NdICYmIChkID0gZ1tjXS5uYW1lLCAwID09PSBkLmluZGV4T2YoXFxcImRhdGEtXFxcIikgJiYgKGQgPSBuLmNhbWVsQ2FzZShkLnNsaWNlKDUpKSwgUihmLCBkLCBlW2RdKSkpO1xcbiAgICAgICAgICB9Ti5zZXQoZiwgXFxcImhhc0RhdGFBdHRyc1xcXCIsICEwKTtcXG4gICAgICAgIH1yZXR1cm4gZTtcXG4gICAgICB9cmV0dXJuIFxcXCJvYmplY3RcXFwiID09ICh0eXBlb2YgYSA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YoYSkpID8gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIE8uc2V0KHRoaXMsIGEpO1xcbiAgICAgIH0pIDogSyh0aGlzLCBmdW5jdGlvbiAoYikge1xcbiAgICAgICAgdmFyIGMsIGQ7aWYgKGYgJiYgdm9pZCAwID09PSBiKSB7XFxuICAgICAgICAgIGlmIChjID0gTy5nZXQoZiwgYSkgfHwgTy5nZXQoZiwgYS5yZXBsYWNlKFEsIFxcXCItJCZcXFwiKS50b0xvd2VyQ2FzZSgpKSwgdm9pZCAwICE9PSBjKSByZXR1cm4gYztpZiAoZCA9IG4uY2FtZWxDYXNlKGEpLCBjID0gTy5nZXQoZiwgZCksIHZvaWQgMCAhPT0gYykgcmV0dXJuIGM7aWYgKGMgPSBSKGYsIGQsIHZvaWQgMCksIHZvaWQgMCAhPT0gYykgcmV0dXJuIGM7XFxuICAgICAgICB9IGVsc2UgZCA9IG4uY2FtZWxDYXNlKGEpLCB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB2YXIgYyA9IE8uZ2V0KHRoaXMsIGQpO08uc2V0KHRoaXMsIGQsIGIpLCBhLmluZGV4T2YoXFxcIi1cXFwiKSA+IC0xICYmIHZvaWQgMCAhPT0gYyAmJiBPLnNldCh0aGlzLCBhLCBiKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0sIG51bGwsIGIsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCAhMCk7XFxuICAgIH0sIHJlbW92ZURhdGE6IGZ1bmN0aW9uIHJlbW92ZURhdGEoYSkge1xcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgTy5yZW1vdmUodGhpcywgYSk7XFxuICAgICAgfSk7XFxuICAgIH0gfSksIG4uZXh0ZW5kKHsgcXVldWU6IGZ1bmN0aW9uIHF1ZXVlKGEsIGIsIGMpIHtcXG4gICAgICB2YXIgZDtyZXR1cm4gYSA/IChiID0gKGIgfHwgXFxcImZ4XFxcIikgKyBcXFwicXVldWVcXFwiLCBkID0gTi5nZXQoYSwgYiksIGMgJiYgKCFkIHx8IG4uaXNBcnJheShjKSA/IGQgPSBOLmFjY2VzcyhhLCBiLCBuLm1ha2VBcnJheShjKSkgOiBkLnB1c2goYykpLCBkIHx8IFtdKSA6IHZvaWQgMDtcXG4gICAgfSwgZGVxdWV1ZTogZnVuY3Rpb24gZGVxdWV1ZShhLCBiKSB7XFxuICAgICAgYiA9IGIgfHwgXFxcImZ4XFxcIjt2YXIgYyA9IG4ucXVldWUoYSwgYiksXFxuICAgICAgICAgIGQgPSBjLmxlbmd0aCxcXG4gICAgICAgICAgZSA9IGMuc2hpZnQoKSxcXG4gICAgICAgICAgZiA9IG4uX3F1ZXVlSG9va3MoYSwgYiksXFxuICAgICAgICAgIGcgPSBmdW5jdGlvbiBnKCkge1xcbiAgICAgICAgbi5kZXF1ZXVlKGEsIGIpO1xcbiAgICAgIH07XFxcImlucHJvZ3Jlc3NcXFwiID09PSBlICYmIChlID0gYy5zaGlmdCgpLCBkLS0pLCBlICYmIChcXFwiZnhcXFwiID09PSBiICYmIGMudW5zaGlmdChcXFwiaW5wcm9ncmVzc1xcXCIpLCBkZWxldGUgZi5zdG9wLCBlLmNhbGwoYSwgZywgZikpLCAhZCAmJiBmICYmIGYuZW1wdHkuZmlyZSgpO1xcbiAgICB9LCBfcXVldWVIb29rczogZnVuY3Rpb24gX3F1ZXVlSG9va3MoYSwgYikge1xcbiAgICAgIHZhciBjID0gYiArIFxcXCJxdWV1ZUhvb2tzXFxcIjtyZXR1cm4gTi5nZXQoYSwgYykgfHwgTi5hY2Nlc3MoYSwgYywgeyBlbXB0eTogbi5DYWxsYmFja3MoXFxcIm9uY2UgbWVtb3J5XFxcIikuYWRkKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgTi5yZW1vdmUoYSwgW2IgKyBcXFwicXVldWVcXFwiLCBjXSk7XFxuICAgICAgICB9KSB9KTtcXG4gICAgfSB9KSwgbi5mbi5leHRlbmQoeyBxdWV1ZTogZnVuY3Rpb24gcXVldWUoYSwgYikge1xcbiAgICAgIHZhciBjID0gMjtyZXR1cm4gXFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGEgJiYgKGIgPSBhLCBhID0gXFxcImZ4XFxcIiwgYy0tKSwgYXJndW1lbnRzLmxlbmd0aCA8IGMgPyBuLnF1ZXVlKHRoaXNbMF0sIGEpIDogdm9pZCAwID09PSBiID8gdGhpcyA6IHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgYyA9IG4ucXVldWUodGhpcywgYSwgYik7bi5fcXVldWVIb29rcyh0aGlzLCBhKSwgXFxcImZ4XFxcIiA9PT0gYSAmJiBcXFwiaW5wcm9ncmVzc1xcXCIgIT09IGNbMF0gJiYgbi5kZXF1ZXVlKHRoaXMsIGEpO1xcbiAgICAgIH0pO1xcbiAgICB9LCBkZXF1ZXVlOiBmdW5jdGlvbiBkZXF1ZXVlKGEpIHtcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIG4uZGVxdWV1ZSh0aGlzLCBhKTtcXG4gICAgICB9KTtcXG4gICAgfSwgY2xlYXJRdWV1ZTogZnVuY3Rpb24gY2xlYXJRdWV1ZShhKSB7XFxuICAgICAgcmV0dXJuIHRoaXMucXVldWUoYSB8fCBcXFwiZnhcXFwiLCBbXSk7XFxuICAgIH0sIHByb21pc2U6IGZ1bmN0aW9uIHByb21pc2UoYSwgYikge1xcbiAgICAgIHZhciBjLFxcbiAgICAgICAgICBkID0gMSxcXG4gICAgICAgICAgZSA9IG4uRGVmZXJyZWQoKSxcXG4gICAgICAgICAgZiA9IHRoaXMsXFxuICAgICAgICAgIGcgPSB0aGlzLmxlbmd0aCxcXG4gICAgICAgICAgaCA9IGZ1bmN0aW9uIGgoKSB7XFxuICAgICAgICAtLWQgfHwgZS5yZXNvbHZlV2l0aChmLCBbZl0pO1xcbiAgICAgIH07XFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGEgJiYgKGIgPSBhLCBhID0gdm9pZCAwKSwgYSA9IGEgfHwgXFxcImZ4XFxcIjt3aGlsZSAoZy0tKSB7XFxuICAgICAgICBjID0gTi5nZXQoZltnXSwgYSArIFxcXCJxdWV1ZUhvb2tzXFxcIiksIGMgJiYgYy5lbXB0eSAmJiAoZCsrLCBjLmVtcHR5LmFkZChoKSk7XFxuICAgICAgfXJldHVybiBoKCksIGUucHJvbWlzZShiKTtcXG4gICAgfSB9KTt2YXIgUyA9IC9bKy1dPyg/OlxcXFxkKlxcXFwufClcXFxcZCsoPzpbZUVdWystXT9cXFxcZCt8KS8uc291cmNlLFxcbiAgICAgIFQgPSBuZXcgUmVnRXhwKFxcXCJeKD86KFsrLV0pPXwpKFxcXCIgKyBTICsgXFxcIikoW2EteiVdKikkXFxcIiwgXFxcImlcXFwiKSxcXG4gICAgICBVID0gW1xcXCJUb3BcXFwiLCBcXFwiUmlnaHRcXFwiLCBcXFwiQm90dG9tXFxcIiwgXFxcIkxlZnRcXFwiXSxcXG4gICAgICBWID0gZnVuY3Rpb24gVihhLCBiKSB7XFxuICAgIHJldHVybiBhID0gYiB8fCBhLCBcXFwibm9uZVxcXCIgPT09IG4uY3NzKGEsIFxcXCJkaXNwbGF5XFxcIikgfHwgIW4uY29udGFpbnMoYS5vd25lckRvY3VtZW50LCBhKTtcXG4gIH07ZnVuY3Rpb24gVyhhLCBiLCBjLCBkKSB7XFxuICAgIHZhciBlLFxcbiAgICAgICAgZiA9IDEsXFxuICAgICAgICBnID0gMjAsXFxuICAgICAgICBoID0gZCA/IGZ1bmN0aW9uICgpIHtcXG4gICAgICByZXR1cm4gZC5jdXIoKTtcXG4gICAgfSA6IGZ1bmN0aW9uICgpIHtcXG4gICAgICByZXR1cm4gbi5jc3MoYSwgYiwgXFxcIlxcXCIpO1xcbiAgICB9LFxcbiAgICAgICAgaSA9IGgoKSxcXG4gICAgICAgIGogPSBjICYmIGNbM10gfHwgKG4uY3NzTnVtYmVyW2JdID8gXFxcIlxcXCIgOiBcXFwicHhcXFwiKSxcXG4gICAgICAgIGsgPSAobi5jc3NOdW1iZXJbYl0gfHwgXFxcInB4XFxcIiAhPT0gaiAmJiAraSkgJiYgVC5leGVjKG4uY3NzKGEsIGIpKTtpZiAoayAmJiBrWzNdICE9PSBqKSB7XFxuICAgICAgaiA9IGogfHwga1szXSwgYyA9IGMgfHwgW10sIGsgPSAraSB8fCAxO2RvIHtcXG4gICAgICAgIGYgPSBmIHx8IFxcXCIuNVxcXCIsIGsgLz0gZiwgbi5zdHlsZShhLCBiLCBrICsgaik7XFxuICAgICAgfSB3aGlsZSAoZiAhPT0gKGYgPSBoKCkgLyBpKSAmJiAxICE9PSBmICYmIC0tZyk7XFxuICAgIH1yZXR1cm4gYyAmJiAoayA9ICtrIHx8ICtpIHx8IDAsIGUgPSBjWzFdID8gayArIChjWzFdICsgMSkgKiBjWzJdIDogK2NbMl0sIGQgJiYgKGQudW5pdCA9IGosIGQuc3RhcnQgPSBrLCBkLmVuZCA9IGUpKSwgZTtcXG4gIH12YXIgWCA9IC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pLFxcbiAgICAgIFkgPSAvPChbXFxcXHc6LV0rKS8sXFxuICAgICAgWiA9IC9eJHxcXFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaSxcXG4gICAgICAkID0geyBvcHRpb246IFsxLCBcXFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlxcXCIsIFxcXCI8L3NlbGVjdD5cXFwiXSwgdGhlYWQ6IFsxLCBcXFwiPHRhYmxlPlxcXCIsIFxcXCI8L3RhYmxlPlxcXCJdLCBjb2w6IFsyLCBcXFwiPHRhYmxlPjxjb2xncm91cD5cXFwiLCBcXFwiPC9jb2xncm91cD48L3RhYmxlPlxcXCJdLCB0cjogWzIsIFxcXCI8dGFibGU+PHRib2R5PlxcXCIsIFxcXCI8L3Rib2R5PjwvdGFibGU+XFxcIl0sIHRkOiBbMywgXFxcIjx0YWJsZT48dGJvZHk+PHRyPlxcXCIsIFxcXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cXFwiXSwgX2RlZmF1bHQ6IFswLCBcXFwiXFxcIiwgXFxcIlxcXCJdIH07JC5vcHRncm91cCA9ICQub3B0aW9uLCAkLnRib2R5ID0gJC50Zm9vdCA9ICQuY29sZ3JvdXAgPSAkLmNhcHRpb24gPSAkLnRoZWFkLCAkLnRoID0gJC50ZDtmdW5jdGlvbiBfKGEsIGIpIHtcXG4gICAgdmFyIGMgPSBcXFwidW5kZWZpbmVkXFxcIiAhPSB0eXBlb2YgYS5nZXRFbGVtZW50c0J5VGFnTmFtZSA/IGEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoYiB8fCBcXFwiKlxcXCIpIDogXFxcInVuZGVmaW5lZFxcXCIgIT0gdHlwZW9mIGEucXVlcnlTZWxlY3RvckFsbCA/IGEucXVlcnlTZWxlY3RvckFsbChiIHx8IFxcXCIqXFxcIikgOiBbXTtyZXR1cm4gdm9pZCAwID09PSBiIHx8IGIgJiYgbi5ub2RlTmFtZShhLCBiKSA/IG4ubWVyZ2UoW2FdLCBjKSA6IGM7XFxuICB9ZnVuY3Rpb24gYWEoYSwgYikge1xcbiAgICBmb3IgKHZhciBjID0gMCwgZCA9IGEubGVuZ3RoOyBkID4gYzsgYysrKSB7XFxuICAgICAgTi5zZXQoYVtjXSwgXFxcImdsb2JhbEV2YWxcXFwiLCAhYiB8fCBOLmdldChiW2NdLCBcXFwiZ2xvYmFsRXZhbFxcXCIpKTtcXG4gICAgfVxcbiAgfXZhciBiYSA9IC88fCYjP1xcXFx3KzsvO2Z1bmN0aW9uIGNhKGEsIGIsIGMsIGQsIGUpIHtcXG4gICAgZm9yICh2YXIgZiwgZywgaCwgaSwgaiwgaywgbCA9IGIuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBtID0gW10sIG8gPSAwLCBwID0gYS5sZW5ndGg7IHAgPiBvOyBvKyspIHtcXG4gICAgICBpZiAoZiA9IGFbb10sIGYgfHwgMCA9PT0gZikgaWYgKFxcXCJvYmplY3RcXFwiID09PSBuLnR5cGUoZikpIG4ubWVyZ2UobSwgZi5ub2RlVHlwZSA/IFtmXSA6IGYpO2Vsc2UgaWYgKGJhLnRlc3QoZikpIHtcXG4gICAgICAgIGcgPSBnIHx8IGwuYXBwZW5kQ2hpbGQoYi5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKSksIGggPSAoWS5leGVjKGYpIHx8IFtcXFwiXFxcIiwgXFxcIlxcXCJdKVsxXS50b0xvd2VyQ2FzZSgpLCBpID0gJFtoXSB8fCAkLl9kZWZhdWx0LCBnLmlubmVySFRNTCA9IGlbMV0gKyBuLmh0bWxQcmVmaWx0ZXIoZikgKyBpWzJdLCBrID0gaVswXTt3aGlsZSAoay0tKSB7XFxuICAgICAgICAgIGcgPSBnLmxhc3RDaGlsZDtcXG4gICAgICAgIH1uLm1lcmdlKG0sIGcuY2hpbGROb2RlcyksIGcgPSBsLmZpcnN0Q2hpbGQsIGcudGV4dENvbnRlbnQgPSBcXFwiXFxcIjtcXG4gICAgICB9IGVsc2UgbS5wdXNoKGIuY3JlYXRlVGV4dE5vZGUoZikpO1xcbiAgICB9bC50ZXh0Q29udGVudCA9IFxcXCJcXFwiLCBvID0gMDt3aGlsZSAoZiA9IG1bbysrXSkge1xcbiAgICAgIGlmIChkICYmIG4uaW5BcnJheShmLCBkKSA+IC0xKSBlICYmIGUucHVzaChmKTtlbHNlIGlmIChqID0gbi5jb250YWlucyhmLm93bmVyRG9jdW1lbnQsIGYpLCBnID0gXyhsLmFwcGVuZENoaWxkKGYpLCBcXFwic2NyaXB0XFxcIiksIGogJiYgYWEoZyksIGMpIHtcXG4gICAgICAgIGsgPSAwO3doaWxlIChmID0gZ1trKytdKSB7XFxuICAgICAgICAgIFoudGVzdChmLnR5cGUgfHwgXFxcIlxcXCIpICYmIGMucHVzaChmKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1yZXR1cm4gbDtcXG4gIH0hZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgYSA9IGQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxcbiAgICAgICAgYiA9IGEuYXBwZW5kQ2hpbGQoZC5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKSksXFxuICAgICAgICBjID0gZC5jcmVhdGVFbGVtZW50KFxcXCJpbnB1dFxcXCIpO2Muc2V0QXR0cmlidXRlKFxcXCJ0eXBlXFxcIiwgXFxcInJhZGlvXFxcIiksIGMuc2V0QXR0cmlidXRlKFxcXCJjaGVja2VkXFxcIiwgXFxcImNoZWNrZWRcXFwiKSwgYy5zZXRBdHRyaWJ1dGUoXFxcIm5hbWVcXFwiLCBcXFwidFxcXCIpLCBiLmFwcGVuZENoaWxkKGMpLCBsLmNoZWNrQ2xvbmUgPSBiLmNsb25lTm9kZSghMCkuY2xvbmVOb2RlKCEwKS5sYXN0Q2hpbGQuY2hlY2tlZCwgYi5pbm5lckhUTUwgPSBcXFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlxcXCIsIGwubm9DbG9uZUNoZWNrZWQgPSAhIWIuY2xvbmVOb2RlKCEwKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlO1xcbiAgfSgpO3ZhciBkYSA9IC9ea2V5LyxcXG4gICAgICBlYSA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxcXG4gICAgICBmYSA9IC9eKFteLl0qKSg/OlxcXFwuKC4rKXwpLztmdW5jdGlvbiBnYSgpIHtcXG4gICAgcmV0dXJuICEwO1xcbiAgfWZ1bmN0aW9uIGhhKCkge1xcbiAgICByZXR1cm4gITE7XFxuICB9ZnVuY3Rpb24gaWEoKSB7XFxuICAgIHRyeSB7XFxuICAgICAgcmV0dXJuIGQuYWN0aXZlRWxlbWVudDtcXG4gICAgfSBjYXRjaCAoYSkge31cXG4gIH1mdW5jdGlvbiBqYShhLCBiLCBjLCBkLCBlLCBmKSB7XFxuICAgIHZhciBnLCBoO2lmIChcXFwib2JqZWN0XFxcIiA9PSAodHlwZW9mIGIgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKGIpKSkge1xcbiAgICAgIFxcXCJzdHJpbmdcXFwiICE9IHR5cGVvZiBjICYmIChkID0gZCB8fCBjLCBjID0gdm9pZCAwKTtmb3IgKGggaW4gYikge1xcbiAgICAgICAgamEoYSwgaCwgYywgZCwgYltoXSwgZik7XFxuICAgICAgfXJldHVybiBhO1xcbiAgICB9aWYgKG51bGwgPT0gZCAmJiBudWxsID09IGUgPyAoZSA9IGMsIGQgPSBjID0gdm9pZCAwKSA6IG51bGwgPT0gZSAmJiAoXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIGMgPyAoZSA9IGQsIGQgPSB2b2lkIDApIDogKGUgPSBkLCBkID0gYywgYyA9IHZvaWQgMCkpLCBlID09PSAhMSkgZSA9IGhhO2Vsc2UgaWYgKCFlKSByZXR1cm4gYTtyZXR1cm4gMSA9PT0gZiAmJiAoZyA9IGUsIGUgPSBmdW5jdGlvbiBlKGEpIHtcXG4gICAgICByZXR1cm4gbigpLm9mZihhKSwgZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICB9LCBlLmd1aWQgPSBnLmd1aWQgfHwgKGcuZ3VpZCA9IG4uZ3VpZCsrKSksIGEuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgbi5ldmVudC5hZGQodGhpcywgYiwgZSwgZCwgYyk7XFxuICAgIH0pO1xcbiAgfW4uZXZlbnQgPSB7IGdsb2JhbDoge30sIGFkZDogZnVuY3Rpb24gYWRkKGEsIGIsIGMsIGQsIGUpIHtcXG4gICAgICB2YXIgZixcXG4gICAgICAgICAgZyxcXG4gICAgICAgICAgaCxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgayxcXG4gICAgICAgICAgbCxcXG4gICAgICAgICAgbSxcXG4gICAgICAgICAgbyxcXG4gICAgICAgICAgcCxcXG4gICAgICAgICAgcSxcXG4gICAgICAgICAgciA9IE4uZ2V0KGEpO2lmIChyKSB7XFxuICAgICAgICBjLmhhbmRsZXIgJiYgKGYgPSBjLCBjID0gZi5oYW5kbGVyLCBlID0gZi5zZWxlY3RvciksIGMuZ3VpZCB8fCAoYy5ndWlkID0gbi5ndWlkKyspLCAoaSA9IHIuZXZlbnRzKSB8fCAoaSA9IHIuZXZlbnRzID0ge30pLCAoZyA9IHIuaGFuZGxlKSB8fCAoZyA9IHIuaGFuZGxlID0gZnVuY3Rpb24gKGIpIHtcXG4gICAgICAgICAgcmV0dXJuIFxcXCJ1bmRlZmluZWRcXFwiICE9IHR5cGVvZiBuICYmIG4uZXZlbnQudHJpZ2dlcmVkICE9PSBiLnR5cGUgPyBuLmV2ZW50LmRpc3BhdGNoLmFwcGx5KGEsIGFyZ3VtZW50cykgOiB2b2lkIDA7XFxuICAgICAgICB9KSwgYiA9IChiIHx8IFxcXCJcXFwiKS5tYXRjaChHKSB8fCBbXFxcIlxcXCJdLCBqID0gYi5sZW5ndGg7d2hpbGUgKGotLSkge1xcbiAgICAgICAgICBoID0gZmEuZXhlYyhiW2pdKSB8fCBbXSwgbyA9IHEgPSBoWzFdLCBwID0gKGhbMl0gfHwgXFxcIlxcXCIpLnNwbGl0KFxcXCIuXFxcIikuc29ydCgpLCBvICYmIChsID0gbi5ldmVudC5zcGVjaWFsW29dIHx8IHt9LCBvID0gKGUgPyBsLmRlbGVnYXRlVHlwZSA6IGwuYmluZFR5cGUpIHx8IG8sIGwgPSBuLmV2ZW50LnNwZWNpYWxbb10gfHwge30sIGsgPSBuLmV4dGVuZCh7IHR5cGU6IG8sIG9yaWdUeXBlOiBxLCBkYXRhOiBkLCBoYW5kbGVyOiBjLCBndWlkOiBjLmd1aWQsIHNlbGVjdG9yOiBlLCBuZWVkc0NvbnRleHQ6IGUgJiYgbi5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KGUpLCBuYW1lc3BhY2U6IHAuam9pbihcXFwiLlxcXCIpIH0sIGYpLCAobSA9IGlbb10pIHx8IChtID0gaVtvXSA9IFtdLCBtLmRlbGVnYXRlQ291bnQgPSAwLCBsLnNldHVwICYmIGwuc2V0dXAuY2FsbChhLCBkLCBwLCBnKSAhPT0gITEgfHwgYS5hZGRFdmVudExpc3RlbmVyICYmIGEuYWRkRXZlbnRMaXN0ZW5lcihvLCBnKSksIGwuYWRkICYmIChsLmFkZC5jYWxsKGEsIGspLCBrLmhhbmRsZXIuZ3VpZCB8fCAoay5oYW5kbGVyLmd1aWQgPSBjLmd1aWQpKSwgZSA/IG0uc3BsaWNlKG0uZGVsZWdhdGVDb3VudCsrLCAwLCBrKSA6IG0ucHVzaChrKSwgbi5ldmVudC5nbG9iYWxbb10gPSAhMCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9LCByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShhLCBiLCBjLCBkLCBlKSB7XFxuICAgICAgdmFyIGYsXFxuICAgICAgICAgIGcsXFxuICAgICAgICAgIGgsXFxuICAgICAgICAgIGksXFxuICAgICAgICAgIGosXFxuICAgICAgICAgIGssXFxuICAgICAgICAgIGwsXFxuICAgICAgICAgIG0sXFxuICAgICAgICAgIG8sXFxuICAgICAgICAgIHAsXFxuICAgICAgICAgIHEsXFxuICAgICAgICAgIHIgPSBOLmhhc0RhdGEoYSkgJiYgTi5nZXQoYSk7aWYgKHIgJiYgKGkgPSByLmV2ZW50cykpIHtcXG4gICAgICAgIGIgPSAoYiB8fCBcXFwiXFxcIikubWF0Y2goRykgfHwgW1xcXCJcXFwiXSwgaiA9IGIubGVuZ3RoO3doaWxlIChqLS0pIHtcXG4gICAgICAgICAgaWYgKGggPSBmYS5leGVjKGJbal0pIHx8IFtdLCBvID0gcSA9IGhbMV0sIHAgPSAoaFsyXSB8fCBcXFwiXFxcIikuc3BsaXQoXFxcIi5cXFwiKS5zb3J0KCksIG8pIHtcXG4gICAgICAgICAgICBsID0gbi5ldmVudC5zcGVjaWFsW29dIHx8IHt9LCBvID0gKGQgPyBsLmRlbGVnYXRlVHlwZSA6IGwuYmluZFR5cGUpIHx8IG8sIG0gPSBpW29dIHx8IFtdLCBoID0gaFsyXSAmJiBuZXcgUmVnRXhwKFxcXCIoXnxcXFxcXFxcXC4pXFxcIiArIHAuam9pbihcXFwiXFxcXFxcXFwuKD86LipcXFxcXFxcXC58KVxcXCIpICsgXFxcIihcXFxcXFxcXC58JClcXFwiKSwgZyA9IGYgPSBtLmxlbmd0aDt3aGlsZSAoZi0tKSB7XFxuICAgICAgICAgICAgICBrID0gbVtmXSwgIWUgJiYgcSAhPT0gay5vcmlnVHlwZSB8fCBjICYmIGMuZ3VpZCAhPT0gay5ndWlkIHx8IGggJiYgIWgudGVzdChrLm5hbWVzcGFjZSkgfHwgZCAmJiBkICE9PSBrLnNlbGVjdG9yICYmIChcXFwiKipcXFwiICE9PSBkIHx8ICFrLnNlbGVjdG9yKSB8fCAobS5zcGxpY2UoZiwgMSksIGsuc2VsZWN0b3IgJiYgbS5kZWxlZ2F0ZUNvdW50LS0sIGwucmVtb3ZlICYmIGwucmVtb3ZlLmNhbGwoYSwgaykpO1xcbiAgICAgICAgICAgIH1nICYmICFtLmxlbmd0aCAmJiAobC50ZWFyZG93biAmJiBsLnRlYXJkb3duLmNhbGwoYSwgcCwgci5oYW5kbGUpICE9PSAhMSB8fCBuLnJlbW92ZUV2ZW50KGEsIG8sIHIuaGFuZGxlKSwgZGVsZXRlIGlbb10pO1xcbiAgICAgICAgICB9IGVsc2UgZm9yIChvIGluIGkpIHtcXG4gICAgICAgICAgICBuLmV2ZW50LnJlbW92ZShhLCBvICsgYltqXSwgYywgZCwgITApO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9bi5pc0VtcHR5T2JqZWN0KGkpICYmIE4ucmVtb3ZlKGEsIFxcXCJoYW5kbGUgZXZlbnRzXFxcIik7XFxuICAgICAgfVxcbiAgICB9LCBkaXNwYXRjaDogZnVuY3Rpb24gZGlzcGF0Y2goYSkge1xcbiAgICAgIGEgPSBuLmV2ZW50LmZpeChhKTt2YXIgYixcXG4gICAgICAgICAgYyxcXG4gICAgICAgICAgZCxcXG4gICAgICAgICAgZixcXG4gICAgICAgICAgZyxcXG4gICAgICAgICAgaCA9IFtdLFxcbiAgICAgICAgICBpID0gZS5jYWxsKGFyZ3VtZW50cyksXFxuICAgICAgICAgIGogPSAoTi5nZXQodGhpcywgXFxcImV2ZW50c1xcXCIpIHx8IHt9KVthLnR5cGVdIHx8IFtdLFxcbiAgICAgICAgICBrID0gbi5ldmVudC5zcGVjaWFsW2EudHlwZV0gfHwge307aWYgKGlbMF0gPSBhLCBhLmRlbGVnYXRlVGFyZ2V0ID0gdGhpcywgIWsucHJlRGlzcGF0Y2ggfHwgay5wcmVEaXNwYXRjaC5jYWxsKHRoaXMsIGEpICE9PSAhMSkge1xcbiAgICAgICAgaCA9IG4uZXZlbnQuaGFuZGxlcnMuY2FsbCh0aGlzLCBhLCBqKSwgYiA9IDA7d2hpbGUgKChmID0gaFtiKytdKSAmJiAhYS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XFxuICAgICAgICAgIGEuY3VycmVudFRhcmdldCA9IGYuZWxlbSwgYyA9IDA7d2hpbGUgKChnID0gZi5oYW5kbGVyc1tjKytdKSAmJiAhYS5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XFxuICAgICAgICAgICAgYS5ybmFtZXNwYWNlICYmICFhLnJuYW1lc3BhY2UudGVzdChnLm5hbWVzcGFjZSkgfHwgKGEuaGFuZGxlT2JqID0gZywgYS5kYXRhID0gZy5kYXRhLCBkID0gKChuLmV2ZW50LnNwZWNpYWxbZy5vcmlnVHlwZV0gfHwge30pLmhhbmRsZSB8fCBnLmhhbmRsZXIpLmFwcGx5KGYuZWxlbSwgaSksIHZvaWQgMCAhPT0gZCAmJiAoYS5yZXN1bHQgPSBkKSA9PT0gITEgJiYgKGEucHJldmVudERlZmF1bHQoKSwgYS5zdG9wUHJvcGFnYXRpb24oKSkpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9cmV0dXJuIGsucG9zdERpc3BhdGNoICYmIGsucG9zdERpc3BhdGNoLmNhbGwodGhpcywgYSksIGEucmVzdWx0O1xcbiAgICAgIH1cXG4gICAgfSwgaGFuZGxlcnM6IGZ1bmN0aW9uIGhhbmRsZXJzKGEsIGIpIHtcXG4gICAgICB2YXIgYyxcXG4gICAgICAgICAgZCxcXG4gICAgICAgICAgZSxcXG4gICAgICAgICAgZixcXG4gICAgICAgICAgZyA9IFtdLFxcbiAgICAgICAgICBoID0gYi5kZWxlZ2F0ZUNvdW50LFxcbiAgICAgICAgICBpID0gYS50YXJnZXQ7aWYgKGggJiYgaS5ub2RlVHlwZSAmJiAoXFxcImNsaWNrXFxcIiAhPT0gYS50eXBlIHx8IGlzTmFOKGEuYnV0dG9uKSB8fCBhLmJ1dHRvbiA8IDEpKSBmb3IgKDsgaSAhPT0gdGhpczsgaSA9IGkucGFyZW50Tm9kZSB8fCB0aGlzKSB7XFxuICAgICAgICBpZiAoMSA9PT0gaS5ub2RlVHlwZSAmJiAoaS5kaXNhYmxlZCAhPT0gITAgfHwgXFxcImNsaWNrXFxcIiAhPT0gYS50eXBlKSkge1xcbiAgICAgICAgICBmb3IgKGQgPSBbXSwgYyA9IDA7IGggPiBjOyBjKyspIHtcXG4gICAgICAgICAgICBmID0gYltjXSwgZSA9IGYuc2VsZWN0b3IgKyBcXFwiIFxcXCIsIHZvaWQgMCA9PT0gZFtlXSAmJiAoZFtlXSA9IGYubmVlZHNDb250ZXh0ID8gbihlLCB0aGlzKS5pbmRleChpKSA+IC0xIDogbi5maW5kKGUsIHRoaXMsIG51bGwsIFtpXSkubGVuZ3RoKSwgZFtlXSAmJiBkLnB1c2goZik7XFxuICAgICAgICAgIH1kLmxlbmd0aCAmJiBnLnB1c2goeyBlbGVtOiBpLCBoYW5kbGVyczogZCB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9cmV0dXJuIGggPCBiLmxlbmd0aCAmJiBnLnB1c2goeyBlbGVtOiB0aGlzLCBoYW5kbGVyczogYi5zbGljZShoKSB9KSwgZztcXG4gICAgfSwgcHJvcHM6IFxcXCJhbHRLZXkgYnViYmxlcyBjYW5jZWxhYmxlIGN0cmxLZXkgY3VycmVudFRhcmdldCBkZXRhaWwgZXZlbnRQaGFzZSBtZXRhS2V5IHJlbGF0ZWRUYXJnZXQgc2hpZnRLZXkgdGFyZ2V0IHRpbWVTdGFtcCB2aWV3IHdoaWNoXFxcIi5zcGxpdChcXFwiIFxcXCIpLCBmaXhIb29rczoge30sIGtleUhvb2tzOiB7IHByb3BzOiBcXFwiY2hhciBjaGFyQ29kZSBrZXkga2V5Q29kZVxcXCIuc3BsaXQoXFxcIiBcXFwiKSwgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoYSwgYikge1xcbiAgICAgICAgcmV0dXJuIG51bGwgPT0gYS53aGljaCAmJiAoYS53aGljaCA9IG51bGwgIT0gYi5jaGFyQ29kZSA/IGIuY2hhckNvZGUgOiBiLmtleUNvZGUpLCBhO1xcbiAgICAgIH0gfSwgbW91c2VIb29rczogeyBwcm9wczogXFxcImJ1dHRvbiBidXR0b25zIGNsaWVudFggY2xpZW50WSBvZmZzZXRYIG9mZnNldFkgcGFnZVggcGFnZVkgc2NyZWVuWCBzY3JlZW5ZIHRvRWxlbWVudFxcXCIuc3BsaXQoXFxcIiBcXFwiKSwgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoYSwgYikge1xcbiAgICAgICAgdmFyIGMsXFxuICAgICAgICAgICAgZSxcXG4gICAgICAgICAgICBmLFxcbiAgICAgICAgICAgIGcgPSBiLmJ1dHRvbjtyZXR1cm4gbnVsbCA9PSBhLnBhZ2VYICYmIG51bGwgIT0gYi5jbGllbnRYICYmIChjID0gYS50YXJnZXQub3duZXJEb2N1bWVudCB8fCBkLCBlID0gYy5kb2N1bWVudEVsZW1lbnQsIGYgPSBjLmJvZHksIGEucGFnZVggPSBiLmNsaWVudFggKyAoZSAmJiBlLnNjcm9sbExlZnQgfHwgZiAmJiBmLnNjcm9sbExlZnQgfHwgMCkgLSAoZSAmJiBlLmNsaWVudExlZnQgfHwgZiAmJiBmLmNsaWVudExlZnQgfHwgMCksIGEucGFnZVkgPSBiLmNsaWVudFkgKyAoZSAmJiBlLnNjcm9sbFRvcCB8fCBmICYmIGYuc2Nyb2xsVG9wIHx8IDApIC0gKGUgJiYgZS5jbGllbnRUb3AgfHwgZiAmJiBmLmNsaWVudFRvcCB8fCAwKSksIGEud2hpY2ggfHwgdm9pZCAwID09PSBnIHx8IChhLndoaWNoID0gMSAmIGcgPyAxIDogMiAmIGcgPyAzIDogNCAmIGcgPyAyIDogMCksIGE7XFxuICAgICAgfSB9LCBmaXg6IGZ1bmN0aW9uIGZpeChhKSB7XFxuICAgICAgaWYgKGFbbi5leHBhbmRvXSkgcmV0dXJuIGE7dmFyIGIsXFxuICAgICAgICAgIGMsXFxuICAgICAgICAgIGUsXFxuICAgICAgICAgIGYgPSBhLnR5cGUsXFxuICAgICAgICAgIGcgPSBhLFxcbiAgICAgICAgICBoID0gdGhpcy5maXhIb29rc1tmXTtoIHx8ICh0aGlzLmZpeEhvb2tzW2ZdID0gaCA9IGVhLnRlc3QoZikgPyB0aGlzLm1vdXNlSG9va3MgOiBkYS50ZXN0KGYpID8gdGhpcy5rZXlIb29rcyA6IHt9KSwgZSA9IGgucHJvcHMgPyB0aGlzLnByb3BzLmNvbmNhdChoLnByb3BzKSA6IHRoaXMucHJvcHMsIGEgPSBuZXcgbi5FdmVudChnKSwgYiA9IGUubGVuZ3RoO3doaWxlIChiLS0pIHtcXG4gICAgICAgIGMgPSBlW2JdLCBhW2NdID0gZ1tjXTtcXG4gICAgICB9cmV0dXJuIGEudGFyZ2V0IHx8IChhLnRhcmdldCA9IGQpLCAzID09PSBhLnRhcmdldC5ub2RlVHlwZSAmJiAoYS50YXJnZXQgPSBhLnRhcmdldC5wYXJlbnROb2RlKSwgaC5maWx0ZXIgPyBoLmZpbHRlcihhLCBnKSA6IGE7XFxuICAgIH0sIHNwZWNpYWw6IHsgbG9hZDogeyBub0J1YmJsZTogITAgfSwgZm9jdXM6IHsgdHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlcigpIHtcXG4gICAgICAgICAgcmV0dXJuIHRoaXMgIT09IGlhKCkgJiYgdGhpcy5mb2N1cyA/ICh0aGlzLmZvY3VzKCksICExKSA6IHZvaWQgMDtcXG4gICAgICAgIH0sIGRlbGVnYXRlVHlwZTogXFxcImZvY3VzaW5cXFwiIH0sIGJsdXI6IHsgdHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlcigpIHtcXG4gICAgICAgICAgcmV0dXJuIHRoaXMgPT09IGlhKCkgJiYgdGhpcy5ibHVyID8gKHRoaXMuYmx1cigpLCAhMSkgOiB2b2lkIDA7XFxuICAgICAgICB9LCBkZWxlZ2F0ZVR5cGU6IFxcXCJmb2N1c291dFxcXCIgfSwgY2xpY2s6IHsgdHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlcigpIHtcXG4gICAgICAgICAgcmV0dXJuIFxcXCJjaGVja2JveFxcXCIgPT09IHRoaXMudHlwZSAmJiB0aGlzLmNsaWNrICYmIG4ubm9kZU5hbWUodGhpcywgXFxcImlucHV0XFxcIikgPyAodGhpcy5jbGljaygpLCAhMSkgOiB2b2lkIDA7XFxuICAgICAgICB9LCBfZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoYSkge1xcbiAgICAgICAgICByZXR1cm4gbi5ub2RlTmFtZShhLnRhcmdldCwgXFxcImFcXFwiKTtcXG4gICAgICAgIH0gfSwgYmVmb3JldW5sb2FkOiB7IHBvc3REaXNwYXRjaDogZnVuY3Rpb24gcG9zdERpc3BhdGNoKGEpIHtcXG4gICAgICAgICAgdm9pZCAwICE9PSBhLnJlc3VsdCAmJiBhLm9yaWdpbmFsRXZlbnQgJiYgKGEub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGEucmVzdWx0KTtcXG4gICAgICAgIH0gfSB9IH0sIG4ucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xcbiAgICBhLnJlbW92ZUV2ZW50TGlzdGVuZXIgJiYgYS5yZW1vdmVFdmVudExpc3RlbmVyKGIsIGMpO1xcbiAgfSwgbi5FdmVudCA9IGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2Ygbi5FdmVudCA/IChhICYmIGEudHlwZSA/ICh0aGlzLm9yaWdpbmFsRXZlbnQgPSBhLCB0aGlzLnR5cGUgPSBhLnR5cGUsIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gYS5kZWZhdWx0UHJldmVudGVkIHx8IHZvaWQgMCA9PT0gYS5kZWZhdWx0UHJldmVudGVkICYmIGEucmV0dXJuVmFsdWUgPT09ICExID8gZ2EgOiBoYSkgOiB0aGlzLnR5cGUgPSBhLCBiICYmIG4uZXh0ZW5kKHRoaXMsIGIpLCB0aGlzLnRpbWVTdGFtcCA9IGEgJiYgYS50aW1lU3RhbXAgfHwgbi5ub3coKSwgdm9pZCAodGhpc1tuLmV4cGFuZG9dID0gITApKSA6IG5ldyBuLkV2ZW50KGEsIGIpO1xcbiAgfSwgbi5FdmVudC5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiBuLkV2ZW50LCBpc0RlZmF1bHRQcmV2ZW50ZWQ6IGhhLCBpc1Byb3BhZ2F0aW9uU3RvcHBlZDogaGEsIGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiBoYSwgaXNTaW11bGF0ZWQ6ICExLCBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gcHJldmVudERlZmF1bHQoKSB7XFxuICAgICAgdmFyIGEgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBnYSwgYSAmJiAhdGhpcy5pc1NpbXVsYXRlZCAmJiBhLnByZXZlbnREZWZhdWx0KCk7XFxuICAgIH0sIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKCkge1xcbiAgICAgIHZhciBhID0gdGhpcy5vcmlnaW5hbEV2ZW50O3RoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBnYSwgYSAmJiAhdGhpcy5pc1NpbXVsYXRlZCAmJiBhLnN0b3BQcm9wYWdhdGlvbigpO1xcbiAgICB9LCBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpIHtcXG4gICAgICB2YXIgYSA9IHRoaXMub3JpZ2luYWxFdmVudDt0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gZ2EsIGEgJiYgIXRoaXMuaXNTaW11bGF0ZWQgJiYgYS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSwgdGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcXG4gICAgfSB9LCBuLmVhY2goeyBtb3VzZWVudGVyOiBcXFwibW91c2VvdmVyXFxcIiwgbW91c2VsZWF2ZTogXFxcIm1vdXNlb3V0XFxcIiwgcG9pbnRlcmVudGVyOiBcXFwicG9pbnRlcm92ZXJcXFwiLCBwb2ludGVybGVhdmU6IFxcXCJwb2ludGVyb3V0XFxcIiB9LCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICBuLmV2ZW50LnNwZWNpYWxbYV0gPSB7IGRlbGVnYXRlVHlwZTogYiwgYmluZFR5cGU6IGIsIGhhbmRsZTogZnVuY3Rpb24gaGFuZGxlKGEpIHtcXG4gICAgICAgIHZhciBjLFxcbiAgICAgICAgICAgIGQgPSB0aGlzLFxcbiAgICAgICAgICAgIGUgPSBhLnJlbGF0ZWRUYXJnZXQsXFxuICAgICAgICAgICAgZiA9IGEuaGFuZGxlT2JqO3JldHVybiBlICYmIChlID09PSBkIHx8IG4uY29udGFpbnMoZCwgZSkpIHx8IChhLnR5cGUgPSBmLm9yaWdUeXBlLCBjID0gZi5oYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIGEudHlwZSA9IGIpLCBjO1xcbiAgICAgIH0gfTtcXG4gIH0pLCBuLmZuLmV4dGVuZCh7IG9uOiBmdW5jdGlvbiBvbihhLCBiLCBjLCBkKSB7XFxuICAgICAgcmV0dXJuIGphKHRoaXMsIGEsIGIsIGMsIGQpO1xcbiAgICB9LCBvbmU6IGZ1bmN0aW9uIG9uZShhLCBiLCBjLCBkKSB7XFxuICAgICAgcmV0dXJuIGphKHRoaXMsIGEsIGIsIGMsIGQsIDEpO1xcbiAgICB9LCBvZmY6IGZ1bmN0aW9uIG9mZihhLCBiLCBjKSB7XFxuICAgICAgdmFyIGQsIGU7aWYgKGEgJiYgYS5wcmV2ZW50RGVmYXVsdCAmJiBhLmhhbmRsZU9iaikgcmV0dXJuIGQgPSBhLmhhbmRsZU9iaiwgbihhLmRlbGVnYXRlVGFyZ2V0KS5vZmYoZC5uYW1lc3BhY2UgPyBkLm9yaWdUeXBlICsgXFxcIi5cXFwiICsgZC5uYW1lc3BhY2UgOiBkLm9yaWdUeXBlLCBkLnNlbGVjdG9yLCBkLmhhbmRsZXIpLCB0aGlzO2lmIChcXFwib2JqZWN0XFxcIiA9PSAodHlwZW9mIGEgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKGEpKSkge1xcbiAgICAgICAgZm9yIChlIGluIGEpIHtcXG4gICAgICAgICAgdGhpcy5vZmYoZSwgYiwgYVtlXSk7XFxuICAgICAgICB9cmV0dXJuIHRoaXM7XFxuICAgICAgfXJldHVybiBiICE9PSAhMSAmJiBcXFwiZnVuY3Rpb25cXFwiICE9IHR5cGVvZiBiIHx8IChjID0gYiwgYiA9IHZvaWQgMCksIGMgPT09ICExICYmIChjID0gaGEpLCB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgbi5ldmVudC5yZW1vdmUodGhpcywgYSwgYywgYik7XFxuICAgICAgfSk7XFxuICAgIH0gfSk7dmFyIGthID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW1xcXFx3Oi1dKylbXj5dKilcXFxcLz4vZ2ksXFxuICAgICAgbGEgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcXG4gICAgICBtYSA9IC9jaGVja2VkXFxcXHMqKD86W149XXw9XFxcXHMqLmNoZWNrZWQuKS9pLFxcbiAgICAgIG5hID0gL150cnVlXFxcXC8oLiopLyxcXG4gICAgICBvYSA9IC9eXFxcXHMqPCEoPzpcXFxcW0NEQVRBXFxcXFt8LS0pfCg/OlxcXFxdXFxcXF18LS0pPlxcXFxzKiQvZztmdW5jdGlvbiBwYShhLCBiKSB7XFxuICAgIHJldHVybiBuLm5vZGVOYW1lKGEsIFxcXCJ0YWJsZVxcXCIpICYmIG4ubm9kZU5hbWUoMTEgIT09IGIubm9kZVR5cGUgPyBiIDogYi5maXJzdENoaWxkLCBcXFwidHJcXFwiKSA/IGEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXFxcInRib2R5XFxcIilbMF0gfHwgYS5hcHBlbmRDaGlsZChhLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwidGJvZHlcXFwiKSkgOiBhO1xcbiAgfWZ1bmN0aW9uIHFhKGEpIHtcXG4gICAgcmV0dXJuIGEudHlwZSA9IChudWxsICE9PSBhLmdldEF0dHJpYnV0ZShcXFwidHlwZVxcXCIpKSArIFxcXCIvXFxcIiArIGEudHlwZSwgYTtcXG4gIH1mdW5jdGlvbiByYShhKSB7XFxuICAgIHZhciBiID0gbmEuZXhlYyhhLnR5cGUpO3JldHVybiBiID8gYS50eXBlID0gYlsxXSA6IGEucmVtb3ZlQXR0cmlidXRlKFxcXCJ0eXBlXFxcIiksIGE7XFxuICB9ZnVuY3Rpb24gc2EoYSwgYikge1xcbiAgICB2YXIgYywgZCwgZSwgZiwgZywgaCwgaSwgajtpZiAoMSA9PT0gYi5ub2RlVHlwZSkge1xcbiAgICAgIGlmIChOLmhhc0RhdGEoYSkgJiYgKGYgPSBOLmFjY2VzcyhhKSwgZyA9IE4uc2V0KGIsIGYpLCBqID0gZi5ldmVudHMpKSB7XFxuICAgICAgICBkZWxldGUgZy5oYW5kbGUsIGcuZXZlbnRzID0ge307Zm9yIChlIGluIGopIHtcXG4gICAgICAgICAgZm9yIChjID0gMCwgZCA9IGpbZV0ubGVuZ3RoOyBkID4gYzsgYysrKSB7XFxuICAgICAgICAgICAgbi5ldmVudC5hZGQoYiwgZSwgaltlXVtjXSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9Ty5oYXNEYXRhKGEpICYmIChoID0gTy5hY2Nlc3MoYSksIGkgPSBuLmV4dGVuZCh7fSwgaCksIE8uc2V0KGIsIGkpKTtcXG4gICAgfVxcbiAgfWZ1bmN0aW9uIHRhKGEsIGIpIHtcXG4gICAgdmFyIGMgPSBiLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XFxcImlucHV0XFxcIiA9PT0gYyAmJiBYLnRlc3QoYS50eXBlKSA/IGIuY2hlY2tlZCA9IGEuY2hlY2tlZCA6IFxcXCJpbnB1dFxcXCIgIT09IGMgJiYgXFxcInRleHRhcmVhXFxcIiAhPT0gYyB8fCAoYi5kZWZhdWx0VmFsdWUgPSBhLmRlZmF1bHRWYWx1ZSk7XFxuICB9ZnVuY3Rpb24gdWEoYSwgYiwgYywgZCkge1xcbiAgICBiID0gZi5hcHBseShbXSwgYik7dmFyIGUsXFxuICAgICAgICBnLFxcbiAgICAgICAgaCxcXG4gICAgICAgIGksXFxuICAgICAgICBqLFxcbiAgICAgICAgayxcXG4gICAgICAgIG0gPSAwLFxcbiAgICAgICAgbyA9IGEubGVuZ3RoLFxcbiAgICAgICAgcCA9IG8gLSAxLFxcbiAgICAgICAgcSA9IGJbMF0sXFxuICAgICAgICByID0gbi5pc0Z1bmN0aW9uKHEpO2lmIChyIHx8IG8gPiAxICYmIFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBxICYmICFsLmNoZWNrQ2xvbmUgJiYgbWEudGVzdChxKSkgcmV0dXJuIGEuZWFjaChmdW5jdGlvbiAoZSkge1xcbiAgICAgIHZhciBmID0gYS5lcShlKTtyICYmIChiWzBdID0gcS5jYWxsKHRoaXMsIGUsIGYuaHRtbCgpKSksIHVhKGYsIGIsIGMsIGQpO1xcbiAgICB9KTtpZiAobyAmJiAoZSA9IGNhKGIsIGFbMF0ub3duZXJEb2N1bWVudCwgITEsIGEsIGQpLCBnID0gZS5maXJzdENoaWxkLCAxID09PSBlLmNoaWxkTm9kZXMubGVuZ3RoICYmIChlID0gZyksIGcgfHwgZCkpIHtcXG4gICAgICBmb3IgKGggPSBuLm1hcChfKGUsIFxcXCJzY3JpcHRcXFwiKSwgcWEpLCBpID0gaC5sZW5ndGg7IG8gPiBtOyBtKyspIHtcXG4gICAgICAgIGogPSBlLCBtICE9PSBwICYmIChqID0gbi5jbG9uZShqLCAhMCwgITApLCBpICYmIG4ubWVyZ2UoaCwgXyhqLCBcXFwic2NyaXB0XFxcIikpKSwgYy5jYWxsKGFbbV0sIGosIG0pO1xcbiAgICAgIH1pZiAoaSkgZm9yIChrID0gaFtoLmxlbmd0aCAtIDFdLm93bmVyRG9jdW1lbnQsIG4ubWFwKGgsIHJhKSwgbSA9IDA7IGkgPiBtOyBtKyspIHtcXG4gICAgICAgIGogPSBoW21dLCBaLnRlc3Qoai50eXBlIHx8IFxcXCJcXFwiKSAmJiAhTi5hY2Nlc3MoaiwgXFxcImdsb2JhbEV2YWxcXFwiKSAmJiBuLmNvbnRhaW5zKGssIGopICYmIChqLnNyYyA/IG4uX2V2YWxVcmwgJiYgbi5fZXZhbFVybChqLnNyYykgOiBuLmdsb2JhbEV2YWwoai50ZXh0Q29udGVudC5yZXBsYWNlKG9hLCBcXFwiXFxcIikpKTtcXG4gICAgICB9XFxuICAgIH1yZXR1cm4gYTtcXG4gIH1mdW5jdGlvbiB2YShhLCBiLCBjKSB7XFxuICAgIGZvciAodmFyIGQsIGUgPSBiID8gbi5maWx0ZXIoYiwgYSkgOiBhLCBmID0gMDsgbnVsbCAhPSAoZCA9IGVbZl0pOyBmKyspIHtcXG4gICAgICBjIHx8IDEgIT09IGQubm9kZVR5cGUgfHwgbi5jbGVhbkRhdGEoXyhkKSksIGQucGFyZW50Tm9kZSAmJiAoYyAmJiBuLmNvbnRhaW5zKGQub3duZXJEb2N1bWVudCwgZCkgJiYgYWEoXyhkLCBcXFwic2NyaXB0XFxcIikpLCBkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZCkpO1xcbiAgICB9cmV0dXJuIGE7XFxuICB9bi5leHRlbmQoeyBodG1sUHJlZmlsdGVyOiBmdW5jdGlvbiBodG1sUHJlZmlsdGVyKGEpIHtcXG4gICAgICByZXR1cm4gYS5yZXBsYWNlKGthLCBcXFwiPCQxPjwvJDI+XFxcIik7XFxuICAgIH0sIGNsb25lOiBmdW5jdGlvbiBjbG9uZShhLCBiLCBjKSB7XFxuICAgICAgdmFyIGQsXFxuICAgICAgICAgIGUsXFxuICAgICAgICAgIGYsXFxuICAgICAgICAgIGcsXFxuICAgICAgICAgIGggPSBhLmNsb25lTm9kZSghMCksXFxuICAgICAgICAgIGkgPSBuLmNvbnRhaW5zKGEub3duZXJEb2N1bWVudCwgYSk7aWYgKCEobC5ub0Nsb25lQ2hlY2tlZCB8fCAxICE9PSBhLm5vZGVUeXBlICYmIDExICE9PSBhLm5vZGVUeXBlIHx8IG4uaXNYTUxEb2MoYSkpKSBmb3IgKGcgPSBfKGgpLCBmID0gXyhhKSwgZCA9IDAsIGUgPSBmLmxlbmd0aDsgZSA+IGQ7IGQrKykge1xcbiAgICAgICAgdGEoZltkXSwgZ1tkXSk7XFxuICAgICAgfWlmIChiKSBpZiAoYykgZm9yIChmID0gZiB8fCBfKGEpLCBnID0gZyB8fCBfKGgpLCBkID0gMCwgZSA9IGYubGVuZ3RoOyBlID4gZDsgZCsrKSB7XFxuICAgICAgICBzYShmW2RdLCBnW2RdKTtcXG4gICAgICB9IGVsc2Ugc2EoYSwgaCk7cmV0dXJuIGcgPSBfKGgsIFxcXCJzY3JpcHRcXFwiKSwgZy5sZW5ndGggPiAwICYmIGFhKGcsICFpICYmIF8oYSwgXFxcInNjcmlwdFxcXCIpKSwgaDtcXG4gICAgfSwgY2xlYW5EYXRhOiBmdW5jdGlvbiBjbGVhbkRhdGEoYSkge1xcbiAgICAgIGZvciAodmFyIGIsIGMsIGQsIGUgPSBuLmV2ZW50LnNwZWNpYWwsIGYgPSAwOyB2b2lkIDAgIT09IChjID0gYVtmXSk7IGYrKykge1xcbiAgICAgICAgaWYgKEwoYykpIHtcXG4gICAgICAgICAgaWYgKGIgPSBjW04uZXhwYW5kb10pIHtcXG4gICAgICAgICAgICBpZiAoYi5ldmVudHMpIGZvciAoZCBpbiBiLmV2ZW50cykge1xcbiAgICAgICAgICAgICAgZVtkXSA/IG4uZXZlbnQucmVtb3ZlKGMsIGQpIDogbi5yZW1vdmVFdmVudChjLCBkLCBiLmhhbmRsZSk7XFxuICAgICAgICAgICAgfWNbTi5leHBhbmRvXSA9IHZvaWQgMDtcXG4gICAgICAgICAgfWNbTy5leHBhbmRvXSAmJiAoY1tPLmV4cGFuZG9dID0gdm9pZCAwKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0gfSksIG4uZm4uZXh0ZW5kKHsgZG9tTWFuaXA6IHVhLCBkZXRhY2g6IGZ1bmN0aW9uIGRldGFjaChhKSB7XFxuICAgICAgcmV0dXJuIHZhKHRoaXMsIGEsICEwKTtcXG4gICAgfSwgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoYSkge1xcbiAgICAgIHJldHVybiB2YSh0aGlzLCBhKTtcXG4gICAgfSwgdGV4dDogZnVuY3Rpb24gdGV4dChhKSB7XFxuICAgICAgcmV0dXJuIEsodGhpcywgZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIHJldHVybiB2b2lkIDAgPT09IGEgPyBuLnRleHQodGhpcykgOiB0aGlzLmVtcHR5KCkuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIDEgIT09IHRoaXMubm9kZVR5cGUgJiYgMTEgIT09IHRoaXMubm9kZVR5cGUgJiYgOSAhPT0gdGhpcy5ub2RlVHlwZSB8fCAodGhpcy50ZXh0Q29udGVudCA9IGEpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSwgbnVsbCwgYSwgYXJndW1lbnRzLmxlbmd0aCk7XFxuICAgIH0sIGFwcGVuZDogZnVuY3Rpb24gYXBwZW5kKCkge1xcbiAgICAgIHJldHVybiB1YSh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICBpZiAoMSA9PT0gdGhpcy5ub2RlVHlwZSB8fCAxMSA9PT0gdGhpcy5ub2RlVHlwZSB8fCA5ID09PSB0aGlzLm5vZGVUeXBlKSB7XFxuICAgICAgICAgIHZhciBiID0gcGEodGhpcywgYSk7Yi5hcHBlbmRDaGlsZChhKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfSwgcHJlcGVuZDogZnVuY3Rpb24gcHJlcGVuZCgpIHtcXG4gICAgICByZXR1cm4gdWEodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgaWYgKDEgPT09IHRoaXMubm9kZVR5cGUgfHwgMTEgPT09IHRoaXMubm9kZVR5cGUgfHwgOSA9PT0gdGhpcy5ub2RlVHlwZSkge1xcbiAgICAgICAgICB2YXIgYiA9IHBhKHRoaXMsIGEpO2IuaW5zZXJ0QmVmb3JlKGEsIGIuZmlyc3RDaGlsZCk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH0sIGJlZm9yZTogZnVuY3Rpb24gYmVmb3JlKCkge1xcbiAgICAgIHJldHVybiB1YSh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICB0aGlzLnBhcmVudE5vZGUgJiYgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLCB0aGlzKTtcXG4gICAgICB9KTtcXG4gICAgfSwgYWZ0ZXI6IGZ1bmN0aW9uIGFmdGVyKCkge1xcbiAgICAgIHJldHVybiB1YSh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICB0aGlzLnBhcmVudE5vZGUgJiYgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLCB0aGlzLm5leHRTaWJsaW5nKTtcXG4gICAgICB9KTtcXG4gICAgfSwgZW1wdHk6IGZ1bmN0aW9uIGVtcHR5KCkge1xcbiAgICAgIGZvciAodmFyIGEsIGIgPSAwOyBudWxsICE9IChhID0gdGhpc1tiXSk7IGIrKykge1xcbiAgICAgICAgMSA9PT0gYS5ub2RlVHlwZSAmJiAobi5jbGVhbkRhdGEoXyhhLCAhMSkpLCBhLnRleHRDb250ZW50ID0gXFxcIlxcXCIpO1xcbiAgICAgIH1yZXR1cm4gdGhpcztcXG4gICAgfSwgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKGEsIGIpIHtcXG4gICAgICByZXR1cm4gYSA9IG51bGwgPT0gYSA/ICExIDogYSwgYiA9IG51bGwgPT0gYiA/IGEgOiBiLCB0aGlzLm1hcChmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gbi5jbG9uZSh0aGlzLCBhLCBiKTtcXG4gICAgICB9KTtcXG4gICAgfSwgaHRtbDogZnVuY3Rpb24gaHRtbChhKSB7XFxuICAgICAgcmV0dXJuIEsodGhpcywgZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIHZhciBiID0gdGhpc1swXSB8fCB7fSxcXG4gICAgICAgICAgICBjID0gMCxcXG4gICAgICAgICAgICBkID0gdGhpcy5sZW5ndGg7aWYgKHZvaWQgMCA9PT0gYSAmJiAxID09PSBiLm5vZGVUeXBlKSByZXR1cm4gYi5pbm5lckhUTUw7aWYgKFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBhICYmICFsYS50ZXN0KGEpICYmICEkWyhZLmV4ZWMoYSkgfHwgW1xcXCJcXFwiLCBcXFwiXFxcIl0pWzFdLnRvTG93ZXJDYXNlKCldKSB7XFxuICAgICAgICAgIGEgPSBuLmh0bWxQcmVmaWx0ZXIoYSk7dHJ5IHtcXG4gICAgICAgICAgICBmb3IgKDsgZCA+IGM7IGMrKykge1xcbiAgICAgICAgICAgICAgYiA9IHRoaXNbY10gfHwge30sIDEgPT09IGIubm9kZVR5cGUgJiYgKG4uY2xlYW5EYXRhKF8oYiwgITEpKSwgYi5pbm5lckhUTUwgPSBhKTtcXG4gICAgICAgICAgICB9YiA9IDA7XFxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XFxuICAgICAgICB9YiAmJiB0aGlzLmVtcHR5KCkuYXBwZW5kKGEpO1xcbiAgICAgIH0sIG51bGwsIGEsIGFyZ3VtZW50cy5sZW5ndGgpO1xcbiAgICB9LCByZXBsYWNlV2l0aDogZnVuY3Rpb24gcmVwbGFjZVdpdGgoKSB7XFxuICAgICAgdmFyIGEgPSBbXTtyZXR1cm4gdWEodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiAoYikge1xcbiAgICAgICAgdmFyIGMgPSB0aGlzLnBhcmVudE5vZGU7bi5pbkFycmF5KHRoaXMsIGEpIDwgMCAmJiAobi5jbGVhbkRhdGEoXyh0aGlzKSksIGMgJiYgYy5yZXBsYWNlQ2hpbGQoYiwgdGhpcykpO1xcbiAgICAgIH0sIGEpO1xcbiAgICB9IH0pLCBuLmVhY2goeyBhcHBlbmRUbzogXFxcImFwcGVuZFxcXCIsIHByZXBlbmRUbzogXFxcInByZXBlbmRcXFwiLCBpbnNlcnRCZWZvcmU6IFxcXCJiZWZvcmVcXFwiLCBpbnNlcnRBZnRlcjogXFxcImFmdGVyXFxcIiwgcmVwbGFjZUFsbDogXFxcInJlcGxhY2VXaXRoXFxcIiB9LCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICBuLmZuW2FdID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgICBmb3IgKHZhciBjLCBkID0gW10sIGUgPSBuKGEpLCBmID0gZS5sZW5ndGggLSAxLCBoID0gMDsgZiA+PSBoOyBoKyspIHtcXG4gICAgICAgIGMgPSBoID09PSBmID8gdGhpcyA6IHRoaXMuY2xvbmUoITApLCBuKGVbaF0pW2JdKGMpLCBnLmFwcGx5KGQsIGMuZ2V0KCkpO1xcbiAgICAgIH1yZXR1cm4gdGhpcy5wdXNoU3RhY2soZCk7XFxuICAgIH07XFxuICB9KTt2YXIgd2EsXFxuICAgICAgeGEgPSB7IEhUTUw6IFxcXCJibG9ja1xcXCIsIEJPRFk6IFxcXCJibG9ja1xcXCIgfTtmdW5jdGlvbiB5YShhLCBiKSB7XFxuICAgIHZhciBjID0gbihiLmNyZWF0ZUVsZW1lbnQoYSkpLmFwcGVuZFRvKGIuYm9keSksXFxuICAgICAgICBkID0gbi5jc3MoY1swXSwgXFxcImRpc3BsYXlcXFwiKTtyZXR1cm4gYy5kZXRhY2goKSwgZDtcXG4gIH1mdW5jdGlvbiB6YShhKSB7XFxuICAgIHZhciBiID0gZCxcXG4gICAgICAgIGMgPSB4YVthXTtyZXR1cm4gYyB8fCAoYyA9IHlhKGEsIGIpLCBcXFwibm9uZVxcXCIgIT09IGMgJiYgYyB8fCAod2EgPSAod2EgfHwgbihcXFwiPGlmcmFtZSBmcmFtZWJvcmRlcj0nMCcgd2lkdGg9JzAnIGhlaWdodD0nMCcvPlxcXCIpKS5hcHBlbmRUbyhiLmRvY3VtZW50RWxlbWVudCksIGIgPSB3YVswXS5jb250ZW50RG9jdW1lbnQsIGIud3JpdGUoKSwgYi5jbG9zZSgpLCBjID0geWEoYSwgYiksIHdhLmRldGFjaCgpKSwgeGFbYV0gPSBjKSwgYztcXG4gIH12YXIgQWEgPSAvXm1hcmdpbi8sXFxuICAgICAgQmEgPSBuZXcgUmVnRXhwKFxcXCJeKFxcXCIgKyBTICsgXFxcIikoPyFweClbYS16JV0rJFxcXCIsIFxcXCJpXFxcIiksXFxuICAgICAgQ2EgPSBmdW5jdGlvbiBDYShiKSB7XFxuICAgIHZhciBjID0gYi5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O3JldHVybiBjICYmIGMub3BlbmVyIHx8IChjID0gYSksIGMuZ2V0Q29tcHV0ZWRTdHlsZShiKTtcXG4gIH0sXFxuICAgICAgRGEgPSBmdW5jdGlvbiBEYShhLCBiLCBjLCBkKSB7XFxuICAgIHZhciBlLFxcbiAgICAgICAgZixcXG4gICAgICAgIGcgPSB7fTtmb3IgKGYgaW4gYikge1xcbiAgICAgIGdbZl0gPSBhLnN0eWxlW2ZdLCBhLnN0eWxlW2ZdID0gYltmXTtcXG4gICAgfWUgPSBjLmFwcGx5KGEsIGQgfHwgW10pO2ZvciAoZiBpbiBiKSB7XFxuICAgICAgYS5zdHlsZVtmXSA9IGdbZl07XFxuICAgIH1yZXR1cm4gZTtcXG4gIH0sXFxuICAgICAgRWEgPSBkLmRvY3VtZW50RWxlbWVudDshZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgYixcXG4gICAgICAgIGMsXFxuICAgICAgICBlLFxcbiAgICAgICAgZixcXG4gICAgICAgIGcgPSBkLmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpLFxcbiAgICAgICAgaCA9IGQuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7aWYgKGguc3R5bGUpIHtcXG4gICAgICAoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGkgPSBmdW5jdGlvbiBpKCkge1xcbiAgICAgICAgICBoLnN0eWxlLmNzc1RleHQgPSBcXFwiLXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7LW1vei1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94O3Bvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7bWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDt0b3A6MSU7d2lkdGg6NTAlXFxcIiwgaC5pbm5lckhUTUwgPSBcXFwiXFxcIiwgRWEuYXBwZW5kQ2hpbGQoZyk7dmFyIGQgPSBhLmdldENvbXB1dGVkU3R5bGUoaCk7YiA9IFxcXCIxJVxcXCIgIT09IGQudG9wLCBmID0gXFxcIjJweFxcXCIgPT09IGQubWFyZ2luTGVmdCwgYyA9IFxcXCI0cHhcXFwiID09PSBkLndpZHRoLCBoLnN0eWxlLm1hcmdpblJpZ2h0ID0gXFxcIjUwJVxcXCIsIGUgPSBcXFwiNHB4XFxcIiA9PT0gZC5tYXJnaW5SaWdodCwgRWEucmVtb3ZlQ2hpbGQoZyk7XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgaC5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFxcXCJjb250ZW50LWJveFxcXCIsIGguY2xvbmVOb2RlKCEwKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFxcXCJcXFwiLCBsLmNsZWFyQ2xvbmVTdHlsZSA9IFxcXCJjb250ZW50LWJveFxcXCIgPT09IGguc3R5bGUuYmFja2dyb3VuZENsaXAsIGcuc3R5bGUuY3NzVGV4dCA9IFxcXCJib3JkZXI6MDt3aWR0aDo4cHg7aGVpZ2h0OjA7dG9wOjA7bGVmdDotOTk5OXB4O3BhZGRpbmc6MDttYXJnaW4tdG9wOjFweDtwb3NpdGlvbjphYnNvbHV0ZVxcXCIsIGcuYXBwZW5kQ2hpbGQoaCk7bi5leHRlbmQobCwgeyBwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbiBwaXhlbFBvc2l0aW9uKCkge1xcbiAgICAgICAgICAgIHJldHVybiBpKCksIGI7XFxuICAgICAgICAgIH0sIGJveFNpemluZ1JlbGlhYmxlOiBmdW5jdGlvbiBib3hTaXppbmdSZWxpYWJsZSgpIHtcXG4gICAgICAgICAgICByZXR1cm4gbnVsbCA9PSBjICYmIGkoKSwgYztcXG4gICAgICAgICAgfSwgcGl4ZWxNYXJnaW5SaWdodDogZnVuY3Rpb24gcGl4ZWxNYXJnaW5SaWdodCgpIHtcXG4gICAgICAgICAgICByZXR1cm4gbnVsbCA9PSBjICYmIGkoKSwgZTtcXG4gICAgICAgICAgfSwgcmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbiByZWxpYWJsZU1hcmdpbkxlZnQoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIG51bGwgPT0gYyAmJiBpKCksIGY7XFxuICAgICAgICAgIH0sIHJlbGlhYmxlTWFyZ2luUmlnaHQ6IGZ1bmN0aW9uIHJlbGlhYmxlTWFyZ2luUmlnaHQoKSB7XFxuICAgICAgICAgICAgdmFyIGIsXFxuICAgICAgICAgICAgICAgIGMgPSBoLmFwcGVuZENoaWxkKGQuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIikpO3JldHVybiBjLnN0eWxlLmNzc1RleHQgPSBoLnN0eWxlLmNzc1RleHQgPSBcXFwiLXdlYmtpdC1ib3gtc2l6aW5nOmNvbnRlbnQtYm94O2JveC1zaXppbmc6Y29udGVudC1ib3g7ZGlzcGxheTpibG9jazttYXJnaW46MDtib3JkZXI6MDtwYWRkaW5nOjBcXFwiLCBjLnN0eWxlLm1hcmdpblJpZ2h0ID0gYy5zdHlsZS53aWR0aCA9IFxcXCIwXFxcIiwgaC5zdHlsZS53aWR0aCA9IFxcXCIxcHhcXFwiLCBFYS5hcHBlbmRDaGlsZChnKSwgYiA9ICFwYXJzZUZsb2F0KGEuZ2V0Q29tcHV0ZWRTdHlsZShjKS5tYXJnaW5SaWdodCksIEVhLnJlbW92ZUNoaWxkKGcpLCBoLnJlbW92ZUNoaWxkKGMpLCBiO1xcbiAgICAgICAgICB9IH0pO1xcbiAgICAgIH0pKCk7XFxuICAgIH1cXG4gIH0oKTtmdW5jdGlvbiBGYShhLCBiLCBjKSB7XFxuICAgIHZhciBkLFxcbiAgICAgICAgZSxcXG4gICAgICAgIGYsXFxuICAgICAgICBnLFxcbiAgICAgICAgaCA9IGEuc3R5bGU7cmV0dXJuIGMgPSBjIHx8IENhKGEpLCBnID0gYyA/IGMuZ2V0UHJvcGVydHlWYWx1ZShiKSB8fCBjW2JdIDogdm9pZCAwLCBcXFwiXFxcIiAhPT0gZyAmJiB2b2lkIDAgIT09IGcgfHwgbi5jb250YWlucyhhLm93bmVyRG9jdW1lbnQsIGEpIHx8IChnID0gbi5zdHlsZShhLCBiKSksIGMgJiYgIWwucGl4ZWxNYXJnaW5SaWdodCgpICYmIEJhLnRlc3QoZykgJiYgQWEudGVzdChiKSAmJiAoZCA9IGgud2lkdGgsIGUgPSBoLm1pbldpZHRoLCBmID0gaC5tYXhXaWR0aCwgaC5taW5XaWR0aCA9IGgubWF4V2lkdGggPSBoLndpZHRoID0gZywgZyA9IGMud2lkdGgsIGgud2lkdGggPSBkLCBoLm1pbldpZHRoID0gZSwgaC5tYXhXaWR0aCA9IGYpLCB2b2lkIDAgIT09IGcgPyBnICsgXFxcIlxcXCIgOiBnO1xcbiAgfWZ1bmN0aW9uIEdhKGEsIGIpIHtcXG4gICAgcmV0dXJuIHsgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XFxuICAgICAgICByZXR1cm4gYSgpID8gdm9pZCBkZWxldGUgdGhpcy5nZXQgOiAodGhpcy5nZXQgPSBiKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIH0gfTtcXG4gIH12YXIgSGEgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXFxuICAgICAgSWEgPSB7IHBvc2l0aW9uOiBcXFwiYWJzb2x1dGVcXFwiLCB2aXNpYmlsaXR5OiBcXFwiaGlkZGVuXFxcIiwgZGlzcGxheTogXFxcImJsb2NrXFxcIiB9LFxcbiAgICAgIEphID0geyBsZXR0ZXJTcGFjaW5nOiBcXFwiMFxcXCIsIGZvbnRXZWlnaHQ6IFxcXCI0MDBcXFwiIH0sXFxuICAgICAgS2EgPSBbXFxcIldlYmtpdFxcXCIsIFxcXCJPXFxcIiwgXFxcIk1velxcXCIsIFxcXCJtc1xcXCJdLFxcbiAgICAgIExhID0gZC5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKS5zdHlsZTtmdW5jdGlvbiBNYShhKSB7XFxuICAgIGlmIChhIGluIExhKSByZXR1cm4gYTt2YXIgYiA9IGFbMF0udG9VcHBlckNhc2UoKSArIGEuc2xpY2UoMSksXFxuICAgICAgICBjID0gS2EubGVuZ3RoO3doaWxlIChjLS0pIHtcXG4gICAgICBpZiAoYSA9IEthW2NdICsgYiwgYSBpbiBMYSkgcmV0dXJuIGE7XFxuICAgIH1cXG4gIH1mdW5jdGlvbiBOYShhLCBiLCBjKSB7XFxuICAgIHZhciBkID0gVC5leGVjKGIpO3JldHVybiBkID8gTWF0aC5tYXgoMCwgZFsyXSAtIChjIHx8IDApKSArIChkWzNdIHx8IFxcXCJweFxcXCIpIDogYjtcXG4gIH1mdW5jdGlvbiBPYShhLCBiLCBjLCBkLCBlKSB7XFxuICAgIGZvciAodmFyIGYgPSBjID09PSAoZCA/IFxcXCJib3JkZXJcXFwiIDogXFxcImNvbnRlbnRcXFwiKSA/IDQgOiBcXFwid2lkdGhcXFwiID09PSBiID8gMSA6IDAsIGcgPSAwOyA0ID4gZjsgZiArPSAyKSB7XFxuICAgICAgXFxcIm1hcmdpblxcXCIgPT09IGMgJiYgKGcgKz0gbi5jc3MoYSwgYyArIFVbZl0sICEwLCBlKSksIGQgPyAoXFxcImNvbnRlbnRcXFwiID09PSBjICYmIChnIC09IG4uY3NzKGEsIFxcXCJwYWRkaW5nXFxcIiArIFVbZl0sICEwLCBlKSksIFxcXCJtYXJnaW5cXFwiICE9PSBjICYmIChnIC09IG4uY3NzKGEsIFxcXCJib3JkZXJcXFwiICsgVVtmXSArIFxcXCJXaWR0aFxcXCIsICEwLCBlKSkpIDogKGcgKz0gbi5jc3MoYSwgXFxcInBhZGRpbmdcXFwiICsgVVtmXSwgITAsIGUpLCBcXFwicGFkZGluZ1xcXCIgIT09IGMgJiYgKGcgKz0gbi5jc3MoYSwgXFxcImJvcmRlclxcXCIgKyBVW2ZdICsgXFxcIldpZHRoXFxcIiwgITAsIGUpKSk7XFxuICAgIH1yZXR1cm4gZztcXG4gIH1mdW5jdGlvbiBQYShhLCBiLCBjKSB7XFxuICAgIHZhciBkID0gITAsXFxuICAgICAgICBlID0gXFxcIndpZHRoXFxcIiA9PT0gYiA/IGEub2Zmc2V0V2lkdGggOiBhLm9mZnNldEhlaWdodCxcXG4gICAgICAgIGYgPSBDYShhKSxcXG4gICAgICAgIGcgPSBcXFwiYm9yZGVyLWJveFxcXCIgPT09IG4uY3NzKGEsIFxcXCJib3hTaXppbmdcXFwiLCAhMSwgZik7aWYgKDAgPj0gZSB8fCBudWxsID09IGUpIHtcXG4gICAgICBpZiAoZSA9IEZhKGEsIGIsIGYpLCAoMCA+IGUgfHwgbnVsbCA9PSBlKSAmJiAoZSA9IGEuc3R5bGVbYl0pLCBCYS50ZXN0KGUpKSByZXR1cm4gZTtkID0gZyAmJiAobC5ib3hTaXppbmdSZWxpYWJsZSgpIHx8IGUgPT09IGEuc3R5bGVbYl0pLCBlID0gcGFyc2VGbG9hdChlKSB8fCAwO1xcbiAgICB9cmV0dXJuIGUgKyBPYShhLCBiLCBjIHx8IChnID8gXFxcImJvcmRlclxcXCIgOiBcXFwiY29udGVudFxcXCIpLCBkLCBmKSArIFxcXCJweFxcXCI7XFxuICB9ZnVuY3Rpb24gUWEoYSwgYikge1xcbiAgICBmb3IgKHZhciBjLCBkLCBlLCBmID0gW10sIGcgPSAwLCBoID0gYS5sZW5ndGg7IGggPiBnOyBnKyspIHtcXG4gICAgICBkID0gYVtnXSwgZC5zdHlsZSAmJiAoZltnXSA9IE4uZ2V0KGQsIFxcXCJvbGRkaXNwbGF5XFxcIiksIGMgPSBkLnN0eWxlLmRpc3BsYXksIGIgPyAoZltnXSB8fCBcXFwibm9uZVxcXCIgIT09IGMgfHwgKGQuc3R5bGUuZGlzcGxheSA9IFxcXCJcXFwiKSwgXFxcIlxcXCIgPT09IGQuc3R5bGUuZGlzcGxheSAmJiBWKGQpICYmIChmW2ddID0gTi5hY2Nlc3MoZCwgXFxcIm9sZGRpc3BsYXlcXFwiLCB6YShkLm5vZGVOYW1lKSkpKSA6IChlID0gVihkKSwgXFxcIm5vbmVcXFwiID09PSBjICYmIGUgfHwgTi5zZXQoZCwgXFxcIm9sZGRpc3BsYXlcXFwiLCBlID8gYyA6IG4uY3NzKGQsIFxcXCJkaXNwbGF5XFxcIikpKSk7XFxuICAgIH1mb3IgKGcgPSAwOyBoID4gZzsgZysrKSB7XFxuICAgICAgZCA9IGFbZ10sIGQuc3R5bGUgJiYgKGIgJiYgXFxcIm5vbmVcXFwiICE9PSBkLnN0eWxlLmRpc3BsYXkgJiYgXFxcIlxcXCIgIT09IGQuc3R5bGUuZGlzcGxheSB8fCAoZC5zdHlsZS5kaXNwbGF5ID0gYiA/IGZbZ10gfHwgXFxcIlxcXCIgOiBcXFwibm9uZVxcXCIpKTtcXG4gICAgfXJldHVybiBhO1xcbiAgfW4uZXh0ZW5kKHsgY3NzSG9va3M6IHsgb3BhY2l0eTogeyBnZXQ6IGZ1bmN0aW9uIGdldChhLCBiKSB7XFxuICAgICAgICAgIGlmIChiKSB7XFxuICAgICAgICAgICAgdmFyIGMgPSBGYShhLCBcXFwib3BhY2l0eVxcXCIpO3JldHVybiBcXFwiXFxcIiA9PT0gYyA/IFxcXCIxXFxcIiA6IGM7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gfSB9LCBjc3NOdW1iZXI6IHsgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6ICEwLCBjb2x1bW5Db3VudDogITAsIGZpbGxPcGFjaXR5OiAhMCwgZmxleEdyb3c6ICEwLCBmbGV4U2hyaW5rOiAhMCwgZm9udFdlaWdodDogITAsIGxpbmVIZWlnaHQ6ICEwLCBvcGFjaXR5OiAhMCwgb3JkZXI6ICEwLCBvcnBoYW5zOiAhMCwgd2lkb3dzOiAhMCwgekluZGV4OiAhMCwgem9vbTogITAgfSwgY3NzUHJvcHM6IHsgXFxcImZsb2F0XFxcIjogXFxcImNzc0Zsb2F0XFxcIiB9LCBzdHlsZTogZnVuY3Rpb24gc3R5bGUoYSwgYiwgYywgZCkge1xcbiAgICAgIGlmIChhICYmIDMgIT09IGEubm9kZVR5cGUgJiYgOCAhPT0gYS5ub2RlVHlwZSAmJiBhLnN0eWxlKSB7XFxuICAgICAgICB2YXIgZSxcXG4gICAgICAgICAgICBmLFxcbiAgICAgICAgICAgIGcsXFxuICAgICAgICAgICAgaCA9IG4uY2FtZWxDYXNlKGIpLFxcbiAgICAgICAgICAgIGkgPSBhLnN0eWxlO3JldHVybiBiID0gbi5jc3NQcm9wc1toXSB8fCAobi5jc3NQcm9wc1toXSA9IE1hKGgpIHx8IGgpLCBnID0gbi5jc3NIb29rc1tiXSB8fCBuLmNzc0hvb2tzW2hdLCB2b2lkIDAgPT09IGMgPyBnICYmIFxcXCJnZXRcXFwiIGluIGcgJiYgdm9pZCAwICE9PSAoZSA9IGcuZ2V0KGEsICExLCBkKSkgPyBlIDogaVtiXSA6IChmID0gdHlwZW9mIGMgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKGMpLCBcXFwic3RyaW5nXFxcIiA9PT0gZiAmJiAoZSA9IFQuZXhlYyhjKSkgJiYgZVsxXSAmJiAoYyA9IFcoYSwgYiwgZSksIGYgPSBcXFwibnVtYmVyXFxcIiksIG51bGwgIT0gYyAmJiBjID09PSBjICYmIChcXFwibnVtYmVyXFxcIiA9PT0gZiAmJiAoYyArPSBlICYmIGVbM10gfHwgKG4uY3NzTnVtYmVyW2hdID8gXFxcIlxcXCIgOiBcXFwicHhcXFwiKSksIGwuY2xlYXJDbG9uZVN0eWxlIHx8IFxcXCJcXFwiICE9PSBjIHx8IDAgIT09IGIuaW5kZXhPZihcXFwiYmFja2dyb3VuZFxcXCIpIHx8IChpW2JdID0gXFxcImluaGVyaXRcXFwiKSwgZyAmJiBcXFwic2V0XFxcIiBpbiBnICYmIHZvaWQgMCA9PT0gKGMgPSBnLnNldChhLCBjLCBkKSkgfHwgKGlbYl0gPSBjKSksIHZvaWQgMCk7XFxuICAgICAgfVxcbiAgICB9LCBjc3M6IGZ1bmN0aW9uIGNzcyhhLCBiLCBjLCBkKSB7XFxuICAgICAgdmFyIGUsXFxuICAgICAgICAgIGYsXFxuICAgICAgICAgIGcsXFxuICAgICAgICAgIGggPSBuLmNhbWVsQ2FzZShiKTtyZXR1cm4gYiA9IG4uY3NzUHJvcHNbaF0gfHwgKG4uY3NzUHJvcHNbaF0gPSBNYShoKSB8fCBoKSwgZyA9IG4uY3NzSG9va3NbYl0gfHwgbi5jc3NIb29rc1toXSwgZyAmJiBcXFwiZ2V0XFxcIiBpbiBnICYmIChlID0gZy5nZXQoYSwgITAsIGMpKSwgdm9pZCAwID09PSBlICYmIChlID0gRmEoYSwgYiwgZCkpLCBcXFwibm9ybWFsXFxcIiA9PT0gZSAmJiBiIGluIEphICYmIChlID0gSmFbYl0pLCBcXFwiXFxcIiA9PT0gYyB8fCBjID8gKGYgPSBwYXJzZUZsb2F0KGUpLCBjID09PSAhMCB8fCBpc0Zpbml0ZShmKSA/IGYgfHwgMCA6IGUpIDogZTtcXG4gICAgfSB9KSwgbi5lYWNoKFtcXFwiaGVpZ2h0XFxcIiwgXFxcIndpZHRoXFxcIl0sIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIG4uY3NzSG9va3NbYl0gPSB7IGdldDogZnVuY3Rpb24gZ2V0KGEsIGMsIGQpIHtcXG4gICAgICAgIHJldHVybiBjID8gSGEudGVzdChuLmNzcyhhLCBcXFwiZGlzcGxheVxcXCIpKSAmJiAwID09PSBhLm9mZnNldFdpZHRoID8gRGEoYSwgSWEsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgcmV0dXJuIFBhKGEsIGIsIGQpO1xcbiAgICAgICAgfSkgOiBQYShhLCBiLCBkKSA6IHZvaWQgMDtcXG4gICAgICB9LCBzZXQ6IGZ1bmN0aW9uIHNldChhLCBjLCBkKSB7XFxuICAgICAgICB2YXIgZSxcXG4gICAgICAgICAgICBmID0gZCAmJiBDYShhKSxcXG4gICAgICAgICAgICBnID0gZCAmJiBPYShhLCBiLCBkLCBcXFwiYm9yZGVyLWJveFxcXCIgPT09IG4uY3NzKGEsIFxcXCJib3hTaXppbmdcXFwiLCAhMSwgZiksIGYpO3JldHVybiBnICYmIChlID0gVC5leGVjKGMpKSAmJiBcXFwicHhcXFwiICE9PSAoZVszXSB8fCBcXFwicHhcXFwiKSAmJiAoYS5zdHlsZVtiXSA9IGMsIGMgPSBuLmNzcyhhLCBiKSksIE5hKGEsIGMsIGcpO1xcbiAgICAgIH0gfTtcXG4gIH0pLCBuLmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBHYShsLnJlbGlhYmxlTWFyZ2luTGVmdCwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgcmV0dXJuIGIgPyAocGFyc2VGbG9hdChGYShhLCBcXFwibWFyZ2luTGVmdFxcXCIpKSB8fCBhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLSBEYShhLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24gKCkge1xcbiAgICAgIHJldHVybiBhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XFxuICAgIH0pKSArIFxcXCJweFxcXCIgOiB2b2lkIDA7XFxuICB9KSwgbi5jc3NIb29rcy5tYXJnaW5SaWdodCA9IEdhKGwucmVsaWFibGVNYXJnaW5SaWdodCwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgcmV0dXJuIGIgPyBEYShhLCB7IGRpc3BsYXk6IFxcXCJpbmxpbmUtYmxvY2tcXFwiIH0sIEZhLCBbYSwgXFxcIm1hcmdpblJpZ2h0XFxcIl0pIDogdm9pZCAwO1xcbiAgfSksIG4uZWFjaCh7IG1hcmdpbjogXFxcIlxcXCIsIHBhZGRpbmc6IFxcXCJcXFwiLCBib3JkZXI6IFxcXCJXaWR0aFxcXCIgfSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgbi5jc3NIb29rc1thICsgYl0gPSB7IGV4cGFuZDogZnVuY3Rpb24gZXhwYW5kKGMpIHtcXG4gICAgICAgIGZvciAodmFyIGQgPSAwLCBlID0ge30sIGYgPSBcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYyA/IGMuc3BsaXQoXFxcIiBcXFwiKSA6IFtjXTsgNCA+IGQ7IGQrKykge1xcbiAgICAgICAgICBlW2EgKyBVW2RdICsgYl0gPSBmW2RdIHx8IGZbZCAtIDJdIHx8IGZbMF07XFxuICAgICAgICB9cmV0dXJuIGU7XFxuICAgICAgfSB9LCBBYS50ZXN0KGEpIHx8IChuLmNzc0hvb2tzW2EgKyBiXS5zZXQgPSBOYSk7XFxuICB9KSwgbi5mbi5leHRlbmQoeyBjc3M6IGZ1bmN0aW9uIGNzcyhhLCBiKSB7XFxuICAgICAgcmV0dXJuIEsodGhpcywgZnVuY3Rpb24gKGEsIGIsIGMpIHtcXG4gICAgICAgIHZhciBkLFxcbiAgICAgICAgICAgIGUsXFxuICAgICAgICAgICAgZiA9IHt9LFxcbiAgICAgICAgICAgIGcgPSAwO2lmIChuLmlzQXJyYXkoYikpIHtcXG4gICAgICAgICAgZm9yIChkID0gQ2EoYSksIGUgPSBiLmxlbmd0aDsgZSA+IGc7IGcrKykge1xcbiAgICAgICAgICAgIGZbYltnXV0gPSBuLmNzcyhhLCBiW2ddLCAhMSwgZCk7XFxuICAgICAgICAgIH1yZXR1cm4gZjtcXG4gICAgICAgIH1yZXR1cm4gdm9pZCAwICE9PSBjID8gbi5zdHlsZShhLCBiLCBjKSA6IG4uY3NzKGEsIGIpO1xcbiAgICAgIH0sIGEsIGIsIGFyZ3VtZW50cy5sZW5ndGggPiAxKTtcXG4gICAgfSwgc2hvdzogZnVuY3Rpb24gc2hvdygpIHtcXG4gICAgICByZXR1cm4gUWEodGhpcywgITApO1xcbiAgICB9LCBoaWRlOiBmdW5jdGlvbiBoaWRlKCkge1xcbiAgICAgIHJldHVybiBRYSh0aGlzKTtcXG4gICAgfSwgdG9nZ2xlOiBmdW5jdGlvbiB0b2dnbGUoYSkge1xcbiAgICAgIHJldHVybiBcXFwiYm9vbGVhblxcXCIgPT0gdHlwZW9mIGEgPyBhID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKSA6IHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBWKHRoaXMpID8gbih0aGlzKS5zaG93KCkgOiBuKHRoaXMpLmhpZGUoKTtcXG4gICAgICB9KTtcXG4gICAgfSB9KTtmdW5jdGlvbiBSYShhLCBiLCBjLCBkLCBlKSB7XFxuICAgIHJldHVybiBuZXcgUmEucHJvdG90eXBlLmluaXQoYSwgYiwgYywgZCwgZSk7XFxuICB9bi5Ud2VlbiA9IFJhLCBSYS5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiBSYSwgaW5pdDogZnVuY3Rpb24gaW5pdChhLCBiLCBjLCBkLCBlLCBmKSB7XFxuICAgICAgdGhpcy5lbGVtID0gYSwgdGhpcy5wcm9wID0gYywgdGhpcy5lYXNpbmcgPSBlIHx8IG4uZWFzaW5nLl9kZWZhdWx0LCB0aGlzLm9wdGlvbnMgPSBiLCB0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpLCB0aGlzLmVuZCA9IGQsIHRoaXMudW5pdCA9IGYgfHwgKG4uY3NzTnVtYmVyW2NdID8gXFxcIlxcXCIgOiBcXFwicHhcXFwiKTtcXG4gICAgfSwgY3VyOiBmdW5jdGlvbiBjdXIoKSB7XFxuICAgICAgdmFyIGEgPSBSYS5wcm9wSG9va3NbdGhpcy5wcm9wXTtyZXR1cm4gYSAmJiBhLmdldCA/IGEuZ2V0KHRoaXMpIDogUmEucHJvcEhvb2tzLl9kZWZhdWx0LmdldCh0aGlzKTtcXG4gICAgfSwgcnVuOiBmdW5jdGlvbiBydW4oYSkge1xcbiAgICAgIHZhciBiLFxcbiAgICAgICAgICBjID0gUmEucHJvcEhvb2tzW3RoaXMucHJvcF07cmV0dXJuIHRoaXMub3B0aW9ucy5kdXJhdGlvbiA/IHRoaXMucG9zID0gYiA9IG4uZWFzaW5nW3RoaXMuZWFzaW5nXShhLCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBhLCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb24pIDogdGhpcy5wb3MgPSBiID0gYSwgdGhpcy5ub3cgPSAodGhpcy5lbmQgLSB0aGlzLnN0YXJ0KSAqIGIgKyB0aGlzLnN0YXJ0LCB0aGlzLm9wdGlvbnMuc3RlcCAmJiB0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMpLCBjICYmIGMuc2V0ID8gYy5zZXQodGhpcykgOiBSYS5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KHRoaXMpLCB0aGlzO1xcbiAgICB9IH0sIFJhLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFJhLnByb3RvdHlwZSwgUmEucHJvcEhvb2tzID0geyBfZGVmYXVsdDogeyBnZXQ6IGZ1bmN0aW9uIGdldChhKSB7XFxuICAgICAgICB2YXIgYjtyZXR1cm4gMSAhPT0gYS5lbGVtLm5vZGVUeXBlIHx8IG51bGwgIT0gYS5lbGVtW2EucHJvcF0gJiYgbnVsbCA9PSBhLmVsZW0uc3R5bGVbYS5wcm9wXSA/IGEuZWxlbVthLnByb3BdIDogKGIgPSBuLmNzcyhhLmVsZW0sIGEucHJvcCwgXFxcIlxcXCIpLCBiICYmIFxcXCJhdXRvXFxcIiAhPT0gYiA/IGIgOiAwKTtcXG4gICAgICB9LCBzZXQ6IGZ1bmN0aW9uIHNldChhKSB7XFxuICAgICAgICBuLmZ4LnN0ZXBbYS5wcm9wXSA/IG4uZnguc3RlcFthLnByb3BdKGEpIDogMSAhPT0gYS5lbGVtLm5vZGVUeXBlIHx8IG51bGwgPT0gYS5lbGVtLnN0eWxlW24uY3NzUHJvcHNbYS5wcm9wXV0gJiYgIW4uY3NzSG9va3NbYS5wcm9wXSA/IGEuZWxlbVthLnByb3BdID0gYS5ub3cgOiBuLnN0eWxlKGEuZWxlbSwgYS5wcm9wLCBhLm5vdyArIGEudW5pdCk7XFxuICAgICAgfSB9IH0sIFJhLnByb3BIb29rcy5zY3JvbGxUb3AgPSBSYS5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHsgc2V0OiBmdW5jdGlvbiBzZXQoYSkge1xcbiAgICAgIGEuZWxlbS5ub2RlVHlwZSAmJiBhLmVsZW0ucGFyZW50Tm9kZSAmJiAoYS5lbGVtW2EucHJvcF0gPSBhLm5vdyk7XFxuICAgIH0gfSwgbi5lYXNpbmcgPSB7IGxpbmVhcjogZnVuY3Rpb24gbGluZWFyKGEpIHtcXG4gICAgICByZXR1cm4gYTtcXG4gICAgfSwgc3dpbmc6IGZ1bmN0aW9uIHN3aW5nKGEpIHtcXG4gICAgICByZXR1cm4gLjUgLSBNYXRoLmNvcyhhICogTWF0aC5QSSkgLyAyO1xcbiAgICB9LCBfZGVmYXVsdDogXFxcInN3aW5nXFxcIiB9LCBuLmZ4ID0gUmEucHJvdG90eXBlLmluaXQsIG4uZnguc3RlcCA9IHt9O3ZhciBTYSxcXG4gICAgICBUYSxcXG4gICAgICBVYSA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcXG4gICAgICBWYSA9IC9xdWV1ZUhvb2tzJC87ZnVuY3Rpb24gV2EoKSB7XFxuICAgIHJldHVybiBhLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgIFNhID0gdm9pZCAwO1xcbiAgICB9KSwgU2EgPSBuLm5vdygpO1xcbiAgfWZ1bmN0aW9uIFhhKGEsIGIpIHtcXG4gICAgdmFyIGMsXFxuICAgICAgICBkID0gMCxcXG4gICAgICAgIGUgPSB7IGhlaWdodDogYSB9O2ZvciAoYiA9IGIgPyAxIDogMDsgNCA+IGQ7IGQgKz0gMiAtIGIpIHtcXG4gICAgICBjID0gVVtkXSwgZVtcXFwibWFyZ2luXFxcIiArIGNdID0gZVtcXFwicGFkZGluZ1xcXCIgKyBjXSA9IGE7XFxuICAgIH1yZXR1cm4gYiAmJiAoZS5vcGFjaXR5ID0gZS53aWR0aCA9IGEpLCBlO1xcbiAgfWZ1bmN0aW9uIFlhKGEsIGIsIGMpIHtcXG4gICAgZm9yICh2YXIgZCwgZSA9IChfYS50d2VlbmVyc1tiXSB8fCBbXSkuY29uY2F0KF9hLnR3ZWVuZXJzW1xcXCIqXFxcIl0pLCBmID0gMCwgZyA9IGUubGVuZ3RoOyBnID4gZjsgZisrKSB7XFxuICAgICAgaWYgKGQgPSBlW2ZdLmNhbGwoYywgYiwgYSkpIHJldHVybiBkO1xcbiAgICB9XFxuICB9ZnVuY3Rpb24gWmEoYSwgYiwgYykge1xcbiAgICB2YXIgZCxcXG4gICAgICAgIGUsXFxuICAgICAgICBmLFxcbiAgICAgICAgZyxcXG4gICAgICAgIGgsXFxuICAgICAgICBpLFxcbiAgICAgICAgaixcXG4gICAgICAgIGssXFxuICAgICAgICBsID0gdGhpcyxcXG4gICAgICAgIG0gPSB7fSxcXG4gICAgICAgIG8gPSBhLnN0eWxlLFxcbiAgICAgICAgcCA9IGEubm9kZVR5cGUgJiYgVihhKSxcXG4gICAgICAgIHEgPSBOLmdldChhLCBcXFwiZnhzaG93XFxcIik7Yy5xdWV1ZSB8fCAoaCA9IG4uX3F1ZXVlSG9va3MoYSwgXFxcImZ4XFxcIiksIG51bGwgPT0gaC51bnF1ZXVlZCAmJiAoaC51bnF1ZXVlZCA9IDAsIGkgPSBoLmVtcHR5LmZpcmUsIGguZW1wdHkuZmlyZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICBoLnVucXVldWVkIHx8IGkoKTtcXG4gICAgfSksIGgudW5xdWV1ZWQrKywgbC5hbHdheXMoZnVuY3Rpb24gKCkge1xcbiAgICAgIGwuYWx3YXlzKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGgudW5xdWV1ZWQtLSwgbi5xdWV1ZShhLCBcXFwiZnhcXFwiKS5sZW5ndGggfHwgaC5lbXB0eS5maXJlKCk7XFxuICAgICAgfSk7XFxuICAgIH0pKSwgMSA9PT0gYS5ub2RlVHlwZSAmJiAoXFxcImhlaWdodFxcXCIgaW4gYiB8fCBcXFwid2lkdGhcXFwiIGluIGIpICYmIChjLm92ZXJmbG93ID0gW28ub3ZlcmZsb3csIG8ub3ZlcmZsb3dYLCBvLm92ZXJmbG93WV0sIGogPSBuLmNzcyhhLCBcXFwiZGlzcGxheVxcXCIpLCBrID0gXFxcIm5vbmVcXFwiID09PSBqID8gTi5nZXQoYSwgXFxcIm9sZGRpc3BsYXlcXFwiKSB8fCB6YShhLm5vZGVOYW1lKSA6IGosIFxcXCJpbmxpbmVcXFwiID09PSBrICYmIFxcXCJub25lXFxcIiA9PT0gbi5jc3MoYSwgXFxcImZsb2F0XFxcIikgJiYgKG8uZGlzcGxheSA9IFxcXCJpbmxpbmUtYmxvY2tcXFwiKSksIGMub3ZlcmZsb3cgJiYgKG8ub3ZlcmZsb3cgPSBcXFwiaGlkZGVuXFxcIiwgbC5hbHdheXMoZnVuY3Rpb24gKCkge1xcbiAgICAgIG8ub3ZlcmZsb3cgPSBjLm92ZXJmbG93WzBdLCBvLm92ZXJmbG93WCA9IGMub3ZlcmZsb3dbMV0sIG8ub3ZlcmZsb3dZID0gYy5vdmVyZmxvd1syXTtcXG4gICAgfSkpO2ZvciAoZCBpbiBiKSB7XFxuICAgICAgaWYgKGUgPSBiW2RdLCBVYS5leGVjKGUpKSB7XFxuICAgICAgICBpZiAoZGVsZXRlIGJbZF0sIGYgPSBmIHx8IFxcXCJ0b2dnbGVcXFwiID09PSBlLCBlID09PSAocCA/IFxcXCJoaWRlXFxcIiA6IFxcXCJzaG93XFxcIikpIHtcXG4gICAgICAgICAgaWYgKFxcXCJzaG93XFxcIiAhPT0gZSB8fCAhcSB8fCB2b2lkIDAgPT09IHFbZF0pIGNvbnRpbnVlO3AgPSAhMDtcXG4gICAgICAgIH1tW2RdID0gcSAmJiBxW2RdIHx8IG4uc3R5bGUoYSwgZCk7XFxuICAgICAgfSBlbHNlIGogPSB2b2lkIDA7XFxuICAgIH1pZiAobi5pc0VtcHR5T2JqZWN0KG0pKSBcXFwiaW5saW5lXFxcIiA9PT0gKFxcXCJub25lXFxcIiA9PT0gaiA/IHphKGEubm9kZU5hbWUpIDogaikgJiYgKG8uZGlzcGxheSA9IGopO2Vsc2Uge1xcbiAgICAgIHEgPyBcXFwiaGlkZGVuXFxcIiBpbiBxICYmIChwID0gcS5oaWRkZW4pIDogcSA9IE4uYWNjZXNzKGEsIFxcXCJmeHNob3dcXFwiLCB7fSksIGYgJiYgKHEuaGlkZGVuID0gIXApLCBwID8gbihhKS5zaG93KCkgOiBsLmRvbmUoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgbihhKS5oaWRlKCk7XFxuICAgICAgfSksIGwuZG9uZShmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgYjtOLnJlbW92ZShhLCBcXFwiZnhzaG93XFxcIik7Zm9yIChiIGluIG0pIHtcXG4gICAgICAgICAgbi5zdHlsZShhLCBiLCBtW2JdKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtmb3IgKGQgaW4gbSkge1xcbiAgICAgICAgZyA9IFlhKHAgPyBxW2RdIDogMCwgZCwgbCksIGQgaW4gcSB8fCAocVtkXSA9IGcuc3RhcnQsIHAgJiYgKGcuZW5kID0gZy5zdGFydCwgZy5zdGFydCA9IFxcXCJ3aWR0aFxcXCIgPT09IGQgfHwgXFxcImhlaWdodFxcXCIgPT09IGQgPyAxIDogMCkpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfWZ1bmN0aW9uICRhKGEsIGIpIHtcXG4gICAgdmFyIGMsIGQsIGUsIGYsIGc7Zm9yIChjIGluIGEpIHtcXG4gICAgICBpZiAoZCA9IG4uY2FtZWxDYXNlKGMpLCBlID0gYltkXSwgZiA9IGFbY10sIG4uaXNBcnJheShmKSAmJiAoZSA9IGZbMV0sIGYgPSBhW2NdID0gZlswXSksIGMgIT09IGQgJiYgKGFbZF0gPSBmLCBkZWxldGUgYVtjXSksIGcgPSBuLmNzc0hvb2tzW2RdLCBnICYmIFxcXCJleHBhbmRcXFwiIGluIGcpIHtcXG4gICAgICAgIGYgPSBnLmV4cGFuZChmKSwgZGVsZXRlIGFbZF07Zm9yIChjIGluIGYpIHtcXG4gICAgICAgICAgYyBpbiBhIHx8IChhW2NdID0gZltjXSwgYltjXSA9IGUpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSBiW2RdID0gZTtcXG4gICAgfVxcbiAgfWZ1bmN0aW9uIF9hKGEsIGIsIGMpIHtcXG4gICAgdmFyIGQsXFxuICAgICAgICBlLFxcbiAgICAgICAgZiA9IDAsXFxuICAgICAgICBnID0gX2EucHJlZmlsdGVycy5sZW5ndGgsXFxuICAgICAgICBoID0gbi5EZWZlcnJlZCgpLmFsd2F5cyhmdW5jdGlvbiAoKSB7XFxuICAgICAgZGVsZXRlIGkuZWxlbTtcXG4gICAgfSksXFxuICAgICAgICBpID0gZnVuY3Rpb24gaSgpIHtcXG4gICAgICBpZiAoZSkgcmV0dXJuICExO2ZvciAodmFyIGIgPSBTYSB8fCBXYSgpLCBjID0gTWF0aC5tYXgoMCwgai5zdGFydFRpbWUgKyBqLmR1cmF0aW9uIC0gYiksIGQgPSBjIC8gai5kdXJhdGlvbiB8fCAwLCBmID0gMSAtIGQsIGcgPSAwLCBpID0gai50d2VlbnMubGVuZ3RoOyBpID4gZzsgZysrKSB7XFxuICAgICAgICBqLnR3ZWVuc1tnXS5ydW4oZik7XFxuICAgICAgfXJldHVybiBoLm5vdGlmeVdpdGgoYSwgW2osIGYsIGNdKSwgMSA+IGYgJiYgaSA/IGMgOiAoaC5yZXNvbHZlV2l0aChhLCBbal0pLCAhMSk7XFxuICAgIH0sXFxuICAgICAgICBqID0gaC5wcm9taXNlKHsgZWxlbTogYSwgcHJvcHM6IG4uZXh0ZW5kKHt9LCBiKSwgb3B0czogbi5leHRlbmQoITAsIHsgc3BlY2lhbEVhc2luZzoge30sIGVhc2luZzogbi5lYXNpbmcuX2RlZmF1bHQgfSwgYyksIG9yaWdpbmFsUHJvcGVydGllczogYiwgb3JpZ2luYWxPcHRpb25zOiBjLCBzdGFydFRpbWU6IFNhIHx8IFdhKCksIGR1cmF0aW9uOiBjLmR1cmF0aW9uLCB0d2VlbnM6IFtdLCBjcmVhdGVUd2VlbjogZnVuY3Rpb24gY3JlYXRlVHdlZW4oYiwgYykge1xcbiAgICAgICAgdmFyIGQgPSBuLlR3ZWVuKGEsIGoub3B0cywgYiwgYywgai5vcHRzLnNwZWNpYWxFYXNpbmdbYl0gfHwgai5vcHRzLmVhc2luZyk7cmV0dXJuIGoudHdlZW5zLnB1c2goZCksIGQ7XFxuICAgICAgfSwgc3RvcDogZnVuY3Rpb24gc3RvcChiKSB7XFxuICAgICAgICB2YXIgYyA9IDAsXFxuICAgICAgICAgICAgZCA9IGIgPyBqLnR3ZWVucy5sZW5ndGggOiAwO2lmIChlKSByZXR1cm4gdGhpcztmb3IgKGUgPSAhMDsgZCA+IGM7IGMrKykge1xcbiAgICAgICAgICBqLnR3ZWVuc1tjXS5ydW4oMSk7XFxuICAgICAgICB9cmV0dXJuIGIgPyAoaC5ub3RpZnlXaXRoKGEsIFtqLCAxLCAwXSksIGgucmVzb2x2ZVdpdGgoYSwgW2osIGJdKSkgOiBoLnJlamVjdFdpdGgoYSwgW2osIGJdKSwgdGhpcztcXG4gICAgICB9IH0pLFxcbiAgICAgICAgayA9IGoucHJvcHM7Zm9yICgkYShrLCBqLm9wdHMuc3BlY2lhbEVhc2luZyk7IGcgPiBmOyBmKyspIHtcXG4gICAgICBpZiAoZCA9IF9hLnByZWZpbHRlcnNbZl0uY2FsbChqLCBhLCBrLCBqLm9wdHMpKSByZXR1cm4gbi5pc0Z1bmN0aW9uKGQuc3RvcCkgJiYgKG4uX3F1ZXVlSG9va3Moai5lbGVtLCBqLm9wdHMucXVldWUpLnN0b3AgPSBuLnByb3h5KGQuc3RvcCwgZCkpLCBkO1xcbiAgICB9cmV0dXJuIG4ubWFwKGssIFlhLCBqKSwgbi5pc0Z1bmN0aW9uKGoub3B0cy5zdGFydCkgJiYgai5vcHRzLnN0YXJ0LmNhbGwoYSwgaiksIG4uZngudGltZXIobi5leHRlbmQoaSwgeyBlbGVtOiBhLCBhbmltOiBqLCBxdWV1ZTogai5vcHRzLnF1ZXVlIH0pKSwgai5wcm9ncmVzcyhqLm9wdHMucHJvZ3Jlc3MpLmRvbmUoai5vcHRzLmRvbmUsIGoub3B0cy5jb21wbGV0ZSkuZmFpbChqLm9wdHMuZmFpbCkuYWx3YXlzKGoub3B0cy5hbHdheXMpO1xcbiAgfW4uQW5pbWF0aW9uID0gbi5leHRlbmQoX2EsIHsgdHdlZW5lcnM6IHsgXFxcIipcXFwiOiBbZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVUd2VlbihhLCBiKTtyZXR1cm4gVyhjLmVsZW0sIGEsIFQuZXhlYyhiKSwgYyksIGM7XFxuICAgICAgfV0gfSwgdHdlZW5lcjogZnVuY3Rpb24gdHdlZW5lcihhLCBiKSB7XFxuICAgICAgbi5pc0Z1bmN0aW9uKGEpID8gKGIgPSBhLCBhID0gW1xcXCIqXFxcIl0pIDogYSA9IGEubWF0Y2goRyk7Zm9yICh2YXIgYywgZCA9IDAsIGUgPSBhLmxlbmd0aDsgZSA+IGQ7IGQrKykge1xcbiAgICAgICAgYyA9IGFbZF0sIF9hLnR3ZWVuZXJzW2NdID0gX2EudHdlZW5lcnNbY10gfHwgW10sIF9hLnR3ZWVuZXJzW2NdLnVuc2hpZnQoYik7XFxuICAgICAgfVxcbiAgICB9LCBwcmVmaWx0ZXJzOiBbWmFdLCBwcmVmaWx0ZXI6IGZ1bmN0aW9uIHByZWZpbHRlcihhLCBiKSB7XFxuICAgICAgYiA/IF9hLnByZWZpbHRlcnMudW5zaGlmdChhKSA6IF9hLnByZWZpbHRlcnMucHVzaChhKTtcXG4gICAgfSB9KSwgbi5zcGVlZCA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XFxuICAgIHZhciBkID0gYSAmJiBcXFwib2JqZWN0XFxcIiA9PSAodHlwZW9mIGEgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKGEpKSA/IG4uZXh0ZW5kKHt9LCBhKSA6IHsgY29tcGxldGU6IGMgfHwgIWMgJiYgYiB8fCBuLmlzRnVuY3Rpb24oYSkgJiYgYSwgZHVyYXRpb246IGEsIGVhc2luZzogYyAmJiBiIHx8IGIgJiYgIW4uaXNGdW5jdGlvbihiKSAmJiBiIH07cmV0dXJuIGQuZHVyYXRpb24gPSBuLmZ4Lm9mZiA/IDAgOiBcXFwibnVtYmVyXFxcIiA9PSB0eXBlb2YgZC5kdXJhdGlvbiA/IGQuZHVyYXRpb24gOiBkLmR1cmF0aW9uIGluIG4uZnguc3BlZWRzID8gbi5meC5zcGVlZHNbZC5kdXJhdGlvbl0gOiBuLmZ4LnNwZWVkcy5fZGVmYXVsdCwgbnVsbCAhPSBkLnF1ZXVlICYmIGQucXVldWUgIT09ICEwIHx8IChkLnF1ZXVlID0gXFxcImZ4XFxcIiksIGQub2xkID0gZC5jb21wbGV0ZSwgZC5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICBuLmlzRnVuY3Rpb24oZC5vbGQpICYmIGQub2xkLmNhbGwodGhpcyksIGQucXVldWUgJiYgbi5kZXF1ZXVlKHRoaXMsIGQucXVldWUpO1xcbiAgICB9LCBkO1xcbiAgfSwgbi5mbi5leHRlbmQoeyBmYWRlVG86IGZ1bmN0aW9uIGZhZGVUbyhhLCBiLCBjLCBkKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKFYpLmNzcyhcXFwib3BhY2l0eVxcXCIsIDApLnNob3coKS5lbmQoKS5hbmltYXRlKHsgb3BhY2l0eTogYiB9LCBhLCBjLCBkKTtcXG4gICAgfSwgYW5pbWF0ZTogZnVuY3Rpb24gYW5pbWF0ZShhLCBiLCBjLCBkKSB7XFxuICAgICAgdmFyIGUgPSBuLmlzRW1wdHlPYmplY3QoYSksXFxuICAgICAgICAgIGYgPSBuLnNwZWVkKGIsIGMsIGQpLFxcbiAgICAgICAgICBnID0gZnVuY3Rpb24gZygpIHtcXG4gICAgICAgIHZhciBiID0gX2EodGhpcywgbi5leHRlbmQoe30sIGEpLCBmKTsoZSB8fCBOLmdldCh0aGlzLCBcXFwiZmluaXNoXFxcIikpICYmIGIuc3RvcCghMCk7XFxuICAgICAgfTtyZXR1cm4gZy5maW5pc2ggPSBnLCBlIHx8IGYucXVldWUgPT09ICExID8gdGhpcy5lYWNoKGcpIDogdGhpcy5xdWV1ZShmLnF1ZXVlLCBnKTtcXG4gICAgfSwgc3RvcDogZnVuY3Rpb24gc3RvcChhLCBiLCBjKSB7XFxuICAgICAgdmFyIGQgPSBmdW5jdGlvbiBkKGEpIHtcXG4gICAgICAgIHZhciBiID0gYS5zdG9wO2RlbGV0ZSBhLnN0b3AsIGIoYyk7XFxuICAgICAgfTtyZXR1cm4gXFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGEgJiYgKGMgPSBiLCBiID0gYSwgYSA9IHZvaWQgMCksIGIgJiYgYSAhPT0gITEgJiYgdGhpcy5xdWV1ZShhIHx8IFxcXCJmeFxcXCIsIFtdKSwgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBiID0gITAsXFxuICAgICAgICAgICAgZSA9IG51bGwgIT0gYSAmJiBhICsgXFxcInF1ZXVlSG9va3NcXFwiLFxcbiAgICAgICAgICAgIGYgPSBuLnRpbWVycyxcXG4gICAgICAgICAgICBnID0gTi5nZXQodGhpcyk7aWYgKGUpIGdbZV0gJiYgZ1tlXS5zdG9wICYmIGQoZ1tlXSk7ZWxzZSBmb3IgKGUgaW4gZykge1xcbiAgICAgICAgICBnW2VdICYmIGdbZV0uc3RvcCAmJiBWYS50ZXN0KGUpICYmIGQoZ1tlXSk7XFxuICAgICAgICB9Zm9yIChlID0gZi5sZW5ndGg7IGUtLTspIHtcXG4gICAgICAgICAgZltlXS5lbGVtICE9PSB0aGlzIHx8IG51bGwgIT0gYSAmJiBmW2VdLnF1ZXVlICE9PSBhIHx8IChmW2VdLmFuaW0uc3RvcChjKSwgYiA9ICExLCBmLnNwbGljZShlLCAxKSk7XFxuICAgICAgICB9IWIgJiYgYyB8fCBuLmRlcXVldWUodGhpcywgYSk7XFxuICAgICAgfSk7XFxuICAgIH0sIGZpbmlzaDogZnVuY3Rpb24gZmluaXNoKGEpIHtcXG4gICAgICByZXR1cm4gYSAhPT0gITEgJiYgKGEgPSBhIHx8IFxcXCJmeFxcXCIpLCB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGIsXFxuICAgICAgICAgICAgYyA9IE4uZ2V0KHRoaXMpLFxcbiAgICAgICAgICAgIGQgPSBjW2EgKyBcXFwicXVldWVcXFwiXSxcXG4gICAgICAgICAgICBlID0gY1thICsgXFxcInF1ZXVlSG9va3NcXFwiXSxcXG4gICAgICAgICAgICBmID0gbi50aW1lcnMsXFxuICAgICAgICAgICAgZyA9IGQgPyBkLmxlbmd0aCA6IDA7Zm9yIChjLmZpbmlzaCA9ICEwLCBuLnF1ZXVlKHRoaXMsIGEsIFtdKSwgZSAmJiBlLnN0b3AgJiYgZS5zdG9wLmNhbGwodGhpcywgITApLCBiID0gZi5sZW5ndGg7IGItLTspIHtcXG4gICAgICAgICAgZltiXS5lbGVtID09PSB0aGlzICYmIGZbYl0ucXVldWUgPT09IGEgJiYgKGZbYl0uYW5pbS5zdG9wKCEwKSwgZi5zcGxpY2UoYiwgMSkpO1xcbiAgICAgICAgfWZvciAoYiA9IDA7IGcgPiBiOyBiKyspIHtcXG4gICAgICAgICAgZFtiXSAmJiBkW2JdLmZpbmlzaCAmJiBkW2JdLmZpbmlzaC5jYWxsKHRoaXMpO1xcbiAgICAgICAgfWRlbGV0ZSBjLmZpbmlzaDtcXG4gICAgICB9KTtcXG4gICAgfSB9KSwgbi5lYWNoKFtcXFwidG9nZ2xlXFxcIiwgXFxcInNob3dcXFwiLCBcXFwiaGlkZVxcXCJdLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICB2YXIgYyA9IG4uZm5bYl07bi5mbltiXSA9IGZ1bmN0aW9uIChhLCBkLCBlKSB7XFxuICAgICAgcmV0dXJuIG51bGwgPT0gYSB8fCBcXFwiYm9vbGVhblxcXCIgPT0gdHlwZW9mIGEgPyBjLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB0aGlzLmFuaW1hdGUoWGEoYiwgITApLCBhLCBkLCBlKTtcXG4gICAgfTtcXG4gIH0pLCBuLmVhY2goeyBzbGlkZURvd246IFhhKFxcXCJzaG93XFxcIiksIHNsaWRlVXA6IFhhKFxcXCJoaWRlXFxcIiksIHNsaWRlVG9nZ2xlOiBYYShcXFwidG9nZ2xlXFxcIiksIGZhZGVJbjogeyBvcGFjaXR5OiBcXFwic2hvd1xcXCIgfSwgZmFkZU91dDogeyBvcGFjaXR5OiBcXFwiaGlkZVxcXCIgfSwgZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcXFwidG9nZ2xlXFxcIiB9IH0sIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIG4uZm5bYV0gPSBmdW5jdGlvbiAoYSwgYywgZCkge1xcbiAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUoYiwgYSwgYywgZCk7XFxuICAgIH07XFxuICB9KSwgbi50aW1lcnMgPSBbXSwgbi5meC50aWNrID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgYSxcXG4gICAgICAgIGIgPSAwLFxcbiAgICAgICAgYyA9IG4udGltZXJzO2ZvciAoU2EgPSBuLm5vdygpOyBiIDwgYy5sZW5ndGg7IGIrKykge1xcbiAgICAgIGEgPSBjW2JdLCBhKCkgfHwgY1tiXSAhPT0gYSB8fCBjLnNwbGljZShiLS0sIDEpO1xcbiAgICB9Yy5sZW5ndGggfHwgbi5meC5zdG9wKCksIFNhID0gdm9pZCAwO1xcbiAgfSwgbi5meC50aW1lciA9IGZ1bmN0aW9uIChhKSB7XFxuICAgIG4udGltZXJzLnB1c2goYSksIGEoKSA/IG4uZnguc3RhcnQoKSA6IG4udGltZXJzLnBvcCgpO1xcbiAgfSwgbi5meC5pbnRlcnZhbCA9IDEzLCBuLmZ4LnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xcbiAgICBUYSB8fCAoVGEgPSBhLnNldEludGVydmFsKG4uZngudGljaywgbi5meC5pbnRlcnZhbCkpO1xcbiAgfSwgbi5meC5zdG9wID0gZnVuY3Rpb24gKCkge1xcbiAgICBhLmNsZWFySW50ZXJ2YWwoVGEpLCBUYSA9IG51bGw7XFxuICB9LCBuLmZ4LnNwZWVkcyA9IHsgc2xvdzogNjAwLCBmYXN0OiAyMDAsIF9kZWZhdWx0OiA0MDAgfSwgbi5mbi5kZWxheSA9IGZ1bmN0aW9uIChiLCBjKSB7XFxuICAgIHJldHVybiBiID0gbi5meCA/IG4uZnguc3BlZWRzW2JdIHx8IGIgOiBiLCBjID0gYyB8fCBcXFwiZnhcXFwiLCB0aGlzLnF1ZXVlKGMsIGZ1bmN0aW9uIChjLCBkKSB7XFxuICAgICAgdmFyIGUgPSBhLnNldFRpbWVvdXQoYywgYik7ZC5zdG9wID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgYS5jbGVhclRpbWVvdXQoZSk7XFxuICAgICAgfTtcXG4gICAgfSk7XFxuICB9LCBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBhID0gZC5jcmVhdGVFbGVtZW50KFxcXCJpbnB1dFxcXCIpLFxcbiAgICAgICAgYiA9IGQuY3JlYXRlRWxlbWVudChcXFwic2VsZWN0XFxcIiksXFxuICAgICAgICBjID0gYi5hcHBlbmRDaGlsZChkLmNyZWF0ZUVsZW1lbnQoXFxcIm9wdGlvblxcXCIpKTthLnR5cGUgPSBcXFwiY2hlY2tib3hcXFwiLCBsLmNoZWNrT24gPSBcXFwiXFxcIiAhPT0gYS52YWx1ZSwgbC5vcHRTZWxlY3RlZCA9IGMuc2VsZWN0ZWQsIGIuZGlzYWJsZWQgPSAhMCwgbC5vcHREaXNhYmxlZCA9ICFjLmRpc2FibGVkLCBhID0gZC5jcmVhdGVFbGVtZW50KFxcXCJpbnB1dFxcXCIpLCBhLnZhbHVlID0gXFxcInRcXFwiLCBhLnR5cGUgPSBcXFwicmFkaW9cXFwiLCBsLnJhZGlvVmFsdWUgPSBcXFwidFxcXCIgPT09IGEudmFsdWU7XFxuICB9KCk7dmFyIGFiLFxcbiAgICAgIGJiID0gbi5leHByLmF0dHJIYW5kbGU7bi5mbi5leHRlbmQoeyBhdHRyOiBmdW5jdGlvbiBhdHRyKGEsIGIpIHtcXG4gICAgICByZXR1cm4gSyh0aGlzLCBuLmF0dHIsIGEsIGIsIGFyZ3VtZW50cy5sZW5ndGggPiAxKTtcXG4gICAgfSwgcmVtb3ZlQXR0cjogZnVuY3Rpb24gcmVtb3ZlQXR0cihhKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBuLnJlbW92ZUF0dHIodGhpcywgYSk7XFxuICAgICAgfSk7XFxuICAgIH0gfSksIG4uZXh0ZW5kKHsgYXR0cjogZnVuY3Rpb24gYXR0cihhLCBiLCBjKSB7XFxuICAgICAgdmFyIGQsXFxuICAgICAgICAgIGUsXFxuICAgICAgICAgIGYgPSBhLm5vZGVUeXBlO2lmICgzICE9PSBmICYmIDggIT09IGYgJiYgMiAhPT0gZikgcmV0dXJuIFxcXCJ1bmRlZmluZWRcXFwiID09IHR5cGVvZiBhLmdldEF0dHJpYnV0ZSA/IG4ucHJvcChhLCBiLCBjKSA6ICgxID09PSBmICYmIG4uaXNYTUxEb2MoYSkgfHwgKGIgPSBiLnRvTG93ZXJDYXNlKCksIGUgPSBuLmF0dHJIb29rc1tiXSB8fCAobi5leHByLm1hdGNoLmJvb2wudGVzdChiKSA/IGFiIDogdm9pZCAwKSksIHZvaWQgMCAhPT0gYyA/IG51bGwgPT09IGMgPyB2b2lkIG4ucmVtb3ZlQXR0cihhLCBiKSA6IGUgJiYgXFxcInNldFxcXCIgaW4gZSAmJiB2b2lkIDAgIT09IChkID0gZS5zZXQoYSwgYywgYikpID8gZCA6IChhLnNldEF0dHJpYnV0ZShiLCBjICsgXFxcIlxcXCIpLCBjKSA6IGUgJiYgXFxcImdldFxcXCIgaW4gZSAmJiBudWxsICE9PSAoZCA9IGUuZ2V0KGEsIGIpKSA/IGQgOiAoZCA9IG4uZmluZC5hdHRyKGEsIGIpLCBudWxsID09IGQgPyB2b2lkIDAgOiBkKSk7XFxuICAgIH0sIGF0dHJIb29rczogeyB0eXBlOiB7IHNldDogZnVuY3Rpb24gc2V0KGEsIGIpIHtcXG4gICAgICAgICAgaWYgKCFsLnJhZGlvVmFsdWUgJiYgXFxcInJhZGlvXFxcIiA9PT0gYiAmJiBuLm5vZGVOYW1lKGEsIFxcXCJpbnB1dFxcXCIpKSB7XFxuICAgICAgICAgICAgdmFyIGMgPSBhLnZhbHVlO3JldHVybiBhLnNldEF0dHJpYnV0ZShcXFwidHlwZVxcXCIsIGIpLCBjICYmIChhLnZhbHVlID0gYyksIGI7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gfSB9LCByZW1vdmVBdHRyOiBmdW5jdGlvbiByZW1vdmVBdHRyKGEsIGIpIHtcXG4gICAgICB2YXIgYyxcXG4gICAgICAgICAgZCxcXG4gICAgICAgICAgZSA9IDAsXFxuICAgICAgICAgIGYgPSBiICYmIGIubWF0Y2goRyk7aWYgKGYgJiYgMSA9PT0gYS5ub2RlVHlwZSkgd2hpbGUgKGMgPSBmW2UrK10pIHtcXG4gICAgICAgIGQgPSBuLnByb3BGaXhbY10gfHwgYywgbi5leHByLm1hdGNoLmJvb2wudGVzdChjKSAmJiAoYVtkXSA9ICExKSwgYS5yZW1vdmVBdHRyaWJ1dGUoYyk7XFxuICAgICAgfVxcbiAgICB9IH0pLCBhYiA9IHsgc2V0OiBmdW5jdGlvbiBzZXQoYSwgYiwgYykge1xcbiAgICAgIHJldHVybiBiID09PSAhMSA/IG4ucmVtb3ZlQXR0cihhLCBjKSA6IGEuc2V0QXR0cmlidXRlKGMsIGMpLCBjO1xcbiAgICB9IH0sIG4uZWFjaChuLmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goL1xcXFx3Ky9nKSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgdmFyIGMgPSBiYltiXSB8fCBuLmZpbmQuYXR0cjtiYltiXSA9IGZ1bmN0aW9uIChhLCBiLCBkKSB7XFxuICAgICAgdmFyIGUsIGY7cmV0dXJuIGQgfHwgKGYgPSBiYltiXSwgYmJbYl0gPSBlLCBlID0gbnVsbCAhPSBjKGEsIGIsIGQpID8gYi50b0xvd2VyQ2FzZSgpIDogbnVsbCwgYmJbYl0gPSBmKSwgZTtcXG4gICAgfTtcXG4gIH0pO3ZhciBjYiA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXFxuICAgICAgZGIgPSAvXig/OmF8YXJlYSkkL2k7bi5mbi5leHRlbmQoeyBwcm9wOiBmdW5jdGlvbiBwcm9wKGEsIGIpIHtcXG4gICAgICByZXR1cm4gSyh0aGlzLCBuLnByb3AsIGEsIGIsIGFyZ3VtZW50cy5sZW5ndGggPiAxKTtcXG4gICAgfSwgcmVtb3ZlUHJvcDogZnVuY3Rpb24gcmVtb3ZlUHJvcChhKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBkZWxldGUgdGhpc1tuLnByb3BGaXhbYV0gfHwgYV07XFxuICAgICAgfSk7XFxuICAgIH0gfSksIG4uZXh0ZW5kKHsgcHJvcDogZnVuY3Rpb24gcHJvcChhLCBiLCBjKSB7XFxuICAgICAgdmFyIGQsXFxuICAgICAgICAgIGUsXFxuICAgICAgICAgIGYgPSBhLm5vZGVUeXBlO2lmICgzICE9PSBmICYmIDggIT09IGYgJiYgMiAhPT0gZikgcmV0dXJuIDEgPT09IGYgJiYgbi5pc1hNTERvYyhhKSB8fCAoYiA9IG4ucHJvcEZpeFtiXSB8fCBiLCBlID0gbi5wcm9wSG9va3NbYl0pLCB2b2lkIDAgIT09IGMgPyBlICYmIFxcXCJzZXRcXFwiIGluIGUgJiYgdm9pZCAwICE9PSAoZCA9IGUuc2V0KGEsIGMsIGIpKSA/IGQgOiBhW2JdID0gYyA6IGUgJiYgXFxcImdldFxcXCIgaW4gZSAmJiBudWxsICE9PSAoZCA9IGUuZ2V0KGEsIGIpKSA/IGQgOiBhW2JdO1xcbiAgICB9LCBwcm9wSG9va3M6IHsgdGFiSW5kZXg6IHsgZ2V0OiBmdW5jdGlvbiBnZXQoYSkge1xcbiAgICAgICAgICB2YXIgYiA9IG4uZmluZC5hdHRyKGEsIFxcXCJ0YWJpbmRleFxcXCIpO3JldHVybiBiID8gcGFyc2VJbnQoYiwgMTApIDogY2IudGVzdChhLm5vZGVOYW1lKSB8fCBkYi50ZXN0KGEubm9kZU5hbWUpICYmIGEuaHJlZiA/IDAgOiAtMTtcXG4gICAgICAgIH0gfSB9LCBwcm9wRml4OiB7IFxcXCJmb3JcXFwiOiBcXFwiaHRtbEZvclxcXCIsIFxcXCJjbGFzc1xcXCI6IFxcXCJjbGFzc05hbWVcXFwiIH0gfSksIGwub3B0U2VsZWN0ZWQgfHwgKG4ucHJvcEhvb2tzLnNlbGVjdGVkID0geyBnZXQ6IGZ1bmN0aW9uIGdldChhKSB7XFxuICAgICAgdmFyIGIgPSBhLnBhcmVudE5vZGU7cmV0dXJuIGIgJiYgYi5wYXJlbnROb2RlICYmIGIucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4LCBudWxsO1xcbiAgICB9LCBzZXQ6IGZ1bmN0aW9uIHNldChhKSB7XFxuICAgICAgdmFyIGIgPSBhLnBhcmVudE5vZGU7YiAmJiAoYi5zZWxlY3RlZEluZGV4LCBiLnBhcmVudE5vZGUgJiYgYi5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXgpO1xcbiAgICB9IH0pLCBuLmVhY2goW1xcXCJ0YWJJbmRleFxcXCIsIFxcXCJyZWFkT25seVxcXCIsIFxcXCJtYXhMZW5ndGhcXFwiLCBcXFwiY2VsbFNwYWNpbmdcXFwiLCBcXFwiY2VsbFBhZGRpbmdcXFwiLCBcXFwicm93U3BhblxcXCIsIFxcXCJjb2xTcGFuXFxcIiwgXFxcInVzZU1hcFxcXCIsIFxcXCJmcmFtZUJvcmRlclxcXCIsIFxcXCJjb250ZW50RWRpdGFibGVcXFwiXSwgZnVuY3Rpb24gKCkge1xcbiAgICBuLnByb3BGaXhbdGhpcy50b0xvd2VyQ2FzZSgpXSA9IHRoaXM7XFxuICB9KTt2YXIgZWIgPSAvW1xcXFx0XFxcXHJcXFxcblxcXFxmXS9nO2Z1bmN0aW9uIGZiKGEpIHtcXG4gICAgcmV0dXJuIGEuZ2V0QXR0cmlidXRlICYmIGEuZ2V0QXR0cmlidXRlKFxcXCJjbGFzc1xcXCIpIHx8IFxcXCJcXFwiO1xcbiAgfW4uZm4uZXh0ZW5kKHsgYWRkQ2xhc3M6IGZ1bmN0aW9uIGFkZENsYXNzKGEpIHtcXG4gICAgICB2YXIgYixcXG4gICAgICAgICAgYyxcXG4gICAgICAgICAgZCxcXG4gICAgICAgICAgZSxcXG4gICAgICAgICAgZixcXG4gICAgICAgICAgZyxcXG4gICAgICAgICAgaCxcXG4gICAgICAgICAgaSA9IDA7aWYgKG4uaXNGdW5jdGlvbihhKSkgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoYikge1xcbiAgICAgICAgbih0aGlzKS5hZGRDbGFzcyhhLmNhbGwodGhpcywgYiwgZmIodGhpcykpKTtcXG4gICAgICB9KTtpZiAoXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIGEgJiYgYSkge1xcbiAgICAgICAgYiA9IGEubWF0Y2goRykgfHwgW107d2hpbGUgKGMgPSB0aGlzW2krK10pIHtcXG4gICAgICAgICAgaWYgKGUgPSBmYihjKSwgZCA9IDEgPT09IGMubm9kZVR5cGUgJiYgKFxcXCIgXFxcIiArIGUgKyBcXFwiIFxcXCIpLnJlcGxhY2UoZWIsIFxcXCIgXFxcIikpIHtcXG4gICAgICAgICAgICBnID0gMDt3aGlsZSAoZiA9IGJbZysrXSkge1xcbiAgICAgICAgICAgICAgZC5pbmRleE9mKFxcXCIgXFxcIiArIGYgKyBcXFwiIFxcXCIpIDwgMCAmJiAoZCArPSBmICsgXFxcIiBcXFwiKTtcXG4gICAgICAgICAgICB9aCA9IG4udHJpbShkKSwgZSAhPT0gaCAmJiBjLnNldEF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiLCBoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1yZXR1cm4gdGhpcztcXG4gICAgfSwgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGEpIHtcXG4gICAgICB2YXIgYixcXG4gICAgICAgICAgYyxcXG4gICAgICAgICAgZCxcXG4gICAgICAgICAgZSxcXG4gICAgICAgICAgZixcXG4gICAgICAgICAgZyxcXG4gICAgICAgICAgaCxcXG4gICAgICAgICAgaSA9IDA7aWYgKG4uaXNGdW5jdGlvbihhKSkgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoYikge1xcbiAgICAgICAgbih0aGlzKS5yZW1vdmVDbGFzcyhhLmNhbGwodGhpcywgYiwgZmIodGhpcykpKTtcXG4gICAgICB9KTtpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLmF0dHIoXFxcImNsYXNzXFxcIiwgXFxcIlxcXCIpO2lmIChcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYSAmJiBhKSB7XFxuICAgICAgICBiID0gYS5tYXRjaChHKSB8fCBbXTt3aGlsZSAoYyA9IHRoaXNbaSsrXSkge1xcbiAgICAgICAgICBpZiAoZSA9IGZiKGMpLCBkID0gMSA9PT0gYy5ub2RlVHlwZSAmJiAoXFxcIiBcXFwiICsgZSArIFxcXCIgXFxcIikucmVwbGFjZShlYiwgXFxcIiBcXFwiKSkge1xcbiAgICAgICAgICAgIGcgPSAwO3doaWxlIChmID0gYltnKytdKSB7XFxuICAgICAgICAgICAgICB3aGlsZSAoZC5pbmRleE9mKFxcXCIgXFxcIiArIGYgKyBcXFwiIFxcXCIpID4gLTEpIHtcXG4gICAgICAgICAgICAgICAgZCA9IGQucmVwbGFjZShcXFwiIFxcXCIgKyBmICsgXFxcIiBcXFwiLCBcXFwiIFxcXCIpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1oID0gbi50cmltKGQpLCBlICE9PSBoICYmIGMuc2V0QXR0cmlidXRlKFxcXCJjbGFzc1xcXCIsIGgpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfXJldHVybiB0aGlzO1xcbiAgICB9LCB0b2dnbGVDbGFzczogZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoYSwgYikge1xcbiAgICAgIHZhciBjID0gdHlwZW9mIGEgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKGEpO3JldHVybiBcXFwiYm9vbGVhblxcXCIgPT0gdHlwZW9mIGIgJiYgXFxcInN0cmluZ1xcXCIgPT09IGMgPyBiID8gdGhpcy5hZGRDbGFzcyhhKSA6IHRoaXMucmVtb3ZlQ2xhc3MoYSkgOiBuLmlzRnVuY3Rpb24oYSkgPyB0aGlzLmVhY2goZnVuY3Rpb24gKGMpIHtcXG4gICAgICAgIG4odGhpcykudG9nZ2xlQ2xhc3MoYS5jYWxsKHRoaXMsIGMsIGZiKHRoaXMpLCBiKSwgYik7XFxuICAgICAgfSkgOiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGIsIGQsIGUsIGY7aWYgKFxcXCJzdHJpbmdcXFwiID09PSBjKSB7XFxuICAgICAgICAgIGQgPSAwLCBlID0gbih0aGlzKSwgZiA9IGEubWF0Y2goRykgfHwgW107d2hpbGUgKGIgPSBmW2QrK10pIHtcXG4gICAgICAgICAgICBlLmhhc0NsYXNzKGIpID8gZS5yZW1vdmVDbGFzcyhiKSA6IGUuYWRkQ2xhc3MoYik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB2b2lkIDAgIT09IGEgJiYgXFxcImJvb2xlYW5cXFwiICE9PSBjIHx8IChiID0gZmIodGhpcyksIGIgJiYgTi5zZXQodGhpcywgXFxcIl9fY2xhc3NOYW1lX19cXFwiLCBiKSwgdGhpcy5zZXRBdHRyaWJ1dGUgJiYgdGhpcy5zZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIiwgYiB8fCBhID09PSAhMSA/IFxcXCJcXFwiIDogTi5nZXQodGhpcywgXFxcIl9fY2xhc3NOYW1lX19cXFwiKSB8fCBcXFwiXFxcIikpO1xcbiAgICAgIH0pO1xcbiAgICB9LCBoYXNDbGFzczogZnVuY3Rpb24gaGFzQ2xhc3MoYSkge1xcbiAgICAgIHZhciBiLFxcbiAgICAgICAgICBjLFxcbiAgICAgICAgICBkID0gMDtiID0gXFxcIiBcXFwiICsgYSArIFxcXCIgXFxcIjt3aGlsZSAoYyA9IHRoaXNbZCsrXSkge1xcbiAgICAgICAgaWYgKDEgPT09IGMubm9kZVR5cGUgJiYgKFxcXCIgXFxcIiArIGZiKGMpICsgXFxcIiBcXFwiKS5yZXBsYWNlKGViLCBcXFwiIFxcXCIpLmluZGV4T2YoYikgPiAtMSkgcmV0dXJuICEwO1xcbiAgICAgIH1yZXR1cm4gITE7XFxuICAgIH0gfSk7dmFyIGdiID0gL1xcXFxyL2csXFxuICAgICAgaGIgPSAvW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl0rL2c7bi5mbi5leHRlbmQoeyB2YWw6IGZ1bmN0aW9uIHZhbChhKSB7XFxuICAgICAgdmFyIGIsXFxuICAgICAgICAgIGMsXFxuICAgICAgICAgIGQsXFxuICAgICAgICAgIGUgPSB0aGlzWzBdO3tcXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZCA9IG4uaXNGdW5jdGlvbihhKSwgdGhpcy5lYWNoKGZ1bmN0aW9uIChjKSB7XFxuICAgICAgICAgIHZhciBlOzEgPT09IHRoaXMubm9kZVR5cGUgJiYgKGUgPSBkID8gYS5jYWxsKHRoaXMsIGMsIG4odGhpcykudmFsKCkpIDogYSwgbnVsbCA9PSBlID8gZSA9IFxcXCJcXFwiIDogXFxcIm51bWJlclxcXCIgPT0gdHlwZW9mIGUgPyBlICs9IFxcXCJcXFwiIDogbi5pc0FycmF5KGUpICYmIChlID0gbi5tYXAoZSwgZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgICAgICByZXR1cm4gbnVsbCA9PSBhID8gXFxcIlxcXCIgOiBhICsgXFxcIlxcXCI7XFxuICAgICAgICAgIH0pKSwgYiA9IG4udmFsSG9va3NbdGhpcy50eXBlXSB8fCBuLnZhbEhvb2tzW3RoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0sIGIgJiYgXFxcInNldFxcXCIgaW4gYiAmJiB2b2lkIDAgIT09IGIuc2V0KHRoaXMsIGUsIFxcXCJ2YWx1ZVxcXCIpIHx8ICh0aGlzLnZhbHVlID0gZSkpO1xcbiAgICAgICAgfSk7aWYgKGUpIHJldHVybiBiID0gbi52YWxIb29rc1tlLnR5cGVdIHx8IG4udmFsSG9va3NbZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXSwgYiAmJiBcXFwiZ2V0XFxcIiBpbiBiICYmIHZvaWQgMCAhPT0gKGMgPSBiLmdldChlLCBcXFwidmFsdWVcXFwiKSkgPyBjIDogKGMgPSBlLnZhbHVlLCBcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYyA/IGMucmVwbGFjZShnYiwgXFxcIlxcXCIpIDogbnVsbCA9PSBjID8gXFxcIlxcXCIgOiBjKTtcXG4gICAgICB9XFxuICAgIH0gfSksIG4uZXh0ZW5kKHsgdmFsSG9va3M6IHsgb3B0aW9uOiB7IGdldDogZnVuY3Rpb24gZ2V0KGEpIHtcXG4gICAgICAgICAgdmFyIGIgPSBuLmZpbmQuYXR0cihhLCBcXFwidmFsdWVcXFwiKTtyZXR1cm4gbnVsbCAhPSBiID8gYiA6IG4udHJpbShuLnRleHQoYSkpLnJlcGxhY2UoaGIsIFxcXCIgXFxcIik7XFxuICAgICAgICB9IH0sIHNlbGVjdDogeyBnZXQ6IGZ1bmN0aW9uIGdldChhKSB7XFxuICAgICAgICAgIGZvciAodmFyIGIsIGMsIGQgPSBhLm9wdGlvbnMsIGUgPSBhLnNlbGVjdGVkSW5kZXgsIGYgPSBcXFwic2VsZWN0LW9uZVxcXCIgPT09IGEudHlwZSB8fCAwID4gZSwgZyA9IGYgPyBudWxsIDogW10sIGggPSBmID8gZSArIDEgOiBkLmxlbmd0aCwgaSA9IDAgPiBlID8gaCA6IGYgPyBlIDogMDsgaCA+IGk7IGkrKykge1xcbiAgICAgICAgICAgIGlmIChjID0gZFtpXSwgKGMuc2VsZWN0ZWQgfHwgaSA9PT0gZSkgJiYgKGwub3B0RGlzYWJsZWQgPyAhYy5kaXNhYmxlZCA6IG51bGwgPT09IGMuZ2V0QXR0cmlidXRlKFxcXCJkaXNhYmxlZFxcXCIpKSAmJiAoIWMucGFyZW50Tm9kZS5kaXNhYmxlZCB8fCAhbi5ub2RlTmFtZShjLnBhcmVudE5vZGUsIFxcXCJvcHRncm91cFxcXCIpKSkge1xcbiAgICAgICAgICAgICAgaWYgKGIgPSBuKGMpLnZhbCgpLCBmKSByZXR1cm4gYjtnLnB1c2goYik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9cmV0dXJuIGc7XFxuICAgICAgICB9LCBzZXQ6IGZ1bmN0aW9uIHNldChhLCBiKSB7XFxuICAgICAgICAgIHZhciBjLFxcbiAgICAgICAgICAgICAgZCxcXG4gICAgICAgICAgICAgIGUgPSBhLm9wdGlvbnMsXFxuICAgICAgICAgICAgICBmID0gbi5tYWtlQXJyYXkoYiksXFxuICAgICAgICAgICAgICBnID0gZS5sZW5ndGg7d2hpbGUgKGctLSkge1xcbiAgICAgICAgICAgIGQgPSBlW2ddLCAoZC5zZWxlY3RlZCA9IG4uaW5BcnJheShuLnZhbEhvb2tzLm9wdGlvbi5nZXQoZCksIGYpID4gLTEpICYmIChjID0gITApO1xcbiAgICAgICAgICB9cmV0dXJuIGMgfHwgKGEuc2VsZWN0ZWRJbmRleCA9IC0xKSwgZjtcXG4gICAgICAgIH0gfSB9IH0pLCBuLmVhY2goW1xcXCJyYWRpb1xcXCIsIFxcXCJjaGVja2JveFxcXCJdLCBmdW5jdGlvbiAoKSB7XFxuICAgIG4udmFsSG9va3NbdGhpc10gPSB7IHNldDogZnVuY3Rpb24gc2V0KGEsIGIpIHtcXG4gICAgICAgIHJldHVybiBuLmlzQXJyYXkoYikgPyBhLmNoZWNrZWQgPSBuLmluQXJyYXkobihhKS52YWwoKSwgYikgPiAtMSA6IHZvaWQgMDtcXG4gICAgICB9IH0sIGwuY2hlY2tPbiB8fCAobi52YWxIb29rc1t0aGlzXS5nZXQgPSBmdW5jdGlvbiAoYSkge1xcbiAgICAgIHJldHVybiBudWxsID09PSBhLmdldEF0dHJpYnV0ZShcXFwidmFsdWVcXFwiKSA/IFxcXCJvblxcXCIgOiBhLnZhbHVlO1xcbiAgICB9KTtcXG4gIH0pO3ZhciBpYiA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLztuLmV4dGVuZChuLmV2ZW50LCB7IHRyaWdnZXI6IGZ1bmN0aW9uIHRyaWdnZXIoYiwgYywgZSwgZikge1xcbiAgICAgIHZhciBnLFxcbiAgICAgICAgICBoLFxcbiAgICAgICAgICBpLFxcbiAgICAgICAgICBqLFxcbiAgICAgICAgICBsLFxcbiAgICAgICAgICBtLFxcbiAgICAgICAgICBvLFxcbiAgICAgICAgICBwID0gW2UgfHwgZF0sXFxuICAgICAgICAgIHEgPSBrLmNhbGwoYiwgXFxcInR5cGVcXFwiKSA/IGIudHlwZSA6IGIsXFxuICAgICAgICAgIHIgPSBrLmNhbGwoYiwgXFxcIm5hbWVzcGFjZVxcXCIpID8gYi5uYW1lc3BhY2Uuc3BsaXQoXFxcIi5cXFwiKSA6IFtdO2lmIChoID0gaSA9IGUgPSBlIHx8IGQsIDMgIT09IGUubm9kZVR5cGUgJiYgOCAhPT0gZS5ub2RlVHlwZSAmJiAhaWIudGVzdChxICsgbi5ldmVudC50cmlnZ2VyZWQpICYmIChxLmluZGV4T2YoXFxcIi5cXFwiKSA+IC0xICYmIChyID0gcS5zcGxpdChcXFwiLlxcXCIpLCBxID0gci5zaGlmdCgpLCByLnNvcnQoKSksIGwgPSBxLmluZGV4T2YoXFxcIjpcXFwiKSA8IDAgJiYgXFxcIm9uXFxcIiArIHEsIGIgPSBiW24uZXhwYW5kb10gPyBiIDogbmV3IG4uRXZlbnQocSwgXFxcIm9iamVjdFxcXCIgPT0gKHR5cGVvZiBiID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZihiKSkgJiYgYiksIGIuaXNUcmlnZ2VyID0gZiA/IDIgOiAzLCBiLm5hbWVzcGFjZSA9IHIuam9pbihcXFwiLlxcXCIpLCBiLnJuYW1lc3BhY2UgPSBiLm5hbWVzcGFjZSA/IG5ldyBSZWdFeHAoXFxcIihefFxcXFxcXFxcLilcXFwiICsgci5qb2luKFxcXCJcXFxcXFxcXC4oPzouKlxcXFxcXFxcLnwpXFxcIikgKyBcXFwiKFxcXFxcXFxcLnwkKVxcXCIpIDogbnVsbCwgYi5yZXN1bHQgPSB2b2lkIDAsIGIudGFyZ2V0IHx8IChiLnRhcmdldCA9IGUpLCBjID0gbnVsbCA9PSBjID8gW2JdIDogbi5tYWtlQXJyYXkoYywgW2JdKSwgbyA9IG4uZXZlbnQuc3BlY2lhbFtxXSB8fCB7fSwgZiB8fCAhby50cmlnZ2VyIHx8IG8udHJpZ2dlci5hcHBseShlLCBjKSAhPT0gITEpKSB7XFxuICAgICAgICBpZiAoIWYgJiYgIW8ubm9CdWJibGUgJiYgIW4uaXNXaW5kb3coZSkpIHtcXG4gICAgICAgICAgZm9yIChqID0gby5kZWxlZ2F0ZVR5cGUgfHwgcSwgaWIudGVzdChqICsgcSkgfHwgKGggPSBoLnBhcmVudE5vZGUpOyBoOyBoID0gaC5wYXJlbnROb2RlKSB7XFxuICAgICAgICAgICAgcC5wdXNoKGgpLCBpID0gaDtcXG4gICAgICAgICAgfWkgPT09IChlLm93bmVyRG9jdW1lbnQgfHwgZCkgJiYgcC5wdXNoKGkuZGVmYXVsdFZpZXcgfHwgaS5wYXJlbnRXaW5kb3cgfHwgYSk7XFxuICAgICAgICB9ZyA9IDA7d2hpbGUgKChoID0gcFtnKytdKSAmJiAhYi5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XFxuICAgICAgICAgIGIudHlwZSA9IGcgPiAxID8gaiA6IG8uYmluZFR5cGUgfHwgcSwgbSA9IChOLmdldChoLCBcXFwiZXZlbnRzXFxcIikgfHwge30pW2IudHlwZV0gJiYgTi5nZXQoaCwgXFxcImhhbmRsZVxcXCIpLCBtICYmIG0uYXBwbHkoaCwgYyksIG0gPSBsICYmIGhbbF0sIG0gJiYgbS5hcHBseSAmJiBMKGgpICYmIChiLnJlc3VsdCA9IG0uYXBwbHkoaCwgYyksIGIucmVzdWx0ID09PSAhMSAmJiBiLnByZXZlbnREZWZhdWx0KCkpO1xcbiAgICAgICAgfXJldHVybiBiLnR5cGUgPSBxLCBmIHx8IGIuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgby5fZGVmYXVsdCAmJiBvLl9kZWZhdWx0LmFwcGx5KHAucG9wKCksIGMpICE9PSAhMSB8fCAhTChlKSB8fCBsICYmIG4uaXNGdW5jdGlvbihlW3FdKSAmJiAhbi5pc1dpbmRvdyhlKSAmJiAoaSA9IGVbbF0sIGkgJiYgKGVbbF0gPSBudWxsKSwgbi5ldmVudC50cmlnZ2VyZWQgPSBxLCBlW3FdKCksIG4uZXZlbnQudHJpZ2dlcmVkID0gdm9pZCAwLCBpICYmIChlW2xdID0gaSkpLCBiLnJlc3VsdDtcXG4gICAgICB9XFxuICAgIH0sIHNpbXVsYXRlOiBmdW5jdGlvbiBzaW11bGF0ZShhLCBiLCBjKSB7XFxuICAgICAgdmFyIGQgPSBuLmV4dGVuZChuZXcgbi5FdmVudCgpLCBjLCB7IHR5cGU6IGEsIGlzU2ltdWxhdGVkOiAhMCB9KTtuLmV2ZW50LnRyaWdnZXIoZCwgbnVsbCwgYik7XFxuICAgIH0gfSksIG4uZm4uZXh0ZW5kKHsgdHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlcihhLCBiKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBuLmV2ZW50LnRyaWdnZXIoYSwgYiwgdGhpcyk7XFxuICAgICAgfSk7XFxuICAgIH0sIHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiB0cmlnZ2VySGFuZGxlcihhLCBiKSB7XFxuICAgICAgdmFyIGMgPSB0aGlzWzBdO3JldHVybiBjID8gbi5ldmVudC50cmlnZ2VyKGEsIGIsIGMsICEwKSA6IHZvaWQgMDtcXG4gICAgfSB9KSwgbi5lYWNoKFxcXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgbG9hZCByZXNpemUgc2Nyb2xsIHVubG9hZCBjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGVycm9yIGNvbnRleHRtZW51XFxcIi5zcGxpdChcXFwiIFxcXCIpLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICBuLmZuW2JdID0gZnVuY3Rpb24gKGEsIGMpIHtcXG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgPyB0aGlzLm9uKGIsIG51bGwsIGEsIGMpIDogdGhpcy50cmlnZ2VyKGIpO1xcbiAgICB9O1xcbiAgfSksIG4uZm4uZXh0ZW5kKHsgaG92ZXI6IGZ1bmN0aW9uIGhvdmVyKGEsIGIpIHtcXG4gICAgICByZXR1cm4gdGhpcy5tb3VzZWVudGVyKGEpLm1vdXNlbGVhdmUoYiB8fCBhKTtcXG4gICAgfSB9KSwgbC5mb2N1c2luID0gXFxcIm9uZm9jdXNpblxcXCIgaW4gYSwgbC5mb2N1c2luIHx8IG4uZWFjaCh7IGZvY3VzOiBcXFwiZm9jdXNpblxcXCIsIGJsdXI6IFxcXCJmb2N1c291dFxcXCIgfSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgdmFyIGMgPSBmdW5jdGlvbiBjKGEpIHtcXG4gICAgICBuLmV2ZW50LnNpbXVsYXRlKGIsIGEudGFyZ2V0LCBuLmV2ZW50LmZpeChhKSk7XFxuICAgIH07bi5ldmVudC5zcGVjaWFsW2JdID0geyBzZXR1cDogZnVuY3Rpb24gc2V0dXAoKSB7XFxuICAgICAgICB2YXIgZCA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxcbiAgICAgICAgICAgIGUgPSBOLmFjY2VzcyhkLCBiKTtlIHx8IGQuYWRkRXZlbnRMaXN0ZW5lcihhLCBjLCAhMCksIE4uYWNjZXNzKGQsIGIsIChlIHx8IDApICsgMSk7XFxuICAgICAgfSwgdGVhcmRvd246IGZ1bmN0aW9uIHRlYXJkb3duKCkge1xcbiAgICAgICAgdmFyIGQgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcXG4gICAgICAgICAgICBlID0gTi5hY2Nlc3MoZCwgYikgLSAxO2UgPyBOLmFjY2VzcyhkLCBiLCBlKSA6IChkLnJlbW92ZUV2ZW50TGlzdGVuZXIoYSwgYywgITApLCBOLnJlbW92ZShkLCBiKSk7XFxuICAgICAgfSB9O1xcbiAgfSk7dmFyIGpiID0gYS5sb2NhdGlvbixcXG4gICAgICBrYiA9IG4ubm93KCksXFxuICAgICAgbGIgPSAvXFxcXD8vO24ucGFyc2VKU09OID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoYSArIFxcXCJcXFwiKTtcXG4gIH0sIG4ucGFyc2VYTUwgPSBmdW5jdGlvbiAoYikge1xcbiAgICB2YXIgYztpZiAoIWIgfHwgXFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGIpIHJldHVybiBudWxsO3RyeSB7XFxuICAgICAgYyA9IG5ldyBhLkRPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhiLCBcXFwidGV4dC94bWxcXFwiKTtcXG4gICAgfSBjYXRjaCAoZCkge1xcbiAgICAgIGMgPSB2b2lkIDA7XFxuICAgIH1yZXR1cm4gYyAmJiAhYy5nZXRFbGVtZW50c0J5VGFnTmFtZShcXFwicGFyc2VyZXJyb3JcXFwiKS5sZW5ndGggfHwgbi5lcnJvcihcXFwiSW52YWxpZCBYTUw6IFxcXCIgKyBiKSwgYztcXG4gIH07dmFyIG1iID0gLyMuKiQvLFxcbiAgICAgIG5iID0gLyhbPyZdKV89W14mXSovLFxcbiAgICAgIG9iID0gL14oLio/KTpbIFxcXFx0XSooW15cXFxcclxcXFxuXSopJC9nbSxcXG4gICAgICBwYiA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxcbiAgICAgIHFiID0gL14oPzpHRVR8SEVBRCkkLyxcXG4gICAgICByYiA9IC9eXFxcXC9cXFxcLy8sXFxuICAgICAgc2IgPSB7fSxcXG4gICAgICB0YiA9IHt9LFxcbiAgICAgIHViID0gXFxcIiovXFxcIi5jb25jYXQoXFxcIipcXFwiKSxcXG4gICAgICB2YiA9IGQuY3JlYXRlRWxlbWVudChcXFwiYVxcXCIpO3ZiLmhyZWYgPSBqYi5ocmVmO2Z1bmN0aW9uIHdiKGEpIHtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChiLCBjKSB7XFxuICAgICAgXFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGIgJiYgKGMgPSBiLCBiID0gXFxcIipcXFwiKTt2YXIgZCxcXG4gICAgICAgICAgZSA9IDAsXFxuICAgICAgICAgIGYgPSBiLnRvTG93ZXJDYXNlKCkubWF0Y2goRykgfHwgW107aWYgKG4uaXNGdW5jdGlvbihjKSkgd2hpbGUgKGQgPSBmW2UrK10pIHtcXG4gICAgICAgIFxcXCIrXFxcIiA9PT0gZFswXSA/IChkID0gZC5zbGljZSgxKSB8fCBcXFwiKlxcXCIsIChhW2RdID0gYVtkXSB8fCBbXSkudW5zaGlmdChjKSkgOiAoYVtkXSA9IGFbZF0gfHwgW10pLnB1c2goYyk7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfWZ1bmN0aW9uIHhiKGEsIGIsIGMsIGQpIHtcXG4gICAgdmFyIGUgPSB7fSxcXG4gICAgICAgIGYgPSBhID09PSB0YjtmdW5jdGlvbiBnKGgpIHtcXG4gICAgICB2YXIgaTtyZXR1cm4gZVtoXSA9ICEwLCBuLmVhY2goYVtoXSB8fCBbXSwgZnVuY3Rpb24gKGEsIGgpIHtcXG4gICAgICAgIHZhciBqID0gaChiLCBjLCBkKTtyZXR1cm4gXFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGogfHwgZiB8fCBlW2pdID8gZiA/ICEoaSA9IGopIDogdm9pZCAwIDogKGIuZGF0YVR5cGVzLnVuc2hpZnQoaiksIGcoaiksICExKTtcXG4gICAgICB9KSwgaTtcXG4gICAgfXJldHVybiBnKGIuZGF0YVR5cGVzWzBdKSB8fCAhZVtcXFwiKlxcXCJdICYmIGcoXFxcIipcXFwiKTtcXG4gIH1mdW5jdGlvbiB5YihhLCBiKSB7XFxuICAgIHZhciBjLFxcbiAgICAgICAgZCxcXG4gICAgICAgIGUgPSBuLmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtmb3IgKGMgaW4gYikge1xcbiAgICAgIHZvaWQgMCAhPT0gYltjXSAmJiAoKGVbY10gPyBhIDogZCB8fCAoZCA9IHt9KSlbY10gPSBiW2NdKTtcXG4gICAgfXJldHVybiBkICYmIG4uZXh0ZW5kKCEwLCBhLCBkKSwgYTtcXG4gIH1mdW5jdGlvbiB6YihhLCBiLCBjKSB7XFxuICAgIHZhciBkLFxcbiAgICAgICAgZSxcXG4gICAgICAgIGYsXFxuICAgICAgICBnLFxcbiAgICAgICAgaCA9IGEuY29udGVudHMsXFxuICAgICAgICBpID0gYS5kYXRhVHlwZXM7d2hpbGUgKFxcXCIqXFxcIiA9PT0gaVswXSkge1xcbiAgICAgIGkuc2hpZnQoKSwgdm9pZCAwID09PSBkICYmIChkID0gYS5taW1lVHlwZSB8fCBiLmdldFJlc3BvbnNlSGVhZGVyKFxcXCJDb250ZW50LVR5cGVcXFwiKSk7XFxuICAgIH1pZiAoZCkgZm9yIChlIGluIGgpIHtcXG4gICAgICBpZiAoaFtlXSAmJiBoW2VdLnRlc3QoZCkpIHtcXG4gICAgICAgIGkudW5zaGlmdChlKTticmVhaztcXG4gICAgICB9XFxuICAgIH1pZiAoaVswXSBpbiBjKSBmID0gaVswXTtlbHNlIHtcXG4gICAgICBmb3IgKGUgaW4gYykge1xcbiAgICAgICAgaWYgKCFpWzBdIHx8IGEuY29udmVydGVyc1tlICsgXFxcIiBcXFwiICsgaVswXV0pIHtcXG4gICAgICAgICAgZiA9IGU7YnJlYWs7XFxuICAgICAgICB9ZyB8fCAoZyA9IGUpO1xcbiAgICAgIH1mID0gZiB8fCBnO1xcbiAgICB9cmV0dXJuIGYgPyAoZiAhPT0gaVswXSAmJiBpLnVuc2hpZnQoZiksIGNbZl0pIDogdm9pZCAwO1xcbiAgfWZ1bmN0aW9uIEFiKGEsIGIsIGMsIGQpIHtcXG4gICAgdmFyIGUsXFxuICAgICAgICBmLFxcbiAgICAgICAgZyxcXG4gICAgICAgIGgsXFxuICAgICAgICBpLFxcbiAgICAgICAgaiA9IHt9LFxcbiAgICAgICAgayA9IGEuZGF0YVR5cGVzLnNsaWNlKCk7aWYgKGtbMV0pIGZvciAoZyBpbiBhLmNvbnZlcnRlcnMpIHtcXG4gICAgICBqW2cudG9Mb3dlckNhc2UoKV0gPSBhLmNvbnZlcnRlcnNbZ107XFxuICAgIH1mID0gay5zaGlmdCgpO3doaWxlIChmKSB7XFxuICAgICAgaWYgKGEucmVzcG9uc2VGaWVsZHNbZl0gJiYgKGNbYS5yZXNwb25zZUZpZWxkc1tmXV0gPSBiKSwgIWkgJiYgZCAmJiBhLmRhdGFGaWx0ZXIgJiYgKGIgPSBhLmRhdGFGaWx0ZXIoYiwgYS5kYXRhVHlwZSkpLCBpID0gZiwgZiA9IGsuc2hpZnQoKSkgaWYgKFxcXCIqXFxcIiA9PT0gZikgZiA9IGk7ZWxzZSBpZiAoXFxcIipcXFwiICE9PSBpICYmIGkgIT09IGYpIHtcXG4gICAgICAgIGlmIChnID0galtpICsgXFxcIiBcXFwiICsgZl0gfHwgaltcXFwiKiBcXFwiICsgZl0sICFnKSBmb3IgKGUgaW4gaikge1xcbiAgICAgICAgICBpZiAoaCA9IGUuc3BsaXQoXFxcIiBcXFwiKSwgaFsxXSA9PT0gZiAmJiAoZyA9IGpbaSArIFxcXCIgXFxcIiArIGhbMF1dIHx8IGpbXFxcIiogXFxcIiArIGhbMF1dKSkge1xcbiAgICAgICAgICAgIGcgPT09ICEwID8gZyA9IGpbZV0gOiBqW2VdICE9PSAhMCAmJiAoZiA9IGhbMF0sIGsudW5zaGlmdChoWzFdKSk7YnJlYWs7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1pZiAoZyAhPT0gITApIGlmIChnICYmIGFbXFxcInRocm93c1xcXCJdKSBiID0gZyhiKTtlbHNlIHRyeSB7XFxuICAgICAgICAgIGIgPSBnKGIpO1xcbiAgICAgICAgfSBjYXRjaCAobCkge1xcbiAgICAgICAgICByZXR1cm4geyBzdGF0ZTogXFxcInBhcnNlcmVycm9yXFxcIiwgZXJyb3I6IGcgPyBsIDogXFxcIk5vIGNvbnZlcnNpb24gZnJvbSBcXFwiICsgaSArIFxcXCIgdG8gXFxcIiArIGYgfTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1yZXR1cm4geyBzdGF0ZTogXFxcInN1Y2Nlc3NcXFwiLCBkYXRhOiBiIH07XFxuICB9bi5leHRlbmQoeyBhY3RpdmU6IDAsIGxhc3RNb2RpZmllZDoge30sIGV0YWc6IHt9LCBhamF4U2V0dGluZ3M6IHsgdXJsOiBqYi5ocmVmLCB0eXBlOiBcXFwiR0VUXFxcIiwgaXNMb2NhbDogcGIudGVzdChqYi5wcm90b2NvbCksIGdsb2JhbDogITAsIHByb2Nlc3NEYXRhOiAhMCwgYXN5bmM6ICEwLCBjb250ZW50VHlwZTogXFxcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFxcXCIsIGFjY2VwdHM6IHsgXFxcIipcXFwiOiB1YiwgdGV4dDogXFxcInRleHQvcGxhaW5cXFwiLCBodG1sOiBcXFwidGV4dC9odG1sXFxcIiwgeG1sOiBcXFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFxcXCIsIGpzb246IFxcXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcXFwiIH0sIGNvbnRlbnRzOiB7IHhtbDogL1xcXFxieG1sXFxcXGIvLCBodG1sOiAvXFxcXGJodG1sLywganNvbjogL1xcXFxianNvblxcXFxiLyB9LCByZXNwb25zZUZpZWxkczogeyB4bWw6IFxcXCJyZXNwb25zZVhNTFxcXCIsIHRleHQ6IFxcXCJyZXNwb25zZVRleHRcXFwiLCBqc29uOiBcXFwicmVzcG9uc2VKU09OXFxcIiB9LCBjb252ZXJ0ZXJzOiB7IFxcXCIqIHRleHRcXFwiOiBTdHJpbmcsIFxcXCJ0ZXh0IGh0bWxcXFwiOiAhMCwgXFxcInRleHQganNvblxcXCI6IG4ucGFyc2VKU09OLCBcXFwidGV4dCB4bWxcXFwiOiBuLnBhcnNlWE1MIH0sIGZsYXRPcHRpb25zOiB7IHVybDogITAsIGNvbnRleHQ6ICEwIH0gfSwgYWpheFNldHVwOiBmdW5jdGlvbiBhamF4U2V0dXAoYSwgYikge1xcbiAgICAgIHJldHVybiBiID8geWIoeWIoYSwgbi5hamF4U2V0dGluZ3MpLCBiKSA6IHliKG4uYWpheFNldHRpbmdzLCBhKTtcXG4gICAgfSwgYWpheFByZWZpbHRlcjogd2Ioc2IpLCBhamF4VHJhbnNwb3J0OiB3Yih0YiksIGFqYXg6IGZ1bmN0aW9uIGFqYXgoYiwgYykge1xcbiAgICAgIFxcXCJvYmplY3RcXFwiID09ICh0eXBlb2YgYiA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YoYikpICYmIChjID0gYiwgYiA9IHZvaWQgMCksIGMgPSBjIHx8IHt9O3ZhciBlLFxcbiAgICAgICAgICBmLFxcbiAgICAgICAgICBnLFxcbiAgICAgICAgICBoLFxcbiAgICAgICAgICBpLFxcbiAgICAgICAgICBqLFxcbiAgICAgICAgICBrLFxcbiAgICAgICAgICBsLFxcbiAgICAgICAgICBtID0gbi5hamF4U2V0dXAoe30sIGMpLFxcbiAgICAgICAgICBvID0gbS5jb250ZXh0IHx8IG0sXFxuICAgICAgICAgIHAgPSBtLmNvbnRleHQgJiYgKG8ubm9kZVR5cGUgfHwgby5qcXVlcnkpID8gbihvKSA6IG4uZXZlbnQsXFxuICAgICAgICAgIHEgPSBuLkRlZmVycmVkKCksXFxuICAgICAgICAgIHIgPSBuLkNhbGxiYWNrcyhcXFwib25jZSBtZW1vcnlcXFwiKSxcXG4gICAgICAgICAgcyA9IG0uc3RhdHVzQ29kZSB8fCB7fSxcXG4gICAgICAgICAgdCA9IHt9LFxcbiAgICAgICAgICB1ID0ge30sXFxuICAgICAgICAgIHYgPSAwLFxcbiAgICAgICAgICB3ID0gXFxcImNhbmNlbGVkXFxcIixcXG4gICAgICAgICAgeCA9IHsgcmVhZHlTdGF0ZTogMCwgZ2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uIGdldFJlc3BvbnNlSGVhZGVyKGEpIHtcXG4gICAgICAgICAgdmFyIGI7aWYgKDIgPT09IHYpIHtcXG4gICAgICAgICAgICBpZiAoIWgpIHtcXG4gICAgICAgICAgICAgIGggPSB7fTt3aGlsZSAoYiA9IG9iLmV4ZWMoZykpIHtcXG4gICAgICAgICAgICAgICAgaFtiWzFdLnRvTG93ZXJDYXNlKCldID0gYlsyXTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9YiA9IGhbYS50b0xvd2VyQ2FzZSgpXTtcXG4gICAgICAgICAgfXJldHVybiBudWxsID09IGIgPyBudWxsIDogYjtcXG4gICAgICAgIH0sIGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24gZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkge1xcbiAgICAgICAgICByZXR1cm4gMiA9PT0gdiA/IGcgOiBudWxsO1xcbiAgICAgICAgfSwgc2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcihhLCBiKSB7XFxuICAgICAgICAgIHZhciBjID0gYS50b0xvd2VyQ2FzZSgpO3JldHVybiB2IHx8IChhID0gdVtjXSA9IHVbY10gfHwgYSwgdFthXSA9IGIpLCB0aGlzO1xcbiAgICAgICAgfSwgb3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24gb3ZlcnJpZGVNaW1lVHlwZShhKSB7XFxuICAgICAgICAgIHJldHVybiB2IHx8IChtLm1pbWVUeXBlID0gYSksIHRoaXM7XFxuICAgICAgICB9LCBzdGF0dXNDb2RlOiBmdW5jdGlvbiBzdGF0dXNDb2RlKGEpIHtcXG4gICAgICAgICAgdmFyIGI7aWYgKGEpIGlmICgyID4gdikgZm9yIChiIGluIGEpIHtcXG4gICAgICAgICAgICBzW2JdID0gW3NbYl0sIGFbYl1dO1xcbiAgICAgICAgICB9IGVsc2UgeC5hbHdheXMoYVt4LnN0YXR1c10pO3JldHVybiB0aGlzO1xcbiAgICAgICAgfSwgYWJvcnQ6IGZ1bmN0aW9uIGFib3J0KGEpIHtcXG4gICAgICAgICAgdmFyIGIgPSBhIHx8IHc7cmV0dXJuIGUgJiYgZS5hYm9ydChiKSwgeigwLCBiKSwgdGhpcztcXG4gICAgICAgIH0gfTtpZiAocS5wcm9taXNlKHgpLmNvbXBsZXRlID0gci5hZGQsIHguc3VjY2VzcyA9IHguZG9uZSwgeC5lcnJvciA9IHguZmFpbCwgbS51cmwgPSAoKGIgfHwgbS51cmwgfHwgamIuaHJlZikgKyBcXFwiXFxcIikucmVwbGFjZShtYiwgXFxcIlxcXCIpLnJlcGxhY2UocmIsIGpiLnByb3RvY29sICsgXFxcIi8vXFxcIiksIG0udHlwZSA9IGMubWV0aG9kIHx8IGMudHlwZSB8fCBtLm1ldGhvZCB8fCBtLnR5cGUsIG0uZGF0YVR5cGVzID0gbi50cmltKG0uZGF0YVR5cGUgfHwgXFxcIipcXFwiKS50b0xvd2VyQ2FzZSgpLm1hdGNoKEcpIHx8IFtcXFwiXFxcIl0sIG51bGwgPT0gbS5jcm9zc0RvbWFpbikge1xcbiAgICAgICAgaiA9IGQuY3JlYXRlRWxlbWVudChcXFwiYVxcXCIpO3RyeSB7XFxuICAgICAgICAgIGouaHJlZiA9IG0udXJsLCBqLmhyZWYgPSBqLmhyZWYsIG0uY3Jvc3NEb21haW4gPSB2Yi5wcm90b2NvbCArIFxcXCIvL1xcXCIgKyB2Yi5ob3N0ICE9IGoucHJvdG9jb2wgKyBcXFwiLy9cXFwiICsgai5ob3N0O1xcbiAgICAgICAgfSBjYXRjaCAoeSkge1xcbiAgICAgICAgICBtLmNyb3NzRG9tYWluID0gITA7XFxuICAgICAgICB9XFxuICAgICAgfWlmIChtLmRhdGEgJiYgbS5wcm9jZXNzRGF0YSAmJiBcXFwic3RyaW5nXFxcIiAhPSB0eXBlb2YgbS5kYXRhICYmIChtLmRhdGEgPSBuLnBhcmFtKG0uZGF0YSwgbS50cmFkaXRpb25hbCkpLCB4YihzYiwgbSwgYywgeCksIDIgPT09IHYpIHJldHVybiB4O2sgPSBuLmV2ZW50ICYmIG0uZ2xvYmFsLCBrICYmIDAgPT09IG4uYWN0aXZlKysgJiYgbi5ldmVudC50cmlnZ2VyKFxcXCJhamF4U3RhcnRcXFwiKSwgbS50eXBlID0gbS50eXBlLnRvVXBwZXJDYXNlKCksIG0uaGFzQ29udGVudCA9ICFxYi50ZXN0KG0udHlwZSksIGYgPSBtLnVybCwgbS5oYXNDb250ZW50IHx8IChtLmRhdGEgJiYgKGYgPSBtLnVybCArPSAobGIudGVzdChmKSA/IFxcXCImXFxcIiA6IFxcXCI/XFxcIikgKyBtLmRhdGEsIGRlbGV0ZSBtLmRhdGEpLCBtLmNhY2hlID09PSAhMSAmJiAobS51cmwgPSBuYi50ZXN0KGYpID8gZi5yZXBsYWNlKG5iLCBcXFwiJDFfPVxcXCIgKyBrYisrKSA6IGYgKyAobGIudGVzdChmKSA/IFxcXCImXFxcIiA6IFxcXCI/XFxcIikgKyBcXFwiXz1cXFwiICsga2IrKykpLCBtLmlmTW9kaWZpZWQgJiYgKG4ubGFzdE1vZGlmaWVkW2ZdICYmIHguc2V0UmVxdWVzdEhlYWRlcihcXFwiSWYtTW9kaWZpZWQtU2luY2VcXFwiLCBuLmxhc3RNb2RpZmllZFtmXSksIG4uZXRhZ1tmXSAmJiB4LnNldFJlcXVlc3RIZWFkZXIoXFxcIklmLU5vbmUtTWF0Y2hcXFwiLCBuLmV0YWdbZl0pKSwgKG0uZGF0YSAmJiBtLmhhc0NvbnRlbnQgJiYgbS5jb250ZW50VHlwZSAhPT0gITEgfHwgYy5jb250ZW50VHlwZSkgJiYgeC5zZXRSZXF1ZXN0SGVhZGVyKFxcXCJDb250ZW50LVR5cGVcXFwiLCBtLmNvbnRlbnRUeXBlKSwgeC5zZXRSZXF1ZXN0SGVhZGVyKFxcXCJBY2NlcHRcXFwiLCBtLmRhdGFUeXBlc1swXSAmJiBtLmFjY2VwdHNbbS5kYXRhVHlwZXNbMF1dID8gbS5hY2NlcHRzW20uZGF0YVR5cGVzWzBdXSArIChcXFwiKlxcXCIgIT09IG0uZGF0YVR5cGVzWzBdID8gXFxcIiwgXFxcIiArIHViICsgXFxcIjsgcT0wLjAxXFxcIiA6IFxcXCJcXFwiKSA6IG0uYWNjZXB0c1tcXFwiKlxcXCJdKTtmb3IgKGwgaW4gbS5oZWFkZXJzKSB7XFxuICAgICAgICB4LnNldFJlcXVlc3RIZWFkZXIobCwgbS5oZWFkZXJzW2xdKTtcXG4gICAgICB9aWYgKG0uYmVmb3JlU2VuZCAmJiAobS5iZWZvcmVTZW5kLmNhbGwobywgeCwgbSkgPT09ICExIHx8IDIgPT09IHYpKSByZXR1cm4geC5hYm9ydCgpO3cgPSBcXFwiYWJvcnRcXFwiO2ZvciAobCBpbiB7IHN1Y2Nlc3M6IDEsIGVycm9yOiAxLCBjb21wbGV0ZTogMSB9KSB7XFxuICAgICAgICB4W2xdKG1bbF0pO1xcbiAgICAgIH1pZiAoZSA9IHhiKHRiLCBtLCBjLCB4KSkge1xcbiAgICAgICAgaWYgKHgucmVhZHlTdGF0ZSA9IDEsIGsgJiYgcC50cmlnZ2VyKFxcXCJhamF4U2VuZFxcXCIsIFt4LCBtXSksIDIgPT09IHYpIHJldHVybiB4O20uYXN5bmMgJiYgbS50aW1lb3V0ID4gMCAmJiAoaSA9IGEuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHguYWJvcnQoXFxcInRpbWVvdXRcXFwiKTtcXG4gICAgICAgIH0sIG0udGltZW91dCkpO3RyeSB7XFxuICAgICAgICAgIHYgPSAxLCBlLnNlbmQodCwgeik7XFxuICAgICAgICB9IGNhdGNoICh5KSB7XFxuICAgICAgICAgIGlmICghKDIgPiB2KSkgdGhyb3cgeTt6KC0xLCB5KTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgeigtMSwgXFxcIk5vIFRyYW5zcG9ydFxcXCIpO2Z1bmN0aW9uIHooYiwgYywgZCwgaCkge1xcbiAgICAgICAgdmFyIGosXFxuICAgICAgICAgICAgbCxcXG4gICAgICAgICAgICB0LFxcbiAgICAgICAgICAgIHUsXFxuICAgICAgICAgICAgdyxcXG4gICAgICAgICAgICB5ID0gYzsyICE9PSB2ICYmICh2ID0gMiwgaSAmJiBhLmNsZWFyVGltZW91dChpKSwgZSA9IHZvaWQgMCwgZyA9IGggfHwgXFxcIlxcXCIsIHgucmVhZHlTdGF0ZSA9IGIgPiAwID8gNCA6IDAsIGogPSBiID49IDIwMCAmJiAzMDAgPiBiIHx8IDMwNCA9PT0gYiwgZCAmJiAodSA9IHpiKG0sIHgsIGQpKSwgdSA9IEFiKG0sIHUsIHgsIGopLCBqID8gKG0uaWZNb2RpZmllZCAmJiAodyA9IHguZ2V0UmVzcG9uc2VIZWFkZXIoXFxcIkxhc3QtTW9kaWZpZWRcXFwiKSwgdyAmJiAobi5sYXN0TW9kaWZpZWRbZl0gPSB3KSwgdyA9IHguZ2V0UmVzcG9uc2VIZWFkZXIoXFxcImV0YWdcXFwiKSwgdyAmJiAobi5ldGFnW2ZdID0gdykpLCAyMDQgPT09IGIgfHwgXFxcIkhFQURcXFwiID09PSBtLnR5cGUgPyB5ID0gXFxcIm5vY29udGVudFxcXCIgOiAzMDQgPT09IGIgPyB5ID0gXFxcIm5vdG1vZGlmaWVkXFxcIiA6ICh5ID0gdS5zdGF0ZSwgbCA9IHUuZGF0YSwgdCA9IHUuZXJyb3IsIGogPSAhdCkpIDogKHQgPSB5LCAhYiAmJiB5IHx8ICh5ID0gXFxcImVycm9yXFxcIiwgMCA+IGIgJiYgKGIgPSAwKSkpLCB4LnN0YXR1cyA9IGIsIHguc3RhdHVzVGV4dCA9IChjIHx8IHkpICsgXFxcIlxcXCIsIGogPyBxLnJlc29sdmVXaXRoKG8sIFtsLCB5LCB4XSkgOiBxLnJlamVjdFdpdGgobywgW3gsIHksIHRdKSwgeC5zdGF0dXNDb2RlKHMpLCBzID0gdm9pZCAwLCBrICYmIHAudHJpZ2dlcihqID8gXFxcImFqYXhTdWNjZXNzXFxcIiA6IFxcXCJhamF4RXJyb3JcXFwiLCBbeCwgbSwgaiA/IGwgOiB0XSksIHIuZmlyZVdpdGgobywgW3gsIHldKSwgayAmJiAocC50cmlnZ2VyKFxcXCJhamF4Q29tcGxldGVcXFwiLCBbeCwgbV0pLCAtLW4uYWN0aXZlIHx8IG4uZXZlbnQudHJpZ2dlcihcXFwiYWpheFN0b3BcXFwiKSkpO1xcbiAgICAgIH1yZXR1cm4geDtcXG4gICAgfSwgZ2V0SlNPTjogZnVuY3Rpb24gZ2V0SlNPTihhLCBiLCBjKSB7XFxuICAgICAgcmV0dXJuIG4uZ2V0KGEsIGIsIGMsIFxcXCJqc29uXFxcIik7XFxuICAgIH0sIGdldFNjcmlwdDogZnVuY3Rpb24gZ2V0U2NyaXB0KGEsIGIpIHtcXG4gICAgICByZXR1cm4gbi5nZXQoYSwgdm9pZCAwLCBiLCBcXFwic2NyaXB0XFxcIik7XFxuICAgIH0gfSksIG4uZWFjaChbXFxcImdldFxcXCIsIFxcXCJwb3N0XFxcIl0sIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIG5bYl0gPSBmdW5jdGlvbiAoYSwgYywgZCwgZSkge1xcbiAgICAgIHJldHVybiBuLmlzRnVuY3Rpb24oYykgJiYgKGUgPSBlIHx8IGQsIGQgPSBjLCBjID0gdm9pZCAwKSwgbi5hamF4KG4uZXh0ZW5kKHsgdXJsOiBhLCB0eXBlOiBiLCBkYXRhVHlwZTogZSwgZGF0YTogYywgc3VjY2VzczogZCB9LCBuLmlzUGxhaW5PYmplY3QoYSkgJiYgYSkpO1xcbiAgICB9O1xcbiAgfSksIG4uX2V2YWxVcmwgPSBmdW5jdGlvbiAoYSkge1xcbiAgICByZXR1cm4gbi5hamF4KHsgdXJsOiBhLCB0eXBlOiBcXFwiR0VUXFxcIiwgZGF0YVR5cGU6IFxcXCJzY3JpcHRcXFwiLCBhc3luYzogITEsIGdsb2JhbDogITEsIFxcXCJ0aHJvd3NcXFwiOiAhMCB9KTtcXG4gIH0sIG4uZm4uZXh0ZW5kKHsgd3JhcEFsbDogZnVuY3Rpb24gd3JhcEFsbChhKSB7XFxuICAgICAgdmFyIGI7cmV0dXJuIG4uaXNGdW5jdGlvbihhKSA/IHRoaXMuZWFjaChmdW5jdGlvbiAoYikge1xcbiAgICAgICAgbih0aGlzKS53cmFwQWxsKGEuY2FsbCh0aGlzLCBiKSk7XFxuICAgICAgfSkgOiAodGhpc1swXSAmJiAoYiA9IG4oYSwgdGhpc1swXS5vd25lckRvY3VtZW50KS5lcSgwKS5jbG9uZSghMCksIHRoaXNbMF0ucGFyZW50Tm9kZSAmJiBiLmluc2VydEJlZm9yZSh0aGlzWzBdKSwgYi5tYXAoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGEgPSB0aGlzO3doaWxlIChhLmZpcnN0RWxlbWVudENoaWxkKSB7XFxuICAgICAgICAgIGEgPSBhLmZpcnN0RWxlbWVudENoaWxkO1xcbiAgICAgICAgfXJldHVybiBhO1xcbiAgICAgIH0pLmFwcGVuZCh0aGlzKSksIHRoaXMpO1xcbiAgICB9LCB3cmFwSW5uZXI6IGZ1bmN0aW9uIHdyYXBJbm5lcihhKSB7XFxuICAgICAgcmV0dXJuIG4uaXNGdW5jdGlvbihhKSA/IHRoaXMuZWFjaChmdW5jdGlvbiAoYikge1xcbiAgICAgICAgbih0aGlzKS53cmFwSW5uZXIoYS5jYWxsKHRoaXMsIGIpKTtcXG4gICAgICB9KSA6IHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgYiA9IG4odGhpcyksXFxuICAgICAgICAgICAgYyA9IGIuY29udGVudHMoKTtjLmxlbmd0aCA/IGMud3JhcEFsbChhKSA6IGIuYXBwZW5kKGEpO1xcbiAgICAgIH0pO1xcbiAgICB9LCB3cmFwOiBmdW5jdGlvbiB3cmFwKGEpIHtcXG4gICAgICB2YXIgYiA9IG4uaXNGdW5jdGlvbihhKTtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChjKSB7XFxuICAgICAgICBuKHRoaXMpLndyYXBBbGwoYiA/IGEuY2FsbCh0aGlzLCBjKSA6IGEpO1xcbiAgICAgIH0pO1xcbiAgICB9LCB1bndyYXA6IGZ1bmN0aW9uIHVud3JhcCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQoKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIG4ubm9kZU5hbWUodGhpcywgXFxcImJvZHlcXFwiKSB8fCBuKHRoaXMpLnJlcGxhY2VXaXRoKHRoaXMuY2hpbGROb2Rlcyk7XFxuICAgICAgfSkuZW5kKCk7XFxuICAgIH0gfSksIG4uZXhwci5maWx0ZXJzLmhpZGRlbiA9IGZ1bmN0aW9uIChhKSB7XFxuICAgIHJldHVybiAhbi5leHByLmZpbHRlcnMudmlzaWJsZShhKTtcXG4gIH0sIG4uZXhwci5maWx0ZXJzLnZpc2libGUgPSBmdW5jdGlvbiAoYSkge1xcbiAgICByZXR1cm4gYS5vZmZzZXRXaWR0aCA+IDAgfHwgYS5vZmZzZXRIZWlnaHQgPiAwIHx8IGEuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggPiAwO1xcbiAgfTt2YXIgQmIgPSAvJTIwL2csXFxuICAgICAgQ2IgPSAvXFxcXFtcXFxcXSQvLFxcbiAgICAgIERiID0gL1xcXFxyP1xcXFxuL2csXFxuICAgICAgRWIgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXFxuICAgICAgRmIgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7ZnVuY3Rpb24gR2IoYSwgYiwgYywgZCkge1xcbiAgICB2YXIgZTtpZiAobi5pc0FycmF5KGIpKSBuLmVhY2goYiwgZnVuY3Rpb24gKGIsIGUpIHtcXG4gICAgICBjIHx8IENiLnRlc3QoYSkgPyBkKGEsIGUpIDogR2IoYSArIFxcXCJbXFxcIiArIChcXFwib2JqZWN0XFxcIiA9PSAodHlwZW9mIGUgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKGUpKSAmJiBudWxsICE9IGUgPyBiIDogXFxcIlxcXCIpICsgXFxcIl1cXFwiLCBlLCBjLCBkKTtcXG4gICAgfSk7ZWxzZSBpZiAoYyB8fCBcXFwib2JqZWN0XFxcIiAhPT0gbi50eXBlKGIpKSBkKGEsIGIpO2Vsc2UgZm9yIChlIGluIGIpIHtcXG4gICAgICBHYihhICsgXFxcIltcXFwiICsgZSArIFxcXCJdXFxcIiwgYltlXSwgYywgZCk7XFxuICAgIH1cXG4gIH1uLnBhcmFtID0gZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgdmFyIGMsXFxuICAgICAgICBkID0gW10sXFxuICAgICAgICBlID0gZnVuY3Rpb24gZShhLCBiKSB7XFxuICAgICAgYiA9IG4uaXNGdW5jdGlvbihiKSA/IGIoKSA6IG51bGwgPT0gYiA/IFxcXCJcXFwiIDogYiwgZFtkLmxlbmd0aF0gPSBlbmNvZGVVUklDb21wb25lbnQoYSkgKyBcXFwiPVxcXCIgKyBlbmNvZGVVUklDb21wb25lbnQoYik7XFxuICAgIH07aWYgKHZvaWQgMCA9PT0gYiAmJiAoYiA9IG4uYWpheFNldHRpbmdzICYmIG4uYWpheFNldHRpbmdzLnRyYWRpdGlvbmFsKSwgbi5pc0FycmF5KGEpIHx8IGEuanF1ZXJ5ICYmICFuLmlzUGxhaW5PYmplY3QoYSkpIG4uZWFjaChhLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgZSh0aGlzLm5hbWUsIHRoaXMudmFsdWUpO1xcbiAgICB9KTtlbHNlIGZvciAoYyBpbiBhKSB7XFxuICAgICAgR2IoYywgYVtjXSwgYiwgZSk7XFxuICAgIH1yZXR1cm4gZC5qb2luKFxcXCImXFxcIikucmVwbGFjZShCYiwgXFxcIitcXFwiKTtcXG4gIH0sIG4uZm4uZXh0ZW5kKHsgc2VyaWFsaXplOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XFxuICAgICAgcmV0dXJuIG4ucGFyYW0odGhpcy5zZXJpYWxpemVBcnJheSgpKTtcXG4gICAgfSwgc2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uIHNlcmlhbGl6ZUFycmF5KCkge1xcbiAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgYSA9IG4ucHJvcCh0aGlzLCBcXFwiZWxlbWVudHNcXFwiKTtyZXR1cm4gYSA/IG4ubWFrZUFycmF5KGEpIDogdGhpcztcXG4gICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGEgPSB0aGlzLnR5cGU7cmV0dXJuIHRoaXMubmFtZSAmJiAhbih0aGlzKS5pcyhcXFwiOmRpc2FibGVkXFxcIikgJiYgRmIudGVzdCh0aGlzLm5vZGVOYW1lKSAmJiAhRWIudGVzdChhKSAmJiAodGhpcy5jaGVja2VkIHx8ICFYLnRlc3QoYSkpO1xcbiAgICAgIH0pLm1hcChmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgICAgdmFyIGMgPSBuKHRoaXMpLnZhbCgpO3JldHVybiBudWxsID09IGMgPyBudWxsIDogbi5pc0FycmF5KGMpID8gbi5tYXAoYywgZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgICAgcmV0dXJuIHsgbmFtZTogYi5uYW1lLCB2YWx1ZTogYS5yZXBsYWNlKERiLCBcXFwiXFxcXHJcXFxcblxcXCIpIH07XFxuICAgICAgICB9KSA6IHsgbmFtZTogYi5uYW1lLCB2YWx1ZTogYy5yZXBsYWNlKERiLCBcXFwiXFxcXHJcXFxcblxcXCIpIH07XFxuICAgICAgfSkuZ2V0KCk7XFxuICAgIH0gfSksIG4uYWpheFNldHRpbmdzLnhociA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdHJ5IHtcXG4gICAgICByZXR1cm4gbmV3IGEuWE1MSHR0cFJlcXVlc3QoKTtcXG4gICAgfSBjYXRjaCAoYikge31cXG4gIH07dmFyIEhiID0geyAwOiAyMDAsIDEyMjM6IDIwNCB9LFxcbiAgICAgIEliID0gbi5hamF4U2V0dGluZ3MueGhyKCk7bC5jb3JzID0gISFJYiAmJiBcXFwid2l0aENyZWRlbnRpYWxzXFxcIiBpbiBJYiwgbC5hamF4ID0gSWIgPSAhIUliLCBuLmFqYXhUcmFuc3BvcnQoZnVuY3Rpb24gKGIpIHtcXG4gICAgdmFyIF9jLCBkO3JldHVybiBsLmNvcnMgfHwgSWIgJiYgIWIuY3Jvc3NEb21haW4gPyB7IHNlbmQ6IGZ1bmN0aW9uIHNlbmQoZSwgZikge1xcbiAgICAgICAgdmFyIGcsXFxuICAgICAgICAgICAgaCA9IGIueGhyKCk7aWYgKGgub3BlbihiLnR5cGUsIGIudXJsLCBiLmFzeW5jLCBiLnVzZXJuYW1lLCBiLnBhc3N3b3JkKSwgYi54aHJGaWVsZHMpIGZvciAoZyBpbiBiLnhockZpZWxkcykge1xcbiAgICAgICAgICBoW2ddID0gYi54aHJGaWVsZHNbZ107XFxuICAgICAgICB9Yi5taW1lVHlwZSAmJiBoLm92ZXJyaWRlTWltZVR5cGUgJiYgaC5vdmVycmlkZU1pbWVUeXBlKGIubWltZVR5cGUpLCBiLmNyb3NzRG9tYWluIHx8IGVbXFxcIlgtUmVxdWVzdGVkLVdpdGhcXFwiXSB8fCAoZVtcXFwiWC1SZXF1ZXN0ZWQtV2l0aFxcXCJdID0gXFxcIlhNTEh0dHBSZXF1ZXN0XFxcIik7Zm9yIChnIGluIGUpIHtcXG4gICAgICAgICAgaC5zZXRSZXF1ZXN0SGVhZGVyKGcsIGVbZ10pO1xcbiAgICAgICAgfV9jID0gZnVuY3Rpb24gYyhhKSB7XFxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgX2MgJiYgKF9jID0gZCA9IGgub25sb2FkID0gaC5vbmVycm9yID0gaC5vbmFib3J0ID0gaC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsLCBcXFwiYWJvcnRcXFwiID09PSBhID8gaC5hYm9ydCgpIDogXFxcImVycm9yXFxcIiA9PT0gYSA/IFxcXCJudW1iZXJcXFwiICE9IHR5cGVvZiBoLnN0YXR1cyA/IGYoMCwgXFxcImVycm9yXFxcIikgOiBmKGguc3RhdHVzLCBoLnN0YXR1c1RleHQpIDogZihIYltoLnN0YXR1c10gfHwgaC5zdGF0dXMsIGguc3RhdHVzVGV4dCwgXFxcInRleHRcXFwiICE9PSAoaC5yZXNwb25zZVR5cGUgfHwgXFxcInRleHRcXFwiKSB8fCBcXFwic3RyaW5nXFxcIiAhPSB0eXBlb2YgaC5yZXNwb25zZVRleHQgPyB7IGJpbmFyeTogaC5yZXNwb25zZSB9IDogeyB0ZXh0OiBoLnJlc3BvbnNlVGV4dCB9LCBoLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSk7XFxuICAgICAgICAgIH07XFxuICAgICAgICB9LCBoLm9ubG9hZCA9IF9jKCksIGQgPSBoLm9uZXJyb3IgPSBfYyhcXFwiZXJyb3JcXFwiKSwgdm9pZCAwICE9PSBoLm9uYWJvcnQgPyBoLm9uYWJvcnQgPSBkIDogaC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIDQgPT09IGgucmVhZHlTdGF0ZSAmJiBhLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIF9jICYmIGQoKTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9LCBfYyA9IF9jKFxcXCJhYm9ydFxcXCIpO3RyeSB7XFxuICAgICAgICAgIGguc2VuZChiLmhhc0NvbnRlbnQgJiYgYi5kYXRhIHx8IG51bGwpO1xcbiAgICAgICAgfSBjYXRjaCAoaSkge1xcbiAgICAgICAgICBpZiAoX2MpIHRocm93IGk7XFxuICAgICAgICB9XFxuICAgICAgfSwgYWJvcnQ6IGZ1bmN0aW9uIGFib3J0KCkge1xcbiAgICAgICAgX2MgJiYgX2MoKTtcXG4gICAgICB9IH0gOiB2b2lkIDA7XFxuICB9KSwgbi5hamF4U2V0dXAoeyBhY2NlcHRzOiB7IHNjcmlwdDogXFxcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XFxcIiB9LCBjb250ZW50czogeyBzY3JpcHQ6IC9cXFxcYig/OmphdmF8ZWNtYSlzY3JpcHRcXFxcYi8gfSwgY29udmVydGVyczogeyBcXFwidGV4dCBzY3JpcHRcXFwiOiBmdW5jdGlvbiB0ZXh0U2NyaXB0KGEpIHtcXG4gICAgICAgIHJldHVybiBuLmdsb2JhbEV2YWwoYSksIGE7XFxuICAgICAgfSB9IH0pLCBuLmFqYXhQcmVmaWx0ZXIoXFxcInNjcmlwdFxcXCIsIGZ1bmN0aW9uIChhKSB7XFxuICAgIHZvaWQgMCA9PT0gYS5jYWNoZSAmJiAoYS5jYWNoZSA9ICExKSwgYS5jcm9zc0RvbWFpbiAmJiAoYS50eXBlID0gXFxcIkdFVFxcXCIpO1xcbiAgfSksIG4uYWpheFRyYW5zcG9ydChcXFwic2NyaXB0XFxcIiwgZnVuY3Rpb24gKGEpIHtcXG4gICAgaWYgKGEuY3Jvc3NEb21haW4pIHtcXG4gICAgICB2YXIgYiwgX2MyO3JldHVybiB7IHNlbmQ6IGZ1bmN0aW9uIHNlbmQoZSwgZikge1xcbiAgICAgICAgICBiID0gbihcXFwiPHNjcmlwdD5cXFwiKS5wcm9wKHsgY2hhcnNldDogYS5zY3JpcHRDaGFyc2V0LCBzcmM6IGEudXJsIH0pLm9uKFxcXCJsb2FkIGVycm9yXFxcIiwgX2MyID0gZnVuY3Rpb24gYyhhKSB7XFxuICAgICAgICAgICAgYi5yZW1vdmUoKSwgX2MyID0gbnVsbCwgYSAmJiBmKFxcXCJlcnJvclxcXCIgPT09IGEudHlwZSA/IDQwNCA6IDIwMCwgYS50eXBlKTtcXG4gICAgICAgICAgfSksIGQuaGVhZC5hcHBlbmRDaGlsZChiWzBdKTtcXG4gICAgICAgIH0sIGFib3J0OiBmdW5jdGlvbiBhYm9ydCgpIHtcXG4gICAgICAgICAgX2MyICYmIF9jMigpO1xcbiAgICAgICAgfSB9O1xcbiAgICB9XFxuICB9KTt2YXIgSmIgPSBbXSxcXG4gICAgICBLYiA9IC8oPSlcXFxcPyg/PSZ8JCl8XFxcXD9cXFxcPy87bi5hamF4U2V0dXAoeyBqc29ucDogXFxcImNhbGxiYWNrXFxcIiwganNvbnBDYWxsYmFjazogZnVuY3Rpb24ganNvbnBDYWxsYmFjaygpIHtcXG4gICAgICB2YXIgYSA9IEpiLnBvcCgpIHx8IG4uZXhwYW5kbyArIFxcXCJfXFxcIiArIGtiKys7cmV0dXJuIHRoaXNbYV0gPSAhMCwgYTtcXG4gICAgfSB9KSwgbi5hamF4UHJlZmlsdGVyKFxcXCJqc29uIGpzb25wXFxcIiwgZnVuY3Rpb24gKGIsIGMsIGQpIHtcXG4gICAgdmFyIGUsXFxuICAgICAgICBmLFxcbiAgICAgICAgZyxcXG4gICAgICAgIGggPSBiLmpzb25wICE9PSAhMSAmJiAoS2IudGVzdChiLnVybCkgPyBcXFwidXJsXFxcIiA6IFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBiLmRhdGEgJiYgMCA9PT0gKGIuY29udGVudFR5cGUgfHwgXFxcIlxcXCIpLmluZGV4T2YoXFxcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFxcXCIpICYmIEtiLnRlc3QoYi5kYXRhKSAmJiBcXFwiZGF0YVxcXCIpO3JldHVybiBoIHx8IFxcXCJqc29ucFxcXCIgPT09IGIuZGF0YVR5cGVzWzBdID8gKGUgPSBiLmpzb25wQ2FsbGJhY2sgPSBuLmlzRnVuY3Rpb24oYi5qc29ucENhbGxiYWNrKSA/IGIuanNvbnBDYWxsYmFjaygpIDogYi5qc29ucENhbGxiYWNrLCBoID8gYltoXSA9IGJbaF0ucmVwbGFjZShLYiwgXFxcIiQxXFxcIiArIGUpIDogYi5qc29ucCAhPT0gITEgJiYgKGIudXJsICs9IChsYi50ZXN0KGIudXJsKSA/IFxcXCImXFxcIiA6IFxcXCI/XFxcIikgKyBiLmpzb25wICsgXFxcIj1cXFwiICsgZSksIGIuY29udmVydGVyc1tcXFwic2NyaXB0IGpzb25cXFwiXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICByZXR1cm4gZyB8fCBuLmVycm9yKGUgKyBcXFwiIHdhcyBub3QgY2FsbGVkXFxcIiksIGdbMF07XFxuICAgIH0sIGIuZGF0YVR5cGVzWzBdID0gXFxcImpzb25cXFwiLCBmID0gYVtlXSwgYVtlXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICBnID0gYXJndW1lbnRzO1xcbiAgICB9LCBkLmFsd2F5cyhmdW5jdGlvbiAoKSB7XFxuICAgICAgdm9pZCAwID09PSBmID8gbihhKS5yZW1vdmVQcm9wKGUpIDogYVtlXSA9IGYsIGJbZV0gJiYgKGIuanNvbnBDYWxsYmFjayA9IGMuanNvbnBDYWxsYmFjaywgSmIucHVzaChlKSksIGcgJiYgbi5pc0Z1bmN0aW9uKGYpICYmIGYoZ1swXSksIGcgPSBmID0gdm9pZCAwO1xcbiAgICB9KSwgXFxcInNjcmlwdFxcXCIpIDogdm9pZCAwO1xcbiAgfSksIG4ucGFyc2VIVE1MID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcXG4gICAgaWYgKCFhIHx8IFxcXCJzdHJpbmdcXFwiICE9IHR5cGVvZiBhKSByZXR1cm4gbnVsbDtcXFwiYm9vbGVhblxcXCIgPT0gdHlwZW9mIGIgJiYgKGMgPSBiLCBiID0gITEpLCBiID0gYiB8fCBkO3ZhciBlID0geC5leGVjKGEpLFxcbiAgICAgICAgZiA9ICFjICYmIFtdO3JldHVybiBlID8gW2IuY3JlYXRlRWxlbWVudChlWzFdKV0gOiAoZSA9IGNhKFthXSwgYiwgZiksIGYgJiYgZi5sZW5ndGggJiYgbihmKS5yZW1vdmUoKSwgbi5tZXJnZShbXSwgZS5jaGlsZE5vZGVzKSk7XFxuICB9O3ZhciBMYiA9IG4uZm4ubG9hZDtuLmZuLmxvYWQgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xcbiAgICBpZiAoXFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGEgJiYgTGIpIHJldHVybiBMYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO3ZhciBkLFxcbiAgICAgICAgZSxcXG4gICAgICAgIGYsXFxuICAgICAgICBnID0gdGhpcyxcXG4gICAgICAgIGggPSBhLmluZGV4T2YoXFxcIiBcXFwiKTtyZXR1cm4gaCA+IC0xICYmIChkID0gbi50cmltKGEuc2xpY2UoaCkpLCBhID0gYS5zbGljZSgwLCBoKSksIG4uaXNGdW5jdGlvbihiKSA/IChjID0gYiwgYiA9IHZvaWQgMCkgOiBiICYmIFxcXCJvYmplY3RcXFwiID09ICh0eXBlb2YgYiA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YoYikpICYmIChlID0gXFxcIlBPU1RcXFwiKSwgZy5sZW5ndGggPiAwICYmIG4uYWpheCh7IHVybDogYSwgdHlwZTogZSB8fCBcXFwiR0VUXFxcIiwgZGF0YVR5cGU6IFxcXCJodG1sXFxcIiwgZGF0YTogYiB9KS5kb25lKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgZiA9IGFyZ3VtZW50cywgZy5odG1sKGQgPyBuKFxcXCI8ZGl2PlxcXCIpLmFwcGVuZChuLnBhcnNlSFRNTChhKSkuZmluZChkKSA6IGEpO1xcbiAgICB9KS5hbHdheXMoYyAmJiBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgIGcuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBjLmFwcGx5KHRoaXMsIGYgfHwgW2EucmVzcG9uc2VUZXh0LCBiLCBhXSk7XFxuICAgICAgfSk7XFxuICAgIH0pLCB0aGlzO1xcbiAgfSwgbi5lYWNoKFtcXFwiYWpheFN0YXJ0XFxcIiwgXFxcImFqYXhTdG9wXFxcIiwgXFxcImFqYXhDb21wbGV0ZVxcXCIsIFxcXCJhamF4RXJyb3JcXFwiLCBcXFwiYWpheFN1Y2Nlc3NcXFwiLCBcXFwiYWpheFNlbmRcXFwiXSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgbi5mbltiXSA9IGZ1bmN0aW9uIChhKSB7XFxuICAgICAgcmV0dXJuIHRoaXMub24oYiwgYSk7XFxuICAgIH07XFxuICB9KSwgbi5leHByLmZpbHRlcnMuYW5pbWF0ZWQgPSBmdW5jdGlvbiAoYSkge1xcbiAgICByZXR1cm4gbi5ncmVwKG4udGltZXJzLCBmdW5jdGlvbiAoYikge1xcbiAgICAgIHJldHVybiBhID09PSBiLmVsZW07XFxuICAgIH0pLmxlbmd0aDtcXG4gIH07ZnVuY3Rpb24gTWIoYSkge1xcbiAgICByZXR1cm4gbi5pc1dpbmRvdyhhKSA/IGEgOiA5ID09PSBhLm5vZGVUeXBlICYmIGEuZGVmYXVsdFZpZXc7XFxuICB9bi5vZmZzZXQgPSB7IHNldE9mZnNldDogZnVuY3Rpb24gc2V0T2Zmc2V0KGEsIGIsIGMpIHtcXG4gICAgICB2YXIgZCxcXG4gICAgICAgICAgZSxcXG4gICAgICAgICAgZixcXG4gICAgICAgICAgZyxcXG4gICAgICAgICAgaCxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgayA9IG4uY3NzKGEsIFxcXCJwb3NpdGlvblxcXCIpLFxcbiAgICAgICAgICBsID0gbihhKSxcXG4gICAgICAgICAgbSA9IHt9O1xcXCJzdGF0aWNcXFwiID09PSBrICYmIChhLnN0eWxlLnBvc2l0aW9uID0gXFxcInJlbGF0aXZlXFxcIiksIGggPSBsLm9mZnNldCgpLCBmID0gbi5jc3MoYSwgXFxcInRvcFxcXCIpLCBpID0gbi5jc3MoYSwgXFxcImxlZnRcXFwiKSwgaiA9IChcXFwiYWJzb2x1dGVcXFwiID09PSBrIHx8IFxcXCJmaXhlZFxcXCIgPT09IGspICYmIChmICsgaSkuaW5kZXhPZihcXFwiYXV0b1xcXCIpID4gLTEsIGogPyAoZCA9IGwucG9zaXRpb24oKSwgZyA9IGQudG9wLCBlID0gZC5sZWZ0KSA6IChnID0gcGFyc2VGbG9hdChmKSB8fCAwLCBlID0gcGFyc2VGbG9hdChpKSB8fCAwKSwgbi5pc0Z1bmN0aW9uKGIpICYmIChiID0gYi5jYWxsKGEsIGMsIG4uZXh0ZW5kKHt9LCBoKSkpLCBudWxsICE9IGIudG9wICYmIChtLnRvcCA9IGIudG9wIC0gaC50b3AgKyBnKSwgbnVsbCAhPSBiLmxlZnQgJiYgKG0ubGVmdCA9IGIubGVmdCAtIGgubGVmdCArIGUpLCBcXFwidXNpbmdcXFwiIGluIGIgPyBiLnVzaW5nLmNhbGwoYSwgbSkgOiBsLmNzcyhtKTtcXG4gICAgfSB9LCBuLmZuLmV4dGVuZCh7IG9mZnNldDogZnVuY3Rpb24gb2Zmc2V0KGEpIHtcXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHZvaWQgMCA9PT0gYSA/IHRoaXMgOiB0aGlzLmVhY2goZnVuY3Rpb24gKGIpIHtcXG4gICAgICAgIG4ub2Zmc2V0LnNldE9mZnNldCh0aGlzLCBhLCBiKTtcXG4gICAgICB9KTt2YXIgYixcXG4gICAgICAgICAgYyxcXG4gICAgICAgICAgZCA9IHRoaXNbMF0sXFxuICAgICAgICAgIGUgPSB7IHRvcDogMCwgbGVmdDogMCB9LFxcbiAgICAgICAgICBmID0gZCAmJiBkLm93bmVyRG9jdW1lbnQ7aWYgKGYpIHJldHVybiBiID0gZi5kb2N1bWVudEVsZW1lbnQsIG4uY29udGFpbnMoYiwgZCkgPyAoZSA9IGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGMgPSBNYihmKSwgeyB0b3A6IGUudG9wICsgYy5wYWdlWU9mZnNldCAtIGIuY2xpZW50VG9wLCBsZWZ0OiBlLmxlZnQgKyBjLnBhZ2VYT2Zmc2V0IC0gYi5jbGllbnRMZWZ0IH0pIDogZTtcXG4gICAgfSwgcG9zaXRpb246IGZ1bmN0aW9uIHBvc2l0aW9uKCkge1xcbiAgICAgIGlmICh0aGlzWzBdKSB7XFxuICAgICAgICB2YXIgYSxcXG4gICAgICAgICAgICBiLFxcbiAgICAgICAgICAgIGMgPSB0aGlzWzBdLFxcbiAgICAgICAgICAgIGQgPSB7IHRvcDogMCwgbGVmdDogMCB9O3JldHVybiBcXFwiZml4ZWRcXFwiID09PSBuLmNzcyhjLCBcXFwicG9zaXRpb25cXFwiKSA/IGIgPSBjLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogKGEgPSB0aGlzLm9mZnNldFBhcmVudCgpLCBiID0gdGhpcy5vZmZzZXQoKSwgbi5ub2RlTmFtZShhWzBdLCBcXFwiaHRtbFxcXCIpIHx8IChkID0gYS5vZmZzZXQoKSksIGQudG9wICs9IG4uY3NzKGFbMF0sIFxcXCJib3JkZXJUb3BXaWR0aFxcXCIsICEwKSwgZC5sZWZ0ICs9IG4uY3NzKGFbMF0sIFxcXCJib3JkZXJMZWZ0V2lkdGhcXFwiLCAhMCkpLCB7IHRvcDogYi50b3AgLSBkLnRvcCAtIG4uY3NzKGMsIFxcXCJtYXJnaW5Ub3BcXFwiLCAhMCksIGxlZnQ6IGIubGVmdCAtIGQubGVmdCAtIG4uY3NzKGMsIFxcXCJtYXJnaW5MZWZ0XFxcIiwgITApIH07XFxuICAgICAgfVxcbiAgICB9LCBvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uIG9mZnNldFBhcmVudCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGEgPSB0aGlzLm9mZnNldFBhcmVudDt3aGlsZSAoYSAmJiBcXFwic3RhdGljXFxcIiA9PT0gbi5jc3MoYSwgXFxcInBvc2l0aW9uXFxcIikpIHtcXG4gICAgICAgICAgYSA9IGEub2Zmc2V0UGFyZW50O1xcbiAgICAgICAgfXJldHVybiBhIHx8IEVhO1xcbiAgICAgIH0pO1xcbiAgICB9IH0pLCBuLmVhY2goeyBzY3JvbGxMZWZ0OiBcXFwicGFnZVhPZmZzZXRcXFwiLCBzY3JvbGxUb3A6IFxcXCJwYWdlWU9mZnNldFxcXCIgfSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgdmFyIGMgPSBcXFwicGFnZVlPZmZzZXRcXFwiID09PSBiO24uZm5bYV0gPSBmdW5jdGlvbiAoZCkge1xcbiAgICAgIHJldHVybiBLKHRoaXMsIGZ1bmN0aW9uIChhLCBkLCBlKSB7XFxuICAgICAgICB2YXIgZiA9IE1iKGEpO3JldHVybiB2b2lkIDAgPT09IGUgPyBmID8gZltiXSA6IGFbZF0gOiB2b2lkIChmID8gZi5zY3JvbGxUbyhjID8gZi5wYWdlWE9mZnNldCA6IGUsIGMgPyBlIDogZi5wYWdlWU9mZnNldCkgOiBhW2RdID0gZSk7XFxuICAgICAgfSwgYSwgZCwgYXJndW1lbnRzLmxlbmd0aCk7XFxuICAgIH07XFxuICB9KSwgbi5lYWNoKFtcXFwidG9wXFxcIiwgXFxcImxlZnRcXFwiXSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgbi5jc3NIb29rc1tiXSA9IEdhKGwucGl4ZWxQb3NpdGlvbiwgZnVuY3Rpb24gKGEsIGMpIHtcXG4gICAgICByZXR1cm4gYyA/IChjID0gRmEoYSwgYiksIEJhLnRlc3QoYykgPyBuKGEpLnBvc2l0aW9uKClbYl0gKyBcXFwicHhcXFwiIDogYykgOiB2b2lkIDA7XFxuICAgIH0pO1xcbiAgfSksIG4uZWFjaCh7IEhlaWdodDogXFxcImhlaWdodFxcXCIsIFdpZHRoOiBcXFwid2lkdGhcXFwiIH0sIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIG4uZWFjaCh7IHBhZGRpbmc6IFxcXCJpbm5lclxcXCIgKyBhLCBjb250ZW50OiBiLCBcXFwiXFxcIjogXFxcIm91dGVyXFxcIiArIGEgfSwgZnVuY3Rpb24gKGMsIGQpIHtcXG4gICAgICBuLmZuW2RdID0gZnVuY3Rpb24gKGQsIGUpIHtcXG4gICAgICAgIHZhciBmID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoYyB8fCBcXFwiYm9vbGVhblxcXCIgIT0gdHlwZW9mIGQpLFxcbiAgICAgICAgICAgIGcgPSBjIHx8IChkID09PSAhMCB8fCBlID09PSAhMCA/IFxcXCJtYXJnaW5cXFwiIDogXFxcImJvcmRlclxcXCIpO3JldHVybiBLKHRoaXMsIGZ1bmN0aW9uIChiLCBjLCBkKSB7XFxuICAgICAgICAgIHZhciBlO3JldHVybiBuLmlzV2luZG93KGIpID8gYi5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbXFxcImNsaWVudFxcXCIgKyBhXSA6IDkgPT09IGIubm9kZVR5cGUgPyAoZSA9IGIuZG9jdW1lbnRFbGVtZW50LCBNYXRoLm1heChiLmJvZHlbXFxcInNjcm9sbFxcXCIgKyBhXSwgZVtcXFwic2Nyb2xsXFxcIiArIGFdLCBiLmJvZHlbXFxcIm9mZnNldFxcXCIgKyBhXSwgZVtcXFwib2Zmc2V0XFxcIiArIGFdLCBlW1xcXCJjbGllbnRcXFwiICsgYV0pKSA6IHZvaWQgMCA9PT0gZCA/IG4uY3NzKGIsIGMsIGcpIDogbi5zdHlsZShiLCBjLCBkLCBnKTtcXG4gICAgICAgIH0sIGIsIGYgPyBkIDogdm9pZCAwLCBmLCBudWxsKTtcXG4gICAgICB9O1xcbiAgICB9KTtcXG4gIH0pLCBuLmZuLmV4dGVuZCh7IGJpbmQ6IGZ1bmN0aW9uIGJpbmQoYSwgYiwgYykge1xcbiAgICAgIHJldHVybiB0aGlzLm9uKGEsIG51bGwsIGIsIGMpO1xcbiAgICB9LCB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZChhLCBiKSB7XFxuICAgICAgcmV0dXJuIHRoaXMub2ZmKGEsIG51bGwsIGIpO1xcbiAgICB9LCBkZWxlZ2F0ZTogZnVuY3Rpb24gZGVsZWdhdGUoYSwgYiwgYywgZCkge1xcbiAgICAgIHJldHVybiB0aGlzLm9uKGIsIGEsIGMsIGQpO1xcbiAgICB9LCB1bmRlbGVnYXRlOiBmdW5jdGlvbiB1bmRlbGVnYXRlKGEsIGIsIGMpIHtcXG4gICAgICByZXR1cm4gMSA9PT0gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMub2ZmKGEsIFxcXCIqKlxcXCIpIDogdGhpcy5vZmYoYiwgYSB8fCBcXFwiKipcXFwiLCBjKTtcXG4gICAgfSwgc2l6ZTogZnVuY3Rpb24gc2l6ZSgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XFxuICAgIH0gfSksIG4uZm4uYW5kU2VsZiA9IG4uZm4uYWRkQmFjaywgXFxcImZ1bmN0aW9uXFxcIiA9PSB0eXBlb2YgZGVmaW5lICYmIGRlZmluZS5hbWQgJiYgZGVmaW5lKFxcXCJqcXVlcnlcXFwiLCBbXSwgZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gbjtcXG4gIH0pO3ZhciBOYiA9IGEualF1ZXJ5LFxcbiAgICAgIE9iID0gYS4kO3JldHVybiBuLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoYikge1xcbiAgICByZXR1cm4gYS4kID09PSBuICYmIChhLiQgPSBPYiksIGIgJiYgYS5qUXVlcnkgPT09IG4gJiYgKGEualF1ZXJ5ID0gTmIpLCBuO1xcbiAgfSwgYiB8fCAoYS5qUXVlcnkgPSBhLiQgPSBuKSwgbjtcXG59KTtcIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Jhdy1sb2FkZXIhLi9+L2JhYmVsLWxvYWRlcj97XCJwcmVzZXRzXCI6W1wicmVhY3RcIixcImVzMjAxNVwiLFwic3RhZ2UtMFwiXX0hLi9+L2pxdWVyeS9kaXN0L2pxdWVyeS5taW4uanNcbiAqKiBtb2R1bGUgaWQgPSAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKFwiISEvaG9tZS9zdGV3YXJ0L2NvZGUvbGVhcm4tcmVkdXgvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS9ob21lL3N0ZXdhcnQvY29kZS9sZWFybi1yZWR1eC9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvaG9tZS9zdGV3YXJ0L2NvZGUvbGVhcm4tcmVkdXgvbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9pbmRleC5qcz97XFxcInByZXNldHNcXFwiOltcXFwicmVhY3RcXFwiLFxcXCJlczIwMTVcXFwiLFxcXCJzdGFnZS0wXFxcIl19IS9ob21lL3N0ZXdhcnQvY29kZS9sZWFybi1yZWR1eC9ub2RlX21vZHVsZXMvZm91bmRhdGlvbi1zaXRlcy9kaXN0L2ZvdW5kYXRpb24ubWluLmpzXCIpKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NjcmlwdC1sb2FkZXIhLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9mb3VuZGF0aW9uLm1pbi5qc1xuICoqIG1vZHVsZSBpZCA9IDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJcXFwidXNlIHN0cmljdFxcXCI7dmFyIF90eXBlb2Y9dHlwZW9mIFN5bWJvbD09PVxcXCJmdW5jdGlvblxcXCImJnR5cGVvZiBTeW1ib2wuaXRlcmF0b3I9PT1cXFwic3ltYm9sXFxcIj9mdW5jdGlvbihvYmope3JldHVybiB0eXBlb2Ygb2JqO306ZnVuY3Rpb24ob2JqKXtyZXR1cm4gb2JqJiZ0eXBlb2YgU3ltYm9sPT09XFxcImZ1bmN0aW9uXFxcIiYmb2JqLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZvYmohPT1TeW1ib2wucHJvdG90eXBlP1xcXCJzeW1ib2xcXFwiOnR5cGVvZiBvYmo7fTtmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTt9ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO31mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTt9ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO31mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTt9ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO31mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTt9ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO31mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTt9ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO31mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTt9ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO31mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTt9IWZ1bmN0aW9uKHQpe1xcXCJ1c2Ugc3RyaWN0XFxcIjtmdW5jdGlvbiBlKHQpe2lmKHZvaWQgMD09PUZ1bmN0aW9uLnByb3RvdHlwZS5uYW1lKXt2YXIgZT0vZnVuY3Rpb25cXFxccyhbXihdezEsfSlcXFxcKC8saT1lLmV4ZWModC50b1N0cmluZygpKTtyZXR1cm4gaSYmaS5sZW5ndGg+MT9pWzFdLnRyaW0oKTpcXFwiXFxcIjt9cmV0dXJuIHZvaWQgMD09PXQucHJvdG90eXBlP3QuY29uc3RydWN0b3IubmFtZTp0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5uYW1lO31mdW5jdGlvbiBpKHQpe3JldHVybiAvdHJ1ZS8udGVzdCh0KT8hMDovZmFsc2UvLnRlc3QodCk/ITE6aXNOYU4oMSp0KT90OnBhcnNlRmxvYXQodCk7fWZ1bmN0aW9uIG4odCl7cmV0dXJuIHQucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZyxcXFwiJDEtJDJcXFwiKS50b0xvd2VyQ2FzZSgpO312YXIgcz1cXFwiNi4yLjNcXFwiLG89e3ZlcnNpb246cyxfcGx1Z2luczp7fSxfdXVpZHM6W10scnRsOmZ1bmN0aW9uIHJ0bCgpe3JldHVyblxcXCJydGxcXFwiPT09dChcXFwiaHRtbFxcXCIpLmF0dHIoXFxcImRpclxcXCIpO30scGx1Z2luOmZ1bmN0aW9uIHBsdWdpbih0LGkpe3ZhciBzPWl8fGUodCksbz1uKHMpO3RoaXMuX3BsdWdpbnNbb109dGhpc1tzXT10O30scmVnaXN0ZXJQbHVnaW46ZnVuY3Rpb24gcmVnaXN0ZXJQbHVnaW4odCxpKXt2YXIgcz1pP24oaSk6ZSh0LmNvbnN0cnVjdG9yKS50b0xvd2VyQ2FzZSgpO3QudXVpZD10aGlzLkdldFlvRGlnaXRzKDYscyksdC4kZWxlbWVudC5hdHRyKFxcXCJkYXRhLVxcXCIrcyl8fHQuJGVsZW1lbnQuYXR0cihcXFwiZGF0YS1cXFwiK3MsdC51dWlkKSx0LiRlbGVtZW50LmRhdGEoXFxcInpmUGx1Z2luXFxcIil8fHQuJGVsZW1lbnQuZGF0YShcXFwiemZQbHVnaW5cXFwiLHQpLHQuJGVsZW1lbnQudHJpZ2dlcihcXFwiaW5pdC56Zi5cXFwiK3MpLHRoaXMuX3V1aWRzLnB1c2godC51dWlkKTt9LHVucmVnaXN0ZXJQbHVnaW46ZnVuY3Rpb24gdW5yZWdpc3RlclBsdWdpbih0KXt2YXIgaT1uKGUodC4kZWxlbWVudC5kYXRhKFxcXCJ6ZlBsdWdpblxcXCIpLmNvbnN0cnVjdG9yKSk7dGhpcy5fdXVpZHMuc3BsaWNlKHRoaXMuX3V1aWRzLmluZGV4T2YodC51dWlkKSwxKSx0LiRlbGVtZW50LnJlbW92ZUF0dHIoXFxcImRhdGEtXFxcIitpKS5yZW1vdmVEYXRhKFxcXCJ6ZlBsdWdpblxcXCIpLnRyaWdnZXIoXFxcImRlc3Ryb3llZC56Zi5cXFwiK2kpO2Zvcih2YXIgcyBpbiB0KXt0W3NdPW51bGw7fX0scmVJbml0OmZ1bmN0aW9uIHJlSW5pdChlKXt2YXIgaT1lIGluc3RhbmNlb2YgdDt0cnl7aWYoaSllLmVhY2goZnVuY3Rpb24oKXt0KHRoaXMpLmRhdGEoXFxcInpmUGx1Z2luXFxcIikuX2luaXQoKTt9KTtlbHNle3ZhciBzPXR5cGVvZiBlPT09XFxcInVuZGVmaW5lZFxcXCI/XFxcInVuZGVmaW5lZFxcXCI6X3R5cGVvZihlKSxvPXRoaXMsYT17b2JqZWN0OmZ1bmN0aW9uIG9iamVjdChlKXtlLmZvckVhY2goZnVuY3Rpb24oZSl7ZT1uKGUpLHQoXFxcIltkYXRhLVxcXCIrZStcXFwiXVxcXCIpLmZvdW5kYXRpb24oXFxcIl9pbml0XFxcIik7fSk7fSxzdHJpbmc6ZnVuY3Rpb24gc3RyaW5nKCl7ZT1uKGUpLHQoXFxcIltkYXRhLVxcXCIrZStcXFwiXVxcXCIpLmZvdW5kYXRpb24oXFxcIl9pbml0XFxcIik7fSx1bmRlZmluZWQ6ZnVuY3Rpb24gdW5kZWZpbmVkKCl7dGhpcy5vYmplY3QoT2JqZWN0LmtleXMoby5fcGx1Z2lucykpO319O2Fbc10oZSk7fX1jYXRjaChyKXtjb25zb2xlLmVycm9yKHIpO31maW5hbGx5e3JldHVybiBlO319LEdldFlvRGlnaXRzOmZ1bmN0aW9uIEdldFlvRGlnaXRzKHQsZSl7cmV0dXJuIHQ9dHx8NixNYXRoLnJvdW5kKE1hdGgucG93KDM2LHQrMSktTWF0aC5yYW5kb20oKSpNYXRoLnBvdygzNix0KSkudG9TdHJpbmcoMzYpLnNsaWNlKDEpKyhlP1xcXCItXFxcIitlOlxcXCJcXFwiKTt9LHJlZmxvdzpmdW5jdGlvbiByZWZsb3coZSxuKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIG4/bj1PYmplY3Qua2V5cyh0aGlzLl9wbHVnaW5zKTpcXFwic3RyaW5nXFxcIj09dHlwZW9mIG4mJihuPVtuXSk7dmFyIHM9dGhpczt0LmVhY2gobixmdW5jdGlvbihuLG8pe3ZhciBhPXMuX3BsdWdpbnNbb10scj10KGUpLmZpbmQoXFxcIltkYXRhLVxcXCIrbytcXFwiXVxcXCIpLmFkZEJhY2soXFxcIltkYXRhLVxcXCIrbytcXFwiXVxcXCIpO3IuZWFjaChmdW5jdGlvbigpe3ZhciBlPXQodGhpcyksbj17fTtpZihlLmRhdGEoXFxcInpmUGx1Z2luXFxcIikpcmV0dXJuIHZvaWQgY29uc29sZS53YXJuKFxcXCJUcmllZCB0byBpbml0aWFsaXplIFxcXCIrbytcXFwiIG9uIGFuIGVsZW1lbnQgdGhhdCBhbHJlYWR5IGhhcyBhIEZvdW5kYXRpb24gcGx1Z2luLlxcXCIpO2lmKGUuYXR0cihcXFwiZGF0YS1vcHRpb25zXFxcIikpe2UuYXR0cihcXFwiZGF0YS1vcHRpb25zXFxcIikuc3BsaXQoXFxcIjtcXFwiKS5mb3JFYWNoKGZ1bmN0aW9uKHQsZSl7dmFyIHM9dC5zcGxpdChcXFwiOlxcXCIpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC50cmltKCk7fSk7c1swXSYmKG5bc1swXV09aShzWzFdKSk7fSk7fXRyeXtlLmRhdGEoXFxcInpmUGx1Z2luXFxcIixuZXcgYSh0KHRoaXMpLG4pKTt9Y2F0Y2gocyl7Y29uc29sZS5lcnJvcihzKTt9ZmluYWxseXtyZXR1cm47fX0pO30pO30sZ2V0Rm5OYW1lOmUsdHJhbnNpdGlvbmVuZDpmdW5jdGlvbiB0cmFuc2l0aW9uZW5kKHQpe3ZhciBlLGk9e3RyYW5zaXRpb246XFxcInRyYW5zaXRpb25lbmRcXFwiLFdlYmtpdFRyYW5zaXRpb246XFxcIndlYmtpdFRyYW5zaXRpb25FbmRcXFwiLE1velRyYW5zaXRpb246XFxcInRyYW5zaXRpb25lbmRcXFwiLE9UcmFuc2l0aW9uOlxcXCJvdHJhbnNpdGlvbmVuZFxcXCJ9LG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7Zm9yKHZhciBzIGluIGkpe1xcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2Ygbi5zdHlsZVtzXSYmKGU9aVtzXSk7fXJldHVybiBlP2U6KGU9c2V0VGltZW91dChmdW5jdGlvbigpe3QudHJpZ2dlckhhbmRsZXIoXFxcInRyYW5zaXRpb25lbmRcXFwiLFt0XSk7fSwxKSxcXFwidHJhbnNpdGlvbmVuZFxcXCIpO319O28udXRpbD17dGhyb3R0bGU6ZnVuY3Rpb24gdGhyb3R0bGUodCxlKXt2YXIgaT1udWxsO3JldHVybiBmdW5jdGlvbigpe3ZhciBuPXRoaXMscz1hcmd1bWVudHM7bnVsbD09PWkmJihpPXNldFRpbWVvdXQoZnVuY3Rpb24oKXt0LmFwcGx5KG4scyksaT1udWxsO30sZSkpO307fX07dmFyIGE9ZnVuY3Rpb24gYShpKXt2YXIgbj10eXBlb2YgaT09PVxcXCJ1bmRlZmluZWRcXFwiP1xcXCJ1bmRlZmluZWRcXFwiOl90eXBlb2YoaSkscz10KFxcXCJtZXRhLmZvdW5kYXRpb24tbXFcXFwiKSxhPXQoXFxcIi5uby1qc1xcXCIpO2lmKHMubGVuZ3RofHx0KCc8bWV0YSBjbGFzcz1cXFwiZm91bmRhdGlvbi1tcVxcXCI+JykuYXBwZW5kVG8oZG9jdW1lbnQuaGVhZCksYS5sZW5ndGgmJmEucmVtb3ZlQ2xhc3MoXFxcIm5vLWpzXFxcIiksXFxcInVuZGVmaW5lZFxcXCI9PT1uKW8uTWVkaWFRdWVyeS5faW5pdCgpLG8ucmVmbG93KHRoaXMpO2Vsc2V7aWYoXFxcInN0cmluZ1xcXCIhPT1uKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIldlJ3JlIHNvcnJ5LCBcXFwiK24rXFxcIiBpcyBub3QgYSB2YWxpZCBwYXJhbWV0ZXIuIFlvdSBtdXN0IHVzZSBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG1ldGhvZCB5b3Ugd2lzaCB0byBpbnZva2UuXFxcIik7dmFyIHI9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpLGw9dGhpcy5kYXRhKFxcXCJ6ZlBsdWdpblxcXCIpO2lmKHZvaWQgMD09PWx8fHZvaWQgMD09PWxbaV0pdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxcXCJXZSdyZSBzb3JyeSwgJ1xcXCIraStcXFwiJyBpcyBub3QgYW4gYXZhaWxhYmxlIG1ldGhvZCBmb3IgXFxcIisobD9lKGwpOlxcXCJ0aGlzIGVsZW1lbnRcXFwiKStcXFwiLlxcXCIpOzE9PT10aGlzLmxlbmd0aD9sW2ldLmFwcGx5KGwscik6dGhpcy5lYWNoKGZ1bmN0aW9uKGUsbil7bFtpXS5hcHBseSh0KG4pLmRhdGEoXFxcInpmUGx1Z2luXFxcIikscik7fSk7fXJldHVybiB0aGlzO307d2luZG93LkZvdW5kYXRpb249byx0LmZuLmZvdW5kYXRpb249YSxmdW5jdGlvbigpe0RhdGUubm93JiZ3aW5kb3cuRGF0ZS5ub3d8fCh3aW5kb3cuRGF0ZS5ub3c9RGF0ZS5ub3c9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7fSk7Zm9yKHZhciB0PVtcXFwid2Via2l0XFxcIixcXFwibW96XFxcIl0sZT0wO2U8dC5sZW5ndGgmJiF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOysrZSl7dmFyIGk9dFtlXTt3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lPXdpbmRvd1tpK1xcXCJSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcXFwiXSx3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWU9d2luZG93W2krXFxcIkNhbmNlbEFuaW1hdGlvbkZyYW1lXFxcIl18fHdpbmRvd1tpK1xcXCJDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcXFwiXTt9aWYoL2lQKGFkfGhvbmV8b2QpLipPUyA2Ly50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KXx8IXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fCF3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUpe3ZhciBuPTA7d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZT1mdW5jdGlvbih0KXt2YXIgZT1EYXRlLm5vdygpLGk9TWF0aC5tYXgobisxNixlKTtyZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpe3Qobj1pKTt9LGktZSk7fSx3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWU9Y2xlYXJUaW1lb3V0O313aW5kb3cucGVyZm9ybWFuY2UmJndpbmRvdy5wZXJmb3JtYW5jZS5ub3d8fCh3aW5kb3cucGVyZm9ybWFuY2U9e3N0YXJ0OkRhdGUubm93KCksbm93OmZ1bmN0aW9uIG5vdygpe3JldHVybiBEYXRlLm5vdygpLXRoaXMuc3RhcnQ7fX0pO30oKSxGdW5jdGlvbi5wcm90b3R5cGUuYmluZHx8KEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kPWZ1bmN0aW9uKHQpe2lmKFxcXCJmdW5jdGlvblxcXCIhPXR5cGVvZiB0aGlzKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIC0gd2hhdCBpcyB0cnlpbmcgdG8gYmUgYm91bmQgaXMgbm90IGNhbGxhYmxlXFxcIik7dmFyIGU9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpLGk9dGhpcyxuPWZ1bmN0aW9uIG4oKXt9LHM9ZnVuY3Rpb24gcygpe3JldHVybiBpLmFwcGx5KHRoaXMgaW5zdGFuY2VvZiBuP3RoaXM6dCxlLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7fTtyZXR1cm4gdGhpcy5wcm90b3R5cGUmJihuLnByb3RvdHlwZT10aGlzLnByb3RvdHlwZSkscy5wcm90b3R5cGU9bmV3IG4oKSxzO30pO30oalF1ZXJ5KSwhZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0LGUsbixzKXt2YXIgbyxhLHIsbCx1PWkodCk7aWYoZSl7dmFyIGQ9aShlKTthPXUub2Zmc2V0LnRvcCt1LmhlaWdodDw9ZC5oZWlnaHQrZC5vZmZzZXQudG9wLG89dS5vZmZzZXQudG9wPj1kLm9mZnNldC50b3Ascj11Lm9mZnNldC5sZWZ0Pj1kLm9mZnNldC5sZWZ0LGw9dS5vZmZzZXQubGVmdCt1LndpZHRoPD1kLndpZHRoK2Qub2Zmc2V0LmxlZnQ7fWVsc2UgYT11Lm9mZnNldC50b3ArdS5oZWlnaHQ8PXUud2luZG93RGltcy5oZWlnaHQrdS53aW5kb3dEaW1zLm9mZnNldC50b3Asbz11Lm9mZnNldC50b3A+PXUud2luZG93RGltcy5vZmZzZXQudG9wLHI9dS5vZmZzZXQubGVmdD49dS53aW5kb3dEaW1zLm9mZnNldC5sZWZ0LGw9dS5vZmZzZXQubGVmdCt1LndpZHRoPD11LndpbmRvd0RpbXMud2lkdGg7dmFyIGg9W2EsbyxyLGxdO3JldHVybiBuP3I9PT1sPT0hMDpzP289PT1hPT0hMDotMT09PWguaW5kZXhPZighMSk7fWZ1bmN0aW9uIGkodCxlKXtpZih0PXQubGVuZ3RoP3RbMF06dCx0PT09d2luZG93fHx0PT09ZG9jdW1lbnQpdGhyb3cgbmV3IEVycm9yKFxcXCJJJ20gc29ycnksIERhdmUuIEknbSBhZnJhaWQgSSBjYW4ndCBkbyB0aGF0LlxcXCIpO3ZhciBpPXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksbj10LnBhcmVudE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkscz1kb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLG89d2luZG93LnBhZ2VZT2Zmc2V0LGE9d2luZG93LnBhZ2VYT2Zmc2V0O3JldHVybnt3aWR0aDppLndpZHRoLGhlaWdodDppLmhlaWdodCxvZmZzZXQ6e3RvcDppLnRvcCtvLGxlZnQ6aS5sZWZ0K2F9LHBhcmVudERpbXM6e3dpZHRoOm4ud2lkdGgsaGVpZ2h0Om4uaGVpZ2h0LG9mZnNldDp7dG9wOm4udG9wK28sbGVmdDpuLmxlZnQrYX19LHdpbmRvd0RpbXM6e3dpZHRoOnMud2lkdGgsaGVpZ2h0OnMuaGVpZ2h0LG9mZnNldDp7dG9wOm8sbGVmdDphfX19O31mdW5jdGlvbiBuKHQsZSxuLHMsbyxhKXt2YXIgcj1pKHQpLGw9ZT9pKGUpOm51bGw7c3dpdGNoKG4pe2Nhc2VcXFwidG9wXFxcIjpyZXR1cm57bGVmdDpGb3VuZGF0aW9uLnJ0bCgpP2wub2Zmc2V0LmxlZnQtci53aWR0aCtsLndpZHRoOmwub2Zmc2V0LmxlZnQsdG9wOmwub2Zmc2V0LnRvcC0oci5oZWlnaHQrcyl9O2Nhc2VcXFwibGVmdFxcXCI6cmV0dXJue2xlZnQ6bC5vZmZzZXQubGVmdC0oci53aWR0aCtvKSx0b3A6bC5vZmZzZXQudG9wfTtjYXNlXFxcInJpZ2h0XFxcIjpyZXR1cm57bGVmdDpsLm9mZnNldC5sZWZ0K2wud2lkdGgrbyx0b3A6bC5vZmZzZXQudG9wfTtjYXNlXFxcImNlbnRlciB0b3BcXFwiOnJldHVybntsZWZ0Omwub2Zmc2V0LmxlZnQrbC53aWR0aC8yLXIud2lkdGgvMix0b3A6bC5vZmZzZXQudG9wLShyLmhlaWdodCtzKX07Y2FzZVxcXCJjZW50ZXIgYm90dG9tXFxcIjpyZXR1cm57bGVmdDphP286bC5vZmZzZXQubGVmdCtsLndpZHRoLzItci53aWR0aC8yLHRvcDpsLm9mZnNldC50b3ArbC5oZWlnaHQrc307Y2FzZVxcXCJjZW50ZXIgbGVmdFxcXCI6cmV0dXJue2xlZnQ6bC5vZmZzZXQubGVmdC0oci53aWR0aCtvKSx0b3A6bC5vZmZzZXQudG9wK2wuaGVpZ2h0LzItci5oZWlnaHQvMn07Y2FzZVxcXCJjZW50ZXIgcmlnaHRcXFwiOnJldHVybntsZWZ0Omwub2Zmc2V0LmxlZnQrbC53aWR0aCtvKzEsdG9wOmwub2Zmc2V0LnRvcCtsLmhlaWdodC8yLXIuaGVpZ2h0LzJ9O2Nhc2VcXFwiY2VudGVyXFxcIjpyZXR1cm57bGVmdDpyLndpbmRvd0RpbXMub2Zmc2V0LmxlZnQrci53aW5kb3dEaW1zLndpZHRoLzItci53aWR0aC8yLHRvcDpyLndpbmRvd0RpbXMub2Zmc2V0LnRvcCtyLndpbmRvd0RpbXMuaGVpZ2h0LzItci5oZWlnaHQvMn07Y2FzZVxcXCJyZXZlYWxcXFwiOnJldHVybntsZWZ0OihyLndpbmRvd0RpbXMud2lkdGgtci53aWR0aCkvMix0b3A6ci53aW5kb3dEaW1zLm9mZnNldC50b3Arc307Y2FzZVxcXCJyZXZlYWwgZnVsbFxcXCI6cmV0dXJue2xlZnQ6ci53aW5kb3dEaW1zLm9mZnNldC5sZWZ0LHRvcDpyLndpbmRvd0RpbXMub2Zmc2V0LnRvcH07Y2FzZVxcXCJsZWZ0IGJvdHRvbVxcXCI6cmV0dXJue2xlZnQ6bC5vZmZzZXQubGVmdC0oci53aWR0aCtvKSx0b3A6bC5vZmZzZXQudG9wK2wuaGVpZ2h0fTtjYXNlXFxcInJpZ2h0IGJvdHRvbVxcXCI6cmV0dXJue2xlZnQ6bC5vZmZzZXQubGVmdCtsLndpZHRoK28tci53aWR0aCx0b3A6bC5vZmZzZXQudG9wK2wuaGVpZ2h0fTtkZWZhdWx0OnJldHVybntsZWZ0OkZvdW5kYXRpb24ucnRsKCk/bC5vZmZzZXQubGVmdC1yLndpZHRoK2wud2lkdGg6bC5vZmZzZXQubGVmdCx0b3A6bC5vZmZzZXQudG9wK2wuaGVpZ2h0K3N9O319Rm91bmRhdGlvbi5Cb3g9e0ltTm90VG91Y2hpbmdZb3U6ZSxHZXREaW1lbnNpb25zOmksR2V0T2Zmc2V0czpufTt9KGpRdWVyeSksIWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCl7dmFyIGU9e307Zm9yKHZhciBpIGluIHQpe2VbdFtpXV09dFtpXTt9cmV0dXJuIGU7fXZhciBpPXs5OlxcXCJUQUJcXFwiLDEzOlxcXCJFTlRFUlxcXCIsMjc6XFxcIkVTQ0FQRVxcXCIsMzI6XFxcIlNQQUNFXFxcIiwzNzpcXFwiQVJST1dfTEVGVFxcXCIsMzg6XFxcIkFSUk9XX1VQXFxcIiwzOTpcXFwiQVJST1dfUklHSFRcXFwiLDQwOlxcXCJBUlJPV19ET1dOXFxcIn0sbj17fSxzPXtrZXlzOmUoaSkscGFyc2VLZXk6ZnVuY3Rpb24gcGFyc2VLZXkodCl7dmFyIGU9aVt0LndoaWNofHx0LmtleUNvZGVdfHxTdHJpbmcuZnJvbUNoYXJDb2RlKHQud2hpY2gpLnRvVXBwZXJDYXNlKCk7cmV0dXJuIHQuc2hpZnRLZXkmJihlPVxcXCJTSElGVF9cXFwiK2UpLHQuY3RybEtleSYmKGU9XFxcIkNUUkxfXFxcIitlKSx0LmFsdEtleSYmKGU9XFxcIkFMVF9cXFwiK2UpLGU7fSxoYW5kbGVLZXk6ZnVuY3Rpb24gaGFuZGxlS2V5KGUsaSxzKXt2YXIgbyxhLHIsbD1uW2ldLHU9dGhpcy5wYXJzZUtleShlKTtpZighbClyZXR1cm4gY29uc29sZS53YXJuKFxcXCJDb21wb25lbnQgbm90IGRlZmluZWQhXFxcIik7aWYobz1cXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGwubHRyP2w6Rm91bmRhdGlvbi5ydGwoKT90LmV4dGVuZCh7fSxsLmx0cixsLnJ0bCk6dC5leHRlbmQoe30sbC5ydGwsbC5sdHIpLGE9b1t1XSxyPXNbYV0sciYmXFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIHIpe3ZhciBkPXIuYXBwbHkoKTsocy5oYW5kbGVkfHxcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2Ygcy5oYW5kbGVkKSYmcy5oYW5kbGVkKGQpO31lbHNlKHMudW5oYW5kbGVkfHxcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2Ygcy51bmhhbmRsZWQpJiZzLnVuaGFuZGxlZCgpO30sZmluZEZvY3VzYWJsZTpmdW5jdGlvbiBmaW5kRm9jdXNhYmxlKGUpe3JldHVybiBlLmZpbmQoXFxcImFbaHJlZl0sIGFyZWFbaHJlZl0sIGlucHV0Om5vdChbZGlzYWJsZWRdKSwgc2VsZWN0Om5vdChbZGlzYWJsZWRdKSwgdGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pLCBidXR0b246bm90KFtkaXNhYmxlZF0pLCBpZnJhbWUsIG9iamVjdCwgZW1iZWQsICpbdGFiaW5kZXhdLCAqW2NvbnRlbnRlZGl0YWJsZV1cXFwiKS5maWx0ZXIoZnVuY3Rpb24oKXtyZXR1cm4gdCh0aGlzKS5pcyhcXFwiOnZpc2libGVcXFwiKSYmISh0KHRoaXMpLmF0dHIoXFxcInRhYmluZGV4XFxcIik8MCk7fSk7fSxyZWdpc3RlcjpmdW5jdGlvbiByZWdpc3Rlcih0LGUpe25bdF09ZTt9fTtGb3VuZGF0aW9uLktleWJvYXJkPXM7fShqUXVlcnkpLCFmdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQpe3ZhciBlPXt9O3JldHVyblxcXCJzdHJpbmdcXFwiIT10eXBlb2YgdD9lOih0PXQudHJpbSgpLnNsaWNlKDEsLTEpKT9lPXQuc3BsaXQoXFxcIiZcXFwiKS5yZWR1Y2UoZnVuY3Rpb24odCxlKXt2YXIgaT1lLnJlcGxhY2UoL1xcXFwrL2csXFxcIiBcXFwiKS5zcGxpdChcXFwiPVxcXCIpLG49aVswXSxzPWlbMV07cmV0dXJuIG49ZGVjb2RlVVJJQ29tcG9uZW50KG4pLHM9dm9pZCAwPT09cz9udWxsOmRlY29kZVVSSUNvbXBvbmVudChzKSx0Lmhhc093blByb3BlcnR5KG4pP0FycmF5LmlzQXJyYXkodFtuXSk/dFtuXS5wdXNoKHMpOnRbbl09W3Rbbl0sc106dFtuXT1zLHQ7fSx7fSk6ZTt9dmFyIGk9e3F1ZXJpZXM6W10sY3VycmVudDpcXFwiXFxcIixfaW5pdDpmdW5jdGlvbiBfaW5pdCgpe3ZhciBpLG49dGhpcyxzPXQoXFxcIi5mb3VuZGF0aW9uLW1xXFxcIikuY3NzKFxcXCJmb250LWZhbWlseVxcXCIpO2k9ZShzKTtmb3IodmFyIG8gaW4gaSl7aS5oYXNPd25Qcm9wZXJ0eShvKSYmbi5xdWVyaWVzLnB1c2goe25hbWU6byx2YWx1ZTpcXFwib25seSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IFxcXCIraVtvXStcXFwiKVxcXCJ9KTt9dGhpcy5jdXJyZW50PXRoaXMuX2dldEN1cnJlbnRTaXplKCksdGhpcy5fd2F0Y2hlcigpO30sYXRMZWFzdDpmdW5jdGlvbiBhdExlYXN0KHQpe3ZhciBlPXRoaXMuZ2V0KHQpO3JldHVybiBlP3dpbmRvdy5tYXRjaE1lZGlhKGUpLm1hdGNoZXM6ITE7fSxnZXQ6ZnVuY3Rpb24gZ2V0KHQpe2Zvcih2YXIgZSBpbiB0aGlzLnF1ZXJpZXMpe2lmKHRoaXMucXVlcmllcy5oYXNPd25Qcm9wZXJ0eShlKSl7dmFyIGk9dGhpcy5xdWVyaWVzW2VdO2lmKHQ9PT1pLm5hbWUpcmV0dXJuIGkudmFsdWU7fX1yZXR1cm4gbnVsbDt9LF9nZXRDdXJyZW50U2l6ZTpmdW5jdGlvbiBfZ2V0Q3VycmVudFNpemUoKXtmb3IodmFyIHQsZT0wO2U8dGhpcy5xdWVyaWVzLmxlbmd0aDtlKyspe3ZhciBpPXRoaXMucXVlcmllc1tlXTt3aW5kb3cubWF0Y2hNZWRpYShpLnZhbHVlKS5tYXRjaGVzJiYodD1pKTt9cmV0dXJuXFxcIm9iamVjdFxcXCI9PSh0eXBlb2YgdD09PVxcXCJ1bmRlZmluZWRcXFwiP1xcXCJ1bmRlZmluZWRcXFwiOl90eXBlb2YodCkpP3QubmFtZTp0O30sX3dhdGNoZXI6ZnVuY3Rpb24gX3dhdGNoZXIoKXt2YXIgZT10aGlzO3Qod2luZG93KS5vbihcXFwicmVzaXplLnpmLm1lZGlhcXVlcnlcXFwiLGZ1bmN0aW9uKCl7dmFyIGk9ZS5fZ2V0Q3VycmVudFNpemUoKSxuPWUuY3VycmVudDtpIT09biYmKGUuY3VycmVudD1pLHQod2luZG93KS50cmlnZ2VyKFxcXCJjaGFuZ2VkLnpmLm1lZGlhcXVlcnlcXFwiLFtpLG5dKSk7fSk7fX07Rm91bmRhdGlvbi5NZWRpYVF1ZXJ5PWksd2luZG93Lm1hdGNoTWVkaWF8fCh3aW5kb3cubWF0Y2hNZWRpYT1mdW5jdGlvbigpe1xcXCJ1c2Ugc3RyaWN0XFxcIjt2YXIgdD13aW5kb3cuc3R5bGVNZWRpYXx8d2luZG93Lm1lZGlhO2lmKCF0KXt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJzdHlsZVxcXCIpLGk9ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXFxcInNjcmlwdFxcXCIpWzBdLG49bnVsbDtlLnR5cGU9XFxcInRleHQvY3NzXFxcIixlLmlkPVxcXCJtYXRjaG1lZGlhanMtdGVzdFxcXCIsaS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlLGkpLG49XFxcImdldENvbXB1dGVkU3R5bGVcXFwiaW4gd2luZG93JiZ3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlLG51bGwpfHxlLmN1cnJlbnRTdHlsZSx0PXttYXRjaE1lZGl1bTpmdW5jdGlvbiBtYXRjaE1lZGl1bSh0KXt2YXIgaT1cXFwiQG1lZGlhIFxcXCIrdCtcXFwieyAjbWF0Y2htZWRpYWpzLXRlc3QgeyB3aWR0aDogMXB4OyB9IH1cXFwiO3JldHVybiBlLnN0eWxlU2hlZXQ/ZS5zdHlsZVNoZWV0LmNzc1RleHQ9aTplLnRleHRDb250ZW50PWksXFxcIjFweFxcXCI9PT1uLndpZHRoO319O31yZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJue21hdGNoZXM6dC5tYXRjaE1lZGl1bShlfHxcXFwiYWxsXFxcIiksbWVkaWE6ZXx8XFxcImFsbFxcXCJ9O307fSgpKSxGb3VuZGF0aW9uLk1lZGlhUXVlcnk9aTt9KGpRdWVyeSksIWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCxlLGkpe2Z1bmN0aW9uIG4ocil7YXx8KGE9d2luZG93LnBlcmZvcm1hbmNlLm5vdygpKSxvPXItYSxpLmFwcGx5KGUpLHQ+bz9zPXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUobixlKTood2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHMpLGUudHJpZ2dlcihcXFwiZmluaXNoZWQuemYuYW5pbWF0ZVxcXCIsW2VdKS50cmlnZ2VySGFuZGxlcihcXFwiZmluaXNoZWQuemYuYW5pbWF0ZVxcXCIsW2VdKSk7fXZhciBzLG8sYT1udWxsO3M9d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShuKTt9ZnVuY3Rpb24gaShlLGksbyxhKXtmdW5jdGlvbiByKCl7ZXx8aS5oaWRlKCksbCgpLGEmJmEuYXBwbHkoaSk7fWZ1bmN0aW9uIGwoKXtpWzBdLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbj0wLGkucmVtb3ZlQ2xhc3ModStcXFwiIFxcXCIrZCtcXFwiIFxcXCIrbyk7fWlmKGk9dChpKS5lcSgwKSxpLmxlbmd0aCl7dmFyIHU9ZT9uWzBdOm5bMV0sZD1lP3NbMF06c1sxXTtsKCksaS5hZGRDbGFzcyhvKS5jc3MoXFxcInRyYW5zaXRpb25cXFwiLFxcXCJub25lXFxcIikscmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7aS5hZGRDbGFzcyh1KSxlJiZpLnNob3coKTt9KSxyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtpWzBdLm9mZnNldFdpZHRoLGkuY3NzKFxcXCJ0cmFuc2l0aW9uXFxcIixcXFwiXFxcIikuYWRkQ2xhc3MoZCk7fSksaS5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKGkpLHIpO319dmFyIG49W1xcXCJtdWktZW50ZXJcXFwiLFxcXCJtdWktbGVhdmVcXFwiXSxzPVtcXFwibXVpLWVudGVyLWFjdGl2ZVxcXCIsXFxcIm11aS1sZWF2ZS1hY3RpdmVcXFwiXSxvPXthbmltYXRlSW46ZnVuY3Rpb24gYW5pbWF0ZUluKHQsZSxuKXtpKCEwLHQsZSxuKTt9LGFuaW1hdGVPdXQ6ZnVuY3Rpb24gYW5pbWF0ZU91dCh0LGUsbil7aSghMSx0LGUsbik7fX07Rm91bmRhdGlvbi5Nb3ZlPWUsRm91bmRhdGlvbi5Nb3Rpb249bzt9KGpRdWVyeSksIWZ1bmN0aW9uKHQpe3ZhciBlPXtGZWF0aGVyOmZ1bmN0aW9uIEZlYXRoZXIoZSl7dmFyIGk9YXJndW1lbnRzLmxlbmd0aDw9MXx8dm9pZCAwPT09YXJndW1lbnRzWzFdP1xcXCJ6ZlxcXCI6YXJndW1lbnRzWzFdO2UuYXR0cihcXFwicm9sZVxcXCIsXFxcIm1lbnViYXJcXFwiKTt2YXIgbj1lLmZpbmQoXFxcImxpXFxcIikuYXR0cih7cm9sZTpcXFwibWVudWl0ZW1cXFwifSkscz1cXFwiaXMtXFxcIitpK1xcXCItc3VibWVudVxcXCIsbz1zK1xcXCItaXRlbVxcXCIsYT1cXFwiaXMtXFxcIitpK1xcXCItc3VibWVudS1wYXJlbnRcXFwiO2UuZmluZChcXFwiYTpmaXJzdFxcXCIpLmF0dHIoXFxcInRhYmluZGV4XFxcIiwwKSxuLmVhY2goZnVuY3Rpb24oKXt2YXIgZT10KHRoaXMpLGk9ZS5jaGlsZHJlbihcXFwidWxcXFwiKTtpLmxlbmd0aCYmKGUuYWRkQ2xhc3MoYSkuYXR0cih7XFxcImFyaWEtaGFzcG9wdXBcXFwiOiEwLFxcXCJhcmlhLWV4cGFuZGVkXFxcIjohMSxcXFwiYXJpYS1sYWJlbFxcXCI6ZS5jaGlsZHJlbihcXFwiYTpmaXJzdFxcXCIpLnRleHQoKX0pLGkuYWRkQ2xhc3MoXFxcInN1Ym1lbnUgXFxcIitzKS5hdHRyKHtcXFwiZGF0YS1zdWJtZW51XFxcIjpcXFwiXFxcIixcXFwiYXJpYS1oaWRkZW5cXFwiOiEwLHJvbGU6XFxcIm1lbnVcXFwifSkpLGUucGFyZW50KFxcXCJbZGF0YS1zdWJtZW51XVxcXCIpLmxlbmd0aCYmZS5hZGRDbGFzcyhcXFwiaXMtc3VibWVudS1pdGVtIFxcXCIrbyk7fSk7fSxCdXJuOmZ1bmN0aW9uIEJ1cm4odCxlKXt2YXIgaT0odC5maW5kKFxcXCJsaVxcXCIpLnJlbW92ZUF0dHIoXFxcInRhYmluZGV4XFxcIiksXFxcImlzLVxcXCIrZStcXFwiLXN1Ym1lbnVcXFwiKSxuPWkrXFxcIi1pdGVtXFxcIixzPVxcXCJpcy1cXFwiK2UrXFxcIi1zdWJtZW51LXBhcmVudFxcXCI7dC5maW5kKFxcXCIqXFxcIikucmVtb3ZlQ2xhc3MoaStcXFwiIFxcXCIrbitcXFwiIFxcXCIrcytcXFwiIGlzLXN1Ym1lbnUtaXRlbSBzdWJtZW51IGlzLWFjdGl2ZVxcXCIpLnJlbW92ZUF0dHIoXFxcImRhdGEtc3VibWVudVxcXCIpLmNzcyhcXFwiZGlzcGxheVxcXCIsXFxcIlxcXCIpO319O0ZvdW5kYXRpb24uTmVzdD1lO30oalF1ZXJ5KSwhZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0LGUsaSl7dmFyIG4scyxvPXRoaXMsYT1lLmR1cmF0aW9uLHI9T2JqZWN0LmtleXModC5kYXRhKCkpWzBdfHxcXFwidGltZXJcXFwiLGw9LTE7dGhpcy5pc1BhdXNlZD0hMSx0aGlzLnJlc3RhcnQ9ZnVuY3Rpb24oKXtsPS0xLGNsZWFyVGltZW91dChzKSx0aGlzLnN0YXJ0KCk7fSx0aGlzLnN0YXJ0PWZ1bmN0aW9uKCl7dGhpcy5pc1BhdXNlZD0hMSxjbGVhclRpbWVvdXQocyksbD0wPj1sP2E6bCx0LmRhdGEoXFxcInBhdXNlZFxcXCIsITEpLG49RGF0ZS5ub3coKSxzPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtlLmluZmluaXRlJiZvLnJlc3RhcnQoKSxpKCk7fSxsKSx0LnRyaWdnZXIoXFxcInRpbWVyc3RhcnQuemYuXFxcIityKTt9LHRoaXMucGF1c2U9ZnVuY3Rpb24oKXt0aGlzLmlzUGF1c2VkPSEwLGNsZWFyVGltZW91dChzKSx0LmRhdGEoXFxcInBhdXNlZFxcXCIsITApO3ZhciBlPURhdGUubm93KCk7bC09ZS1uLHQudHJpZ2dlcihcXFwidGltZXJwYXVzZWQuemYuXFxcIityKTt9O31mdW5jdGlvbiBpKGUsaSl7ZnVuY3Rpb24gbigpe3MtLSwwPT09cyYmaSgpO312YXIgcz1lLmxlbmd0aDswPT09cyYmaSgpLGUuZWFjaChmdW5jdGlvbigpe3RoaXMuY29tcGxldGU/bigpOlxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgdGhpcy5uYXR1cmFsV2lkdGgmJnRoaXMubmF0dXJhbFdpZHRoPjA/bigpOnQodGhpcykub25lKFxcXCJsb2FkXFxcIixmdW5jdGlvbigpe24oKTt9KTt9KTt9Rm91bmRhdGlvbi5UaW1lcj1lLEZvdW5kYXRpb24ub25JbWFnZXNMb2FkZWQ9aTt9KGpRdWVyeSksZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3RoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcXFwidG91Y2htb3ZlXFxcIixpKSx0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXFxcInRvdWNoZW5kXFxcIixlKSx1PSExO31mdW5jdGlvbiBpKGkpe2lmKHQuc3BvdFN3aXBlLnByZXZlbnREZWZhdWx0JiZpLnByZXZlbnREZWZhdWx0KCksdSl7dmFyIG4scz1pLnRvdWNoZXNbMF0ucGFnZVgsYT0oaS50b3VjaGVzWzBdLnBhZ2VZLG8tcyk7bD1uZXcgRGF0ZSgpLmdldFRpbWUoKS1yLE1hdGguYWJzKGEpPj10LnNwb3RTd2lwZS5tb3ZlVGhyZXNob2xkJiZsPD10LnNwb3RTd2lwZS50aW1lVGhyZXNob2xkJiYobj1hPjA/XFxcImxlZnRcXFwiOlxcXCJyaWdodFxcXCIpLG4mJihpLnByZXZlbnREZWZhdWx0KCksZS5jYWxsKHRoaXMpLHQodGhpcykudHJpZ2dlcihcXFwic3dpcGVcXFwiLG4pLnRyaWdnZXIoXFxcInN3aXBlXFxcIituKSk7fX1mdW5jdGlvbiBuKHQpezE9PXQudG91Y2hlcy5sZW5ndGgmJihvPXQudG91Y2hlc1swXS5wYWdlWCxhPXQudG91Y2hlc1swXS5wYWdlWSx1PSEwLHI9bmV3IERhdGUoKS5nZXRUaW1lKCksdGhpcy5hZGRFdmVudExpc3RlbmVyKFxcXCJ0b3VjaG1vdmVcXFwiLGksITEpLHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcXFwidG91Y2hlbmRcXFwiLGUsITEpKTt9ZnVuY3Rpb24gcygpe3RoaXMuYWRkRXZlbnRMaXN0ZW5lciYmdGhpcy5hZGRFdmVudExpc3RlbmVyKFxcXCJ0b3VjaHN0YXJ0XFxcIixuLCExKTt9dC5zcG90U3dpcGU9e3ZlcnNpb246XFxcIjEuMC4wXFxcIixlbmFibGVkOlxcXCJvbnRvdWNoc3RhcnRcXFwiaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LHByZXZlbnREZWZhdWx0OiExLG1vdmVUaHJlc2hvbGQ6NzUsdGltZVRocmVzaG9sZDoyMDB9O3ZhciBvLGEscixsLHU9ITE7dC5ldmVudC5zcGVjaWFsLnN3aXBlPXtzZXR1cDpzfSx0LmVhY2goW1xcXCJsZWZ0XFxcIixcXFwidXBcXFwiLFxcXCJkb3duXFxcIixcXFwicmlnaHRcXFwiXSxmdW5jdGlvbigpe3QuZXZlbnQuc3BlY2lhbFtcXFwic3dpcGVcXFwiK3RoaXNdPXtzZXR1cDpmdW5jdGlvbiBzZXR1cCgpe3QodGhpcykub24oXFxcInN3aXBlXFxcIix0Lm5vb3ApO319O30pO30oalF1ZXJ5KSwhZnVuY3Rpb24odCl7dC5mbi5hZGRUb3VjaD1mdW5jdGlvbigpe3RoaXMuZWFjaChmdW5jdGlvbihpLG4pe3QobikuYmluZChcXFwidG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWxcXFwiLGZ1bmN0aW9uKCl7ZShldmVudCk7fSk7fSk7dmFyIGU9ZnVuY3Rpb24gZSh0KXt2YXIgZSxpPXQuY2hhbmdlZFRvdWNoZXMsbj1pWzBdLHM9e3RvdWNoc3RhcnQ6XFxcIm1vdXNlZG93blxcXCIsdG91Y2htb3ZlOlxcXCJtb3VzZW1vdmVcXFwiLHRvdWNoZW5kOlxcXCJtb3VzZXVwXFxcIn0sbz1zW3QudHlwZV07XFxcIk1vdXNlRXZlbnRcXFwiaW4gd2luZG93JiZcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2Ygd2luZG93Lk1vdXNlRXZlbnQ/ZT1uZXcgd2luZG93Lk1vdXNlRXZlbnQobyx7YnViYmxlczohMCxjYW5jZWxhYmxlOiEwLHNjcmVlblg6bi5zY3JlZW5YLHNjcmVlblk6bi5zY3JlZW5ZLGNsaWVudFg6bi5jbGllbnRYLGNsaWVudFk6bi5jbGllbnRZfSk6KGU9ZG9jdW1lbnQuY3JlYXRlRXZlbnQoXFxcIk1vdXNlRXZlbnRcXFwiKSxlLmluaXRNb3VzZUV2ZW50KG8sITAsITAsd2luZG93LDEsbi5zY3JlZW5YLG4uc2NyZWVuWSxuLmNsaWVudFgsbi5jbGllbnRZLCExLCExLCExLCExLDAsbnVsbCkpLG4udGFyZ2V0LmRpc3BhdGNoRXZlbnQoZSk7fTt9O30oalF1ZXJ5KSwhZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe28oKSxuKCkscygpLGkoKTt9ZnVuY3Rpb24gaShlKXt2YXIgaT10KFxcXCJbZGF0YS15ZXRpLWJveF1cXFwiKSxuPVtcXFwiZHJvcGRvd25cXFwiLFxcXCJ0b29sdGlwXFxcIixcXFwicmV2ZWFsXFxcIl07aWYoZSYmKFxcXCJzdHJpbmdcXFwiPT10eXBlb2YgZT9uLnB1c2goZSk6XFxcIm9iamVjdFxcXCI9PSh0eXBlb2YgZT09PVxcXCJ1bmRlZmluZWRcXFwiP1xcXCJ1bmRlZmluZWRcXFwiOl90eXBlb2YoZSkpJiZcXFwic3RyaW5nXFxcIj09dHlwZW9mIGVbMF0/bi5jb25jYXQoZSk6Y29uc29sZS5lcnJvcihcXFwiUGx1Z2luIG5hbWVzIG11c3QgYmUgc3RyaW5nc1xcXCIpKSxpLmxlbmd0aCl7dmFyIHM9bi5tYXAoZnVuY3Rpb24odCl7cmV0dXJuXFxcImNsb3NlbWUuemYuXFxcIit0O30pLmpvaW4oXFxcIiBcXFwiKTt0KHdpbmRvdykub2ZmKHMpLm9uKHMsZnVuY3Rpb24oZSxpKXt2YXIgbj1lLm5hbWVzcGFjZS5zcGxpdChcXFwiLlxcXCIpWzBdLHM9dChcXFwiW2RhdGEtXFxcIituK1xcXCJdXFxcIikubm90KCdbZGF0YS15ZXRpLWJveD1cXFwiJytpKydcXFwiXScpO3MuZWFjaChmdW5jdGlvbigpe3ZhciBlPXQodGhpcyk7ZS50cmlnZ2VySGFuZGxlcihcXFwiY2xvc2UuemYudHJpZ2dlclxcXCIsW2VdKTt9KTt9KTt9fWZ1bmN0aW9uIG4oZSl7dmFyIGk9dm9pZCAwLG49dChcXFwiW2RhdGEtcmVzaXplXVxcXCIpO24ubGVuZ3RoJiZ0KHdpbmRvdykub2ZmKFxcXCJyZXNpemUuemYudHJpZ2dlclxcXCIpLm9uKFxcXCJyZXNpemUuemYudHJpZ2dlclxcXCIsZnVuY3Rpb24ocyl7aSYmY2xlYXJUaW1lb3V0KGkpLGk9c2V0VGltZW91dChmdW5jdGlvbigpe2F8fG4uZWFjaChmdW5jdGlvbigpe3QodGhpcykudHJpZ2dlckhhbmRsZXIoXFxcInJlc2l6ZW1lLnpmLnRyaWdnZXJcXFwiKTt9KSxuLmF0dHIoXFxcImRhdGEtZXZlbnRzXFxcIixcXFwicmVzaXplXFxcIik7fSxlfHwxMCk7fSk7fWZ1bmN0aW9uIHMoZSl7dmFyIGk9dm9pZCAwLG49dChcXFwiW2RhdGEtc2Nyb2xsXVxcXCIpO24ubGVuZ3RoJiZ0KHdpbmRvdykub2ZmKFxcXCJzY3JvbGwuemYudHJpZ2dlclxcXCIpLm9uKFxcXCJzY3JvbGwuemYudHJpZ2dlclxcXCIsZnVuY3Rpb24ocyl7aSYmY2xlYXJUaW1lb3V0KGkpLGk9c2V0VGltZW91dChmdW5jdGlvbigpe2F8fG4uZWFjaChmdW5jdGlvbigpe3QodGhpcykudHJpZ2dlckhhbmRsZXIoXFxcInNjcm9sbG1lLnpmLnRyaWdnZXJcXFwiKTt9KSxuLmF0dHIoXFxcImRhdGEtZXZlbnRzXFxcIixcXFwic2Nyb2xsXFxcIik7fSxlfHwxMCk7fSk7fWZ1bmN0aW9uIG8oKXtpZighYSlyZXR1cm4hMTt2YXIgZT1kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFxcXCJbZGF0YS1yZXNpemVdLCBbZGF0YS1zY3JvbGxdLCBbZGF0YS1tdXRhdGVdXFxcIiksaT1mdW5jdGlvbiBpKGUpe3ZhciBpPXQoZVswXS50YXJnZXQpO3N3aXRjaChpLmF0dHIoXFxcImRhdGEtZXZlbnRzXFxcIikpe2Nhc2VcXFwicmVzaXplXFxcIjppLnRyaWdnZXJIYW5kbGVyKFxcXCJyZXNpemVtZS56Zi50cmlnZ2VyXFxcIixbaV0pO2JyZWFrO2Nhc2VcXFwic2Nyb2xsXFxcIjppLnRyaWdnZXJIYW5kbGVyKFxcXCJzY3JvbGxtZS56Zi50cmlnZ2VyXFxcIixbaSx3aW5kb3cucGFnZVlPZmZzZXRdKTticmVhaztkZWZhdWx0OnJldHVybiExO319O2lmKGUubGVuZ3RoKWZvcih2YXIgbj0wO248PWUubGVuZ3RoLTE7bisrKXt2YXIgcz1uZXcgYShpKTtzLm9ic2VydmUoZVtuXSx7YXR0cmlidXRlczohMCxjaGlsZExpc3Q6ITEsY2hhcmFjdGVyRGF0YTohMSxzdWJ0cmVlOiExLGF0dHJpYnV0ZUZpbHRlcjpbXFxcImRhdGEtZXZlbnRzXFxcIl19KTt9fXZhciBhPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtcXFwiV2ViS2l0XFxcIixcXFwiTW96XFxcIixcXFwiT1xcXCIsXFxcIk1zXFxcIixcXFwiXFxcIl0sZT0wO2U8dC5sZW5ndGg7ZSsrKXtpZih0W2VdK1xcXCJNdXRhdGlvbk9ic2VydmVyXFxcImluIHdpbmRvdylyZXR1cm4gd2luZG93W3RbZV0rXFxcIk11dGF0aW9uT2JzZXJ2ZXJcXFwiXTt9cmV0dXJuITE7fSgpLHI9ZnVuY3Rpb24gcihlLGkpe2UuZGF0YShpKS5zcGxpdChcXFwiIFxcXCIpLmZvckVhY2goZnVuY3Rpb24obil7dChcXFwiI1xcXCIrbilbXFxcImNsb3NlXFxcIj09PWk/XFxcInRyaWdnZXJcXFwiOlxcXCJ0cmlnZ2VySGFuZGxlclxcXCJdKGkrXFxcIi56Zi50cmlnZ2VyXFxcIixbZV0pO30pO307dChkb2N1bWVudCkub24oXFxcImNsaWNrLnpmLnRyaWdnZXJcXFwiLFxcXCJbZGF0YS1vcGVuXVxcXCIsZnVuY3Rpb24oKXtyKHQodGhpcyksXFxcIm9wZW5cXFwiKTt9KSx0KGRvY3VtZW50KS5vbihcXFwiY2xpY2suemYudHJpZ2dlclxcXCIsXFxcIltkYXRhLWNsb3NlXVxcXCIsZnVuY3Rpb24oKXt2YXIgZT10KHRoaXMpLmRhdGEoXFxcImNsb3NlXFxcIik7ZT9yKHQodGhpcyksXFxcImNsb3NlXFxcIik6dCh0aGlzKS50cmlnZ2VyKFxcXCJjbG9zZS56Zi50cmlnZ2VyXFxcIik7fSksdChkb2N1bWVudCkub24oXFxcImNsaWNrLnpmLnRyaWdnZXJcXFwiLFxcXCJbZGF0YS10b2dnbGVdXFxcIixmdW5jdGlvbigpe3IodCh0aGlzKSxcXFwidG9nZ2xlXFxcIik7fSksdChkb2N1bWVudCkub24oXFxcImNsb3NlLnpmLnRyaWdnZXJcXFwiLFxcXCJbZGF0YS1jbG9zYWJsZV1cXFwiLGZ1bmN0aW9uKGUpe2Uuc3RvcFByb3BhZ2F0aW9uKCk7dmFyIGk9dCh0aGlzKS5kYXRhKFxcXCJjbG9zYWJsZVxcXCIpO1xcXCJcXFwiIT09aT9Gb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlT3V0KHQodGhpcyksaSxmdW5jdGlvbigpe3QodGhpcykudHJpZ2dlcihcXFwiY2xvc2VkLnpmXFxcIik7fSk6dCh0aGlzKS5mYWRlT3V0KCkudHJpZ2dlcihcXFwiY2xvc2VkLnpmXFxcIik7fSksdChkb2N1bWVudCkub24oXFxcImZvY3VzLnpmLnRyaWdnZXIgYmx1ci56Zi50cmlnZ2VyXFxcIixcXFwiW2RhdGEtdG9nZ2xlLWZvY3VzXVxcXCIsZnVuY3Rpb24oKXt2YXIgZT10KHRoaXMpLmRhdGEoXFxcInRvZ2dsZS1mb2N1c1xcXCIpO3QoXFxcIiNcXFwiK2UpLnRyaWdnZXJIYW5kbGVyKFxcXCJ0b2dnbGUuemYudHJpZ2dlclxcXCIsW3QodGhpcyldKTt9KSx0KHdpbmRvdykubG9hZChmdW5jdGlvbigpe2UoKTt9KSxGb3VuZGF0aW9uLklIZWFyWW91PWU7fShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXFxcInZhbHVlXFxcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLmtleSxuKTt9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGU7fTt9KCk7IWZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShpKXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPD0xfHx2b2lkIDA9PT1hcmd1bWVudHNbMV0/e306YXJndW1lbnRzWzFdO19jbGFzc0NhbGxDaGVjayh0aGlzLGUpLHRoaXMuJGVsZW1lbnQ9aSx0aGlzLm9wdGlvbnM9dC5leHRlbmQoe30sZS5kZWZhdWx0cyx0aGlzLiRlbGVtZW50LmRhdGEoKSxuKSx0aGlzLl9pbml0KCksRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLFxcXCJBYmlkZVxcXCIpO31yZXR1cm4gX2NyZWF0ZUNsYXNzKGUsW3trZXk6XFxcIl9pbml0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuJGlucHV0cz10aGlzLiRlbGVtZW50LmZpbmQoXFxcImlucHV0LCB0ZXh0YXJlYSwgc2VsZWN0XFxcIiksdGhpcy5fZXZlbnRzKCk7fX0se2tleTpcXFwiX2V2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzO3RoaXMuJGVsZW1lbnQub2ZmKFxcXCIuYWJpZGVcXFwiKS5vbihcXFwicmVzZXQuemYuYWJpZGVcXFwiLGZ1bmN0aW9uKCl7ZS5yZXNldEZvcm0oKTt9KS5vbihcXFwic3VibWl0LnpmLmFiaWRlXFxcIixmdW5jdGlvbigpe3JldHVybiBlLnZhbGlkYXRlRm9ybSgpO30pLFxcXCJmaWVsZENoYW5nZVxcXCI9PT10aGlzLm9wdGlvbnMudmFsaWRhdGVPbiYmdGhpcy4kaW5wdXRzLm9mZihcXFwiY2hhbmdlLnpmLmFiaWRlXFxcIikub24oXFxcImNoYW5nZS56Zi5hYmlkZVxcXCIsZnVuY3Rpb24oaSl7ZS52YWxpZGF0ZUlucHV0KHQoaS50YXJnZXQpKTt9KSx0aGlzLm9wdGlvbnMubGl2ZVZhbGlkYXRlJiZ0aGlzLiRpbnB1dHMub2ZmKFxcXCJpbnB1dC56Zi5hYmlkZVxcXCIpLm9uKFxcXCJpbnB1dC56Zi5hYmlkZVxcXCIsZnVuY3Rpb24oaSl7ZS52YWxpZGF0ZUlucHV0KHQoaS50YXJnZXQpKTt9KTt9fSx7a2V5OlxcXCJfcmVmbG93XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuX2luaXQoKTt9fSx7a2V5OlxcXCJyZXF1aXJlZENoZWNrXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXtpZighdC5hdHRyKFxcXCJyZXF1aXJlZFxcXCIpKXJldHVybiEwO3ZhciBlPSEwO3N3aXRjaCh0WzBdLnR5cGUpe2Nhc2VcXFwiY2hlY2tib3hcXFwiOmU9dFswXS5jaGVja2VkO2JyZWFrO2Nhc2VcXFwic2VsZWN0XFxcIjpjYXNlXFxcInNlbGVjdC1vbmVcXFwiOmNhc2VcXFwic2VsZWN0LW11bHRpcGxlXFxcIjp2YXIgaT10LmZpbmQoXFxcIm9wdGlvbjpzZWxlY3RlZFxcXCIpO2kubGVuZ3RoJiZpLnZhbCgpfHwoZT0hMSk7YnJlYWs7ZGVmYXVsdDp0LnZhbCgpJiZ0LnZhbCgpLmxlbmd0aHx8KGU9ITEpO31yZXR1cm4gZTt9fSx7a2V5OlxcXCJmaW5kRm9ybUVycm9yXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt2YXIgZT10LnNpYmxpbmdzKHRoaXMub3B0aW9ucy5mb3JtRXJyb3JTZWxlY3Rvcik7cmV0dXJuIGUubGVuZ3RofHwoZT10LnBhcmVudCgpLmZpbmQodGhpcy5vcHRpb25zLmZvcm1FcnJvclNlbGVjdG9yKSksZTt9fSx7a2V5OlxcXCJmaW5kTGFiZWxcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3ZhciBlPXRbMF0uaWQsaT10aGlzLiRlbGVtZW50LmZpbmQoJ2xhYmVsW2Zvcj1cXFwiJytlKydcXFwiXScpO3JldHVybiBpLmxlbmd0aD9pOnQuY2xvc2VzdChcXFwibGFiZWxcXFwiKTt9fSx7a2V5OlxcXCJmaW5kUmFkaW9MYWJlbHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKGUpe3ZhciBpPXRoaXMsbj1lLm1hcChmdW5jdGlvbihlLG4pe3ZhciBzPW4uaWQsbz1pLiRlbGVtZW50LmZpbmQoJ2xhYmVsW2Zvcj1cXFwiJytzKydcXFwiXScpO3JldHVybiBvLmxlbmd0aHx8KG89dChuKS5jbG9zZXN0KFxcXCJsYWJlbFxcXCIpKSxvWzBdO30pO3JldHVybiB0KG4pO319LHtrZXk6XFxcImFkZEVycm9yQ2xhc3Nlc1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dmFyIGU9dGhpcy5maW5kTGFiZWwodCksaT10aGlzLmZpbmRGb3JtRXJyb3IodCk7ZS5sZW5ndGgmJmUuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmxhYmVsRXJyb3JDbGFzcyksaS5sZW5ndGgmJmkuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmZvcm1FcnJvckNsYXNzKSx0LmFkZENsYXNzKHRoaXMub3B0aW9ucy5pbnB1dEVycm9yQ2xhc3MpLmF0dHIoXFxcImRhdGEtaW52YWxpZFxcXCIsXFxcIlxcXCIpO319LHtrZXk6XFxcInJlbW92ZVJhZGlvRXJyb3JDbGFzc2VzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt2YXIgZT10aGlzLiRlbGVtZW50LmZpbmQoJzpyYWRpb1tuYW1lPVxcXCInK3QrJ1xcXCJdJyksaT10aGlzLmZpbmRSYWRpb0xhYmVscyhlKSxuPXRoaXMuZmluZEZvcm1FcnJvcihlKTtpLmxlbmd0aCYmaS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMubGFiZWxFcnJvckNsYXNzKSxuLmxlbmd0aCYmbi5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuZm9ybUVycm9yQ2xhc3MpLGUucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmlucHV0RXJyb3JDbGFzcykucmVtb3ZlQXR0cihcXFwiZGF0YS1pbnZhbGlkXFxcIik7fX0se2tleTpcXFwicmVtb3ZlRXJyb3JDbGFzc2VzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXtpZihcXFwicmFkaW9cXFwiPT10WzBdLnR5cGUpcmV0dXJuIHRoaXMucmVtb3ZlUmFkaW9FcnJvckNsYXNzZXModC5hdHRyKFxcXCJuYW1lXFxcIikpO3ZhciBlPXRoaXMuZmluZExhYmVsKHQpLGk9dGhpcy5maW5kRm9ybUVycm9yKHQpO2UubGVuZ3RoJiZlLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5sYWJlbEVycm9yQ2xhc3MpLGkubGVuZ3RoJiZpLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5mb3JtRXJyb3JDbGFzcyksdC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuaW5wdXRFcnJvckNsYXNzKS5yZW1vdmVBdHRyKFxcXCJkYXRhLWludmFsaWRcXFwiKTt9fSx7a2V5OlxcXCJ2YWxpZGF0ZUlucHV0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt2YXIgZT10aGlzLnJlcXVpcmVkQ2hlY2sodCksaT0hMSxuPSEwLHM9dC5hdHRyKFxcXCJkYXRhLXZhbGlkYXRvclxcXCIpLG89ITA7aWYodC5pcyhcXFwiW2RhdGEtYWJpZGUtaWdub3JlXVxcXCIpfHx0LmlzKCdbdHlwZT1cXFwiaGlkZGVuXFxcIl0nKSlyZXR1cm4hMDtzd2l0Y2godFswXS50eXBlKXtjYXNlXFxcInJhZGlvXFxcIjppPXRoaXMudmFsaWRhdGVSYWRpbyh0LmF0dHIoXFxcIm5hbWVcXFwiKSk7YnJlYWs7Y2FzZVxcXCJjaGVja2JveFxcXCI6aT1lO2JyZWFrO2Nhc2VcXFwic2VsZWN0XFxcIjpjYXNlXFxcInNlbGVjdC1vbmVcXFwiOmNhc2VcXFwic2VsZWN0LW11bHRpcGxlXFxcIjppPWU7YnJlYWs7ZGVmYXVsdDppPXRoaXMudmFsaWRhdGVUZXh0KHQpO31zJiYobj10aGlzLm1hdGNoVmFsaWRhdGlvbih0LHMsdC5hdHRyKFxcXCJyZXF1aXJlZFxcXCIpKSksdC5hdHRyKFxcXCJkYXRhLWVxdWFsdG9cXFwiKSYmKG89dGhpcy5vcHRpb25zLnZhbGlkYXRvcnMuZXF1YWxUbyh0KSk7dmFyIGE9LTE9PT1bZSxpLG4sb10uaW5kZXhPZighMSkscj0oYT9cXFwidmFsaWRcXFwiOlxcXCJpbnZhbGlkXFxcIikrXFxcIi56Zi5hYmlkZVxcXCI7cmV0dXJuIHRoaXNbYT9cXFwicmVtb3ZlRXJyb3JDbGFzc2VzXFxcIjpcXFwiYWRkRXJyb3JDbGFzc2VzXFxcIl0odCksdC50cmlnZ2VyKHIsW3RdKSxhO319LHtrZXk6XFxcInZhbGlkYXRlRm9ybVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT1bXSxpPXRoaXM7dGhpcy4kaW5wdXRzLmVhY2goZnVuY3Rpb24oKXtlLnB1c2goaS52YWxpZGF0ZUlucHV0KHQodGhpcykpKTt9KTt2YXIgbj0tMT09PWUuaW5kZXhPZighMSk7cmV0dXJuIHRoaXMuJGVsZW1lbnQuZmluZChcXFwiW2RhdGEtYWJpZGUtZXJyb3JdXFxcIikuY3NzKFxcXCJkaXNwbGF5XFxcIixuP1xcXCJub25lXFxcIjpcXFwiYmxvY2tcXFwiKSx0aGlzLiRlbGVtZW50LnRyaWdnZXIoKG4/XFxcImZvcm12YWxpZFxcXCI6XFxcImZvcm1pbnZhbGlkXFxcIikrXFxcIi56Zi5hYmlkZVxcXCIsW3RoaXMuJGVsZW1lbnRdKSxuO319LHtrZXk6XFxcInZhbGlkYXRlVGV4dFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCxlKXtlPWV8fHQuYXR0cihcXFwicGF0dGVyblxcXCIpfHx0LmF0dHIoXFxcInR5cGVcXFwiKTt2YXIgaT10LnZhbCgpLG49ITE7cmV0dXJuIGkubGVuZ3RoP249dGhpcy5vcHRpb25zLnBhdHRlcm5zLmhhc093blByb3BlcnR5KGUpP3RoaXMub3B0aW9ucy5wYXR0ZXJuc1tlXS50ZXN0KGkpOmUhPT10LmF0dHIoXFxcInR5cGVcXFwiKT9uZXcgUmVnRXhwKGUpLnRlc3QoaSk6ITA6dC5wcm9wKFxcXCJyZXF1aXJlZFxcXCIpfHwobj0hMCksbjt9fSx7a2V5OlxcXCJ2YWxpZGF0ZVJhZGlvXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZShlKXt2YXIgaT10aGlzLiRlbGVtZW50LmZpbmQoJzpyYWRpb1tuYW1lPVxcXCInK2UrJ1xcXCJdJyksbj0hMSxzPSExO3JldHVybiBpLmVhY2goZnVuY3Rpb24oZSxpKXt0KGkpLmF0dHIoXFxcInJlcXVpcmVkXFxcIikmJihzPSEwKTt9KSxzfHwobj0hMCksbnx8aS5lYWNoKGZ1bmN0aW9uKGUsaSl7dChpKS5wcm9wKFxcXCJjaGVja2VkXFxcIikmJihuPSEwKTt9KSxuO319LHtrZXk6XFxcIm1hdGNoVmFsaWRhdGlvblxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCxlLGkpe3ZhciBuPXRoaXM7aT0hIWk7dmFyIHM9ZS5zcGxpdChcXFwiIFxcXCIpLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gbi5vcHRpb25zLnZhbGlkYXRvcnNbZV0odCxpLHQucGFyZW50KCkpO30pO3JldHVybi0xPT09cy5pbmRleE9mKCExKTt9fSx7a2V5OlxcXCJyZXNldEZvcm1cXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpcy4kZWxlbWVudCxpPXRoaXMub3B0aW9uczt0KFxcXCIuXFxcIitpLmxhYmVsRXJyb3JDbGFzcyxlKS5ub3QoXFxcInNtYWxsXFxcIikucmVtb3ZlQ2xhc3MoaS5sYWJlbEVycm9yQ2xhc3MpLHQoXFxcIi5cXFwiK2kuaW5wdXRFcnJvckNsYXNzLGUpLm5vdChcXFwic21hbGxcXFwiKS5yZW1vdmVDbGFzcyhpLmlucHV0RXJyb3JDbGFzcyksdChpLmZvcm1FcnJvclNlbGVjdG9yK1xcXCIuXFxcIitpLmZvcm1FcnJvckNsYXNzKS5yZW1vdmVDbGFzcyhpLmZvcm1FcnJvckNsYXNzKSxlLmZpbmQoXFxcIltkYXRhLWFiaWRlLWVycm9yXVxcXCIpLmNzcyhcXFwiZGlzcGxheVxcXCIsXFxcIm5vbmVcXFwiKSx0KFxcXCI6aW5wdXRcXFwiLGUpLm5vdChcXFwiOmJ1dHRvbiwgOnN1Ym1pdCwgOnJlc2V0LCA6aGlkZGVuLCA6cmFkaW8sIDpjaGVja2JveCwgW2RhdGEtYWJpZGUtaWdub3JlXVxcXCIpLnZhbChcXFwiXFxcIikucmVtb3ZlQXR0cihcXFwiZGF0YS1pbnZhbGlkXFxcIiksdChcXFwiOmlucHV0OnJhZGlvXFxcIixlKS5ub3QoXFxcIltkYXRhLWFiaWRlLWlnbm9yZV1cXFwiKS5wcm9wKFxcXCJjaGVja2VkXFxcIiwhMSkucmVtb3ZlQXR0cihcXFwiZGF0YS1pbnZhbGlkXFxcIiksdChcXFwiOmlucHV0OmNoZWNrYm94XFxcIixlKS5ub3QoXFxcIltkYXRhLWFiaWRlLWlnbm9yZV1cXFwiKS5wcm9wKFxcXCJjaGVja2VkXFxcIiwhMSkucmVtb3ZlQXR0cihcXFwiZGF0YS1pbnZhbGlkXFxcIiksZS50cmlnZ2VyKFxcXCJmb3JtcmVzZXQuemYuYWJpZGVcXFwiLFtlXSk7fX0se2tleTpcXFwiZGVzdHJveVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzO3RoaXMuJGVsZW1lbnQub2ZmKFxcXCIuYWJpZGVcXFwiKS5maW5kKFxcXCJbZGF0YS1hYmlkZS1lcnJvcl1cXFwiKS5jc3MoXFxcImRpc3BsYXlcXFwiLFxcXCJub25lXFxcIiksdGhpcy4kaW5wdXRzLm9mZihcXFwiLmFiaWRlXFxcIikuZWFjaChmdW5jdGlvbigpe2UucmVtb3ZlRXJyb3JDbGFzc2VzKHQodGhpcykpO30pLEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTt9fV0pLGU7fSgpO2UuZGVmYXVsdHM9e3ZhbGlkYXRlT246XFxcImZpZWxkQ2hhbmdlXFxcIixsYWJlbEVycm9yQ2xhc3M6XFxcImlzLWludmFsaWQtbGFiZWxcXFwiLGlucHV0RXJyb3JDbGFzczpcXFwiaXMtaW52YWxpZC1pbnB1dFxcXCIsZm9ybUVycm9yU2VsZWN0b3I6XFxcIi5mb3JtLWVycm9yXFxcIixmb3JtRXJyb3JDbGFzczpcXFwiaXMtdmlzaWJsZVxcXCIsbGl2ZVZhbGlkYXRlOiExLHBhdHRlcm5zOnthbHBoYTovXlthLXpBLVpdKyQvLGFscGhhX251bWVyaWM6L15bYS16QS1aMC05XSskLyxpbnRlZ2VyOi9eWy0rXT9cXFxcZCskLyxudW1iZXI6L15bLStdP1xcXFxkKig/OltcXFxcLlxcXFwsXVxcXFxkKyk/JC8sY2FyZDovXig/OjRbMC05XXsxMn0oPzpbMC05XXszfSk/fDVbMS01XVswLTldezE0fXw2KD86MDExfDVbMC05XVswLTldKVswLTldezEyfXwzWzQ3XVswLTldezEzfXwzKD86MFswLTVdfFs2OF1bMC05XSlbMC05XXsxMX18KD86MjEzMXwxODAwfDM1XFxcXGR7M30pXFxcXGR7MTF9KSQvLGN2djovXihbMC05XSl7Myw0fSQvLGVtYWlsOi9eW2EtekEtWjAtOS4hIyQlJicqK1xcXFwvPT9eX2B7fH1+LV0rQFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcXFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSskLyx1cmw6L14oaHR0cHM/fGZ0cHxmaWxlfHNzaCk6XFxcXC9cXFxcLygoKChbYS16QS1aXXxcXFxcZHwtfFxcXFwufF98fnxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSl8KCVbXFxcXGRhLWZdezJ9KXxbIVxcXFwkJidcXFxcKFxcXFwpXFxcXCpcXFxcKyw7PV18OikqQCk/KCgoXFxcXGR8WzEtOV1cXFxcZHwxXFxcXGRcXFxcZHwyWzAtNF1cXFxcZHwyNVswLTVdKVxcXFwuKFxcXFxkfFsxLTldXFxcXGR8MVxcXFxkXFxcXGR8MlswLTRdXFxcXGR8MjVbMC01XSlcXFxcLihcXFxcZHxbMS05XVxcXFxkfDFcXFxcZFxcXFxkfDJbMC00XVxcXFxkfDI1WzAtNV0pXFxcXC4oXFxcXGR8WzEtOV1cXFxcZHwxXFxcXGRcXFxcZHwyWzAtNF1cXFxcZHwyNVswLTVdKSl8KCgoW2EtekEtWl18XFxcXGR8W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pfCgoW2EtekEtWl18XFxcXGR8W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pKFthLXpBLVpdfFxcXFxkfC18XFxcXC58X3x+fFtcXFxcdTAwQTAtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdKSooW2EtekEtWl18XFxcXGR8W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pKSlcXFxcLikrKChbYS16QS1aXXxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSl8KChbYS16QS1aXXxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSkoW2EtekEtWl18XFxcXGR8LXxcXFxcLnxffH58W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pKihbYS16QS1aXXxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSkpKVxcXFwuPykoOlxcXFxkKik/KShcXFxcLygoKFthLXpBLVpdfFxcXFxkfC18XFxcXC58X3x+fFtcXFxcdTAwQTAtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdKXwoJVtcXFxcZGEtZl17Mn0pfFshXFxcXCQmJ1xcXFwoXFxcXClcXFxcKlxcXFwrLDs9XXw6fEApKyhcXFxcLygoW2EtekEtWl18XFxcXGR8LXxcXFxcLnxffH58W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pfCglW1xcXFxkYS1mXXsyfSl8WyFcXFxcJCYnXFxcXChcXFxcKVxcXFwqXFxcXCssOz1dfDp8QCkqKSopPyk/KFxcXFw/KCgoW2EtekEtWl18XFxcXGR8LXxcXFxcLnxffH58W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pfCglW1xcXFxkYS1mXXsyfSl8WyFcXFxcJCYnXFxcXChcXFxcKVxcXFwqXFxcXCssOz1dfDp8QCl8W1xcXFx1RTAwMC1cXFxcdUY4RkZdfFxcXFwvfFxcXFw/KSopPyhcXFxcIygoKFthLXpBLVpdfFxcXFxkfC18XFxcXC58X3x+fFtcXFxcdTAwQTAtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdKXwoJVtcXFxcZGEtZl17Mn0pfFshXFxcXCQmJ1xcXFwoXFxcXClcXFxcKlxcXFwrLDs9XXw6fEApfFxcXFwvfFxcXFw/KSopPyQvLGRvbWFpbjovXihbYS16QS1aMC05XShbYS16QS1aMC05XFxcXC1dezAsNjF9W2EtekEtWjAtOV0pP1xcXFwuKStbYS16QS1aXXsyLDh9JC8sZGF0ZXRpbWU6L14oWzAtMl1bMC05XXszfSlcXFxcLShbMC0xXVswLTldKVxcXFwtKFswLTNdWzAtOV0pVChbMC01XVswLTldKVxcXFw6KFswLTVdWzAtOV0pXFxcXDooWzAtNV1bMC05XSkoWnwoW1xcXFwtXFxcXCtdKFswLTFdWzAtOV0pXFxcXDowMCkpJC8sZGF0ZTovKD86MTl8MjApWzAtOV17Mn0tKD86KD86MFsxLTldfDFbMC0yXSktKD86MFsxLTldfDFbMC05XXwyWzAtOV0pfCg/Oig/ITAyKSg/OjBbMS05XXwxWzAtMl0pLSg/OjMwKSl8KD86KD86MFsxMzU3OF18MVswMl0pLTMxKSkkLyx0aW1lOi9eKDBbMC05XXwxWzAtOV18MlswLTNdKSg6WzAtNV1bMC05XSl7Mn0kLyxkYXRlSVNPOi9eXFxcXGR7NH1bXFxcXC9cXFxcLV1cXFxcZHsxLDJ9W1xcXFwvXFxcXC1dXFxcXGR7MSwyfSQvLG1vbnRoX2RheV95ZWFyOi9eKDBbMS05XXwxWzAxMl0pWy0gXFxcXC8uXSgwWzEtOV18WzEyXVswLTldfDNbMDFdKVstIFxcXFwvLl1cXFxcZHs0fSQvLGRheV9tb250aF95ZWFyOi9eKDBbMS05XXxbMTJdWzAtOV18M1swMV0pWy0gXFxcXC8uXSgwWzEtOV18MVswMTJdKVstIFxcXFwvLl1cXFxcZHs0fSQvLGNvbG9yOi9eIz8oW2EtZkEtRjAtOV17Nn18W2EtZkEtRjAtOV17M30pJC99LHZhbGlkYXRvcnM6e2VxdWFsVG86ZnVuY3Rpb24gZXF1YWxUbyhlLGksbil7cmV0dXJuIHQoXFxcIiNcXFwiK2UuYXR0cihcXFwiZGF0YS1lcXVhbHRvXFxcIikpLnZhbCgpPT09ZS52YWwoKTt9fX0sRm91bmRhdGlvbi5wbHVnaW4oZSxcXFwiQWJpZGVcXFwiKTt9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcXFwidmFsdWVcXFwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pO319cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZTt9O30oKTshZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGksbil7X2NsYXNzQ2FsbENoZWNrKHRoaXMsZSksdGhpcy4kZWxlbWVudD1pLHRoaXMub3B0aW9ucz10LmV4dGVuZCh7fSxlLmRlZmF1bHRzLHRoaXMuJGVsZW1lbnQuZGF0YSgpLG4pLHRoaXMuX2luaXQoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXFxcIkFjY29yZGlvblxcXCIpLEZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIoXFxcIkFjY29yZGlvblxcXCIse0VOVEVSOlxcXCJ0b2dnbGVcXFwiLFNQQUNFOlxcXCJ0b2dnbGVcXFwiLEFSUk9XX0RPV046XFxcIm5leHRcXFwiLEFSUk9XX1VQOlxcXCJwcmV2aW91c1xcXCJ9KTt9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLFt7a2V5OlxcXCJfaW5pdFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLiRlbGVtZW50LmF0dHIoXFxcInJvbGVcXFwiLFxcXCJ0YWJsaXN0XFxcIiksdGhpcy4kdGFicz10aGlzLiRlbGVtZW50LmNoaWxkcmVuKFxcXCJsaSwgW2RhdGEtYWNjb3JkaW9uLWl0ZW1dXFxcIiksdGhpcy4kdGFicy5lYWNoKGZ1bmN0aW9uKGUsaSl7dmFyIG49dChpKSxzPW4uY2hpbGRyZW4oXFxcIltkYXRhLXRhYi1jb250ZW50XVxcXCIpLG89c1swXS5pZHx8Rm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LFxcXCJhY2NvcmRpb25cXFwiKSxhPWkuaWR8fG8rXFxcIi1sYWJlbFxcXCI7bi5maW5kKFxcXCJhOmZpcnN0XFxcIikuYXR0cih7XFxcImFyaWEtY29udHJvbHNcXFwiOm8scm9sZTpcXFwidGFiXFxcIixpZDphLFxcXCJhcmlhLWV4cGFuZGVkXFxcIjohMSxcXFwiYXJpYS1zZWxlY3RlZFxcXCI6ITF9KSxzLmF0dHIoe3JvbGU6XFxcInRhYnBhbmVsXFxcIixcXFwiYXJpYS1sYWJlbGxlZGJ5XFxcIjphLFxcXCJhcmlhLWhpZGRlblxcXCI6ITAsaWQ6b30pO30pO3ZhciBlPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiLmlzLWFjdGl2ZVxcXCIpLmNoaWxkcmVuKFxcXCJbZGF0YS10YWItY29udGVudF1cXFwiKTtlLmxlbmd0aCYmdGhpcy5kb3duKGUsITApLHRoaXMuX2V2ZW50cygpO319LHtrZXk6XFxcIl9ldmVudHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpczt0aGlzLiR0YWJzLmVhY2goZnVuY3Rpb24oKXt2YXIgaT10KHRoaXMpLG49aS5jaGlsZHJlbihcXFwiW2RhdGEtdGFiLWNvbnRlbnRdXFxcIik7bi5sZW5ndGgmJmkuY2hpbGRyZW4oXFxcImFcXFwiKS5vZmYoXFxcImNsaWNrLnpmLmFjY29yZGlvbiBrZXlkb3duLnpmLmFjY29yZGlvblxcXCIpLm9uKFxcXCJjbGljay56Zi5hY2NvcmRpb25cXFwiLGZ1bmN0aW9uKHQpe3QucHJldmVudERlZmF1bHQoKSxpLmhhc0NsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKT8oZS5vcHRpb25zLmFsbG93QWxsQ2xvc2VkfHxpLnNpYmxpbmdzKCkuaGFzQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpKSYmZS51cChuKTplLmRvd24obik7fSkub24oXFxcImtleWRvd24uemYuYWNjb3JkaW9uXFxcIixmdW5jdGlvbih0KXtGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleSh0LFxcXCJBY2NvcmRpb25cXFwiLHt0b2dnbGU6ZnVuY3Rpb24gdG9nZ2xlKCl7ZS50b2dnbGUobik7fSxuZXh0OmZ1bmN0aW9uIG5leHQoKXt2YXIgdD1pLm5leHQoKS5maW5kKFxcXCJhXFxcIikuZm9jdXMoKTtlLm9wdGlvbnMubXVsdGlFeHBhbmR8fHQudHJpZ2dlcihcXFwiY2xpY2suemYuYWNjb3JkaW9uXFxcIik7fSxwcmV2aW91czpmdW5jdGlvbiBwcmV2aW91cygpe3ZhciB0PWkucHJldigpLmZpbmQoXFxcImFcXFwiKS5mb2N1cygpO2Uub3B0aW9ucy5tdWx0aUV4cGFuZHx8dC50cmlnZ2VyKFxcXCJjbGljay56Zi5hY2NvcmRpb25cXFwiKTt9LGhhbmRsZWQ6ZnVuY3Rpb24gaGFuZGxlZCgpe3QucHJldmVudERlZmF1bHQoKSx0LnN0b3BQcm9wYWdhdGlvbigpO319KTt9KTt9KTt9fSx7a2V5OlxcXCJ0b2dnbGVcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe2lmKHQucGFyZW50KCkuaGFzQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpKXtpZighdGhpcy5vcHRpb25zLmFsbG93QWxsQ2xvc2VkJiYhdC5wYXJlbnQoKS5zaWJsaW5ncygpLmhhc0NsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKSlyZXR1cm47dGhpcy51cCh0KTt9ZWxzZSB0aGlzLmRvd24odCk7fX0se2tleTpcXFwiZG93blxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSxpKXt2YXIgbj10aGlzO2lmKCF0aGlzLm9wdGlvbnMubXVsdGlFeHBhbmQmJiFpKXt2YXIgcz10aGlzLiRlbGVtZW50LmNoaWxkcmVuKFxcXCIuaXMtYWN0aXZlXFxcIikuY2hpbGRyZW4oXFxcIltkYXRhLXRhYi1jb250ZW50XVxcXCIpO3MubGVuZ3RoJiZ0aGlzLnVwKHMpO31lLmF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIiwhMSkucGFyZW50KFxcXCJbZGF0YS10YWItY29udGVudF1cXFwiKS5hZGRCYWNrKCkucGFyZW50KCkuYWRkQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpLGUuc2xpZGVEb3duKHRoaXMub3B0aW9ucy5zbGlkZVNwZWVkLGZ1bmN0aW9uKCl7bi4kZWxlbWVudC50cmlnZ2VyKFxcXCJkb3duLnpmLmFjY29yZGlvblxcXCIsW2VdKTt9KSx0KFxcXCIjXFxcIitlLmF0dHIoXFxcImFyaWEtbGFiZWxsZWRieVxcXCIpKS5hdHRyKHtcXFwiYXJpYS1leHBhbmRlZFxcXCI6ITAsXFxcImFyaWEtc2VsZWN0ZWRcXFwiOiEwfSk7fX0se2tleTpcXFwidXBcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKGUpe3ZhciBpPWUucGFyZW50KCkuc2libGluZ3MoKSxuPXRoaXMscz10aGlzLm9wdGlvbnMubXVsdGlFeHBhbmQ/aS5oYXNDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIik6ZS5wYXJlbnQoKS5oYXNDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIik7KHRoaXMub3B0aW9ucy5hbGxvd0FsbENsb3NlZHx8cykmJihlLnNsaWRlVXAobi5vcHRpb25zLnNsaWRlU3BlZWQsZnVuY3Rpb24oKXtuLiRlbGVtZW50LnRyaWdnZXIoXFxcInVwLnpmLmFjY29yZGlvblxcXCIsW2VdKTt9KSxlLmF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIiwhMCkucGFyZW50KCkucmVtb3ZlQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpLHQoXFxcIiNcXFwiK2UuYXR0cihcXFwiYXJpYS1sYWJlbGxlZGJ5XFxcIikpLmF0dHIoe1xcXCJhcmlhLWV4cGFuZGVkXFxcIjohMSxcXFwiYXJpYS1zZWxlY3RlZFxcXCI6ITF9KSk7fX0se2tleTpcXFwiZGVzdHJveVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLiRlbGVtZW50LmZpbmQoXFxcIltkYXRhLXRhYi1jb250ZW50XVxcXCIpLnN0b3AoITApLnNsaWRlVXAoMCkuY3NzKFxcXCJkaXNwbGF5XFxcIixcXFwiXFxcIiksdGhpcy4kZWxlbWVudC5maW5kKFxcXCJhXFxcIikub2ZmKFxcXCIuemYuYWNjb3JkaW9uXFxcIiksRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSksZTt9KCk7ZS5kZWZhdWx0cz17c2xpZGVTcGVlZDoyNTAsbXVsdGlFeHBhbmQ6ITEsYWxsb3dBbGxDbG9zZWQ6ITF9LEZvdW5kYXRpb24ucGx1Z2luKGUsXFxcIkFjY29yZGlvblxcXCIpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbj1lW2ldO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFxcXCJ2YWx1ZVxcXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbik7fX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlO307fSgpOyFmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PWksdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGUuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksbiksRm91bmRhdGlvbi5OZXN0LkZlYXRoZXIodGhpcy4kZWxlbWVudCxcXFwiYWNjb3JkaW9uXFxcIiksdGhpcy5faW5pdCgpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcXFwiQWNjb3JkaW9uTWVudVxcXCIpLEZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIoXFxcIkFjY29yZGlvbk1lbnVcXFwiLHtFTlRFUjpcXFwidG9nZ2xlXFxcIixTUEFDRTpcXFwidG9nZ2xlXFxcIixBUlJPV19SSUdIVDpcXFwib3BlblxcXCIsQVJST1dfVVA6XFxcInVwXFxcIixBUlJPV19ET1dOOlxcXCJkb3duXFxcIixBUlJPV19MRUZUOlxcXCJjbG9zZVxcXCIsRVNDQVBFOlxcXCJjbG9zZUFsbFxcXCIsVEFCOlxcXCJkb3duXFxcIixTSElGVF9UQUI6XFxcInVwXFxcIn0pO31yZXR1cm4gX2NyZWF0ZUNsYXNzKGUsW3trZXk6XFxcIl9pbml0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuJGVsZW1lbnQuZmluZChcXFwiW2RhdGEtc3VibWVudV1cXFwiKS5ub3QoXFxcIi5pcy1hY3RpdmVcXFwiKS5zbGlkZVVwKDApLHRoaXMuJGVsZW1lbnQuYXR0cih7cm9sZTpcXFwidGFibGlzdFxcXCIsXFxcImFyaWEtbXVsdGlzZWxlY3RhYmxlXFxcIjp0aGlzLm9wdGlvbnMubXVsdGlPcGVufSksdGhpcy4kbWVudUxpbmtzPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiLmlzLWFjY29yZGlvbi1zdWJtZW51LXBhcmVudFxcXCIpLHRoaXMuJG1lbnVMaW5rcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5pZHx8Rm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LFxcXCJhY2MtbWVudS1saW5rXFxcIiksaT10KHRoaXMpLG49aS5jaGlsZHJlbihcXFwiW2RhdGEtc3VibWVudV1cXFwiKSxzPW5bMF0uaWR8fEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNixcXFwiYWNjLW1lbnVcXFwiKSxvPW4uaGFzQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpO2kuYXR0cih7XFxcImFyaWEtY29udHJvbHNcXFwiOnMsXFxcImFyaWEtZXhwYW5kZWRcXFwiOm8scm9sZTpcXFwidGFiXFxcIixpZDplfSksbi5hdHRyKHtcXFwiYXJpYS1sYWJlbGxlZGJ5XFxcIjplLFxcXCJhcmlhLWhpZGRlblxcXCI6IW8scm9sZTpcXFwidGFicGFuZWxcXFwiLGlkOnN9KTt9KTt2YXIgZT10aGlzLiRlbGVtZW50LmZpbmQoXFxcIi5pcy1hY3RpdmVcXFwiKTtpZihlLmxlbmd0aCl7dmFyIGk9dGhpcztlLmVhY2goZnVuY3Rpb24oKXtpLmRvd24odCh0aGlzKSk7fSk7fXRoaXMuX2V2ZW50cygpO319LHtrZXk6XFxcIl9ldmVudHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpczt0aGlzLiRlbGVtZW50LmZpbmQoXFxcImxpXFxcIikuZWFjaChmdW5jdGlvbigpe3ZhciBpPXQodGhpcykuY2hpbGRyZW4oXFxcIltkYXRhLXN1Ym1lbnVdXFxcIik7aS5sZW5ndGgmJnQodGhpcykuY2hpbGRyZW4oXFxcImFcXFwiKS5vZmYoXFxcImNsaWNrLnpmLmFjY29yZGlvbk1lbnVcXFwiKS5vbihcXFwiY2xpY2suemYuYWNjb3JkaW9uTWVudVxcXCIsZnVuY3Rpb24odCl7dC5wcmV2ZW50RGVmYXVsdCgpLGUudG9nZ2xlKGkpO30pO30pLm9uKFxcXCJrZXlkb3duLnpmLmFjY29yZGlvbm1lbnVcXFwiLGZ1bmN0aW9uKGkpe3ZhciBuLHMsbz10KHRoaXMpLGE9by5wYXJlbnQoXFxcInVsXFxcIikuY2hpbGRyZW4oXFxcImxpXFxcIikscj1vLmNoaWxkcmVuKFxcXCJbZGF0YS1zdWJtZW51XVxcXCIpO2EuZWFjaChmdW5jdGlvbihlKXtyZXR1cm4gdCh0aGlzKS5pcyhvKT8obj1hLmVxKE1hdGgubWF4KDAsZS0xKSkuZmluZChcXFwiYVxcXCIpLmZpcnN0KCkscz1hLmVxKE1hdGgubWluKGUrMSxhLmxlbmd0aC0xKSkuZmluZChcXFwiYVxcXCIpLmZpcnN0KCksdCh0aGlzKS5jaGlsZHJlbihcXFwiW2RhdGEtc3VibWVudV06dmlzaWJsZVxcXCIpLmxlbmd0aCYmKHM9by5maW5kKFxcXCJsaTpmaXJzdC1jaGlsZFxcXCIpLmZpbmQoXFxcImFcXFwiKS5maXJzdCgpKSx0KHRoaXMpLmlzKFxcXCI6Zmlyc3QtY2hpbGRcXFwiKT9uPW8ucGFyZW50cyhcXFwibGlcXFwiKS5maXJzdCgpLmZpbmQoXFxcImFcXFwiKS5maXJzdCgpOm4uY2hpbGRyZW4oXFxcIltkYXRhLXN1Ym1lbnVdOnZpc2libGVcXFwiKS5sZW5ndGgmJihuPW4uZmluZChcXFwibGk6bGFzdC1jaGlsZFxcXCIpLmZpbmQoXFxcImFcXFwiKS5maXJzdCgpKSx2b2lkKHQodGhpcykuaXMoXFxcIjpsYXN0LWNoaWxkXFxcIikmJihzPW8ucGFyZW50cyhcXFwibGlcXFwiKS5maXJzdCgpLm5leHQoXFxcImxpXFxcIikuZmluZChcXFwiYVxcXCIpLmZpcnN0KCkpKSk6dm9pZCAwO30pLEZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KGksXFxcIkFjY29yZGlvbk1lbnVcXFwiLHtvcGVuOmZ1bmN0aW9uIG9wZW4oKXtyLmlzKFxcXCI6aGlkZGVuXFxcIikmJihlLmRvd24ociksci5maW5kKFxcXCJsaVxcXCIpLmZpcnN0KCkuZmluZChcXFwiYVxcXCIpLmZpcnN0KCkuZm9jdXMoKSk7fSxjbG9zZTpmdW5jdGlvbiBjbG9zZSgpe3IubGVuZ3RoJiYhci5pcyhcXFwiOmhpZGRlblxcXCIpP2UudXAocik6by5wYXJlbnQoXFxcIltkYXRhLXN1Ym1lbnVdXFxcIikubGVuZ3RoJiYoZS51cChvLnBhcmVudChcXFwiW2RhdGEtc3VibWVudV1cXFwiKSksby5wYXJlbnRzKFxcXCJsaVxcXCIpLmZpcnN0KCkuZmluZChcXFwiYVxcXCIpLmZpcnN0KCkuZm9jdXMoKSk7fSx1cDpmdW5jdGlvbiB1cCgpe3JldHVybiBuLmF0dHIoXFxcInRhYmluZGV4XFxcIiwtMSkuZm9jdXMoKSwhMDt9LGRvd246ZnVuY3Rpb24gZG93bigpe3JldHVybiBzLmF0dHIoXFxcInRhYmluZGV4XFxcIiwtMSkuZm9jdXMoKSwhMDt9LHRvZ2dsZTpmdW5jdGlvbiB0b2dnbGUoKXtvLmNoaWxkcmVuKFxcXCJbZGF0YS1zdWJtZW51XVxcXCIpLmxlbmd0aCYmZS50b2dnbGUoby5jaGlsZHJlbihcXFwiW2RhdGEtc3VibWVudV1cXFwiKSk7fSxjbG9zZUFsbDpmdW5jdGlvbiBjbG9zZUFsbCgpe2UuaGlkZUFsbCgpO30saGFuZGxlZDpmdW5jdGlvbiBoYW5kbGVkKHQpe3QmJmkucHJldmVudERlZmF1bHQoKSxpLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO319KTt9KTt9fSx7a2V5OlxcXCJoaWRlQWxsXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuJGVsZW1lbnQuZmluZChcXFwiW2RhdGEtc3VibWVudV1cXFwiKS5zbGlkZVVwKHRoaXMub3B0aW9ucy5zbGlkZVNwZWVkKTt9fSx7a2V5OlxcXCJ0b2dnbGVcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3QuaXMoXFxcIjphbmltYXRlZFxcXCIpfHwodC5pcyhcXFwiOmhpZGRlblxcXCIpP3RoaXMuZG93bih0KTp0aGlzLnVwKHQpKTt9fSx7a2V5OlxcXCJkb3duXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt2YXIgZT10aGlzO3RoaXMub3B0aW9ucy5tdWx0aU9wZW58fHRoaXMudXAodGhpcy4kZWxlbWVudC5maW5kKFxcXCIuaXMtYWN0aXZlXFxcIikubm90KHQucGFyZW50c1VudGlsKHRoaXMuJGVsZW1lbnQpLmFkZCh0KSkpLHQuYWRkQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpLmF0dHIoe1xcXCJhcmlhLWhpZGRlblxcXCI6ITF9KS5wYXJlbnQoXFxcIi5pcy1hY2NvcmRpb24tc3VibWVudS1wYXJlbnRcXFwiKS5hdHRyKHtcXFwiYXJpYS1leHBhbmRlZFxcXCI6ITB9KSx0LnNsaWRlRG93bihlLm9wdGlvbnMuc2xpZGVTcGVlZCxmdW5jdGlvbigpe2UuJGVsZW1lbnQudHJpZ2dlcihcXFwiZG93bi56Zi5hY2NvcmRpb25NZW51XFxcIixbdF0pO30pO319LHtrZXk6XFxcInVwXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt2YXIgZT10aGlzO3Quc2xpZGVVcChlLm9wdGlvbnMuc2xpZGVTcGVlZCxmdW5jdGlvbigpe2UuJGVsZW1lbnQudHJpZ2dlcihcXFwidXAuemYuYWNjb3JkaW9uTWVudVxcXCIsW3RdKTt9KTt2YXIgaT10LmZpbmQoXFxcIltkYXRhLXN1Ym1lbnVdXFxcIikuc2xpZGVVcCgwKS5hZGRCYWNrKCkuYXR0cihcXFwiYXJpYS1oaWRkZW5cXFwiLCEwKTtpLnBhcmVudChcXFwiLmlzLWFjY29yZGlvbi1zdWJtZW51LXBhcmVudFxcXCIpLmF0dHIoXFxcImFyaWEtZXhwYW5kZWRcXFwiLCExKTt9fSx7a2V5OlxcXCJkZXN0cm95XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuJGVsZW1lbnQuZmluZChcXFwiW2RhdGEtc3VibWVudV1cXFwiKS5zbGlkZURvd24oMCkuY3NzKFxcXCJkaXNwbGF5XFxcIixcXFwiXFxcIiksdGhpcy4kZWxlbWVudC5maW5kKFxcXCJhXFxcIikub2ZmKFxcXCJjbGljay56Zi5hY2NvcmRpb25NZW51XFxcIiksRm91bmRhdGlvbi5OZXN0LkJ1cm4odGhpcy4kZWxlbWVudCxcXFwiYWNjb3JkaW9uXFxcIiksRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSksZTt9KCk7ZS5kZWZhdWx0cz17c2xpZGVTcGVlZDoyNTAsbXVsdGlPcGVuOiEwfSxGb3VuZGF0aW9uLnBsdWdpbihlLFxcXCJBY2NvcmRpb25NZW51XFxcIik7fShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXFxcInZhbHVlXFxcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLmtleSxuKTt9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGU7fTt9KCk7IWZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShpLG4pe19jbGFzc0NhbGxDaGVjayh0aGlzLGUpLHRoaXMuJGVsZW1lbnQ9aSx0aGlzLm9wdGlvbnM9dC5leHRlbmQoe30sZS5kZWZhdWx0cyx0aGlzLiRlbGVtZW50LmRhdGEoKSxuKSxGb3VuZGF0aW9uLk5lc3QuRmVhdGhlcih0aGlzLiRlbGVtZW50LFxcXCJkcmlsbGRvd25cXFwiKSx0aGlzLl9pbml0KCksRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLFxcXCJEcmlsbGRvd25cXFwiKSxGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKFxcXCJEcmlsbGRvd25cXFwiLHtFTlRFUjpcXFwib3BlblxcXCIsU1BBQ0U6XFxcIm9wZW5cXFwiLEFSUk9XX1JJR0hUOlxcXCJuZXh0XFxcIixBUlJPV19VUDpcXFwidXBcXFwiLEFSUk9XX0RPV046XFxcImRvd25cXFwiLEFSUk9XX0xFRlQ6XFxcInByZXZpb3VzXFxcIixFU0NBUEU6XFxcImNsb3NlXFxcIixUQUI6XFxcImRvd25cXFwiLFNISUZUX1RBQjpcXFwidXBcXFwifSk7fXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcXFwiX2luaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy4kc3VibWVudUFuY2hvcnM9dGhpcy4kZWxlbWVudC5maW5kKFxcXCJsaS5pcy1kcmlsbGRvd24tc3VibWVudS1wYXJlbnRcXFwiKS5jaGlsZHJlbihcXFwiYVxcXCIpLHRoaXMuJHN1Ym1lbnVzPXRoaXMuJHN1Ym1lbnVBbmNob3JzLnBhcmVudChcXFwibGlcXFwiKS5jaGlsZHJlbihcXFwiW2RhdGEtc3VibWVudV1cXFwiKSx0aGlzLiRtZW51SXRlbXM9dGhpcy4kZWxlbWVudC5maW5kKFxcXCJsaVxcXCIpLm5vdChcXFwiLmpzLWRyaWxsZG93bi1iYWNrXFxcIikuYXR0cihcXFwicm9sZVxcXCIsXFxcIm1lbnVpdGVtXFxcIikuZmluZChcXFwiYVxcXCIpLHRoaXMuX3ByZXBhcmVNZW51KCksdGhpcy5fa2V5Ym9hcmRFdmVudHMoKTt9fSx7a2V5OlxcXCJfcHJlcGFyZU1lbnVcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpczt0aGlzLiRzdWJtZW51QW5jaG9ycy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGk9dCh0aGlzKSxuPWkucGFyZW50KCk7ZS5vcHRpb25zLnBhcmVudExpbmsmJmkuY2xvbmUoKS5wcmVwZW5kVG8obi5jaGlsZHJlbihcXFwiW2RhdGEtc3VibWVudV1cXFwiKSkud3JhcCgnPGxpIGNsYXNzPVxcXCJpcy1zdWJtZW51LXBhcmVudC1pdGVtIGlzLXN1Ym1lbnUtaXRlbSBpcy1kcmlsbGRvd24tc3VibWVudS1pdGVtXFxcIiByb2xlPVxcXCJtZW51LWl0ZW1cXFwiPjwvbGk+JyksaS5kYXRhKFxcXCJzYXZlZEhyZWZcXFwiLGkuYXR0cihcXFwiaHJlZlxcXCIpKS5yZW1vdmVBdHRyKFxcXCJocmVmXFxcIiksaS5jaGlsZHJlbihcXFwiW2RhdGEtc3VibWVudV1cXFwiKS5hdHRyKHtcXFwiYXJpYS1oaWRkZW5cXFwiOiEwLHRhYmluZGV4OjAscm9sZTpcXFwibWVudVxcXCJ9KSxlLl9ldmVudHMoaSk7fSksdGhpcy4kc3VibWVudXMuZWFjaChmdW5jdGlvbigpe3ZhciBpPXQodGhpcyksbj1pLmZpbmQoXFxcIi5qcy1kcmlsbGRvd24tYmFja1xcXCIpO24ubGVuZ3RofHxpLnByZXBlbmQoZS5vcHRpb25zLmJhY2tCdXR0b24pLGUuX2JhY2soaSk7fSksdGhpcy4kZWxlbWVudC5wYXJlbnQoKS5oYXNDbGFzcyhcXFwiaXMtZHJpbGxkb3duXFxcIil8fCh0aGlzLiR3cmFwcGVyPXQodGhpcy5vcHRpb25zLndyYXBwZXIpLmFkZENsYXNzKFxcXCJpcy1kcmlsbGRvd25cXFwiKSx0aGlzLiR3cmFwcGVyPXRoaXMuJGVsZW1lbnQud3JhcCh0aGlzLiR3cmFwcGVyKS5wYXJlbnQoKS5jc3ModGhpcy5fZ2V0TWF4RGltcygpKSk7fX0se2tleTpcXFwiX2V2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSl7dmFyIGk9dGhpcztlLm9mZihcXFwiY2xpY2suemYuZHJpbGxkb3duXFxcIikub24oXFxcImNsaWNrLnpmLmRyaWxsZG93blxcXCIsZnVuY3Rpb24obil7aWYodChuLnRhcmdldCkucGFyZW50c1VudGlsKFxcXCJ1bFxcXCIsXFxcImxpXFxcIikuaGFzQ2xhc3MoXFxcImlzLWRyaWxsZG93bi1zdWJtZW51LXBhcmVudFxcXCIpJiYobi5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSxuLnByZXZlbnREZWZhdWx0KCkpLGkuX3Nob3coZS5wYXJlbnQoXFxcImxpXFxcIikpLGkub3B0aW9ucy5jbG9zZU9uQ2xpY2spe3ZhciBzPXQoXFxcImJvZHlcXFwiKTtzLm9mZihcXFwiLnpmLmRyaWxsZG93blxcXCIpLm9uKFxcXCJjbGljay56Zi5kcmlsbGRvd25cXFwiLGZ1bmN0aW9uKGUpe2UudGFyZ2V0PT09aS4kZWxlbWVudFswXXx8dC5jb250YWlucyhpLiRlbGVtZW50WzBdLGUudGFyZ2V0KXx8KGUucHJldmVudERlZmF1bHQoKSxpLl9oaWRlQWxsKCkscy5vZmYoXFxcIi56Zi5kcmlsbGRvd25cXFwiKSk7fSk7fX0pO319LHtrZXk6XFxcIl9rZXlib2FyZEV2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzO3RoaXMuJG1lbnVJdGVtcy5hZGQodGhpcy4kZWxlbWVudC5maW5kKFxcXCIuanMtZHJpbGxkb3duLWJhY2sgPiBhXFxcIikpLm9uKFxcXCJrZXlkb3duLnpmLmRyaWxsZG93blxcXCIsZnVuY3Rpb24oaSl7dmFyIG4scyxvPXQodGhpcyksYT1vLnBhcmVudChcXFwibGlcXFwiKS5wYXJlbnQoXFxcInVsXFxcIikuY2hpbGRyZW4oXFxcImxpXFxcIikuY2hpbGRyZW4oXFxcImFcXFwiKTthLmVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIHQodGhpcykuaXMobyk/KG49YS5lcShNYXRoLm1heCgwLGUtMSkpLHZvaWQocz1hLmVxKE1hdGgubWluKGUrMSxhLmxlbmd0aC0xKSkpKTp2b2lkIDA7fSksRm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoaSxcXFwiRHJpbGxkb3duXFxcIix7bmV4dDpmdW5jdGlvbiBuZXh0KCl7cmV0dXJuIG8uaXMoZS4kc3VibWVudUFuY2hvcnMpPyhlLl9zaG93KG8ucGFyZW50KFxcXCJsaVxcXCIpKSxvLnBhcmVudChcXFwibGlcXFwiKS5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKG8pLGZ1bmN0aW9uKCl7by5wYXJlbnQoXFxcImxpXFxcIikuZmluZChcXFwidWwgbGkgYVxcXCIpLmZpbHRlcihlLiRtZW51SXRlbXMpLmZpcnN0KCkuZm9jdXMoKTt9KSwhMCk6dm9pZCAwO30scHJldmlvdXM6ZnVuY3Rpb24gcHJldmlvdXMoKXtyZXR1cm4gZS5faGlkZShvLnBhcmVudChcXFwibGlcXFwiKS5wYXJlbnQoXFxcInVsXFxcIikpLG8ucGFyZW50KFxcXCJsaVxcXCIpLnBhcmVudChcXFwidWxcXFwiKS5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKG8pLGZ1bmN0aW9uKCl7c2V0VGltZW91dChmdW5jdGlvbigpe28ucGFyZW50KFxcXCJsaVxcXCIpLnBhcmVudChcXFwidWxcXFwiKS5wYXJlbnQoXFxcImxpXFxcIikuY2hpbGRyZW4oXFxcImFcXFwiKS5maXJzdCgpLmZvY3VzKCk7fSwxKTt9KSwhMDt9LHVwOmZ1bmN0aW9uIHVwKCl7cmV0dXJuIG4uZm9jdXMoKSwhMDt9LGRvd246ZnVuY3Rpb24gZG93bigpe3JldHVybiBzLmZvY3VzKCksITA7fSxjbG9zZTpmdW5jdGlvbiBjbG9zZSgpe2UuX2JhY2soKTt9LG9wZW46ZnVuY3Rpb24gb3Blbigpe3JldHVybiBvLmlzKGUuJG1lbnVJdGVtcyk/by5pcyhlLiRzdWJtZW51QW5jaG9ycykmJihlLl9zaG93KG8ucGFyZW50KFxcXCJsaVxcXCIpKSxvLnBhcmVudChcXFwibGlcXFwiKS5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKG8pLGZ1bmN0aW9uKCl7by5wYXJlbnQoXFxcImxpXFxcIikuZmluZChcXFwidWwgbGkgYVxcXCIpLmZpbHRlcihlLiRtZW51SXRlbXMpLmZpcnN0KCkuZm9jdXMoKTt9KSk6KGUuX2hpZGUoby5wYXJlbnQoXFxcImxpXFxcIikucGFyZW50KFxcXCJ1bFxcXCIpKSxvLnBhcmVudChcXFwibGlcXFwiKS5wYXJlbnQoXFxcInVsXFxcIikub25lKEZvdW5kYXRpb24udHJhbnNpdGlvbmVuZChvKSxmdW5jdGlvbigpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXtvLnBhcmVudChcXFwibGlcXFwiKS5wYXJlbnQoXFxcInVsXFxcIikucGFyZW50KFxcXCJsaVxcXCIpLmNoaWxkcmVuKFxcXCJhXFxcIikuZmlyc3QoKS5mb2N1cygpO30sMSk7fSkpLCEwO30saGFuZGxlZDpmdW5jdGlvbiBoYW5kbGVkKHQpe3QmJmkucHJldmVudERlZmF1bHQoKSxpLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO319KTt9KTt9fSx7a2V5OlxcXCJfaGlkZUFsbFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgdD10aGlzLiRlbGVtZW50LmZpbmQoXFxcIi5pcy1kcmlsbGRvd24tc3VibWVudS5pcy1hY3RpdmVcXFwiKS5hZGRDbGFzcyhcXFwiaXMtY2xvc2luZ1xcXCIpO3Qub25lKEZvdW5kYXRpb24udHJhbnNpdGlvbmVuZCh0KSxmdW5jdGlvbihlKXt0LnJlbW92ZUNsYXNzKFxcXCJpcy1hY3RpdmUgaXMtY2xvc2luZ1xcXCIpO30pLHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwiY2xvc2VkLnpmLmRyaWxsZG93blxcXCIpO319LHtrZXk6XFxcIl9iYWNrXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt2YXIgZT10aGlzO3Qub2ZmKFxcXCJjbGljay56Zi5kcmlsbGRvd25cXFwiKSx0LmNoaWxkcmVuKFxcXCIuanMtZHJpbGxkb3duLWJhY2tcXFwiKS5vbihcXFwiY2xpY2suemYuZHJpbGxkb3duXFxcIixmdW5jdGlvbihpKXtpLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLGUuX2hpZGUodCk7fSk7fX0se2tleTpcXFwiX21lbnVMaW5rRXZlbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciB0PXRoaXM7dGhpcy4kbWVudUl0ZW1zLm5vdChcXFwiLmlzLWRyaWxsZG93bi1zdWJtZW51LXBhcmVudFxcXCIpLm9mZihcXFwiY2xpY2suemYuZHJpbGxkb3duXFxcIikub24oXFxcImNsaWNrLnpmLmRyaWxsZG93blxcXCIsZnVuY3Rpb24oZSl7c2V0VGltZW91dChmdW5jdGlvbigpe3QuX2hpZGVBbGwoKTt9LDApO30pO319LHtrZXk6XFxcIl9zaG93XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt0LmNoaWxkcmVuKFxcXCJbZGF0YS1zdWJtZW51XVxcXCIpLmFkZENsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKSx0aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcIm9wZW4uemYuZHJpbGxkb3duXFxcIixbdF0pO319LHtrZXk6XFxcIl9oaWRlXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt0LmFkZENsYXNzKFxcXCJpcy1jbG9zaW5nXFxcIikub25lKEZvdW5kYXRpb24udHJhbnNpdGlvbmVuZCh0KSxmdW5jdGlvbigpe3QucmVtb3ZlQ2xhc3MoXFxcImlzLWFjdGl2ZSBpcy1jbG9zaW5nXFxcIiksdC5ibHVyKCk7fSksdC50cmlnZ2VyKFxcXCJoaWRlLnpmLmRyaWxsZG93blxcXCIsW3RdKTt9fSx7a2V5OlxcXCJfZ2V0TWF4RGltc1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT0wLGk9e307cmV0dXJuIHRoaXMuJHN1Ym1lbnVzLmFkZCh0aGlzLiRlbGVtZW50KS5lYWNoKGZ1bmN0aW9uKCl7dmFyIGk9dCh0aGlzKS5jaGlsZHJlbihcXFwibGlcXFwiKS5sZW5ndGg7ZT1pPmU/aTplO30pLGlbXFxcIm1pbi1oZWlnaHRcXFwiXT1lKnRoaXMuJG1lbnVJdGVtc1swXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQrXFxcInB4XFxcIixpW1xcXCJtYXgtd2lkdGhcXFwiXT10aGlzLiRlbGVtZW50WzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoK1xcXCJweFxcXCIsaTt9fSx7a2V5OlxcXCJkZXN0cm95XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuX2hpZGVBbGwoKSxGb3VuZGF0aW9uLk5lc3QuQnVybih0aGlzLiRlbGVtZW50LFxcXCJkcmlsbGRvd25cXFwiKSx0aGlzLiRlbGVtZW50LnVud3JhcCgpLmZpbmQoXFxcIi5qcy1kcmlsbGRvd24tYmFjaywgLmlzLXN1Ym1lbnUtcGFyZW50LWl0ZW1cXFwiKS5yZW1vdmUoKS5lbmQoKS5maW5kKFxcXCIuaXMtYWN0aXZlLCAuaXMtY2xvc2luZywgLmlzLWRyaWxsZG93bi1zdWJtZW51XFxcIikucmVtb3ZlQ2xhc3MoXFxcImlzLWFjdGl2ZSBpcy1jbG9zaW5nIGlzLWRyaWxsZG93bi1zdWJtZW51XFxcIikuZW5kKCkuZmluZChcXFwiW2RhdGEtc3VibWVudV1cXFwiKS5yZW1vdmVBdHRyKFxcXCJhcmlhLWhpZGRlbiB0YWJpbmRleCByb2xlXFxcIiksdGhpcy4kc3VibWVudUFuY2hvcnMuZWFjaChmdW5jdGlvbigpe3QodGhpcykub2ZmKFxcXCIuemYuZHJpbGxkb3duXFxcIik7fSksdGhpcy4kZWxlbWVudC5maW5kKFxcXCJhXFxcIikuZWFjaChmdW5jdGlvbigpe3ZhciBlPXQodGhpcyk7ZS5kYXRhKFxcXCJzYXZlZEhyZWZcXFwiKSYmZS5hdHRyKFxcXCJocmVmXFxcIixlLmRhdGEoXFxcInNhdmVkSHJlZlxcXCIpKS5yZW1vdmVEYXRhKFxcXCJzYXZlZEhyZWZcXFwiKTt9KSxGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKSxlO30oKTtlLmRlZmF1bHRzPXtiYWNrQnV0dG9uOic8bGkgY2xhc3M9XFxcImpzLWRyaWxsZG93bi1iYWNrXFxcIj48YSB0YWJpbmRleD1cXFwiMFxcXCI+QmFjazwvYT48L2xpPicsd3JhcHBlcjpcXFwiPGRpdj48L2Rpdj5cXFwiLHBhcmVudExpbms6ITEsY2xvc2VPbkNsaWNrOiExfSxGb3VuZGF0aW9uLnBsdWdpbihlLFxcXCJEcmlsbGRvd25cXFwiKTt9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcXFwidmFsdWVcXFwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pO319cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZTt9O30oKTshZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGksbil7X2NsYXNzQ2FsbENoZWNrKHRoaXMsZSksdGhpcy4kZWxlbWVudD1pLHRoaXMub3B0aW9ucz10LmV4dGVuZCh7fSxlLmRlZmF1bHRzLHRoaXMuJGVsZW1lbnQuZGF0YSgpLG4pLHRoaXMuX2luaXQoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXFxcIkRyb3Bkb3duXFxcIiksRm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcihcXFwiRHJvcGRvd25cXFwiLHtFTlRFUjpcXFwib3BlblxcXCIsU1BBQ0U6XFxcIm9wZW5cXFwiLEVTQ0FQRTpcXFwiY2xvc2VcXFwiLFRBQjpcXFwidGFiX2ZvcndhcmRcXFwiLFNISUZUX1RBQjpcXFwidGFiX2JhY2t3YXJkXFxcIn0pO31yZXR1cm4gX2NyZWF0ZUNsYXNzKGUsW3trZXk6XFxcIl9pbml0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXMuJGVsZW1lbnQuYXR0cihcXFwiaWRcXFwiKTt0aGlzLiRhbmNob3I9dCgnW2RhdGEtdG9nZ2xlPVxcXCInK2UrJ1xcXCJdJyl8fHQoJ1tkYXRhLW9wZW49XFxcIicrZSsnXFxcIl0nKSx0aGlzLiRhbmNob3IuYXR0cih7XFxcImFyaWEtY29udHJvbHNcXFwiOmUsXFxcImRhdGEtaXMtZm9jdXNcXFwiOiExLFxcXCJkYXRhLXlldGktYm94XFxcIjplLFxcXCJhcmlhLWhhc3BvcHVwXFxcIjohMCxcXFwiYXJpYS1leHBhbmRlZFxcXCI6ITF9KSx0aGlzLm9wdGlvbnMucG9zaXRpb25DbGFzcz10aGlzLmdldFBvc2l0aW9uQ2xhc3MoKSx0aGlzLmNvdW50ZXI9NCx0aGlzLnVzZWRQb3NpdGlvbnM9W10sdGhpcy4kZWxlbWVudC5hdHRyKHtcXFwiYXJpYS1oaWRkZW5cXFwiOlxcXCJ0cnVlXFxcIixcXFwiZGF0YS15ZXRpLWJveFxcXCI6ZSxcXFwiZGF0YS1yZXNpemVcXFwiOmUsXFxcImFyaWEtbGFiZWxsZWRieVxcXCI6dGhpcy4kYW5jaG9yWzBdLmlkfHxGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsXFxcImRkLWFuY2hvclxcXCIpfSksdGhpcy5fZXZlbnRzKCk7fX0se2tleTpcXFwiZ2V0UG9zaXRpb25DbGFzc1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgdD10aGlzLiRlbGVtZW50WzBdLmNsYXNzTmFtZS5tYXRjaCgvKHRvcHxsZWZ0fHJpZ2h0fGJvdHRvbSkvZyk7dD10P3RbMF06XFxcIlxcXCI7dmFyIGU9L2Zsb2F0LShcXFxcUyspXFxcXHMvLmV4ZWModGhpcy4kYW5jaG9yWzBdLmNsYXNzTmFtZSk7ZT1lP2VbMV06XFxcIlxcXCI7dmFyIGk9ZT9lK1xcXCIgXFxcIit0OnQ7cmV0dXJuIGk7fX0se2tleTpcXFwiX3JlcG9zaXRpb25cXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3RoaXMudXNlZFBvc2l0aW9ucy5wdXNoKHQ/dDpcXFwiYm90dG9tXFxcIiksIXQmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJ0b3BcXFwiKTwwP3RoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoXFxcInRvcFxcXCIpOlxcXCJ0b3BcXFwiPT09dCYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcImJvdHRvbVxcXCIpPDA/dGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh0KTpcXFwibGVmdFxcXCI9PT10JiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwicmlnaHRcXFwiKTwwP3RoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModCkuYWRkQ2xhc3MoXFxcInJpZ2h0XFxcIik6XFxcInJpZ2h0XFxcIj09PXQmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJsZWZ0XFxcIik8MD90aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHQpLmFkZENsYXNzKFxcXCJsZWZ0XFxcIik6IXQmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJ0b3BcXFwiKT4tMSYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcImxlZnRcXFwiKTwwP3RoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoXFxcImxlZnRcXFwiKTpcXFwidG9wXFxcIj09PXQmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJib3R0b21cXFwiKT4tMSYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcImxlZnRcXFwiKTwwP3RoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModCkuYWRkQ2xhc3MoXFxcImxlZnRcXFwiKTpcXFwibGVmdFxcXCI9PT10JiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwicmlnaHRcXFwiKT4tMSYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcImJvdHRvbVxcXCIpPDA/dGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh0KTpcXFwicmlnaHRcXFwiPT09dCYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcImxlZnRcXFwiKT4tMSYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcImJvdHRvbVxcXCIpPDA/dGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh0KTp0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHQpLHRoaXMuY2xhc3NDaGFuZ2VkPSEwLHRoaXMuY291bnRlci0tO319LHtrZXk6XFxcIl9zZXRQb3NpdGlvblxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXtpZihcXFwiZmFsc2VcXFwiPT09dGhpcy4kYW5jaG9yLmF0dHIoXFxcImFyaWEtZXhwYW5kZWRcXFwiKSlyZXR1cm4hMTt2YXIgdD10aGlzLmdldFBvc2l0aW9uQ2xhc3MoKSxlPUZvdW5kYXRpb24uQm94LkdldERpbWVuc2lvbnModGhpcy4kZWxlbWVudCksaT0oRm91bmRhdGlvbi5Cb3guR2V0RGltZW5zaW9ucyh0aGlzLiRhbmNob3IpLFxcXCJsZWZ0XFxcIj09PXQ/XFxcImxlZnRcXFwiOlxcXCJyaWdodFxcXCI9PT10P1xcXCJsZWZ0XFxcIjpcXFwidG9wXFxcIiksbj1cXFwidG9wXFxcIj09PWk/XFxcImhlaWdodFxcXCI6XFxcIndpZHRoXFxcIjtcXFwiaGVpZ2h0XFxcIj09PW4/dGhpcy5vcHRpb25zLnZPZmZzZXQ6dGhpcy5vcHRpb25zLmhPZmZzZXQ7aWYoZS53aWR0aD49ZS53aW5kb3dEaW1zLndpZHRofHwhdGhpcy5jb3VudGVyJiYhRm91bmRhdGlvbi5Cb3guSW1Ob3RUb3VjaGluZ1lvdSh0aGlzLiRlbGVtZW50KSlyZXR1cm4gdGhpcy4kZWxlbWVudC5vZmZzZXQoRm91bmRhdGlvbi5Cb3guR2V0T2Zmc2V0cyh0aGlzLiRlbGVtZW50LHRoaXMuJGFuY2hvcixcXFwiY2VudGVyIGJvdHRvbVxcXCIsdGhpcy5vcHRpb25zLnZPZmZzZXQsdGhpcy5vcHRpb25zLmhPZmZzZXQsITApKS5jc3Moe3dpZHRoOmUud2luZG93RGltcy53aWR0aC0yKnRoaXMub3B0aW9ucy5oT2Zmc2V0LGhlaWdodDpcXFwiYXV0b1xcXCJ9KSx0aGlzLmNsYXNzQ2hhbmdlZD0hMCwhMTtmb3IodGhpcy4kZWxlbWVudC5vZmZzZXQoRm91bmRhdGlvbi5Cb3guR2V0T2Zmc2V0cyh0aGlzLiRlbGVtZW50LHRoaXMuJGFuY2hvcix0LHRoaXMub3B0aW9ucy52T2Zmc2V0LHRoaXMub3B0aW9ucy5oT2Zmc2V0KSk7IUZvdW5kYXRpb24uQm94LkltTm90VG91Y2hpbmdZb3UodGhpcy4kZWxlbWVudCwhMSwhMCkmJnRoaXMuY291bnRlcjspe3RoaXMuX3JlcG9zaXRpb24odCksdGhpcy5fc2V0UG9zaXRpb24oKTt9fX0se2tleTpcXFwiX2V2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzO3RoaXMuJGVsZW1lbnQub24oe1xcXCJvcGVuLnpmLnRyaWdnZXJcXFwiOnRoaXMub3Blbi5iaW5kKHRoaXMpLFxcXCJjbG9zZS56Zi50cmlnZ2VyXFxcIjp0aGlzLmNsb3NlLmJpbmQodGhpcyksXFxcInRvZ2dsZS56Zi50cmlnZ2VyXFxcIjp0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpLFxcXCJyZXNpemVtZS56Zi50cmlnZ2VyXFxcIjp0aGlzLl9zZXRQb3NpdGlvbi5iaW5kKHRoaXMpfSksdGhpcy5vcHRpb25zLmhvdmVyJiYodGhpcy4kYW5jaG9yLm9mZihcXFwibW91c2VlbnRlci56Zi5kcm9wZG93biBtb3VzZWxlYXZlLnpmLmRyb3Bkb3duXFxcIikub24oXFxcIm1vdXNlZW50ZXIuemYuZHJvcGRvd25cXFwiLGZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KGUudGltZW91dCksZS50aW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXtlLm9wZW4oKSxlLiRhbmNob3IuZGF0YShcXFwiaG92ZXJcXFwiLCEwKTt9LGUub3B0aW9ucy5ob3ZlckRlbGF5KTt9KS5vbihcXFwibW91c2VsZWF2ZS56Zi5kcm9wZG93blxcXCIsZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQoZS50aW1lb3V0KSxlLnRpbWVvdXQ9c2V0VGltZW91dChmdW5jdGlvbigpe2UuY2xvc2UoKSxlLiRhbmNob3IuZGF0YShcXFwiaG92ZXJcXFwiLCExKTt9LGUub3B0aW9ucy5ob3ZlckRlbGF5KTt9KSx0aGlzLm9wdGlvbnMuaG92ZXJQYW5lJiZ0aGlzLiRlbGVtZW50Lm9mZihcXFwibW91c2VlbnRlci56Zi5kcm9wZG93biBtb3VzZWxlYXZlLnpmLmRyb3Bkb3duXFxcIikub24oXFxcIm1vdXNlZW50ZXIuemYuZHJvcGRvd25cXFwiLGZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KGUudGltZW91dCk7fSkub24oXFxcIm1vdXNlbGVhdmUuemYuZHJvcGRvd25cXFwiLGZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KGUudGltZW91dCksZS50aW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXtlLmNsb3NlKCksZS4kYW5jaG9yLmRhdGEoXFxcImhvdmVyXFxcIiwhMSk7fSxlLm9wdGlvbnMuaG92ZXJEZWxheSk7fSkpLHRoaXMuJGFuY2hvci5hZGQodGhpcy4kZWxlbWVudCkub24oXFxcImtleWRvd24uemYuZHJvcGRvd25cXFwiLGZ1bmN0aW9uKGkpe3ZhciBuPXQodGhpcykscz1Gb3VuZGF0aW9uLktleWJvYXJkLmZpbmRGb2N1c2FibGUoZS4kZWxlbWVudCk7Rm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoaSxcXFwiRHJvcGRvd25cXFwiLHt0YWJfZm9yd2FyZDpmdW5jdGlvbiB0YWJfZm9yd2FyZCgpe2UuJGVsZW1lbnQuZmluZChcXFwiOmZvY3VzXFxcIikuaXMocy5lcSgtMSkpJiYoZS5vcHRpb25zLnRyYXBGb2N1cz8ocy5lcSgwKS5mb2N1cygpLGkucHJldmVudERlZmF1bHQoKSk6ZS5jbG9zZSgpKTt9LHRhYl9iYWNrd2FyZDpmdW5jdGlvbiB0YWJfYmFja3dhcmQoKXsoZS4kZWxlbWVudC5maW5kKFxcXCI6Zm9jdXNcXFwiKS5pcyhzLmVxKDApKXx8ZS4kZWxlbWVudC5pcyhcXFwiOmZvY3VzXFxcIikpJiYoZS5vcHRpb25zLnRyYXBGb2N1cz8ocy5lcSgtMSkuZm9jdXMoKSxpLnByZXZlbnREZWZhdWx0KCkpOmUuY2xvc2UoKSk7fSxvcGVuOmZ1bmN0aW9uIG9wZW4oKXtuLmlzKGUuJGFuY2hvcikmJihlLm9wZW4oKSxlLiRlbGVtZW50LmF0dHIoXFxcInRhYmluZGV4XFxcIiwtMSkuZm9jdXMoKSxpLnByZXZlbnREZWZhdWx0KCkpO30sY2xvc2U6ZnVuY3Rpb24gY2xvc2UoKXtlLmNsb3NlKCksZS4kYW5jaG9yLmZvY3VzKCk7fX0pO30pO319LHtrZXk6XFxcIl9hZGRCb2R5SGFuZGxlclxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10KGRvY3VtZW50LmJvZHkpLm5vdCh0aGlzLiRlbGVtZW50KSxpPXRoaXM7ZS5vZmYoXFxcImNsaWNrLnpmLmRyb3Bkb3duXFxcIikub24oXFxcImNsaWNrLnpmLmRyb3Bkb3duXFxcIixmdW5jdGlvbih0KXtpLiRhbmNob3IuaXModC50YXJnZXQpfHxpLiRhbmNob3IuZmluZCh0LnRhcmdldCkubGVuZ3RofHxpLiRlbGVtZW50LmZpbmQodC50YXJnZXQpLmxlbmd0aHx8KGkuY2xvc2UoKSxlLm9mZihcXFwiY2xpY2suemYuZHJvcGRvd25cXFwiKSk7fSk7fX0se2tleTpcXFwib3BlblxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXtpZih0aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcImNsb3NlbWUuemYuZHJvcGRvd25cXFwiLHRoaXMuJGVsZW1lbnQuYXR0cihcXFwiaWRcXFwiKSksdGhpcy4kYW5jaG9yLmFkZENsYXNzKFxcXCJob3ZlclxcXCIpLmF0dHIoe1xcXCJhcmlhLWV4cGFuZGVkXFxcIjohMH0pLHRoaXMuX3NldFBvc2l0aW9uKCksdGhpcy4kZWxlbWVudC5hZGRDbGFzcyhcXFwiaXMtb3BlblxcXCIpLmF0dHIoe1xcXCJhcmlhLWhpZGRlblxcXCI6ITF9KSx0aGlzLm9wdGlvbnMuYXV0b0ZvY3VzKXt2YXIgdD1Gb3VuZGF0aW9uLktleWJvYXJkLmZpbmRGb2N1c2FibGUodGhpcy4kZWxlbWVudCk7dC5sZW5ndGgmJnQuZXEoMCkuZm9jdXMoKTt9dGhpcy5vcHRpb25zLmNsb3NlT25DbGljayYmdGhpcy5fYWRkQm9keUhhbmRsZXIoKSx0aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcInNob3cuemYuZHJvcGRvd25cXFwiLFt0aGlzLiRlbGVtZW50XSk7fX0se2tleTpcXFwiY2xvc2VcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7aWYoIXRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXFxcImlzLW9wZW5cXFwiKSlyZXR1cm4hMTtpZih0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKFxcXCJpcy1vcGVuXFxcIikuYXR0cih7XFxcImFyaWEtaGlkZGVuXFxcIjohMH0pLHRoaXMuJGFuY2hvci5yZW1vdmVDbGFzcyhcXFwiaG92ZXJcXFwiKS5hdHRyKFxcXCJhcmlhLWV4cGFuZGVkXFxcIiwhMSksdGhpcy5jbGFzc0NoYW5nZWQpe3ZhciB0PXRoaXMuZ2V0UG9zaXRpb25DbGFzcygpO3QmJnRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModCksdGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMucG9zaXRpb25DbGFzcykuY3NzKHtoZWlnaHQ6XFxcIlxcXCIsd2lkdGg6XFxcIlxcXCJ9KSx0aGlzLmNsYXNzQ2hhbmdlZD0hMSx0aGlzLmNvdW50ZXI9NCx0aGlzLnVzZWRQb3NpdGlvbnMubGVuZ3RoPTA7fXRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwiaGlkZS56Zi5kcm9wZG93blxcXCIsW3RoaXMuJGVsZW1lbnRdKTt9fSx7a2V5OlxcXCJ0b2dnbGVcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7aWYodGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcXFwiaXMtb3BlblxcXCIpKXtpZih0aGlzLiRhbmNob3IuZGF0YShcXFwiaG92ZXJcXFwiKSlyZXR1cm47dGhpcy5jbG9zZSgpO31lbHNlIHRoaXMub3BlbigpO319LHtrZXk6XFxcImRlc3Ryb3lcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy4kZWxlbWVudC5vZmYoXFxcIi56Zi50cmlnZ2VyXFxcIikuaGlkZSgpLHRoaXMuJGFuY2hvci5vZmYoXFxcIi56Zi5kcm9wZG93blxcXCIpLEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTt9fV0pLGU7fSgpO2UuZGVmYXVsdHM9e2hvdmVyRGVsYXk6MjUwLGhvdmVyOiExLGhvdmVyUGFuZTohMSx2T2Zmc2V0OjEsaE9mZnNldDoxLHBvc2l0aW9uQ2xhc3M6XFxcIlxcXCIsdHJhcEZvY3VzOiExLGF1dG9Gb2N1czohMSxjbG9zZU9uQ2xpY2s6ITF9LEZvdW5kYXRpb24ucGx1Z2luKGUsXFxcIkRyb3Bkb3duXFxcIik7fShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXFxcInZhbHVlXFxcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLmtleSxuKTt9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGU7fTt9KCk7IWZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShpLG4pe19jbGFzc0NhbGxDaGVjayh0aGlzLGUpLHRoaXMuJGVsZW1lbnQ9aSx0aGlzLm9wdGlvbnM9dC5leHRlbmQoe30sZS5kZWZhdWx0cyx0aGlzLiRlbGVtZW50LmRhdGEoKSxuKSxGb3VuZGF0aW9uLk5lc3QuRmVhdGhlcih0aGlzLiRlbGVtZW50LFxcXCJkcm9wZG93blxcXCIpLHRoaXMuX2luaXQoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXFxcIkRyb3Bkb3duTWVudVxcXCIpLEZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIoXFxcIkRyb3Bkb3duTWVudVxcXCIse0VOVEVSOlxcXCJvcGVuXFxcIixTUEFDRTpcXFwib3BlblxcXCIsQVJST1dfUklHSFQ6XFxcIm5leHRcXFwiLEFSUk9XX1VQOlxcXCJ1cFxcXCIsQVJST1dfRE9XTjpcXFwiZG93blxcXCIsQVJST1dfTEVGVDpcXFwicHJldmlvdXNcXFwiLEVTQ0FQRTpcXFwiY2xvc2VcXFwifSk7fXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcXFwiX2luaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIHQ9dGhpcy4kZWxlbWVudC5maW5kKFxcXCJsaS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudFxcXCIpO3RoaXMuJGVsZW1lbnQuY2hpbGRyZW4oXFxcIi5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudFxcXCIpLmNoaWxkcmVuKFxcXCIuaXMtZHJvcGRvd24tc3VibWVudVxcXCIpLmFkZENsYXNzKFxcXCJmaXJzdC1zdWJcXFwiKSx0aGlzLiRtZW51SXRlbXM9dGhpcy4kZWxlbWVudC5maW5kKCdbcm9sZT1cXFwibWVudWl0ZW1cXFwiXScpLHRoaXMuJHRhYnM9dGhpcy4kZWxlbWVudC5jaGlsZHJlbignW3JvbGU9XFxcIm1lbnVpdGVtXFxcIl0nKSx0aGlzLiR0YWJzLmZpbmQoXFxcInVsLmlzLWRyb3Bkb3duLXN1Ym1lbnVcXFwiKS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMudmVydGljYWxDbGFzcyksdGhpcy4kZWxlbWVudC5oYXNDbGFzcyh0aGlzLm9wdGlvbnMucmlnaHRDbGFzcyl8fFxcXCJyaWdodFxcXCI9PT10aGlzLm9wdGlvbnMuYWxpZ25tZW50fHxGb3VuZGF0aW9uLnJ0bCgpfHx0aGlzLiRlbGVtZW50LnBhcmVudHMoXFxcIi50b3AtYmFyLXJpZ2h0XFxcIikuaXMoXFxcIipcXFwiKT8odGhpcy5vcHRpb25zLmFsaWdubWVudD1cXFwicmlnaHRcXFwiLHQuYWRkQ2xhc3MoXFxcIm9wZW5zLWxlZnRcXFwiKSk6dC5hZGRDbGFzcyhcXFwib3BlbnMtcmlnaHRcXFwiKSx0aGlzLmNoYW5nZWQ9ITEsdGhpcy5fZXZlbnRzKCk7fX0se2tleTpcXFwiX2V2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzLGk9XFxcIm9udG91Y2hzdGFydFxcXCJpbiB3aW5kb3d8fFxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2Ygd2luZG93Lm9udG91Y2hzdGFydCxuPVxcXCJpcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudFxcXCIscz1mdW5jdGlvbiBzKF9zKXt2YXIgbz10KF9zLnRhcmdldCkucGFyZW50c1VudGlsKFxcXCJ1bFxcXCIsXFxcIi5cXFwiK24pLGE9by5oYXNDbGFzcyhuKSxyPVxcXCJ0cnVlXFxcIj09PW8uYXR0cihcXFwiZGF0YS1pcy1jbGlja1xcXCIpO28uY2hpbGRyZW4oXFxcIi5pcy1kcm9wZG93bi1zdWJtZW51XFxcIik7aWYoYSlpZihyKXtpZighZS5vcHRpb25zLmNsb3NlT25DbGlja3x8IWUub3B0aW9ucy5jbGlja09wZW4mJiFpfHxlLm9wdGlvbnMuZm9yY2VGb2xsb3cmJmkpcmV0dXJuO19zLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLF9zLnByZXZlbnREZWZhdWx0KCksZS5faGlkZShvKTt9ZWxzZSBfcy5wcmV2ZW50RGVmYXVsdCgpLF9zLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLGUuX3Nob3coby5jaGlsZHJlbihcXFwiLmlzLWRyb3Bkb3duLXN1Ym1lbnVcXFwiKSksby5hZGQoby5wYXJlbnRzVW50aWwoZS4kZWxlbWVudCxcXFwiLlxcXCIrbikpLmF0dHIoXFxcImRhdGEtaXMtY2xpY2tcXFwiLCEwKTt9Oyh0aGlzLm9wdGlvbnMuY2xpY2tPcGVufHxpKSYmdGhpcy4kbWVudUl0ZW1zLm9uKFxcXCJjbGljay56Zi5kcm9wZG93bm1lbnUgdG91Y2hzdGFydC56Zi5kcm9wZG93bm1lbnVcXFwiLHMpLHRoaXMub3B0aW9ucy5kaXNhYmxlSG92ZXJ8fHRoaXMuJG1lbnVJdGVtcy5vbihcXFwibW91c2VlbnRlci56Zi5kcm9wZG93bm1lbnVcXFwiLGZ1bmN0aW9uKGkpe3ZhciBzPXQodGhpcyksbz1zLmhhc0NsYXNzKG4pO28mJihjbGVhclRpbWVvdXQoZS5kZWxheSksZS5kZWxheT1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZS5fc2hvdyhzLmNoaWxkcmVuKFxcXCIuaXMtZHJvcGRvd24tc3VibWVudVxcXCIpKTt9LGUub3B0aW9ucy5ob3ZlckRlbGF5KSk7fSkub24oXFxcIm1vdXNlbGVhdmUuemYuZHJvcGRvd25tZW51XFxcIixmdW5jdGlvbihpKXt2YXIgcz10KHRoaXMpLG89cy5oYXNDbGFzcyhuKTtpZihvJiZlLm9wdGlvbnMuYXV0b2Nsb3NlKXtpZihcXFwidHJ1ZVxcXCI9PT1zLmF0dHIoXFxcImRhdGEtaXMtY2xpY2tcXFwiKSYmZS5vcHRpb25zLmNsaWNrT3BlbilyZXR1cm4hMTtjbGVhclRpbWVvdXQoZS5kZWxheSksZS5kZWxheT1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZS5faGlkZShzKTt9LGUub3B0aW9ucy5jbG9zaW5nVGltZSk7fX0pLHRoaXMuJG1lbnVJdGVtcy5vbihcXFwia2V5ZG93bi56Zi5kcm9wZG93bm1lbnVcXFwiLGZ1bmN0aW9uKGkpe3ZhciBuLHMsbz10KGkudGFyZ2V0KS5wYXJlbnRzVW50aWwoXFxcInVsXFxcIiwnW3JvbGU9XFxcIm1lbnVpdGVtXFxcIl0nKSxhPWUuJHRhYnMuaW5kZXgobyk+LTEscj1hP2UuJHRhYnM6by5zaWJsaW5ncyhcXFwibGlcXFwiKS5hZGQobyk7ci5lYWNoKGZ1bmN0aW9uKGUpe3JldHVybiB0KHRoaXMpLmlzKG8pPyhuPXIuZXEoZS0xKSx2b2lkKHM9ci5lcShlKzEpKSk6dm9pZCAwO30pO3ZhciBsPWZ1bmN0aW9uIGwoKXtvLmlzKFxcXCI6bGFzdC1jaGlsZFxcXCIpfHwocy5jaGlsZHJlbihcXFwiYTpmaXJzdFxcXCIpLmZvY3VzKCksaS5wcmV2ZW50RGVmYXVsdCgpKTt9LHU9ZnVuY3Rpb24gdSgpe24uY2hpbGRyZW4oXFxcImE6Zmlyc3RcXFwiKS5mb2N1cygpLGkucHJldmVudERlZmF1bHQoKTt9LGQ9ZnVuY3Rpb24gZCgpe3ZhciB0PW8uY2hpbGRyZW4oXFxcInVsLmlzLWRyb3Bkb3duLXN1Ym1lbnVcXFwiKTt0Lmxlbmd0aCYmKGUuX3Nob3codCksby5maW5kKFxcXCJsaSA+IGE6Zmlyc3RcXFwiKS5mb2N1cygpLGkucHJldmVudERlZmF1bHQoKSk7fSxoPWZ1bmN0aW9uIGgoKXt2YXIgdD1vLnBhcmVudChcXFwidWxcXFwiKS5wYXJlbnQoXFxcImxpXFxcIik7dC5jaGlsZHJlbihcXFwiYTpmaXJzdFxcXCIpLmZvY3VzKCksZS5faGlkZSh0KSxpLnByZXZlbnREZWZhdWx0KCk7fSxjPXtvcGVuOmQsY2xvc2U6ZnVuY3Rpb24gY2xvc2UoKXtlLl9oaWRlKGUuJGVsZW1lbnQpLGUuJG1lbnVJdGVtcy5maW5kKFxcXCJhOmZpcnN0XFxcIikuZm9jdXMoKSxpLnByZXZlbnREZWZhdWx0KCk7fSxoYW5kbGVkOmZ1bmN0aW9uIGhhbmRsZWQoKXtpLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO319O2E/ZS4kZWxlbWVudC5oYXNDbGFzcyhlLm9wdGlvbnMudmVydGljYWxDbGFzcyk/XFxcImxlZnRcXFwiPT09ZS5vcHRpb25zLmFsaWdubWVudD90LmV4dGVuZChjLHtkb3duOmwsdXA6dSxuZXh0OmQscHJldmlvdXM6aH0pOnQuZXh0ZW5kKGMse2Rvd246bCx1cDp1LG5leHQ6aCxwcmV2aW91czpkfSk6dC5leHRlbmQoYyx7bmV4dDpsLHByZXZpb3VzOnUsZG93bjpkLHVwOmh9KTpcXFwibGVmdFxcXCI9PT1lLm9wdGlvbnMuYWxpZ25tZW50P3QuZXh0ZW5kKGMse25leHQ6ZCxwcmV2aW91czpoLGRvd246bCx1cDp1fSk6dC5leHRlbmQoYyx7bmV4dDpoLHByZXZpb3VzOmQsZG93bjpsLHVwOnV9KSxGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShpLFxcXCJEcm9wZG93bk1lbnVcXFwiLGMpO30pO319LHtrZXk6XFxcIl9hZGRCb2R5SGFuZGxlclxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10KGRvY3VtZW50LmJvZHkpLGk9dGhpcztlLm9mZihcXFwibW91c2V1cC56Zi5kcm9wZG93bm1lbnUgdG91Y2hlbmQuemYuZHJvcGRvd25tZW51XFxcIikub24oXFxcIm1vdXNldXAuemYuZHJvcGRvd25tZW51IHRvdWNoZW5kLnpmLmRyb3Bkb3dubWVudVxcXCIsZnVuY3Rpb24odCl7dmFyIG49aS4kZWxlbWVudC5maW5kKHQudGFyZ2V0KTtuLmxlbmd0aHx8KGkuX2hpZGUoKSxlLm9mZihcXFwibW91c2V1cC56Zi5kcm9wZG93bm1lbnUgdG91Y2hlbmQuemYuZHJvcGRvd25tZW51XFxcIikpO30pO319LHtrZXk6XFxcIl9zaG93XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZShlKXt2YXIgaT10aGlzLiR0YWJzLmluZGV4KHRoaXMuJHRhYnMuZmlsdGVyKGZ1bmN0aW9uKGksbil7cmV0dXJuIHQobikuZmluZChlKS5sZW5ndGg+MDt9KSksbj1lLnBhcmVudChcXFwibGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnRcXFwiKS5zaWJsaW5ncyhcXFwibGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnRcXFwiKTt0aGlzLl9oaWRlKG4saSksZS5jc3MoXFxcInZpc2liaWxpdHlcXFwiLFxcXCJoaWRkZW5cXFwiKS5hZGRDbGFzcyhcXFwianMtZHJvcGRvd24tYWN0aXZlXFxcIikuYXR0cih7XFxcImFyaWEtaGlkZGVuXFxcIjohMX0pLnBhcmVudChcXFwibGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnRcXFwiKS5hZGRDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIikuYXR0cih7XFxcImFyaWEtZXhwYW5kZWRcXFwiOiEwfSk7dmFyIHM9Rm91bmRhdGlvbi5Cb3guSW1Ob3RUb3VjaGluZ1lvdShlLG51bGwsITApO2lmKCFzKXt2YXIgbz1cXFwibGVmdFxcXCI9PT10aGlzLm9wdGlvbnMuYWxpZ25tZW50P1xcXCItcmlnaHRcXFwiOlxcXCItbGVmdFxcXCIsYT1lLnBhcmVudChcXFwiLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50XFxcIik7YS5yZW1vdmVDbGFzcyhcXFwib3BlbnNcXFwiK28pLmFkZENsYXNzKFxcXCJvcGVucy1cXFwiK3RoaXMub3B0aW9ucy5hbGlnbm1lbnQpLHM9Rm91bmRhdGlvbi5Cb3guSW1Ob3RUb3VjaGluZ1lvdShlLG51bGwsITApLHN8fGEucmVtb3ZlQ2xhc3MoXFxcIm9wZW5zLVxcXCIrdGhpcy5vcHRpb25zLmFsaWdubWVudCkuYWRkQ2xhc3MoXFxcIm9wZW5zLWlubmVyXFxcIiksdGhpcy5jaGFuZ2VkPSEwO31lLmNzcyhcXFwidmlzaWJpbGl0eVxcXCIsXFxcIlxcXCIpLHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2smJnRoaXMuX2FkZEJvZHlIYW5kbGVyKCksdGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJzaG93LnpmLmRyb3Bkb3dubWVudVxcXCIsW2VdKTt9fSx7a2V5OlxcXCJfaGlkZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCxlKXt2YXIgaTtpPXQmJnQubGVuZ3RoP3Q6dm9pZCAwIT09ZT90aGlzLiR0YWJzLm5vdChmdW5jdGlvbih0LGkpe3JldHVybiB0PT09ZTt9KTp0aGlzLiRlbGVtZW50O3ZhciBuPWkuaGFzQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpfHxpLmZpbmQoXFxcIi5pcy1hY3RpdmVcXFwiKS5sZW5ndGg+MDtpZihuKXtpZihpLmZpbmQoXFxcImxpLmlzLWFjdGl2ZVxcXCIpLmFkZChpKS5hdHRyKHtcXFwiYXJpYS1leHBhbmRlZFxcXCI6ITEsXFxcImRhdGEtaXMtY2xpY2tcXFwiOiExfSkucmVtb3ZlQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpLGkuZmluZChcXFwidWwuanMtZHJvcGRvd24tYWN0aXZlXFxcIikuYXR0cih7XFxcImFyaWEtaGlkZGVuXFxcIjohMH0pLnJlbW92ZUNsYXNzKFxcXCJqcy1kcm9wZG93bi1hY3RpdmVcXFwiKSx0aGlzLmNoYW5nZWR8fGkuZmluZChcXFwib3BlbnMtaW5uZXJcXFwiKS5sZW5ndGgpe3ZhciBzPVxcXCJsZWZ0XFxcIj09PXRoaXMub3B0aW9ucy5hbGlnbm1lbnQ/XFxcInJpZ2h0XFxcIjpcXFwibGVmdFxcXCI7aS5maW5kKFxcXCJsaS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudFxcXCIpLmFkZChpKS5yZW1vdmVDbGFzcyhcXFwib3BlbnMtaW5uZXIgb3BlbnMtXFxcIit0aGlzLm9wdGlvbnMuYWxpZ25tZW50KS5hZGRDbGFzcyhcXFwib3BlbnMtXFxcIitzKSx0aGlzLmNoYW5nZWQ9ITE7fXRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwiaGlkZS56Zi5kcm9wZG93bm1lbnVcXFwiLFtpXSk7fX19LHtrZXk6XFxcImRlc3Ryb3lcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy4kbWVudUl0ZW1zLm9mZihcXFwiLnpmLmRyb3Bkb3dubWVudVxcXCIpLnJlbW92ZUF0dHIoXFxcImRhdGEtaXMtY2xpY2tcXFwiKS5yZW1vdmVDbGFzcyhcXFwiaXMtcmlnaHQtYXJyb3cgaXMtbGVmdC1hcnJvdyBpcy1kb3duLWFycm93IG9wZW5zLXJpZ2h0IG9wZW5zLWxlZnQgb3BlbnMtaW5uZXJcXFwiKSx0KGRvY3VtZW50LmJvZHkpLm9mZihcXFwiLnpmLmRyb3Bkb3dubWVudVxcXCIpLEZvdW5kYXRpb24uTmVzdC5CdXJuKHRoaXMuJGVsZW1lbnQsXFxcImRyb3Bkb3duXFxcIiksRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSksZTt9KCk7ZS5kZWZhdWx0cz17ZGlzYWJsZUhvdmVyOiExLGF1dG9jbG9zZTohMCxob3ZlckRlbGF5OjUwLGNsaWNrT3BlbjohMSxjbG9zaW5nVGltZTo1MDAsYWxpZ25tZW50OlxcXCJsZWZ0XFxcIixjbG9zZU9uQ2xpY2s6ITAsdmVydGljYWxDbGFzczpcXFwidmVydGljYWxcXFwiLHJpZ2h0Q2xhc3M6XFxcImFsaWduLXJpZ2h0XFxcIixmb3JjZUZvbGxvdzohMH0sRm91bmRhdGlvbi5wbHVnaW4oZSxcXFwiRHJvcGRvd25NZW51XFxcIik7fShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXFxcInZhbHVlXFxcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLmtleSxuKTt9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGU7fTt9KCk7IWZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShpLG4pe19jbGFzc0NhbGxDaGVjayh0aGlzLGUpLHRoaXMuJGVsZW1lbnQ9aSx0aGlzLm9wdGlvbnM9dC5leHRlbmQoe30sZS5kZWZhdWx0cyx0aGlzLiRlbGVtZW50LmRhdGEoKSxuKSx0aGlzLl9pbml0KCksRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLFxcXCJFcXVhbGl6ZXJcXFwiKTt9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLFt7a2V5OlxcXCJfaW5pdFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzLiRlbGVtZW50LmF0dHIoXFxcImRhdGEtZXF1YWxpemVyXFxcIil8fFxcXCJcXFwiLGk9dGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1lcXVhbGl6ZXItd2F0Y2g9XFxcIicrZSsnXFxcIl0nKTt0aGlzLiR3YXRjaGVkPWkubGVuZ3RoP2k6dGhpcy4kZWxlbWVudC5maW5kKFxcXCJbZGF0YS1lcXVhbGl6ZXItd2F0Y2hdXFxcIiksdGhpcy4kZWxlbWVudC5hdHRyKFxcXCJkYXRhLXJlc2l6ZVxcXCIsZXx8Rm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LFxcXCJlcVxcXCIpKSx0aGlzLmhhc05lc3RlZD10aGlzLiRlbGVtZW50LmZpbmQoXFxcIltkYXRhLWVxdWFsaXplcl1cXFwiKS5sZW5ndGg+MCx0aGlzLmlzTmVzdGVkPXRoaXMuJGVsZW1lbnQucGFyZW50c1VudGlsKGRvY3VtZW50LmJvZHksXFxcIltkYXRhLWVxdWFsaXplcl1cXFwiKS5sZW5ndGg+MCx0aGlzLmlzT249ITEsdGhpcy5fYmluZEhhbmRsZXI9e29uUmVzaXplTWVCb3VuZDp0aGlzLl9vblJlc2l6ZU1lLmJpbmQodGhpcyksb25Qb3N0RXF1YWxpemVkQm91bmQ6dGhpcy5fb25Qb3N0RXF1YWxpemVkLmJpbmQodGhpcyl9O3ZhciBuLHM9dGhpcy4kZWxlbWVudC5maW5kKFxcXCJpbWdcXFwiKTt0aGlzLm9wdGlvbnMuZXF1YWxpemVPbj8obj10aGlzLl9jaGVja01RKCksdCh3aW5kb3cpLm9uKFxcXCJjaGFuZ2VkLnpmLm1lZGlhcXVlcnlcXFwiLHRoaXMuX2NoZWNrTVEuYmluZCh0aGlzKSkpOnRoaXMuX2V2ZW50cygpLCh2b2lkIDAhPT1uJiZuPT09ITF8fHZvaWQgMD09PW4pJiYocy5sZW5ndGg/Rm91bmRhdGlvbi5vbkltYWdlc0xvYWRlZChzLHRoaXMuX3JlZmxvdy5iaW5kKHRoaXMpKTp0aGlzLl9yZWZsb3coKSk7fX0se2tleTpcXFwiX3BhdXNlRXZlbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuaXNPbj0hMSx0aGlzLiRlbGVtZW50Lm9mZih7XFxcIi56Zi5lcXVhbGl6ZXJcXFwiOnRoaXMuX2JpbmRIYW5kbGVyLm9uUG9zdEVxdWFsaXplZEJvdW5kLFxcXCJyZXNpemVtZS56Zi50cmlnZ2VyXFxcIjp0aGlzLl9iaW5kSGFuZGxlci5vblJlc2l6ZU1lQm91bmR9KTt9fSx7a2V5OlxcXCJfb25SZXNpemVNZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dGhpcy5fcmVmbG93KCk7fX0se2tleTpcXFwiX29uUG9zdEVxdWFsaXplZFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dC50YXJnZXQhPT10aGlzLiRlbGVtZW50WzBdJiZ0aGlzLl9yZWZsb3coKTt9fSx7a2V5OlxcXCJfZXZlbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuX3BhdXNlRXZlbnRzKCksdGhpcy5oYXNOZXN0ZWQ/dGhpcy4kZWxlbWVudC5vbihcXFwicG9zdGVxdWFsaXplZC56Zi5lcXVhbGl6ZXJcXFwiLHRoaXMuX2JpbmRIYW5kbGVyLm9uUG9zdEVxdWFsaXplZEJvdW5kKTp0aGlzLiRlbGVtZW50Lm9uKFxcXCJyZXNpemVtZS56Zi50cmlnZ2VyXFxcIix0aGlzLl9iaW5kSGFuZGxlci5vblJlc2l6ZU1lQm91bmQpLHRoaXMuaXNPbj0hMDt9fSx7a2V5OlxcXCJfY2hlY2tNUVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgdD0hRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmF0TGVhc3QodGhpcy5vcHRpb25zLmVxdWFsaXplT24pO3JldHVybiB0P3RoaXMuaXNPbiYmKHRoaXMuX3BhdXNlRXZlbnRzKCksdGhpcy4kd2F0Y2hlZC5jc3MoXFxcImhlaWdodFxcXCIsXFxcImF1dG9cXFwiKSk6dGhpcy5pc09ufHx0aGlzLl9ldmVudHMoKSx0O319LHtrZXk6XFxcIl9raWxsc3dpdGNoXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe319LHtrZXk6XFxcIl9yZWZsb3dcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7cmV0dXJuIXRoaXMub3B0aW9ucy5lcXVhbGl6ZU9uU3RhY2smJnRoaXMuX2lzU3RhY2tlZCgpPyh0aGlzLiR3YXRjaGVkLmNzcyhcXFwiaGVpZ2h0XFxcIixcXFwiYXV0b1xcXCIpLCExKTp2b2lkKHRoaXMub3B0aW9ucy5lcXVhbGl6ZUJ5Um93P3RoaXMuZ2V0SGVpZ2h0c0J5Um93KHRoaXMuYXBwbHlIZWlnaHRCeVJvdy5iaW5kKHRoaXMpKTp0aGlzLmdldEhlaWdodHModGhpcy5hcHBseUhlaWdodC5iaW5kKHRoaXMpKSk7fX0se2tleTpcXFwiX2lzU3RhY2tlZFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXtyZXR1cm4gdGhpcy4kd2F0Y2hlZFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AhPT10aGlzLiR3YXRjaGVkWzFdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDt9fSx7a2V5OlxcXCJnZXRIZWlnaHRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXtmb3IodmFyIGU9W10saT0wLG49dGhpcy4kd2F0Y2hlZC5sZW5ndGg7bj5pO2krKyl7dGhpcy4kd2F0Y2hlZFtpXS5zdHlsZS5oZWlnaHQ9XFxcImF1dG9cXFwiLGUucHVzaCh0aGlzLiR3YXRjaGVkW2ldLm9mZnNldEhlaWdodCk7fXQoZSk7fX0se2tleTpcXFwiZ2V0SGVpZ2h0c0J5Um93XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZShlKXt2YXIgaT10aGlzLiR3YXRjaGVkLmxlbmd0aD90aGlzLiR3YXRjaGVkLmZpcnN0KCkub2Zmc2V0KCkudG9wOjAsbj1bXSxzPTA7bltzXT1bXTtmb3IodmFyIG89MCxhPXRoaXMuJHdhdGNoZWQubGVuZ3RoO2E+bztvKyspe3RoaXMuJHdhdGNoZWRbb10uc3R5bGUuaGVpZ2h0PVxcXCJhdXRvXFxcIjt2YXIgcj10KHRoaXMuJHdhdGNoZWRbb10pLm9mZnNldCgpLnRvcDtyIT1pJiYocysrLG5bc109W10saT1yKSxuW3NdLnB1c2goW3RoaXMuJHdhdGNoZWRbb10sdGhpcy4kd2F0Y2hlZFtvXS5vZmZzZXRIZWlnaHRdKTt9Zm9yKHZhciBsPTAsdT1uLmxlbmd0aDt1Pmw7bCsrKXt2YXIgZD10KG5bbF0pLm1hcChmdW5jdGlvbigpe3JldHVybiB0aGlzWzFdO30pLmdldCgpLGg9TWF0aC5tYXguYXBwbHkobnVsbCxkKTtuW2xdLnB1c2goaCk7fWUobik7fX0se2tleTpcXFwiYXBwbHlIZWlnaHRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3ZhciBlPU1hdGgubWF4LmFwcGx5KG51bGwsdCk7dGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJwcmVlcXVhbGl6ZWQuemYuZXF1YWxpemVyXFxcIiksdGhpcy4kd2F0Y2hlZC5jc3MoXFxcImhlaWdodFxcXCIsZSksdGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJwb3N0ZXF1YWxpemVkLnpmLmVxdWFsaXplclxcXCIpO319LHtrZXk6XFxcImFwcGx5SGVpZ2h0QnlSb3dcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKGUpe3RoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwicHJlZXF1YWxpemVkLnpmLmVxdWFsaXplclxcXCIpO2Zvcih2YXIgaT0wLG49ZS5sZW5ndGg7bj5pO2krKyl7dmFyIHM9ZVtpXS5sZW5ndGgsbz1lW2ldW3MtMV07aWYoMj49cyl0KGVbaV1bMF1bMF0pLmNzcyh7aGVpZ2h0OlxcXCJhdXRvXFxcIn0pO2Vsc2V7dGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJwcmVlcXVhbGl6ZWRyb3cuemYuZXF1YWxpemVyXFxcIik7Zm9yKHZhciBhPTAscj1zLTE7cj5hO2ErKyl7dChlW2ldW2FdWzBdKS5jc3Moe2hlaWdodDpvfSk7fXRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwicG9zdGVxdWFsaXplZHJvdy56Zi5lcXVhbGl6ZXJcXFwiKTt9fXRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwicG9zdGVxdWFsaXplZC56Zi5lcXVhbGl6ZXJcXFwiKTt9fSx7a2V5OlxcXCJkZXN0cm95XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuX3BhdXNlRXZlbnRzKCksdGhpcy4kd2F0Y2hlZC5jc3MoXFxcImhlaWdodFxcXCIsXFxcImF1dG9cXFwiKSxGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKSxlO30oKTtlLmRlZmF1bHRzPXtlcXVhbGl6ZU9uU3RhY2s6ITAsZXF1YWxpemVCeVJvdzohMSxlcXVhbGl6ZU9uOlxcXCJcXFwifSxGb3VuZGF0aW9uLnBsdWdpbihlLFxcXCJFcXVhbGl6ZXJcXFwiKTt9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcXFwidmFsdWVcXFwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pO319cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZTt9O30oKTshZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGksbil7X2NsYXNzQ2FsbENoZWNrKHRoaXMsZSksdGhpcy4kZWxlbWVudD1pLHRoaXMub3B0aW9ucz10LmV4dGVuZCh7fSxlLmRlZmF1bHRzLG4pLHRoaXMucnVsZXM9W10sdGhpcy5jdXJyZW50UGF0aD1cXFwiXFxcIix0aGlzLl9pbml0KCksdGhpcy5fZXZlbnRzKCksRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLFxcXCJJbnRlcmNoYW5nZVxcXCIpO31yZXR1cm4gX2NyZWF0ZUNsYXNzKGUsW3trZXk6XFxcIl9pbml0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuX2FkZEJyZWFrcG9pbnRzKCksdGhpcy5fZ2VuZXJhdGVSdWxlcygpLHRoaXMuX3JlZmxvdygpO319LHtrZXk6XFxcIl9ldmVudHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dCh3aW5kb3cpLm9uKFxcXCJyZXNpemUuemYuaW50ZXJjaGFuZ2VcXFwiLEZvdW5kYXRpb24udXRpbC50aHJvdHRsZSh0aGlzLl9yZWZsb3cuYmluZCh0aGlzKSw1MCkpO319LHtrZXk6XFxcIl9yZWZsb3dcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIHQ7Zm9yKHZhciBlIGluIHRoaXMucnVsZXMpe2lmKHRoaXMucnVsZXMuaGFzT3duUHJvcGVydHkoZSkpe3ZhciBpPXRoaXMucnVsZXNbZV07d2luZG93Lm1hdGNoTWVkaWEoaS5xdWVyeSkubWF0Y2hlcyYmKHQ9aSk7fX10JiZ0aGlzLnJlcGxhY2UodC5wYXRoKTt9fSx7a2V5OlxcXCJfYWRkQnJlYWtwb2ludHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7Zm9yKHZhciB0IGluIEZvdW5kYXRpb24uTWVkaWFRdWVyeS5xdWVyaWVzKXtpZihGb3VuZGF0aW9uLk1lZGlhUXVlcnkucXVlcmllcy5oYXNPd25Qcm9wZXJ0eSh0KSl7dmFyIGk9Rm91bmRhdGlvbi5NZWRpYVF1ZXJ5LnF1ZXJpZXNbdF07ZS5TUEVDSUFMX1FVRVJJRVNbaS5uYW1lXT1pLnZhbHVlO319fX0se2tleTpcXFwiX2dlbmVyYXRlUnVsZXNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3ZhciBpLG49W107aT10aGlzLm9wdGlvbnMucnVsZXM/dGhpcy5vcHRpb25zLnJ1bGVzOnRoaXMuJGVsZW1lbnQuZGF0YShcXFwiaW50ZXJjaGFuZ2VcXFwiKS5tYXRjaCgvXFxcXFsuKj9cXFxcXS9nKTtmb3IodmFyIHMgaW4gaSl7aWYoaS5oYXNPd25Qcm9wZXJ0eShzKSl7dmFyIG89aVtzXS5zbGljZSgxLC0xKS5zcGxpdChcXFwiLCBcXFwiKSxhPW8uc2xpY2UoMCwtMSkuam9pbihcXFwiXFxcIikscj1vW28ubGVuZ3RoLTFdO2UuU1BFQ0lBTF9RVUVSSUVTW3JdJiYocj1lLlNQRUNJQUxfUVVFUklFU1tyXSksbi5wdXNoKHtwYXRoOmEscXVlcnk6cn0pO319dGhpcy5ydWxlcz1uO319LHtrZXk6XFxcInJlcGxhY2VcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKGUpe2lmKHRoaXMuY3VycmVudFBhdGghPT1lKXt2YXIgaT10aGlzLG49XFxcInJlcGxhY2VkLnpmLmludGVyY2hhbmdlXFxcIjtcXFwiSU1HXFxcIj09PXRoaXMuJGVsZW1lbnRbMF0ubm9kZU5hbWU/dGhpcy4kZWxlbWVudC5hdHRyKFxcXCJzcmNcXFwiLGUpLmxvYWQoZnVuY3Rpb24oKXtpLmN1cnJlbnRQYXRoPWU7fSkudHJpZ2dlcihuKTplLm1hdGNoKC9cXFxcLihnaWZ8anBnfGpwZWd8cG5nfHN2Z3x0aWZmKShbPyNdLiopPy9pKT90aGlzLiRlbGVtZW50LmNzcyh7XFxcImJhY2tncm91bmQtaW1hZ2VcXFwiOlxcXCJ1cmwoXFxcIitlK1xcXCIpXFxcIn0pLnRyaWdnZXIobik6dC5nZXQoZSxmdW5jdGlvbihzKXtpLiRlbGVtZW50Lmh0bWwocykudHJpZ2dlcihuKSx0KHMpLmZvdW5kYXRpb24oKSxpLmN1cnJlbnRQYXRoPWU7fSk7fX19LHtrZXk6XFxcImRlc3Ryb3lcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7fX1dKSxlO30oKTtlLmRlZmF1bHRzPXtydWxlczpudWxsfSxlLlNQRUNJQUxfUVVFUklFUz17bGFuZHNjYXBlOlxcXCJzY3JlZW4gYW5kIChvcmllbnRhdGlvbjogbGFuZHNjYXBlKVxcXCIscG9ydHJhaXQ6XFxcInNjcmVlbiBhbmQgKG9yaWVudGF0aW9uOiBwb3J0cmFpdClcXFwiLHJldGluYTpcXFwib25seSBzY3JlZW4gYW5kICgtd2Via2l0LW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDIpLCBvbmx5IHNjcmVlbiBhbmQgKG1pbi0tbW96LWRldmljZS1waXhlbC1yYXRpbzogMiksIG9ubHkgc2NyZWVuIGFuZCAoLW8tbWluLWRldmljZS1waXhlbC1yYXRpbzogMi8xKSwgb25seSBzY3JlZW4gYW5kIChtaW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAyKSwgb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogMTkyZHBpKSwgb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogMmRwcHgpXFxcIn0sRm91bmRhdGlvbi5wbHVnaW4oZSxcXFwiSW50ZXJjaGFuZ2VcXFwiKTt9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcXFwidmFsdWVcXFwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pO319cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZTt9O30oKTshZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGksbil7X2NsYXNzQ2FsbENoZWNrKHRoaXMsZSksdGhpcy4kZWxlbWVudD1pLHRoaXMub3B0aW9ucz10LmV4dGVuZCh7fSxlLmRlZmF1bHRzLHRoaXMuJGVsZW1lbnQuZGF0YSgpLG4pLHRoaXMuX2luaXQoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXFxcIk1hZ2VsbGFuXFxcIik7fXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcXFwiX2luaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpcy4kZWxlbWVudFswXS5pZHx8Rm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LFxcXCJtYWdlbGxhblxcXCIpO3RoaXMuJHRhcmdldHM9dChcXFwiW2RhdGEtbWFnZWxsYW4tdGFyZ2V0XVxcXCIpLHRoaXMuJGxpbmtzPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiYVxcXCIpLHRoaXMuJGVsZW1lbnQuYXR0cih7XFxcImRhdGEtcmVzaXplXFxcIjplLFxcXCJkYXRhLXNjcm9sbFxcXCI6ZSxpZDplfSksdGhpcy4kYWN0aXZlPXQoKSx0aGlzLnNjcm9sbFBvcz1wYXJzZUludCh3aW5kb3cucGFnZVlPZmZzZXQsMTApLHRoaXMuX2V2ZW50cygpO319LHtrZXk6XFxcImNhbGNQb2ludHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpcyxpPWRvY3VtZW50LmJvZHksbj1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7dGhpcy5wb2ludHM9W10sdGhpcy53aW5IZWlnaHQ9TWF0aC5yb3VuZChNYXRoLm1heCh3aW5kb3cuaW5uZXJIZWlnaHQsbi5jbGllbnRIZWlnaHQpKSx0aGlzLmRvY0hlaWdodD1NYXRoLnJvdW5kKE1hdGgubWF4KGkuc2Nyb2xsSGVpZ2h0LGkub2Zmc2V0SGVpZ2h0LG4uY2xpZW50SGVpZ2h0LG4uc2Nyb2xsSGVpZ2h0LG4ub2Zmc2V0SGVpZ2h0KSksdGhpcy4kdGFyZ2V0cy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGk9dCh0aGlzKSxuPU1hdGgucm91bmQoaS5vZmZzZXQoKS50b3AtZS5vcHRpb25zLnRocmVzaG9sZCk7aS50YXJnZXRQb2ludD1uLGUucG9pbnRzLnB1c2gobik7fSk7fX0se2tleTpcXFwiX2V2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzO3QoXFxcImh0bWwsIGJvZHlcXFwiKSx7ZHVyYXRpb246ZS5vcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uLGVhc2luZzplLm9wdGlvbnMuYW5pbWF0aW9uRWFzaW5nfTt0KHdpbmRvdykub25lKFxcXCJsb2FkXFxcIixmdW5jdGlvbigpe2Uub3B0aW9ucy5kZWVwTGlua2luZyYmbG9jYXRpb24uaGFzaCYmZS5zY3JvbGxUb0xvYyhsb2NhdGlvbi5oYXNoKSxlLmNhbGNQb2ludHMoKSxlLl91cGRhdGVBY3RpdmUoKTt9KSx0aGlzLiRlbGVtZW50Lm9uKHtcXFwicmVzaXplbWUuemYudHJpZ2dlclxcXCI6dGhpcy5yZWZsb3cuYmluZCh0aGlzKSxcXFwic2Nyb2xsbWUuemYudHJpZ2dlclxcXCI6dGhpcy5fdXBkYXRlQWN0aXZlLmJpbmQodGhpcyl9KS5vbihcXFwiY2xpY2suemYubWFnZWxsYW5cXFwiLCdhW2hyZWZePVxcXCIjXFxcIl0nLGZ1bmN0aW9uKHQpe3QucHJldmVudERlZmF1bHQoKTt2YXIgaT10aGlzLmdldEF0dHJpYnV0ZShcXFwiaHJlZlxcXCIpO2Uuc2Nyb2xsVG9Mb2MoaSk7fSk7fX0se2tleTpcXFwic2Nyb2xsVG9Mb2NcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKGUpe3ZhciBpPU1hdGgucm91bmQodChlKS5vZmZzZXQoKS50b3AtdGhpcy5vcHRpb25zLnRocmVzaG9sZC8yLXRoaXMub3B0aW9ucy5iYXJPZmZzZXQpO3QoXFxcImh0bWwsIGJvZHlcXFwiKS5zdG9wKCEwKS5hbmltYXRlKHtzY3JvbGxUb3A6aX0sdGhpcy5vcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uLHRoaXMub3B0aW9ucy5hbmltYXRpb25FYXNpbmcpO319LHtrZXk6XFxcInJlZmxvd1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLmNhbGNQb2ludHMoKSx0aGlzLl91cGRhdGVBY3RpdmUoKTt9fSx7a2V5OlxcXCJfdXBkYXRlQWN0aXZlXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciB0LGU9cGFyc2VJbnQod2luZG93LnBhZ2VZT2Zmc2V0LDEwKTtpZihlK3RoaXMud2luSGVpZ2h0PT09dGhpcy5kb2NIZWlnaHQpdD10aGlzLnBvaW50cy5sZW5ndGgtMTtlbHNlIGlmKGU8dGhpcy5wb2ludHNbMF0pdD0wO2Vsc2V7dmFyIGk9dGhpcy5zY3JvbGxQb3M8ZSxuPXRoaXMscz10aGlzLnBvaW50cy5maWx0ZXIoZnVuY3Rpb24odCxzKXtyZXR1cm4gaT90LW4ub3B0aW9ucy5iYXJPZmZzZXQ8PWU6dC1uLm9wdGlvbnMuYmFyT2Zmc2V0LW4ub3B0aW9ucy50aHJlc2hvbGQ8PWU7fSk7dD1zLmxlbmd0aD9zLmxlbmd0aC0xOjA7fWlmKHRoaXMuJGFjdGl2ZS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpLHRoaXMuJGFjdGl2ZT10aGlzLiRsaW5rcy5lcSh0KS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpLHRoaXMub3B0aW9ucy5kZWVwTGlua2luZyl7dmFyIG89dGhpcy4kYWN0aXZlWzBdLmdldEF0dHJpYnV0ZShcXFwiaHJlZlxcXCIpO3dpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZT93aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUobnVsbCxudWxsLG8pOndpbmRvdy5sb2NhdGlvbi5oYXNoPW87fXRoaXMuc2Nyb2xsUG9zPWUsdGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJ1cGRhdGUuemYubWFnZWxsYW5cXFwiLFt0aGlzLiRhY3RpdmVdKTt9fSx7a2V5OlxcXCJkZXN0cm95XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe2lmKHRoaXMuJGVsZW1lbnQub2ZmKFxcXCIuemYudHJpZ2dlciAuemYubWFnZWxsYW5cXFwiKS5maW5kKFxcXCIuXFxcIit0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcyksdGhpcy5vcHRpb25zLmRlZXBMaW5raW5nKXt2YXIgdD10aGlzLiRhY3RpdmVbMF0uZ2V0QXR0cmlidXRlKFxcXCJocmVmXFxcIik7d2luZG93LmxvY2F0aW9uLmhhc2gucmVwbGFjZSh0LFxcXCJcXFwiKTt9Rm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSksZTt9KCk7ZS5kZWZhdWx0cz17YW5pbWF0aW9uRHVyYXRpb246NTAwLGFuaW1hdGlvbkVhc2luZzpcXFwibGluZWFyXFxcIix0aHJlc2hvbGQ6NTAsYWN0aXZlQ2xhc3M6XFxcImFjdGl2ZVxcXCIsZGVlcExpbmtpbmc6ITEsYmFyT2Zmc2V0OjB9LEZvdW5kYXRpb24ucGx1Z2luKGUsXFxcIk1hZ2VsbGFuXFxcIik7fShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXFxcInZhbHVlXFxcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLmtleSxuKTt9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGU7fTt9KCk7IWZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShpLG4pe19jbGFzc0NhbGxDaGVjayh0aGlzLGUpLHRoaXMuJGVsZW1lbnQ9aSx0aGlzLm9wdGlvbnM9dC5leHRlbmQoe30sZS5kZWZhdWx0cyx0aGlzLiRlbGVtZW50LmRhdGEoKSxuKSx0aGlzLiRsYXN0VHJpZ2dlcj10KCksdGhpcy4kdHJpZ2dlcnM9dCgpLHRoaXMuX2luaXQoKSx0aGlzLl9ldmVudHMoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXFxcIk9mZkNhbnZhc1xcXCIpO31yZXR1cm4gX2NyZWF0ZUNsYXNzKGUsW3trZXk6XFxcIl9pbml0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXMuJGVsZW1lbnQuYXR0cihcXFwiaWRcXFwiKTtpZih0aGlzLiRlbGVtZW50LmF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIixcXFwidHJ1ZVxcXCIpLHRoaXMuJHRyaWdnZXJzPXQoZG9jdW1lbnQpLmZpbmQoJ1tkYXRhLW9wZW49XFxcIicrZSsnXFxcIl0sIFtkYXRhLWNsb3NlPVxcXCInK2UrJ1xcXCJdLCBbZGF0YS10b2dnbGU9XFxcIicrZSsnXFxcIl0nKS5hdHRyKFxcXCJhcmlhLWV4cGFuZGVkXFxcIixcXFwiZmFsc2VcXFwiKS5hdHRyKFxcXCJhcmlhLWNvbnRyb2xzXFxcIixlKSx0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrKWlmKHQoXFxcIi5qcy1vZmYtY2FudmFzLWV4aXRcXFwiKS5sZW5ndGgpdGhpcy4kZXhpdGVyPXQoXFxcIi5qcy1vZmYtY2FudmFzLWV4aXRcXFwiKTtlbHNle3ZhciBpPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpO2kuc2V0QXR0cmlidXRlKFxcXCJjbGFzc1xcXCIsXFxcImpzLW9mZi1jYW52YXMtZXhpdFxcXCIpLHQoXFxcIltkYXRhLW9mZi1jYW52YXMtY29udGVudF1cXFwiKS5hcHBlbmQoaSksdGhpcy4kZXhpdGVyPXQoaSk7fXRoaXMub3B0aW9ucy5pc1JldmVhbGVkPXRoaXMub3B0aW9ucy5pc1JldmVhbGVkfHxuZXcgUmVnRXhwKHRoaXMub3B0aW9ucy5yZXZlYWxDbGFzcyxcXFwiZ1xcXCIpLnRlc3QodGhpcy4kZWxlbWVudFswXS5jbGFzc05hbWUpLHRoaXMub3B0aW9ucy5pc1JldmVhbGVkJiYodGhpcy5vcHRpb25zLnJldmVhbE9uPXRoaXMub3B0aW9ucy5yZXZlYWxPbnx8dGhpcy4kZWxlbWVudFswXS5jbGFzc05hbWUubWF0Y2goLyhyZXZlYWwtZm9yLW1lZGl1bXxyZXZlYWwtZm9yLWxhcmdlKS9nKVswXS5zcGxpdChcXFwiLVxcXCIpWzJdLHRoaXMuX3NldE1RQ2hlY2tlcigpKSx0aGlzLm9wdGlvbnMudHJhbnNpdGlvblRpbWV8fCh0aGlzLm9wdGlvbnMudHJhbnNpdGlvblRpbWU9MWUzKnBhcnNlRmxvYXQod2luZG93LmdldENvbXB1dGVkU3R5bGUodChcXFwiW2RhdGEtb2ZmLWNhbnZhcy13cmFwcGVyXVxcXCIpWzBdKS50cmFuc2l0aW9uRHVyYXRpb24pKTt9fSx7a2V5OlxcXCJfZXZlbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuJGVsZW1lbnQub2ZmKFxcXCIuemYudHJpZ2dlciAuemYub2ZmY2FudmFzXFxcIikub24oe1xcXCJvcGVuLnpmLnRyaWdnZXJcXFwiOnRoaXMub3Blbi5iaW5kKHRoaXMpLFxcXCJjbG9zZS56Zi50cmlnZ2VyXFxcIjp0aGlzLmNsb3NlLmJpbmQodGhpcyksXFxcInRvZ2dsZS56Zi50cmlnZ2VyXFxcIjp0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpLFxcXCJrZXlkb3duLnpmLm9mZmNhbnZhc1xcXCI6dGhpcy5faGFuZGxlS2V5Ym9hcmQuYmluZCh0aGlzKX0pLHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2smJnRoaXMuJGV4aXRlci5sZW5ndGgmJnRoaXMuJGV4aXRlci5vbih7XFxcImNsaWNrLnpmLm9mZmNhbnZhc1xcXCI6dGhpcy5jbG9zZS5iaW5kKHRoaXMpfSk7fX0se2tleTpcXFwiX3NldE1RQ2hlY2tlclxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzO3Qod2luZG93KS5vbihcXFwiY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5XFxcIixmdW5jdGlvbigpe0ZvdW5kYXRpb24uTWVkaWFRdWVyeS5hdExlYXN0KGUub3B0aW9ucy5yZXZlYWxPbik/ZS5yZXZlYWwoITApOmUucmV2ZWFsKCExKTt9KS5vbmUoXFxcImxvYWQuemYub2ZmY2FudmFzXFxcIixmdW5jdGlvbigpe0ZvdW5kYXRpb24uTWVkaWFRdWVyeS5hdExlYXN0KGUub3B0aW9ucy5yZXZlYWxPbikmJmUucmV2ZWFsKCEwKTt9KTt9fSx7a2V5OlxcXCJyZXZlYWxcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3ZhciBlPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiW2RhdGEtY2xvc2VdXFxcIik7dD8odGhpcy5jbG9zZSgpLHRoaXMuaXNSZXZlYWxlZD0hMCx0aGlzLiRlbGVtZW50Lm9mZihcXFwib3Blbi56Zi50cmlnZ2VyIHRvZ2dsZS56Zi50cmlnZ2VyXFxcIiksZS5sZW5ndGgmJmUuaGlkZSgpKToodGhpcy5pc1JldmVhbGVkPSExLHRoaXMuJGVsZW1lbnQub24oe1xcXCJvcGVuLnpmLnRyaWdnZXJcXFwiOnRoaXMub3Blbi5iaW5kKHRoaXMpLFxcXCJ0b2dnbGUuemYudHJpZ2dlclxcXCI6dGhpcy50b2dnbGUuYmluZCh0aGlzKX0pLGUubGVuZ3RoJiZlLnNob3coKSk7fX0se2tleTpcXFwib3BlblxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSxpKXtpZighdGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcXFwiaXMtb3BlblxcXCIpJiYhdGhpcy5pc1JldmVhbGVkKXt2YXIgbj10aGlzO3QoZG9jdW1lbnQuYm9keSk7dGhpcy5vcHRpb25zLmZvcmNlVG9wJiZ0KFxcXCJib2R5XFxcIikuc2Nyb2xsVG9wKDApLEZvdW5kYXRpb24uTW92ZSh0aGlzLm9wdGlvbnMudHJhbnNpdGlvblRpbWUsdGhpcy4kZWxlbWVudCxmdW5jdGlvbigpe3QoXFxcIltkYXRhLW9mZi1jYW52YXMtd3JhcHBlcl1cXFwiKS5hZGRDbGFzcyhcXFwiaXMtb2ZmLWNhbnZhcy1vcGVuIGlzLW9wZW4tXFxcIituLm9wdGlvbnMucG9zaXRpb24pLG4uJGVsZW1lbnQuYWRkQ2xhc3MoXFxcImlzLW9wZW5cXFwiKTt9KSx0aGlzLiR0cmlnZ2Vycy5hdHRyKFxcXCJhcmlhLWV4cGFuZGVkXFxcIixcXFwidHJ1ZVxcXCIpLHRoaXMuJGVsZW1lbnQuYXR0cihcXFwiYXJpYS1oaWRkZW5cXFwiLFxcXCJmYWxzZVxcXCIpLnRyaWdnZXIoXFxcIm9wZW5lZC56Zi5vZmZjYW52YXNcXFwiKSx0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrJiZ0aGlzLiRleGl0ZXIuYWRkQ2xhc3MoXFxcImlzLXZpc2libGVcXFwiKSxpJiYodGhpcy4kbGFzdFRyaWdnZXI9aSksdGhpcy5vcHRpb25zLmF1dG9Gb2N1cyYmdGhpcy4kZWxlbWVudC5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKHRoaXMuJGVsZW1lbnQpLGZ1bmN0aW9uKCl7bi4kZWxlbWVudC5maW5kKFxcXCJhLCBidXR0b25cXFwiKS5lcSgwKS5mb2N1cygpO30pLHRoaXMub3B0aW9ucy50cmFwRm9jdXMmJih0KFxcXCJbZGF0YS1vZmYtY2FudmFzLWNvbnRlbnRdXFxcIikuYXR0cihcXFwidGFiaW5kZXhcXFwiLFxcXCItMVxcXCIpLHRoaXMuX3RyYXBGb2N1cygpKTt9fX0se2tleTpcXFwiX3RyYXBGb2N1c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgdD1Gb3VuZGF0aW9uLktleWJvYXJkLmZpbmRGb2N1c2FibGUodGhpcy4kZWxlbWVudCksZT10LmVxKDApLGk9dC5lcSgtMSk7dC5vZmYoXFxcIi56Zi5vZmZjYW52YXNcXFwiKS5vbihcXFwia2V5ZG93bi56Zi5vZmZjYW52YXNcXFwiLGZ1bmN0aW9uKHQpezkhPT10LndoaWNoJiY5IT09dC5rZXljb2RlfHwodC50YXJnZXQhPT1pWzBdfHx0LnNoaWZ0S2V5fHwodC5wcmV2ZW50RGVmYXVsdCgpLGUuZm9jdXMoKSksdC50YXJnZXQ9PT1lWzBdJiZ0LnNoaWZ0S2V5JiYodC5wcmV2ZW50RGVmYXVsdCgpLGkuZm9jdXMoKSkpO30pO319LHtrZXk6XFxcImNsb3NlXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZShlKXtpZih0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFxcXCJpcy1vcGVuXFxcIikmJiF0aGlzLmlzUmV2ZWFsZWQpe3ZhciBpPXRoaXM7dChcXFwiW2RhdGEtb2ZmLWNhbnZhcy13cmFwcGVyXVxcXCIpLnJlbW92ZUNsYXNzKFxcXCJpcy1vZmYtY2FudmFzLW9wZW4gaXMtb3Blbi1cXFwiK2kub3B0aW9ucy5wb3NpdGlvbiksaS4kZWxlbWVudC5yZW1vdmVDbGFzcyhcXFwiaXMtb3BlblxcXCIpLHRoaXMuJGVsZW1lbnQuYXR0cihcXFwiYXJpYS1oaWRkZW5cXFwiLFxcXCJ0cnVlXFxcIikudHJpZ2dlcihcXFwiY2xvc2VkLnpmLm9mZmNhbnZhc1xcXCIpLHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2smJnRoaXMuJGV4aXRlci5yZW1vdmVDbGFzcyhcXFwiaXMtdmlzaWJsZVxcXCIpLHRoaXMuJHRyaWdnZXJzLmF0dHIoXFxcImFyaWEtZXhwYW5kZWRcXFwiLFxcXCJmYWxzZVxcXCIpLHRoaXMub3B0aW9ucy50cmFwRm9jdXMmJnQoXFxcIltkYXRhLW9mZi1jYW52YXMtY29udGVudF1cXFwiKS5yZW1vdmVBdHRyKFxcXCJ0YWJpbmRleFxcXCIpO319fSx7a2V5OlxcXCJ0b2dnbGVcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQsZSl7dGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcXFwiaXMtb3BlblxcXCIpP3RoaXMuY2xvc2UodCxlKTp0aGlzLm9wZW4odCxlKTt9fSx7a2V5OlxcXCJfaGFuZGxlS2V5Ym9hcmRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpezI3PT09dC53aGljaCYmKHQuc3RvcFByb3BhZ2F0aW9uKCksdC5wcmV2ZW50RGVmYXVsdCgpLHRoaXMuY2xvc2UoKSx0aGlzLiRsYXN0VHJpZ2dlci5mb2N1cygpKTt9fSx7a2V5OlxcXCJkZXN0cm95XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuY2xvc2UoKSx0aGlzLiRlbGVtZW50Lm9mZihcXFwiLnpmLnRyaWdnZXIgLnpmLm9mZmNhbnZhc1xcXCIpLHRoaXMuJGV4aXRlci5vZmYoXFxcIi56Zi5vZmZjYW52YXNcXFwiKSxGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKSxlO30oKTtlLmRlZmF1bHRzPXtjbG9zZU9uQ2xpY2s6ITAsdHJhbnNpdGlvblRpbWU6MCxwb3NpdGlvbjpcXFwibGVmdFxcXCIsZm9yY2VUb3A6ITAsaXNSZXZlYWxlZDohMSxyZXZlYWxPbjpudWxsLGF1dG9Gb2N1czohMCxyZXZlYWxDbGFzczpcXFwicmV2ZWFsLWZvci1cXFwiLHRyYXBGb2N1czohMX0sRm91bmRhdGlvbi5wbHVnaW4oZSxcXFwiT2ZmQ2FudmFzXFxcIik7fShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXFxcInZhbHVlXFxcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLmtleSxuKTt9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGU7fTt9KCk7IWZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShpLG4pe19jbGFzc0NhbGxDaGVjayh0aGlzLGUpLHRoaXMuJGVsZW1lbnQ9aSx0aGlzLm9wdGlvbnM9dC5leHRlbmQoe30sZS5kZWZhdWx0cyx0aGlzLiRlbGVtZW50LmRhdGEoKSxuKSx0aGlzLl9pbml0KCksRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLFxcXCJPcmJpdFxcXCIpLEZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIoXFxcIk9yYml0XFxcIix7bHRyOntBUlJPV19SSUdIVDpcXFwibmV4dFxcXCIsQVJST1dfTEVGVDpcXFwicHJldmlvdXNcXFwifSxydGw6e0FSUk9XX0xFRlQ6XFxcIm5leHRcXFwiLEFSUk9XX1JJR0hUOlxcXCJwcmV2aW91c1xcXCJ9fSk7fXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcXFwiX2luaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy4kd3JhcHBlcj10aGlzLiRlbGVtZW50LmZpbmQoXFxcIi5cXFwiK3RoaXMub3B0aW9ucy5jb250YWluZXJDbGFzcyksdGhpcy4kc2xpZGVzPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiLlxcXCIrdGhpcy5vcHRpb25zLnNsaWRlQ2xhc3MpO3ZhciB0PXRoaXMuJGVsZW1lbnQuZmluZChcXFwiaW1nXFxcIiksZT10aGlzLiRzbGlkZXMuZmlsdGVyKFxcXCIuaXMtYWN0aXZlXFxcIik7ZS5sZW5ndGh8fHRoaXMuJHNsaWRlcy5lcSgwKS5hZGRDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIiksdGhpcy5vcHRpb25zLnVzZU1VSXx8dGhpcy4kc2xpZGVzLmFkZENsYXNzKFxcXCJuby1tb3Rpb251aVxcXCIpLHQubGVuZ3RoP0ZvdW5kYXRpb24ub25JbWFnZXNMb2FkZWQodCx0aGlzLl9wcmVwYXJlRm9yT3JiaXQuYmluZCh0aGlzKSk6dGhpcy5fcHJlcGFyZUZvck9yYml0KCksdGhpcy5vcHRpb25zLmJ1bGxldHMmJnRoaXMuX2xvYWRCdWxsZXRzKCksdGhpcy5fZXZlbnRzKCksdGhpcy5vcHRpb25zLmF1dG9QbGF5JiZ0aGlzLiRzbGlkZXMubGVuZ3RoPjEmJnRoaXMuZ2VvU3luYygpLHRoaXMub3B0aW9ucy5hY2Nlc3NpYmxlJiZ0aGlzLiR3cmFwcGVyLmF0dHIoXFxcInRhYmluZGV4XFxcIiwwKTt9fSx7a2V5OlxcXCJfbG9hZEJ1bGxldHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy4kYnVsbGV0cz10aGlzLiRlbGVtZW50LmZpbmQoXFxcIi5cXFwiK3RoaXMub3B0aW9ucy5ib3hPZkJ1bGxldHMpLmZpbmQoXFxcImJ1dHRvblxcXCIpO319LHtrZXk6XFxcImdlb1N5bmNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIHQ9dGhpczt0aGlzLnRpbWVyPW5ldyBGb3VuZGF0aW9uLlRpbWVyKHRoaXMuJGVsZW1lbnQse2R1cmF0aW9uOnRoaXMub3B0aW9ucy50aW1lckRlbGF5LGluZmluaXRlOiExfSxmdW5jdGlvbigpe3QuY2hhbmdlU2xpZGUoITApO30pLHRoaXMudGltZXIuc3RhcnQoKTt9fSx7a2V5OlxcXCJfcHJlcGFyZUZvck9yYml0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciB0PXRoaXM7dGhpcy5fc2V0V3JhcHBlckhlaWdodChmdW5jdGlvbihlKXt0Ll9zZXRTbGlkZUhlaWdodChlKTt9KTt9fSx7a2V5OlxcXCJfc2V0V3JhcHBlckhlaWdodFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSl7dmFyIGksbj0wLHM9MDt0aGlzLiRzbGlkZXMuZWFjaChmdW5jdGlvbigpe2k9dGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQsdCh0aGlzKS5hdHRyKFxcXCJkYXRhLXNsaWRlXFxcIixzKSxzJiZ0KHRoaXMpLmNzcyh7cG9zaXRpb246XFxcInJlbGF0aXZlXFxcIixkaXNwbGF5OlxcXCJub25lXFxcIn0pLG49aT5uP2k6bixzKys7fSkscz09PXRoaXMuJHNsaWRlcy5sZW5ndGgmJih0aGlzLiR3cmFwcGVyLmNzcyh7aGVpZ2h0Om59KSxlKG4pKTt9fSx7a2V5OlxcXCJfc2V0U2xpZGVIZWlnaHRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKGUpe3RoaXMuJHNsaWRlcy5lYWNoKGZ1bmN0aW9uKCl7dCh0aGlzKS5jc3MoXFxcIm1heC1oZWlnaHRcXFwiLGUpO30pO319LHtrZXk6XFxcIl9ldmVudHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpcztpZih0aGlzLiRzbGlkZXMubGVuZ3RoPjEpe2lmKHRoaXMub3B0aW9ucy5zd2lwZSYmdGhpcy4kc2xpZGVzLm9mZihcXFwic3dpcGVsZWZ0LnpmLm9yYml0IHN3aXBlcmlnaHQuemYub3JiaXRcXFwiKS5vbihcXFwic3dpcGVsZWZ0LnpmLm9yYml0XFxcIixmdW5jdGlvbih0KXt0LnByZXZlbnREZWZhdWx0KCksZS5jaGFuZ2VTbGlkZSghMCk7fSkub24oXFxcInN3aXBlcmlnaHQuemYub3JiaXRcXFwiLGZ1bmN0aW9uKHQpe3QucHJldmVudERlZmF1bHQoKSxlLmNoYW5nZVNsaWRlKCExKTt9KSx0aGlzLm9wdGlvbnMuYXV0b1BsYXkmJih0aGlzLiRzbGlkZXMub24oXFxcImNsaWNrLnpmLm9yYml0XFxcIixmdW5jdGlvbigpe2UuJGVsZW1lbnQuZGF0YShcXFwiY2xpY2tlZE9uXFxcIiwhZS4kZWxlbWVudC5kYXRhKFxcXCJjbGlja2VkT25cXFwiKSksZS50aW1lcltlLiRlbGVtZW50LmRhdGEoXFxcImNsaWNrZWRPblxcXCIpP1xcXCJwYXVzZVxcXCI6XFxcInN0YXJ0XFxcIl0oKTt9KSx0aGlzLm9wdGlvbnMucGF1c2VPbkhvdmVyJiZ0aGlzLiRlbGVtZW50Lm9uKFxcXCJtb3VzZWVudGVyLnpmLm9yYml0XFxcIixmdW5jdGlvbigpe2UudGltZXIucGF1c2UoKTt9KS5vbihcXFwibW91c2VsZWF2ZS56Zi5vcmJpdFxcXCIsZnVuY3Rpb24oKXtlLiRlbGVtZW50LmRhdGEoXFxcImNsaWNrZWRPblxcXCIpfHxlLnRpbWVyLnN0YXJ0KCk7fSkpLHRoaXMub3B0aW9ucy5uYXZCdXR0b25zKXt2YXIgaT10aGlzLiRlbGVtZW50LmZpbmQoXFxcIi5cXFwiK3RoaXMub3B0aW9ucy5uZXh0Q2xhc3MrXFxcIiwgLlxcXCIrdGhpcy5vcHRpb25zLnByZXZDbGFzcyk7aS5hdHRyKFxcXCJ0YWJpbmRleFxcXCIsMCkub24oXFxcImNsaWNrLnpmLm9yYml0IHRvdWNoZW5kLnpmLm9yYml0XFxcIixmdW5jdGlvbihpKXtpLnByZXZlbnREZWZhdWx0KCksZS5jaGFuZ2VTbGlkZSh0KHRoaXMpLmhhc0NsYXNzKGUub3B0aW9ucy5uZXh0Q2xhc3MpKTt9KTt9dGhpcy5vcHRpb25zLmJ1bGxldHMmJnRoaXMuJGJ1bGxldHMub24oXFxcImNsaWNrLnpmLm9yYml0IHRvdWNoZW5kLnpmLm9yYml0XFxcIixmdW5jdGlvbigpe2lmKC9pcy1hY3RpdmUvZy50ZXN0KHRoaXMuY2xhc3NOYW1lKSlyZXR1cm4hMTt2YXIgaT10KHRoaXMpLmRhdGEoXFxcInNsaWRlXFxcIiksbj1pPmUuJHNsaWRlcy5maWx0ZXIoXFxcIi5pcy1hY3RpdmVcXFwiKS5kYXRhKFxcXCJzbGlkZVxcXCIpLHM9ZS4kc2xpZGVzLmVxKGkpO2UuY2hhbmdlU2xpZGUobixzLGkpO30pLHRoaXMuJHdyYXBwZXIuYWRkKHRoaXMuJGJ1bGxldHMpLm9uKFxcXCJrZXlkb3duLnpmLm9yYml0XFxcIixmdW5jdGlvbihpKXtGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShpLFxcXCJPcmJpdFxcXCIse25leHQ6ZnVuY3Rpb24gbmV4dCgpe2UuY2hhbmdlU2xpZGUoITApO30scHJldmlvdXM6ZnVuY3Rpb24gcHJldmlvdXMoKXtlLmNoYW5nZVNsaWRlKCExKTt9LGhhbmRsZWQ6ZnVuY3Rpb24gaGFuZGxlZCgpe3QoaS50YXJnZXQpLmlzKGUuJGJ1bGxldHMpJiZlLiRidWxsZXRzLmZpbHRlcihcXFwiLmlzLWFjdGl2ZVxcXCIpLmZvY3VzKCk7fX0pO30pO319fSx7a2V5OlxcXCJjaGFuZ2VTbGlkZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCxlLGkpe3ZhciBuPXRoaXMuJHNsaWRlcy5maWx0ZXIoXFxcIi5pcy1hY3RpdmVcXFwiKS5lcSgwKTtpZigvbXVpL2cudGVzdChuWzBdLmNsYXNzTmFtZSkpcmV0dXJuITE7dmFyIHMsbz10aGlzLiRzbGlkZXMuZmlyc3QoKSxhPXRoaXMuJHNsaWRlcy5sYXN0KCkscj10P1xcXCJSaWdodFxcXCI6XFxcIkxlZnRcXFwiLGw9dD9cXFwiTGVmdFxcXCI6XFxcIlJpZ2h0XFxcIix1PXRoaXM7cz1lP2U6dD90aGlzLm9wdGlvbnMuaW5maW5pdGVXcmFwP24ubmV4dChcXFwiLlxcXCIrdGhpcy5vcHRpb25zLnNsaWRlQ2xhc3MpLmxlbmd0aD9uLm5leHQoXFxcIi5cXFwiK3RoaXMub3B0aW9ucy5zbGlkZUNsYXNzKTpvOm4ubmV4dChcXFwiLlxcXCIrdGhpcy5vcHRpb25zLnNsaWRlQ2xhc3MpOnRoaXMub3B0aW9ucy5pbmZpbml0ZVdyYXA/bi5wcmV2KFxcXCIuXFxcIit0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcykubGVuZ3RoP24ucHJldihcXFwiLlxcXCIrdGhpcy5vcHRpb25zLnNsaWRlQ2xhc3MpOmE6bi5wcmV2KFxcXCIuXFxcIit0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcykscy5sZW5ndGgmJih0aGlzLm9wdGlvbnMuYnVsbGV0cyYmKGk9aXx8dGhpcy4kc2xpZGVzLmluZGV4KHMpLHRoaXMuX3VwZGF0ZUJ1bGxldHMoaSkpLHRoaXMub3B0aW9ucy51c2VNVUk/KEZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVJbihzLmFkZENsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKS5jc3Moe3Bvc2l0aW9uOlxcXCJhYnNvbHV0ZVxcXCIsdG9wOjB9KSx0aGlzLm9wdGlvbnNbXFxcImFuaW1JbkZyb21cXFwiK3JdLGZ1bmN0aW9uKCl7cy5jc3Moe3Bvc2l0aW9uOlxcXCJyZWxhdGl2ZVxcXCIsZGlzcGxheTpcXFwiYmxvY2tcXFwifSkuYXR0cihcXFwiYXJpYS1saXZlXFxcIixcXFwicG9saXRlXFxcIik7fSksRm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZU91dChuLnJlbW92ZUNsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKSx0aGlzLm9wdGlvbnNbXFxcImFuaW1PdXRUb1xcXCIrbF0sZnVuY3Rpb24oKXtuLnJlbW92ZUF0dHIoXFxcImFyaWEtbGl2ZVxcXCIpLHUub3B0aW9ucy5hdXRvUGxheSYmIXUudGltZXIuaXNQYXVzZWQmJnUudGltZXIucmVzdGFydCgpO30pKToobi5yZW1vdmVDbGFzcyhcXFwiaXMtYWN0aXZlIGlzLWluXFxcIikucmVtb3ZlQXR0cihcXFwiYXJpYS1saXZlXFxcIikuaGlkZSgpLHMuYWRkQ2xhc3MoXFxcImlzLWFjdGl2ZSBpcy1pblxcXCIpLmF0dHIoXFxcImFyaWEtbGl2ZVxcXCIsXFxcInBvbGl0ZVxcXCIpLnNob3coKSx0aGlzLm9wdGlvbnMuYXV0b1BsYXkmJiF0aGlzLnRpbWVyLmlzUGF1c2VkJiZ0aGlzLnRpbWVyLnJlc3RhcnQoKSksdGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJzbGlkZWNoYW5nZS56Zi5vcmJpdFxcXCIsW3NdKSk7fX0se2tleTpcXFwiX3VwZGF0ZUJ1bGxldHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3ZhciBlPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiLlxcXCIrdGhpcy5vcHRpb25zLmJveE9mQnVsbGV0cykuZmluZChcXFwiLmlzLWFjdGl2ZVxcXCIpLnJlbW92ZUNsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKS5ibHVyKCksaT1lLmZpbmQoXFxcInNwYW46bGFzdFxcXCIpLmRldGFjaCgpO3RoaXMuJGJ1bGxldHMuZXEodCkuYWRkQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpLmFwcGVuZChpKTt9fSx7a2V5OlxcXCJkZXN0cm95XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuJGVsZW1lbnQub2ZmKFxcXCIuemYub3JiaXRcXFwiKS5maW5kKFxcXCIqXFxcIikub2ZmKFxcXCIuemYub3JiaXRcXFwiKS5lbmQoKS5oaWRlKCksRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSksZTt9KCk7ZS5kZWZhdWx0cz17YnVsbGV0czohMCxuYXZCdXR0b25zOiEwLGFuaW1JbkZyb21SaWdodDpcXFwic2xpZGUtaW4tcmlnaHRcXFwiLGFuaW1PdXRUb1JpZ2h0OlxcXCJzbGlkZS1vdXQtcmlnaHRcXFwiLGFuaW1JbkZyb21MZWZ0OlxcXCJzbGlkZS1pbi1sZWZ0XFxcIixhbmltT3V0VG9MZWZ0OlxcXCJzbGlkZS1vdXQtbGVmdFxcXCIsYXV0b1BsYXk6ITAsdGltZXJEZWxheTo1ZTMsaW5maW5pdGVXcmFwOiEwLHN3aXBlOiEwLHBhdXNlT25Ib3ZlcjohMCxhY2Nlc3NpYmxlOiEwLGNvbnRhaW5lckNsYXNzOlxcXCJvcmJpdC1jb250YWluZXJcXFwiLHNsaWRlQ2xhc3M6XFxcIm9yYml0LXNsaWRlXFxcIixib3hPZkJ1bGxldHM6XFxcIm9yYml0LWJ1bGxldHNcXFwiLG5leHRDbGFzczpcXFwib3JiaXQtbmV4dFxcXCIscHJldkNsYXNzOlxcXCJvcmJpdC1wcmV2aW91c1xcXCIsdXNlTVVJOiEwfSxGb3VuZGF0aW9uLnBsdWdpbihlLFxcXCJPcmJpdFxcXCIpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbj1lW2ldO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFxcXCJ2YWx1ZVxcXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbik7fX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlO307fSgpOyFmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PXQoaSksdGhpcy5ydWxlcz10aGlzLiRlbGVtZW50LmRhdGEoXFxcInJlc3BvbnNpdmUtbWVudVxcXCIpLHRoaXMuY3VycmVudE1xPW51bGwsdGhpcy5jdXJyZW50UGx1Z2luPW51bGwsdGhpcy5faW5pdCgpLHRoaXMuX2V2ZW50cygpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcXFwiUmVzcG9uc2l2ZU1lbnVcXFwiKTt9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLFt7a2V5OlxcXCJfaW5pdFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXtpZihcXFwic3RyaW5nXFxcIj09dHlwZW9mIHRoaXMucnVsZXMpe2Zvcih2YXIgZT17fSxuPXRoaXMucnVsZXMuc3BsaXQoXFxcIiBcXFwiKSxzPTA7czxuLmxlbmd0aDtzKyspe3ZhciBvPW5bc10uc3BsaXQoXFxcIi1cXFwiKSxhPW8ubGVuZ3RoPjE/b1swXTpcXFwic21hbGxcXFwiLHI9by5sZW5ndGg+MT9vWzFdOm9bMF07bnVsbCE9PWlbcl0mJihlW2FdPWlbcl0pO310aGlzLnJ1bGVzPWU7fXQuaXNFbXB0eU9iamVjdCh0aGlzLnJ1bGVzKXx8dGhpcy5fY2hlY2tNZWRpYVF1ZXJpZXMoKTt9fSx7a2V5OlxcXCJfZXZlbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXM7dCh3aW5kb3cpLm9uKFxcXCJjaGFuZ2VkLnpmLm1lZGlhcXVlcnlcXFwiLGZ1bmN0aW9uKCl7ZS5fY2hlY2tNZWRpYVF1ZXJpZXMoKTt9KTt9fSx7a2V5OlxcXCJfY2hlY2tNZWRpYVF1ZXJpZXNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGUsbj10aGlzO3QuZWFjaCh0aGlzLnJ1bGVzLGZ1bmN0aW9uKHQpe0ZvdW5kYXRpb24uTWVkaWFRdWVyeS5hdExlYXN0KHQpJiYoZT10KTt9KSxlJiYodGhpcy5jdXJyZW50UGx1Z2luIGluc3RhbmNlb2YgdGhpcy5ydWxlc1tlXS5wbHVnaW58fCh0LmVhY2goaSxmdW5jdGlvbih0LGUpe24uJGVsZW1lbnQucmVtb3ZlQ2xhc3MoZS5jc3NDbGFzcyk7fSksdGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLnJ1bGVzW2VdLmNzc0NsYXNzKSx0aGlzLmN1cnJlbnRQbHVnaW4mJnRoaXMuY3VycmVudFBsdWdpbi5kZXN0cm95KCksdGhpcy5jdXJyZW50UGx1Z2luPW5ldyB0aGlzLnJ1bGVzW2VdLnBsdWdpbih0aGlzLiRlbGVtZW50LHt9KSkpO319LHtrZXk6XFxcImRlc3Ryb3lcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy5jdXJyZW50UGx1Z2luLmRlc3Ryb3koKSx0KHdpbmRvdykub2ZmKFxcXCIuemYuUmVzcG9uc2l2ZU1lbnVcXFwiKSxGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKSxlO30oKTtlLmRlZmF1bHRzPXt9O3ZhciBpPXtkcm9wZG93bjp7Y3NzQ2xhc3M6XFxcImRyb3Bkb3duXFxcIixwbHVnaW46Rm91bmRhdGlvbi5fcGx1Z2luc1tcXFwiZHJvcGRvd24tbWVudVxcXCJdfHxudWxsfSxkcmlsbGRvd246e2Nzc0NsYXNzOlxcXCJkcmlsbGRvd25cXFwiLHBsdWdpbjpGb3VuZGF0aW9uLl9wbHVnaW5zLmRyaWxsZG93bnx8bnVsbH0sYWNjb3JkaW9uOntjc3NDbGFzczpcXFwiYWNjb3JkaW9uLW1lbnVcXFwiLHBsdWdpbjpGb3VuZGF0aW9uLl9wbHVnaW5zW1xcXCJhY2NvcmRpb24tbWVudVxcXCJdfHxudWxsfX07Rm91bmRhdGlvbi5wbHVnaW4oZSxcXFwiUmVzcG9uc2l2ZU1lbnVcXFwiKTt9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcXFwidmFsdWVcXFwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pO319cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZTt9O30oKTshZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGksbil7X2NsYXNzQ2FsbENoZWNrKHRoaXMsZSksdGhpcy4kZWxlbWVudD10KGkpLHRoaXMub3B0aW9ucz10LmV4dGVuZCh7fSxlLmRlZmF1bHRzLHRoaXMuJGVsZW1lbnQuZGF0YSgpLG4pLHRoaXMuX2luaXQoKSx0aGlzLl9ldmVudHMoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXFxcIlJlc3BvbnNpdmVUb2dnbGVcXFwiKTt9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLFt7a2V5OlxcXCJfaW5pdFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzLiRlbGVtZW50LmRhdGEoXFxcInJlc3BvbnNpdmUtdG9nZ2xlXFxcIik7ZXx8Y29uc29sZS5lcnJvcihcXFwiWW91ciB0YWIgYmFyIG5lZWRzIGFuIElEIG9mIGEgTWVudSBhcyB0aGUgdmFsdWUgb2YgZGF0YS10YWItYmFyLlxcXCIpLHRoaXMuJHRhcmdldE1lbnU9dChcXFwiI1xcXCIrZSksdGhpcy4kdG9nZ2xlcj10aGlzLiRlbGVtZW50LmZpbmQoXFxcIltkYXRhLXRvZ2dsZV1cXFwiKSx0aGlzLl91cGRhdGUoKTt9fSx7a2V5OlxcXCJfZXZlbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuX3VwZGF0ZU1xSGFuZGxlcj10aGlzLl91cGRhdGUuYmluZCh0aGlzKSx0KHdpbmRvdykub24oXFxcImNoYW5nZWQuemYubWVkaWFxdWVyeVxcXCIsdGhpcy5fdXBkYXRlTXFIYW5kbGVyKSx0aGlzLiR0b2dnbGVyLm9uKFxcXCJjbGljay56Zi5yZXNwb25zaXZlVG9nZ2xlXFxcIix0aGlzLnRvZ2dsZU1lbnUuYmluZCh0aGlzKSk7fX0se2tleTpcXFwiX3VwZGF0ZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXtGb3VuZGF0aW9uLk1lZGlhUXVlcnkuYXRMZWFzdCh0aGlzLm9wdGlvbnMuaGlkZUZvcik/KHRoaXMuJGVsZW1lbnQuaGlkZSgpLHRoaXMuJHRhcmdldE1lbnUuc2hvdygpKToodGhpcy4kZWxlbWVudC5zaG93KCksdGhpcy4kdGFyZ2V0TWVudS5oaWRlKCkpO319LHtrZXk6XFxcInRvZ2dsZU1lbnVcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7Rm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmF0TGVhc3QodGhpcy5vcHRpb25zLmhpZGVGb3IpfHwodGhpcy4kdGFyZ2V0TWVudS50b2dnbGUoMCksdGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJ0b2dnbGVkLnpmLnJlc3BvbnNpdmVUb2dnbGVcXFwiKSk7fX0se2tleTpcXFwiZGVzdHJveVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLiRlbGVtZW50Lm9mZihcXFwiLnpmLnJlc3BvbnNpdmVUb2dnbGVcXFwiKSx0aGlzLiR0b2dnbGVyLm9mZihcXFwiLnpmLnJlc3BvbnNpdmVUb2dnbGVcXFwiKSx0KHdpbmRvdykub2ZmKFxcXCJjaGFuZ2VkLnpmLm1lZGlhcXVlcnlcXFwiLHRoaXMuX3VwZGF0ZU1xSGFuZGxlciksRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSksZTt9KCk7ZS5kZWZhdWx0cz17aGlkZUZvcjpcXFwibWVkaXVtXFxcIn0sRm91bmRhdGlvbi5wbHVnaW4oZSxcXFwiUmVzcG9uc2l2ZVRvZ2dsZVxcXCIpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbj1lW2ldO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFxcXCJ2YWx1ZVxcXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbik7fX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlO307fSgpOyFmdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7cmV0dXJuIC9pUChhZHxob25lfG9kKS4qT1MvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO31mdW5jdGlvbiBpKCl7cmV0dXJuIC9BbmRyb2lkLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTt9ZnVuY3Rpb24gbigpe3JldHVybiBlKCl8fGkoKTt9dmFyIHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGksbil7X2NsYXNzQ2FsbENoZWNrKHRoaXMsZSksdGhpcy4kZWxlbWVudD1pLHRoaXMub3B0aW9ucz10LmV4dGVuZCh7fSxlLmRlZmF1bHRzLHRoaXMuJGVsZW1lbnQuZGF0YSgpLG4pLHRoaXMuX2luaXQoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXFxcIlJldmVhbFxcXCIpLEZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIoXFxcIlJldmVhbFxcXCIse0VOVEVSOlxcXCJvcGVuXFxcIixTUEFDRTpcXFwib3BlblxcXCIsRVNDQVBFOlxcXCJjbG9zZVxcXCIsVEFCOlxcXCJ0YWJfZm9yd2FyZFxcXCIsU0hJRlRfVEFCOlxcXCJ0YWJfYmFja3dhcmRcXFwifSk7fXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcXFwiX2luaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy5pZD10aGlzLiRlbGVtZW50LmF0dHIoXFxcImlkXFxcIiksdGhpcy5pc0FjdGl2ZT0hMSx0aGlzLmNhY2hlZD17bXE6Rm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmN1cnJlbnR9LHRoaXMuaXNNb2JpbGU9bigpLHRoaXMuJGFuY2hvcj10KHQoJ1tkYXRhLW9wZW49XFxcIicrdGhpcy5pZCsnXFxcIl0nKS5sZW5ndGg/J1tkYXRhLW9wZW49XFxcIicrdGhpcy5pZCsnXFxcIl0nOidbZGF0YS10b2dnbGU9XFxcIicrdGhpcy5pZCsnXFxcIl0nKSx0aGlzLiRhbmNob3IuYXR0cih7XFxcImFyaWEtY29udHJvbHNcXFwiOnRoaXMuaWQsXFxcImFyaWEtaGFzcG9wdXBcXFwiOiEwLHRhYmluZGV4OjB9KSwodGhpcy5vcHRpb25zLmZ1bGxTY3JlZW58fHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXFxcImZ1bGxcXFwiKSkmJih0aGlzLm9wdGlvbnMuZnVsbFNjcmVlbj0hMCx0aGlzLm9wdGlvbnMub3ZlcmxheT0hMSksdGhpcy5vcHRpb25zLm92ZXJsYXkmJiF0aGlzLiRvdmVybGF5JiYodGhpcy4kb3ZlcmxheT10aGlzLl9tYWtlT3ZlcmxheSh0aGlzLmlkKSksdGhpcy4kZWxlbWVudC5hdHRyKHtyb2xlOlxcXCJkaWFsb2dcXFwiLFxcXCJhcmlhLWhpZGRlblxcXCI6ITAsXFxcImRhdGEteWV0aS1ib3hcXFwiOnRoaXMuaWQsXFxcImRhdGEtcmVzaXplXFxcIjp0aGlzLmlkfSksdGhpcy4kb3ZlcmxheT90aGlzLiRlbGVtZW50LmRldGFjaCgpLmFwcGVuZFRvKHRoaXMuJG92ZXJsYXkpOih0aGlzLiRlbGVtZW50LmRldGFjaCgpLmFwcGVuZFRvKHQoXFxcImJvZHlcXFwiKSksdGhpcy4kZWxlbWVudC5hZGRDbGFzcyhcXFwid2l0aG91dC1vdmVybGF5XFxcIikpLHRoaXMuX2V2ZW50cygpLHRoaXMub3B0aW9ucy5kZWVwTGluayYmd2luZG93LmxvY2F0aW9uLmhhc2g9PT1cXFwiI1xcXCIrdGhpcy5pZCYmdCh3aW5kb3cpLm9uZShcXFwibG9hZC56Zi5yZXZlYWxcXFwiLHRoaXMub3Blbi5iaW5kKHRoaXMpKTt9fSx7a2V5OlxcXCJfbWFrZU92ZXJsYXlcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKGUpe3ZhciBpPXQoXFxcIjxkaXY+PC9kaXY+XFxcIikuYWRkQ2xhc3MoXFxcInJldmVhbC1vdmVybGF5XFxcIikuYXBwZW5kVG8oXFxcImJvZHlcXFwiKTtyZXR1cm4gaTt9fSx7a2V5OlxcXCJfdXBkYXRlUG9zaXRpb25cXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGUsaSxuPXRoaXMuJGVsZW1lbnQub3V0ZXJXaWR0aCgpLHM9dCh3aW5kb3cpLndpZHRoKCksbz10aGlzLiRlbGVtZW50Lm91dGVySGVpZ2h0KCksYT10KHdpbmRvdykuaGVpZ2h0KCk7ZT1cXFwiYXV0b1xcXCI9PT10aGlzLm9wdGlvbnMuaE9mZnNldD9wYXJzZUludCgocy1uKS8yLDEwKTpwYXJzZUludCh0aGlzLm9wdGlvbnMuaE9mZnNldCwxMCksaT1cXFwiYXV0b1xcXCI9PT10aGlzLm9wdGlvbnMudk9mZnNldD9vPmE/cGFyc2VJbnQoTWF0aC5taW4oMTAwLGEvMTApLDEwKTpwYXJzZUludCgoYS1vKS80LDEwKTpwYXJzZUludCh0aGlzLm9wdGlvbnMudk9mZnNldCwxMCksdGhpcy4kZWxlbWVudC5jc3Moe3RvcDppK1xcXCJweFxcXCJ9KSx0aGlzLiRvdmVybGF5JiZcXFwiYXV0b1xcXCI9PT10aGlzLm9wdGlvbnMuaE9mZnNldHx8KHRoaXMuJGVsZW1lbnQuY3NzKHtsZWZ0OmUrXFxcInB4XFxcIn0pLHRoaXMuJGVsZW1lbnQuY3NzKHttYXJnaW46XFxcIjBweFxcXCJ9KSk7fX0se2tleTpcXFwiX2V2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzLGk9dGhpczt0aGlzLiRlbGVtZW50Lm9uKHtcXFwib3Blbi56Zi50cmlnZ2VyXFxcIjp0aGlzLm9wZW4uYmluZCh0aGlzKSxcXFwiY2xvc2UuemYudHJpZ2dlclxcXCI6ZnVuY3Rpb24gY2xvc2VaZlRyaWdnZXIobixzKXtyZXR1cm4gbi50YXJnZXQ9PT1pLiRlbGVtZW50WzBdfHx0KG4udGFyZ2V0KS5wYXJlbnRzKFxcXCJbZGF0YS1jbG9zYWJsZV1cXFwiKVswXT09PXM/ZS5jbG9zZS5hcHBseShlKTp2b2lkIDA7fSxcXFwidG9nZ2xlLnpmLnRyaWdnZXJcXFwiOnRoaXMudG9nZ2xlLmJpbmQodGhpcyksXFxcInJlc2l6ZW1lLnpmLnRyaWdnZXJcXFwiOmZ1bmN0aW9uIHJlc2l6ZW1lWmZUcmlnZ2VyKCl7aS5fdXBkYXRlUG9zaXRpb24oKTt9fSksdGhpcy4kYW5jaG9yLmxlbmd0aCYmdGhpcy4kYW5jaG9yLm9uKFxcXCJrZXlkb3duLnpmLnJldmVhbFxcXCIsZnVuY3Rpb24odCl7MTMhPT10LndoaWNoJiYzMiE9PXQud2hpY2h8fCh0LnN0b3BQcm9wYWdhdGlvbigpLHQucHJldmVudERlZmF1bHQoKSxpLm9wZW4oKSk7fSksdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayYmdGhpcy5vcHRpb25zLm92ZXJsYXkmJnRoaXMuJG92ZXJsYXkub2ZmKFxcXCIuemYucmV2ZWFsXFxcIikub24oXFxcImNsaWNrLnpmLnJldmVhbFxcXCIsZnVuY3Rpb24oZSl7ZS50YXJnZXQ9PT1pLiRlbGVtZW50WzBdfHx0LmNvbnRhaW5zKGkuJGVsZW1lbnRbMF0sZS50YXJnZXQpfHxpLmNsb3NlKCk7fSksdGhpcy5vcHRpb25zLmRlZXBMaW5rJiZ0KHdpbmRvdykub24oXFxcInBvcHN0YXRlLnpmLnJldmVhbDpcXFwiK3RoaXMuaWQsdGhpcy5faGFuZGxlU3RhdGUuYmluZCh0aGlzKSk7fX0se2tleTpcXFwiX2hhbmRsZVN0YXRlXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt3aW5kb3cubG9jYXRpb24uaGFzaCE9PVxcXCIjXFxcIit0aGlzLmlkfHx0aGlzLmlzQWN0aXZlP3RoaXMuY2xvc2UoKTp0aGlzLm9wZW4oKTt9fSx7a2V5OlxcXCJvcGVuXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXM7aWYodGhpcy5vcHRpb25zLmRlZXBMaW5rKXt2YXIgaT1cXFwiI1xcXCIrdGhpcy5pZDt3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGU/d2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKG51bGwsbnVsbCxpKTp3aW5kb3cubG9jYXRpb24uaGFzaD1pO31pZih0aGlzLmlzQWN0aXZlPSEwLHRoaXMuJGVsZW1lbnQuY3NzKHt2aXNpYmlsaXR5OlxcXCJoaWRkZW5cXFwifSkuc2hvdygpLnNjcm9sbFRvcCgwKSx0aGlzLm9wdGlvbnMub3ZlcmxheSYmdGhpcy4kb3ZlcmxheS5jc3Moe3Zpc2liaWxpdHk6XFxcImhpZGRlblxcXCJ9KS5zaG93KCksdGhpcy5fdXBkYXRlUG9zaXRpb24oKSx0aGlzLiRlbGVtZW50LmhpZGUoKS5jc3Moe3Zpc2liaWxpdHk6XFxcIlxcXCJ9KSx0aGlzLiRvdmVybGF5JiYodGhpcy4kb3ZlcmxheS5jc3Moe3Zpc2liaWxpdHk6XFxcIlxcXCJ9KS5oaWRlKCksdGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcXFwiZmFzdFxcXCIpP3RoaXMuJG92ZXJsYXkuYWRkQ2xhc3MoXFxcImZhc3RcXFwiKTp0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFxcXCJzbG93XFxcIikmJnRoaXMuJG92ZXJsYXkuYWRkQ2xhc3MoXFxcInNsb3dcXFwiKSksdGhpcy5vcHRpb25zLm11bHRpcGxlT3BlbmVkfHx0aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcImNsb3NlbWUuemYucmV2ZWFsXFxcIix0aGlzLmlkKSx0aGlzLm9wdGlvbnMuYW5pbWF0aW9uSW4pe3ZhciBuOyFmdW5jdGlvbigpe3ZhciB0PWZ1bmN0aW9uIHQoKXtuLiRlbGVtZW50LmF0dHIoe1xcXCJhcmlhLWhpZGRlblxcXCI6ITEsdGFiaW5kZXg6LTF9KS5mb2N1cygpLGNvbnNvbGUubG9nKFxcXCJmb2N1c1xcXCIpO307bj1lLGUub3B0aW9ucy5vdmVybGF5JiZGb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlSW4oZS4kb3ZlcmxheSxcXFwiZmFkZS1pblxcXCIpLEZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVJbihlLiRlbGVtZW50LGUub3B0aW9ucy5hbmltYXRpb25JbixmdW5jdGlvbigpe2UuZm9jdXNhYmxlRWxlbWVudHM9Rm91bmRhdGlvbi5LZXlib2FyZC5maW5kRm9jdXNhYmxlKGUuJGVsZW1lbnQpLHQoKTt9KTt9KCk7fWVsc2UgdGhpcy5vcHRpb25zLm92ZXJsYXkmJnRoaXMuJG92ZXJsYXkuc2hvdygwKSx0aGlzLiRlbGVtZW50LnNob3codGhpcy5vcHRpb25zLnNob3dEZWxheSk7dGhpcy4kZWxlbWVudC5hdHRyKHtcXFwiYXJpYS1oaWRkZW5cXFwiOiExLHRhYmluZGV4Oi0xfSkuZm9jdXMoKSx0aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcIm9wZW4uemYucmV2ZWFsXFxcIiksdGhpcy5pc01vYmlsZT8odGhpcy5vcmlnaW5hbFNjcm9sbFBvcz13aW5kb3cucGFnZVlPZmZzZXQsdChcXFwiaHRtbCwgYm9keVxcXCIpLmFkZENsYXNzKFxcXCJpcy1yZXZlYWwtb3BlblxcXCIpKTp0KFxcXCJib2R5XFxcIikuYWRkQ2xhc3MoXFxcImlzLXJldmVhbC1vcGVuXFxcIiksc2V0VGltZW91dChmdW5jdGlvbigpe2UuX2V4dHJhSGFuZGxlcnMoKTt9LDApO319LHtrZXk6XFxcIl9leHRyYUhhbmRsZXJzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXM7dGhpcy5mb2N1c2FibGVFbGVtZW50cz1Gb3VuZGF0aW9uLktleWJvYXJkLmZpbmRGb2N1c2FibGUodGhpcy4kZWxlbWVudCksdGhpcy5vcHRpb25zLm92ZXJsYXl8fCF0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrfHx0aGlzLm9wdGlvbnMuZnVsbFNjcmVlbnx8dChcXFwiYm9keVxcXCIpLm9uKFxcXCJjbGljay56Zi5yZXZlYWxcXFwiLGZ1bmN0aW9uKGkpe2kudGFyZ2V0PT09ZS4kZWxlbWVudFswXXx8dC5jb250YWlucyhlLiRlbGVtZW50WzBdLGkudGFyZ2V0KXx8ZS5jbG9zZSgpO30pLHRoaXMub3B0aW9ucy5jbG9zZU9uRXNjJiZ0KHdpbmRvdykub24oXFxcImtleWRvd24uemYucmV2ZWFsXFxcIixmdW5jdGlvbih0KXtGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleSh0LFxcXCJSZXZlYWxcXFwiLHtjbG9zZTpmdW5jdGlvbiBjbG9zZSgpe2Uub3B0aW9ucy5jbG9zZU9uRXNjJiYoZS5jbG9zZSgpLGUuJGFuY2hvci5mb2N1cygpKTt9fSk7fSksdGhpcy4kZWxlbWVudC5vbihcXFwia2V5ZG93bi56Zi5yZXZlYWxcXFwiLGZ1bmN0aW9uKGkpe3ZhciBuPXQodGhpcyk7Rm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoaSxcXFwiUmV2ZWFsXFxcIix7dGFiX2ZvcndhcmQ6ZnVuY3Rpb24gdGFiX2ZvcndhcmQoKXtyZXR1cm4gZS4kZWxlbWVudC5maW5kKFxcXCI6Zm9jdXNcXFwiKS5pcyhlLmZvY3VzYWJsZUVsZW1lbnRzLmVxKC0xKSk/KGUuZm9jdXNhYmxlRWxlbWVudHMuZXEoMCkuZm9jdXMoKSwhMCk6MD09PWUuZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoPyEwOnZvaWQgMDt9LHRhYl9iYWNrd2FyZDpmdW5jdGlvbiB0YWJfYmFja3dhcmQoKXtyZXR1cm4gZS4kZWxlbWVudC5maW5kKFxcXCI6Zm9jdXNcXFwiKS5pcyhlLmZvY3VzYWJsZUVsZW1lbnRzLmVxKDApKXx8ZS4kZWxlbWVudC5pcyhcXFwiOmZvY3VzXFxcIik/KGUuZm9jdXNhYmxlRWxlbWVudHMuZXEoLTEpLmZvY3VzKCksITApOjA9PT1lLmZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aD8hMDp2b2lkIDA7fSxvcGVuOmZ1bmN0aW9uIG9wZW4oKXtlLiRlbGVtZW50LmZpbmQoXFxcIjpmb2N1c1xcXCIpLmlzKGUuJGVsZW1lbnQuZmluZChcXFwiW2RhdGEtY2xvc2VdXFxcIikpP3NldFRpbWVvdXQoZnVuY3Rpb24oKXtlLiRhbmNob3IuZm9jdXMoKTt9LDEpOm4uaXMoZS5mb2N1c2FibGVFbGVtZW50cykmJmUub3BlbigpO30sY2xvc2U6ZnVuY3Rpb24gY2xvc2UoKXtlLm9wdGlvbnMuY2xvc2VPbkVzYyYmKGUuY2xvc2UoKSxlLiRhbmNob3IuZm9jdXMoKSk7fSxoYW5kbGVkOmZ1bmN0aW9uIGhhbmRsZWQodCl7dCYmaS5wcmV2ZW50RGVmYXVsdCgpO319KTt9KTt9fSx7a2V5OlxcXCJjbG9zZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXtmdW5jdGlvbiBlKCl7aS5pc01vYmlsZT8odChcXFwiaHRtbCwgYm9keVxcXCIpLnJlbW92ZUNsYXNzKFxcXCJpcy1yZXZlYWwtb3BlblxcXCIpLGkub3JpZ2luYWxTY3JvbGxQb3MmJih0KFxcXCJib2R5XFxcIikuc2Nyb2xsVG9wKGkub3JpZ2luYWxTY3JvbGxQb3MpLGkub3JpZ2luYWxTY3JvbGxQb3M9bnVsbCkpOnQoXFxcImJvZHlcXFwiKS5yZW1vdmVDbGFzcyhcXFwiaXMtcmV2ZWFsLW9wZW5cXFwiKSxpLiRlbGVtZW50LmF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIiwhMCksaS4kZWxlbWVudC50cmlnZ2VyKFxcXCJjbG9zZWQuemYucmV2ZWFsXFxcIik7fWlmKCF0aGlzLmlzQWN0aXZlfHwhdGhpcy4kZWxlbWVudC5pcyhcXFwiOnZpc2libGVcXFwiKSlyZXR1cm4hMTt2YXIgaT10aGlzO3RoaXMub3B0aW9ucy5hbmltYXRpb25PdXQ/KHRoaXMub3B0aW9ucy5vdmVybGF5P0ZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVPdXQodGhpcy4kb3ZlcmxheSxcXFwiZmFkZS1vdXRcXFwiLGUpOmUoKSxGb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlT3V0KHRoaXMuJGVsZW1lbnQsdGhpcy5vcHRpb25zLmFuaW1hdGlvbk91dCkpOih0aGlzLm9wdGlvbnMub3ZlcmxheT90aGlzLiRvdmVybGF5LmhpZGUoMCxlKTplKCksdGhpcy4kZWxlbWVudC5oaWRlKHRoaXMub3B0aW9ucy5oaWRlRGVsYXkpKSx0aGlzLm9wdGlvbnMuY2xvc2VPbkVzYyYmdCh3aW5kb3cpLm9mZihcXFwia2V5ZG93bi56Zi5yZXZlYWxcXFwiKSwhdGhpcy5vcHRpb25zLm92ZXJsYXkmJnRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2smJnQoXFxcImJvZHlcXFwiKS5vZmYoXFxcImNsaWNrLnpmLnJldmVhbFxcXCIpLHRoaXMuJGVsZW1lbnQub2ZmKFxcXCJrZXlkb3duLnpmLnJldmVhbFxcXCIpLHRoaXMub3B0aW9ucy5yZXNldE9uQ2xvc2UmJnRoaXMuJGVsZW1lbnQuaHRtbCh0aGlzLiRlbGVtZW50Lmh0bWwoKSksdGhpcy5pc0FjdGl2ZT0hMSxpLm9wdGlvbnMuZGVlcExpbmsmJih3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGU/d2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKFxcXCJcXFwiLGRvY3VtZW50LnRpdGxlLHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSk6d2luZG93LmxvY2F0aW9uLmhhc2g9XFxcIlxcXCIpO319LHtrZXk6XFxcInRvZ2dsZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLmlzQWN0aXZlP3RoaXMuY2xvc2UoKTp0aGlzLm9wZW4oKTt9fSx7a2V5OlxcXCJkZXN0cm95XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMub3B0aW9ucy5vdmVybGF5JiYodGhpcy4kZWxlbWVudC5hcHBlbmRUbyh0KFxcXCJib2R5XFxcIikpLHRoaXMuJG92ZXJsYXkuaGlkZSgpLm9mZigpLnJlbW92ZSgpKSx0aGlzLiRlbGVtZW50LmhpZGUoKS5vZmYoKSx0aGlzLiRhbmNob3Iub2ZmKFxcXCIuemZcXFwiKSx0KHdpbmRvdykub2ZmKFxcXCIuemYucmV2ZWFsOlxcXCIrdGhpcy5pZCksRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSksZTt9KCk7cy5kZWZhdWx0cz17YW5pbWF0aW9uSW46XFxcIlxcXCIsYW5pbWF0aW9uT3V0OlxcXCJcXFwiLHNob3dEZWxheTowLGhpZGVEZWxheTowLGNsb3NlT25DbGljazohMCxjbG9zZU9uRXNjOiEwLG11bHRpcGxlT3BlbmVkOiExLHZPZmZzZXQ6XFxcImF1dG9cXFwiLGhPZmZzZXQ6XFxcImF1dG9cXFwiLGZ1bGxTY3JlZW46ITEsYnRtT2Zmc2V0UGN0OjEwLG92ZXJsYXk6ITAscmVzZXRPbkNsb3NlOiExLGRlZXBMaW5rOiExfSxGb3VuZGF0aW9uLnBsdWdpbihzLFxcXCJSZXZlYWxcXFwiKTt9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcXFwidmFsdWVcXFwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pO319cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZTt9O30oKTshZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0LGUpe3JldHVybiB0L2U7fWZ1bmN0aW9uIGkodCxlLGksbil7cmV0dXJuIE1hdGguYWJzKHQucG9zaXRpb24oKVtlXSt0W25dKCkvMi1pKTt9dmFyIG49ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKGUsaSl7X2NsYXNzQ2FsbENoZWNrKHRoaXMsbiksdGhpcy4kZWxlbWVudD1lLHRoaXMub3B0aW9ucz10LmV4dGVuZCh7fSxuLmRlZmF1bHRzLHRoaXMuJGVsZW1lbnQuZGF0YSgpLGkpLHRoaXMuX2luaXQoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXFxcIlNsaWRlclxcXCIpLEZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIoXFxcIlNsaWRlclxcXCIse2x0cjp7QVJST1dfUklHSFQ6XFxcImluY3JlYXNlXFxcIixBUlJPV19VUDpcXFwiaW5jcmVhc2VcXFwiLEFSUk9XX0RPV046XFxcImRlY3JlYXNlXFxcIixBUlJPV19MRUZUOlxcXCJkZWNyZWFzZVxcXCIsU0hJRlRfQVJST1dfUklHSFQ6XFxcImluY3JlYXNlX2Zhc3RcXFwiLFNISUZUX0FSUk9XX1VQOlxcXCJpbmNyZWFzZV9mYXN0XFxcIixTSElGVF9BUlJPV19ET1dOOlxcXCJkZWNyZWFzZV9mYXN0XFxcIixTSElGVF9BUlJPV19MRUZUOlxcXCJkZWNyZWFzZV9mYXN0XFxcIn0scnRsOntBUlJPV19MRUZUOlxcXCJpbmNyZWFzZVxcXCIsQVJST1dfUklHSFQ6XFxcImRlY3JlYXNlXFxcIixTSElGVF9BUlJPV19MRUZUOlxcXCJpbmNyZWFzZV9mYXN0XFxcIixTSElGVF9BUlJPV19SSUdIVDpcXFwiZGVjcmVhc2VfZmFzdFxcXCJ9fSk7fXJldHVybiBfY3JlYXRlQ2xhc3Mobixbe2tleTpcXFwiX2luaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy5pbnB1dHM9dGhpcy4kZWxlbWVudC5maW5kKFxcXCJpbnB1dFxcXCIpLHRoaXMuaGFuZGxlcz10aGlzLiRlbGVtZW50LmZpbmQoXFxcIltkYXRhLXNsaWRlci1oYW5kbGVdXFxcIiksdGhpcy4kaGFuZGxlPXRoaXMuaGFuZGxlcy5lcSgwKSx0aGlzLiRpbnB1dD10aGlzLmlucHV0cy5sZW5ndGg/dGhpcy5pbnB1dHMuZXEoMCk6dChcXFwiI1xcXCIrdGhpcy4kaGFuZGxlLmF0dHIoXFxcImFyaWEtY29udHJvbHNcXFwiKSksdGhpcy4kZmlsbD10aGlzLiRlbGVtZW50LmZpbmQoXFxcIltkYXRhLXNsaWRlci1maWxsXVxcXCIpLmNzcyh0aGlzLm9wdGlvbnMudmVydGljYWw/XFxcImhlaWdodFxcXCI6XFxcIndpZHRoXFxcIiwwKTt2YXIgZT0hMSxpPXRoaXM7KHRoaXMub3B0aW9ucy5kaXNhYmxlZHx8dGhpcy4kZWxlbWVudC5oYXNDbGFzcyh0aGlzLm9wdGlvbnMuZGlzYWJsZWRDbGFzcykpJiYodGhpcy5vcHRpb25zLmRpc2FibGVkPSEwLHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmRpc2FibGVkQ2xhc3MpKSx0aGlzLmlucHV0cy5sZW5ndGh8fCh0aGlzLmlucHV0cz10KCkuYWRkKHRoaXMuJGlucHV0KSx0aGlzLm9wdGlvbnMuYmluZGluZz0hMCksdGhpcy5fc2V0SW5pdEF0dHIoMCksdGhpcy5fZXZlbnRzKHRoaXMuJGhhbmRsZSksdGhpcy5oYW5kbGVzWzFdJiYodGhpcy5vcHRpb25zLmRvdWJsZVNpZGVkPSEwLHRoaXMuJGhhbmRsZTI9dGhpcy5oYW5kbGVzLmVxKDEpLHRoaXMuJGlucHV0Mj10aGlzLmlucHV0cy5sZW5ndGg+MT90aGlzLmlucHV0cy5lcSgxKTp0KFxcXCIjXFxcIit0aGlzLiRoYW5kbGUyLmF0dHIoXFxcImFyaWEtY29udHJvbHNcXFwiKSksdGhpcy5pbnB1dHNbMV18fCh0aGlzLmlucHV0cz10aGlzLmlucHV0cy5hZGQodGhpcy4kaW5wdXQyKSksZT0hMCx0aGlzLl9zZXRIYW5kbGVQb3ModGhpcy4kaGFuZGxlLHRoaXMub3B0aW9ucy5pbml0aWFsU3RhcnQsITAsZnVuY3Rpb24oKXtpLl9zZXRIYW5kbGVQb3MoaS4kaGFuZGxlMixpLm9wdGlvbnMuaW5pdGlhbEVuZCwhMCk7fSksdGhpcy5fc2V0SW5pdEF0dHIoMSksdGhpcy5fZXZlbnRzKHRoaXMuJGhhbmRsZTIpKSxlfHx0aGlzLl9zZXRIYW5kbGVQb3ModGhpcy4kaGFuZGxlLHRoaXMub3B0aW9ucy5pbml0aWFsU3RhcnQsITApO319LHtrZXk6XFxcIl9zZXRIYW5kbGVQb3NcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQsaSxuLHMpe2lmKCF0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKHRoaXMub3B0aW9ucy5kaXNhYmxlZENsYXNzKSl7aT1wYXJzZUZsb2F0KGkpLGk8dGhpcy5vcHRpb25zLnN0YXJ0P2k9dGhpcy5vcHRpb25zLnN0YXJ0Omk+dGhpcy5vcHRpb25zLmVuZCYmKGk9dGhpcy5vcHRpb25zLmVuZCk7dmFyIG89dGhpcy5vcHRpb25zLmRvdWJsZVNpZGVkO2lmKG8paWYoMD09PXRoaXMuaGFuZGxlcy5pbmRleCh0KSl7dmFyIGE9cGFyc2VGbG9hdCh0aGlzLiRoYW5kbGUyLmF0dHIoXFxcImFyaWEtdmFsdWVub3dcXFwiKSk7aT1pPj1hP2EtdGhpcy5vcHRpb25zLnN0ZXA6aTt9ZWxzZXt2YXIgcj1wYXJzZUZsb2F0KHRoaXMuJGhhbmRsZS5hdHRyKFxcXCJhcmlhLXZhbHVlbm93XFxcIikpO2k9cj49aT9yK3RoaXMub3B0aW9ucy5zdGVwOmk7fXRoaXMub3B0aW9ucy52ZXJ0aWNhbCYmIW4mJihpPXRoaXMub3B0aW9ucy5lbmQtaSk7dmFyIGw9dGhpcyx1PXRoaXMub3B0aW9ucy52ZXJ0aWNhbCxkPXU/XFxcImhlaWdodFxcXCI6XFxcIndpZHRoXFxcIixoPXU/XFxcInRvcFxcXCI6XFxcImxlZnRcXFwiLGM9dFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtkXSxmPXRoaXMuJGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbZF0scD1lKGktdGhpcy5vcHRpb25zLnN0YXJ0LHRoaXMub3B0aW9ucy5lbmQtdGhpcy5vcHRpb25zLnN0YXJ0KS50b0ZpeGVkKDIpLG09KGYtYykqcCx2PSgxMDAqZShtLGYpKS50b0ZpeGVkKHRoaXMub3B0aW9ucy5kZWNpbWFsKTtpPXBhcnNlRmxvYXQoaS50b0ZpeGVkKHRoaXMub3B0aW9ucy5kZWNpbWFsKSk7dmFyIGc9e307aWYodGhpcy5fc2V0VmFsdWVzKHQsaSksbyl7dmFyIHcseT0wPT09dGhpcy5oYW5kbGVzLmluZGV4KHQpLGI9fn4oMTAwKmUoYyxmKSk7aWYoeSlnW2hdPXYrXFxcIiVcXFwiLHc9cGFyc2VGbG9hdCh0aGlzLiRoYW5kbGUyWzBdLnN0eWxlW2hdKS12K2IscyYmXFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIHMmJnMoKTtlbHNle3ZhciAkPXBhcnNlRmxvYXQodGhpcy4kaGFuZGxlWzBdLnN0eWxlW2hdKTt3PXYtKGlzTmFOKCQpP3RoaXMub3B0aW9ucy5pbml0aWFsU3RhcnQvKCh0aGlzLm9wdGlvbnMuZW5kLXRoaXMub3B0aW9ucy5zdGFydCkvMTAwKTokKStiO31nW1xcXCJtaW4tXFxcIitkXT13K1xcXCIlXFxcIjt9dGhpcy4kZWxlbWVudC5vbmUoXFxcImZpbmlzaGVkLnpmLmFuaW1hdGVcXFwiLGZ1bmN0aW9uKCl7bC4kZWxlbWVudC50cmlnZ2VyKFxcXCJtb3ZlZC56Zi5zbGlkZXJcXFwiLFt0XSk7fSk7dmFyIEM9dGhpcy4kZWxlbWVudC5kYXRhKFxcXCJkcmFnZ2luZ1xcXCIpPzFlMy82MDp0aGlzLm9wdGlvbnMubW92ZVRpbWU7Rm91bmRhdGlvbi5Nb3ZlKEMsdCxmdW5jdGlvbigpe3QuY3NzKGgsditcXFwiJVxcXCIpLGwub3B0aW9ucy5kb3VibGVTaWRlZD9sLiRmaWxsLmNzcyhnKTpsLiRmaWxsLmNzcyhkLDEwMCpwK1xcXCIlXFxcIik7fSksY2xlYXJUaW1lb3V0KGwudGltZW91dCksbC50aW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXtsLiRlbGVtZW50LnRyaWdnZXIoXFxcImNoYW5nZWQuemYuc2xpZGVyXFxcIixbdF0pO30sbC5vcHRpb25zLmNoYW5nZWREZWxheSk7fX19LHtrZXk6XFxcIl9zZXRJbml0QXR0clxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dmFyIGU9dGhpcy5pbnB1dHMuZXEodCkuYXR0cihcXFwiaWRcXFwiKXx8Rm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LFxcXCJzbGlkZXJcXFwiKTt0aGlzLmlucHV0cy5lcSh0KS5hdHRyKHtpZDplLG1heDp0aGlzLm9wdGlvbnMuZW5kLG1pbjp0aGlzLm9wdGlvbnMuc3RhcnQsc3RlcDp0aGlzLm9wdGlvbnMuc3RlcH0pLHRoaXMuaGFuZGxlcy5lcSh0KS5hdHRyKHtyb2xlOlxcXCJzbGlkZXJcXFwiLFxcXCJhcmlhLWNvbnRyb2xzXFxcIjplLFxcXCJhcmlhLXZhbHVlbWF4XFxcIjp0aGlzLm9wdGlvbnMuZW5kLFxcXCJhcmlhLXZhbHVlbWluXFxcIjp0aGlzLm9wdGlvbnMuc3RhcnQsXFxcImFyaWEtdmFsdWVub3dcXFwiOjA9PT10P3RoaXMub3B0aW9ucy5pbml0aWFsU3RhcnQ6dGhpcy5vcHRpb25zLmluaXRpYWxFbmQsXFxcImFyaWEtb3JpZW50YXRpb25cXFwiOnRoaXMub3B0aW9ucy52ZXJ0aWNhbD9cXFwidmVydGljYWxcXFwiOlxcXCJob3Jpem9udGFsXFxcIix0YWJpbmRleDowfSk7fX0se2tleTpcXFwiX3NldFZhbHVlc1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCxlKXt2YXIgaT10aGlzLm9wdGlvbnMuZG91YmxlU2lkZWQ/dGhpcy5oYW5kbGVzLmluZGV4KHQpOjA7dGhpcy5pbnB1dHMuZXEoaSkudmFsKGUpLHQuYXR0cihcXFwiYXJpYS12YWx1ZW5vd1xcXCIsZSk7fX0se2tleTpcXFwiX2hhbmRsZUV2ZW50XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZShuLHMsbyl7dmFyIGEscjtpZihvKWE9dGhpcy5fYWRqdXN0VmFsdWUobnVsbCxvKSxyPSEwO2Vsc2V7bi5wcmV2ZW50RGVmYXVsdCgpO3ZhciBsPXRoaXMsdT10aGlzLm9wdGlvbnMudmVydGljYWwsZD11P1xcXCJoZWlnaHRcXFwiOlxcXCJ3aWR0aFxcXCIsaD11P1xcXCJ0b3BcXFwiOlxcXCJsZWZ0XFxcIixjPXU/bi5wYWdlWTpuLnBhZ2VYLGY9KHRoaXMuJGhhbmRsZVswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtkXS8yLHRoaXMuJGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbZF0pLHA9dT90KHdpbmRvdykuc2Nyb2xsVG9wKCk6dCh3aW5kb3cpLnNjcm9sbExlZnQoKSxtPXRoaXMuJGVsZW1lbnQub2Zmc2V0KClbaF07bi5jbGllbnRZPT09bi5wYWdlWSYmKGMrPXApO3ZhciB2LGc9Yy1tO2lmKHY9MD5nPzA6Zz5mP2Y6ZyxvZmZzZXRQY3Q9ZSh2LGYpLGE9KHRoaXMub3B0aW9ucy5lbmQtdGhpcy5vcHRpb25zLnN0YXJ0KSpvZmZzZXRQY3QrdGhpcy5vcHRpb25zLnN0YXJ0LEZvdW5kYXRpb24ucnRsKCkmJiF0aGlzLm9wdGlvbnMudmVydGljYWwmJihhPXRoaXMub3B0aW9ucy5lbmQtYSksYT1sLl9hZGp1c3RWYWx1ZShudWxsLGEpLHI9ITEsIXMpe3ZhciB3PWkodGhpcy4kaGFuZGxlLGgsdixkKSx5PWkodGhpcy4kaGFuZGxlMixoLHYsZCk7cz15Pj13P3RoaXMuJGhhbmRsZTp0aGlzLiRoYW5kbGUyO319dGhpcy5fc2V0SGFuZGxlUG9zKHMsYSxyKTt9fSx7a2V5OlxcXCJfYWRqdXN0VmFsdWVcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQsZSl7dmFyIGksbixzLG8sYT10aGlzLm9wdGlvbnMuc3RlcCxyPXBhcnNlRmxvYXQoYS8yKTtyZXR1cm4gaT10P3BhcnNlRmxvYXQodC5hdHRyKFxcXCJhcmlhLXZhbHVlbm93XFxcIikpOmUsbj1pJWEscz1pLW4sbz1zK2EsMD09PW4/aTppPWk+PXMrcj9vOnM7fX0se2tleTpcXFwiX2V2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSl7dmFyIGksbj10aGlzO2lmKHRoaXMuaW5wdXRzLm9mZihcXFwiY2hhbmdlLnpmLnNsaWRlclxcXCIpLm9uKFxcXCJjaGFuZ2UuemYuc2xpZGVyXFxcIixmdW5jdGlvbihlKXt2YXIgaT1uLmlucHV0cy5pbmRleCh0KHRoaXMpKTtuLl9oYW5kbGVFdmVudChlLG4uaGFuZGxlcy5lcShpKSx0KHRoaXMpLnZhbCgpKTt9KSx0aGlzLm9wdGlvbnMuY2xpY2tTZWxlY3QmJnRoaXMuJGVsZW1lbnQub2ZmKFxcXCJjbGljay56Zi5zbGlkZXJcXFwiKS5vbihcXFwiY2xpY2suemYuc2xpZGVyXFxcIixmdW5jdGlvbihlKXtyZXR1cm4gbi4kZWxlbWVudC5kYXRhKFxcXCJkcmFnZ2luZ1xcXCIpPyExOnZvaWQodChlLnRhcmdldCkuaXMoXFxcIltkYXRhLXNsaWRlci1oYW5kbGVdXFxcIil8fChuLm9wdGlvbnMuZG91YmxlU2lkZWQ/bi5faGFuZGxlRXZlbnQoZSk6bi5faGFuZGxlRXZlbnQoZSxuLiRoYW5kbGUpKSk7fSksdGhpcy5vcHRpb25zLmRyYWdnYWJsZSl7dGhpcy5oYW5kbGVzLmFkZFRvdWNoKCk7dmFyIHM9dChcXFwiYm9keVxcXCIpO2Uub2ZmKFxcXCJtb3VzZWRvd24uemYuc2xpZGVyXFxcIikub24oXFxcIm1vdXNlZG93bi56Zi5zbGlkZXJcXFwiLGZ1bmN0aW9uKG8pe2UuYWRkQ2xhc3MoXFxcImlzLWRyYWdnaW5nXFxcIiksbi4kZmlsbC5hZGRDbGFzcyhcXFwiaXMtZHJhZ2dpbmdcXFwiKSxuLiRlbGVtZW50LmRhdGEoXFxcImRyYWdnaW5nXFxcIiwhMCksaT10KG8uY3VycmVudFRhcmdldCkscy5vbihcXFwibW91c2Vtb3ZlLnpmLnNsaWRlclxcXCIsZnVuY3Rpb24odCl7dC5wcmV2ZW50RGVmYXVsdCgpLG4uX2hhbmRsZUV2ZW50KHQsaSk7fSkub24oXFxcIm1vdXNldXAuemYuc2xpZGVyXFxcIixmdW5jdGlvbih0KXtuLl9oYW5kbGVFdmVudCh0LGkpLGUucmVtb3ZlQ2xhc3MoXFxcImlzLWRyYWdnaW5nXFxcIiksbi4kZmlsbC5yZW1vdmVDbGFzcyhcXFwiaXMtZHJhZ2dpbmdcXFwiKSxuLiRlbGVtZW50LmRhdGEoXFxcImRyYWdnaW5nXFxcIiwhMSkscy5vZmYoXFxcIm1vdXNlbW92ZS56Zi5zbGlkZXIgbW91c2V1cC56Zi5zbGlkZXJcXFwiKTt9KTt9KS5vbihcXFwic2VsZWN0c3RhcnQuemYuc2xpZGVyIHRvdWNobW92ZS56Zi5zbGlkZXJcXFwiLGZ1bmN0aW9uKHQpe3QucHJldmVudERlZmF1bHQoKTt9KTt9ZS5vZmYoXFxcImtleWRvd24uemYuc2xpZGVyXFxcIikub24oXFxcImtleWRvd24uemYuc2xpZGVyXFxcIixmdW5jdGlvbihlKXt2YXIgaSxzPXQodGhpcyksbz1uLm9wdGlvbnMuZG91YmxlU2lkZWQ/bi5oYW5kbGVzLmluZGV4KHMpOjAsYT1wYXJzZUZsb2F0KG4uaW5wdXRzLmVxKG8pLnZhbCgpKTtGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShlLFxcXCJTbGlkZXJcXFwiLHtkZWNyZWFzZTpmdW5jdGlvbiBkZWNyZWFzZSgpe2k9YS1uLm9wdGlvbnMuc3RlcDt9LGluY3JlYXNlOmZ1bmN0aW9uIGluY3JlYXNlKCl7aT1hK24ub3B0aW9ucy5zdGVwO30sZGVjcmVhc2VfZmFzdDpmdW5jdGlvbiBkZWNyZWFzZV9mYXN0KCl7aT1hLTEwKm4ub3B0aW9ucy5zdGVwO30saW5jcmVhc2VfZmFzdDpmdW5jdGlvbiBpbmNyZWFzZV9mYXN0KCl7aT1hKzEwKm4ub3B0aW9ucy5zdGVwO30saGFuZGxlZDpmdW5jdGlvbiBoYW5kbGVkKCl7ZS5wcmV2ZW50RGVmYXVsdCgpLG4uX3NldEhhbmRsZVBvcyhzLGksITApO319KTt9KTt9fSx7a2V5OlxcXCJkZXN0cm95XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuaGFuZGxlcy5vZmYoXFxcIi56Zi5zbGlkZXJcXFwiKSx0aGlzLmlucHV0cy5vZmYoXFxcIi56Zi5zbGlkZXJcXFwiKSx0aGlzLiRlbGVtZW50Lm9mZihcXFwiLnpmLnNsaWRlclxcXCIpLEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTt9fV0pLG47fSgpO24uZGVmYXVsdHM9e3N0YXJ0OjAsZW5kOjEwMCxzdGVwOjEsaW5pdGlhbFN0YXJ0OjAsaW5pdGlhbEVuZDoxMDAsYmluZGluZzohMSxjbGlja1NlbGVjdDohMCx2ZXJ0aWNhbDohMSxkcmFnZ2FibGU6ITAsZGlzYWJsZWQ6ITEsZG91YmxlU2lkZWQ6ITEsZGVjaW1hbDoyLG1vdmVUaW1lOjIwMCxkaXNhYmxlZENsYXNzOlxcXCJkaXNhYmxlZFxcXCIsaW52ZXJ0VmVydGljYWw6ITEsY2hhbmdlZERlbGF5OjUwMH0sRm91bmRhdGlvbi5wbHVnaW4obixcXFwiU2xpZGVyXFxcIik7fShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXFxcInZhbHVlXFxcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLmtleSxuKTt9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGU7fTt9KCk7IWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCl7cmV0dXJuIHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmJvZHksbnVsbCkuZm9udFNpemUsMTApKnQ7fXZhciBpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gaShlLG4pe19jbGFzc0NhbGxDaGVjayh0aGlzLGkpLHRoaXMuJGVsZW1lbnQ9ZSx0aGlzLm9wdGlvbnM9dC5leHRlbmQoe30saS5kZWZhdWx0cyx0aGlzLiRlbGVtZW50LmRhdGEoKSxuKSx0aGlzLl9pbml0KCksRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLFxcXCJTdGlja3lcXFwiKTt9cmV0dXJuIF9jcmVhdGVDbGFzcyhpLFt7a2V5OlxcXCJfaW5pdFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzLiRlbGVtZW50LnBhcmVudChcXFwiW2RhdGEtc3RpY2t5LWNvbnRhaW5lcl1cXFwiKSxpPXRoaXMuJGVsZW1lbnRbMF0uaWR8fEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNixcXFwic3RpY2t5XFxcIiksbj10aGlzO2UubGVuZ3RofHwodGhpcy53YXNXcmFwcGVkPSEwKSx0aGlzLiRjb250YWluZXI9ZS5sZW5ndGg/ZTp0KHRoaXMub3B0aW9ucy5jb250YWluZXIpLndyYXBJbm5lcih0aGlzLiRlbGVtZW50KSx0aGlzLiRjb250YWluZXIuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmNvbnRhaW5lckNsYXNzKSx0aGlzLiRlbGVtZW50LmFkZENsYXNzKHRoaXMub3B0aW9ucy5zdGlja3lDbGFzcykuYXR0cih7XFxcImRhdGEtcmVzaXplXFxcIjppfSksdGhpcy5zY3JvbGxDb3VudD10aGlzLm9wdGlvbnMuY2hlY2tFdmVyeSx0aGlzLmlzU3R1Y2s9ITEsdCh3aW5kb3cpLm9uZShcXFwibG9hZC56Zi5zdGlja3lcXFwiLGZ1bmN0aW9uKCl7XFxcIlxcXCIhPT1uLm9wdGlvbnMuYW5jaG9yP24uJGFuY2hvcj10KFxcXCIjXFxcIituLm9wdGlvbnMuYW5jaG9yKTpuLl9wYXJzZVBvaW50cygpLG4uX3NldFNpemVzKGZ1bmN0aW9uKCl7bi5fY2FsYyghMSk7fSksbi5fZXZlbnRzKGkuc3BsaXQoXFxcIi1cXFwiKS5yZXZlcnNlKCkuam9pbihcXFwiLVxcXCIpKTt9KTt9fSx7a2V5OlxcXCJfcGFyc2VQb2ludHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7Zm9yKHZhciBlPVxcXCJcXFwiPT10aGlzLm9wdGlvbnMudG9wQW5jaG9yPzE6dGhpcy5vcHRpb25zLnRvcEFuY2hvcixpPVxcXCJcXFwiPT10aGlzLm9wdGlvbnMuYnRtQW5jaG9yP2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQ6dGhpcy5vcHRpb25zLmJ0bUFuY2hvcixuPVtlLGldLHM9e30sbz0wLGE9bi5sZW5ndGg7YT5vJiZuW29dO28rKyl7dmFyIHI7aWYoXFxcIm51bWJlclxcXCI9PXR5cGVvZiBuW29dKXI9bltvXTtlbHNle3ZhciBsPW5bb10uc3BsaXQoXFxcIjpcXFwiKSx1PXQoXFxcIiNcXFwiK2xbMF0pO3I9dS5vZmZzZXQoKS50b3AsbFsxXSYmXFxcImJvdHRvbVxcXCI9PT1sWzFdLnRvTG93ZXJDYXNlKCkmJihyKz11WzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCk7fXNbb109cjt9dGhpcy5wb2ludHM9czt9fSx7a2V5OlxcXCJfZXZlbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZShlKXt2YXIgaT10aGlzLG49dGhpcy5zY3JvbGxMaXN0ZW5lcj1cXFwic2Nyb2xsLnpmLlxcXCIrZTt0aGlzLmlzT258fCh0aGlzLmNhblN0aWNrJiYodGhpcy5pc09uPSEwLHQod2luZG93KS5vZmYobikub24obixmdW5jdGlvbih0KXswPT09aS5zY3JvbGxDb3VudD8oaS5zY3JvbGxDb3VudD1pLm9wdGlvbnMuY2hlY2tFdmVyeSxpLl9zZXRTaXplcyhmdW5jdGlvbigpe2kuX2NhbGMoITEsd2luZG93LnBhZ2VZT2Zmc2V0KTt9KSk6KGkuc2Nyb2xsQ291bnQtLSxpLl9jYWxjKCExLHdpbmRvdy5wYWdlWU9mZnNldCkpO30pKSx0aGlzLiRlbGVtZW50Lm9mZihcXFwicmVzaXplbWUuemYudHJpZ2dlclxcXCIpLm9uKFxcXCJyZXNpemVtZS56Zi50cmlnZ2VyXFxcIixmdW5jdGlvbih0LHMpe2kuX3NldFNpemVzKGZ1bmN0aW9uKCl7aS5fY2FsYyghMSksaS5jYW5TdGljaz9pLmlzT258fGkuX2V2ZW50cyhlKTppLmlzT24mJmkuX3BhdXNlTGlzdGVuZXJzKG4pO30pO30pKTt9fSx7a2V5OlxcXCJfcGF1c2VMaXN0ZW5lcnNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKGUpe3RoaXMuaXNPbj0hMSx0KHdpbmRvdykub2ZmKGUpLHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwicGF1c2UuemYuc3RpY2t5XFxcIik7fX0se2tleTpcXFwiX2NhbGNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQsZSl7cmV0dXJuIHQmJnRoaXMuX3NldFNpemVzKCksdGhpcy5jYW5TdGljaz8oZXx8KGU9d2luZG93LnBhZ2VZT2Zmc2V0KSx2b2lkKGU+PXRoaXMudG9wUG9pbnQ/ZTw9dGhpcy5ib3R0b21Qb2ludD90aGlzLmlzU3R1Y2t8fHRoaXMuX3NldFN0aWNreSgpOnRoaXMuaXNTdHVjayYmdGhpcy5fcmVtb3ZlU3RpY2t5KCExKTp0aGlzLmlzU3R1Y2smJnRoaXMuX3JlbW92ZVN0aWNreSghMCkpKToodGhpcy5pc1N0dWNrJiZ0aGlzLl9yZW1vdmVTdGlja3koITApLCExKTt9fSx7a2V5OlxcXCJfc2V0U3RpY2t5XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciB0PXRoaXMsZT10aGlzLm9wdGlvbnMuc3RpY2tUbyxpPVxcXCJ0b3BcXFwiPT09ZT9cXFwibWFyZ2luVG9wXFxcIjpcXFwibWFyZ2luQm90dG9tXFxcIixuPVxcXCJ0b3BcXFwiPT09ZT9cXFwiYm90dG9tXFxcIjpcXFwidG9wXFxcIixzPXt9O3NbaV09dGhpcy5vcHRpb25zW2ldK1xcXCJlbVxcXCIsc1tlXT0wLHNbbl09XFxcImF1dG9cXFwiLHMubGVmdD10aGlzLiRjb250YWluZXIub2Zmc2V0KCkubGVmdCtwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiRjb250YWluZXJbMF0pW1xcXCJwYWRkaW5nLWxlZnRcXFwiXSwxMCksdGhpcy5pc1N0dWNrPSEwLHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoXFxcImlzLWFuY2hvcmVkIGlzLWF0LVxcXCIrbikuYWRkQ2xhc3MoXFxcImlzLXN0dWNrIGlzLWF0LVxcXCIrZSkuY3NzKHMpLnRyaWdnZXIoXFxcInN0aWNreS56Zi5zdHVja3RvOlxcXCIrZSksdGhpcy4kZWxlbWVudC5vbihcXFwidHJhbnNpdGlvbmVuZCB3ZWJraXRUcmFuc2l0aW9uRW5kIG9UcmFuc2l0aW9uRW5kIG90cmFuc2l0aW9uZW5kIE1TVHJhbnNpdGlvbkVuZFxcXCIsZnVuY3Rpb24oKXt0Ll9zZXRTaXplcygpO30pO319LHtrZXk6XFxcIl9yZW1vdmVTdGlja3lcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3ZhciBlPXRoaXMub3B0aW9ucy5zdGlja1RvLGk9XFxcInRvcFxcXCI9PT1lLG49e30scz0odGhpcy5wb2ludHM/dGhpcy5wb2ludHNbMV0tdGhpcy5wb2ludHNbMF06dGhpcy5hbmNob3JIZWlnaHQpLXRoaXMuZWxlbUhlaWdodCxvPWk/XFxcIm1hcmdpblRvcFxcXCI6XFxcIm1hcmdpbkJvdHRvbVxcXCIsYT10P1xcXCJ0b3BcXFwiOlxcXCJib3R0b21cXFwiO25bb109MCxuLmJvdHRvbT1cXFwiYXV0b1xcXCIsdD9uLnRvcD0wOm4udG9wPXMsbi5sZWZ0PVxcXCJcXFwiLHRoaXMuaXNTdHVjaz0hMSx0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKFxcXCJpcy1zdHVjayBpcy1hdC1cXFwiK2UpLmFkZENsYXNzKFxcXCJpcy1hbmNob3JlZCBpcy1hdC1cXFwiK2EpLmNzcyhuKS50cmlnZ2VyKFxcXCJzdGlja3kuemYudW5zdHVja2Zyb206XFxcIithKTt9fSx7a2V5OlxcXCJfc2V0U2l6ZXNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3RoaXMuY2FuU3RpY2s9Rm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmF0TGVhc3QodGhpcy5vcHRpb25zLnN0aWNreU9uKSx0aGlzLmNhblN0aWNrfHx0KCk7dmFyIGU9dGhpcy4kY29udGFpbmVyWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoLGk9d2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy4kY29udGFpbmVyWzBdKSxuPXBhcnNlSW50KGlbXFxcInBhZGRpbmctcmlnaHRcXFwiXSwxMCk7dGhpcy4kYW5jaG9yJiZ0aGlzLiRhbmNob3IubGVuZ3RoP3RoaXMuYW5jaG9ySGVpZ2h0PXRoaXMuJGFuY2hvclswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ6dGhpcy5fcGFyc2VQb2ludHMoKSx0aGlzLiRlbGVtZW50LmNzcyh7XFxcIm1heC13aWR0aFxcXCI6ZS1uK1xcXCJweFxcXCJ9KTt2YXIgcz10aGlzLiRlbGVtZW50WzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodHx8dGhpcy5jb250YWluZXJIZWlnaHQ7XFxcIm5vbmVcXFwiPT10aGlzLiRlbGVtZW50LmNzcyhcXFwiZGlzcGxheVxcXCIpJiYocz0wKSx0aGlzLmNvbnRhaW5lckhlaWdodD1zLHRoaXMuJGNvbnRhaW5lci5jc3Moe2hlaWdodDpzfSksdGhpcy5lbGVtSGVpZ2h0PXMsdGhpcy5pc1N0dWNrJiZ0aGlzLiRlbGVtZW50LmNzcyh7bGVmdDp0aGlzLiRjb250YWluZXIub2Zmc2V0KCkubGVmdCtwYXJzZUludChpW1xcXCJwYWRkaW5nLWxlZnRcXFwiXSwxMCl9KSx0aGlzLl9zZXRCcmVha1BvaW50cyhzLGZ1bmN0aW9uKCl7dCYmdCgpO30pO319LHtrZXk6XFxcIl9zZXRCcmVha1BvaW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCxpKXtpZighdGhpcy5jYW5TdGljayl7aWYoIWkpcmV0dXJuITE7aSgpO312YXIgbj1lKHRoaXMub3B0aW9ucy5tYXJnaW5Ub3ApLHM9ZSh0aGlzLm9wdGlvbnMubWFyZ2luQm90dG9tKSxvPXRoaXMucG9pbnRzP3RoaXMucG9pbnRzWzBdOnRoaXMuJGFuY2hvci5vZmZzZXQoKS50b3AsYT10aGlzLnBvaW50cz90aGlzLnBvaW50c1sxXTpvK3RoaXMuYW5jaG9ySGVpZ2h0LHI9d2luZG93LmlubmVySGVpZ2h0O1xcXCJ0b3BcXFwiPT09dGhpcy5vcHRpb25zLnN0aWNrVG8/KG8tPW4sYS09dCtuKTpcXFwiYm90dG9tXFxcIj09PXRoaXMub3B0aW9ucy5zdGlja1RvJiYoby09ci0odCtzKSxhLT1yLXMpLHRoaXMudG9wUG9pbnQ9byx0aGlzLmJvdHRvbVBvaW50PWEsaSYmaSgpO319LHtrZXk6XFxcImRlc3Ryb3lcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy5fcmVtb3ZlU3RpY2t5KCEwKSx0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5zdGlja3lDbGFzcytcXFwiIGlzLWFuY2hvcmVkIGlzLWF0LXRvcFxcXCIpLmNzcyh7aGVpZ2h0OlxcXCJcXFwiLHRvcDpcXFwiXFxcIixib3R0b206XFxcIlxcXCIsXFxcIm1heC13aWR0aFxcXCI6XFxcIlxcXCJ9KS5vZmYoXFxcInJlc2l6ZW1lLnpmLnRyaWdnZXJcXFwiKSx0aGlzLiRhbmNob3ImJnRoaXMuJGFuY2hvci5sZW5ndGgmJnRoaXMuJGFuY2hvci5vZmYoXFxcImNoYW5nZS56Zi5zdGlja3lcXFwiKSx0KHdpbmRvdykub2ZmKHRoaXMuc2Nyb2xsTGlzdGVuZXIpLHRoaXMud2FzV3JhcHBlZD90aGlzLiRlbGVtZW50LnVud3JhcCgpOnRoaXMuJGNvbnRhaW5lci5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuY29udGFpbmVyQ2xhc3MpLmNzcyh7aGVpZ2h0OlxcXCJcXFwifSksRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSksaTt9KCk7aS5kZWZhdWx0cz17Y29udGFpbmVyOlxcXCI8ZGl2IGRhdGEtc3RpY2t5LWNvbnRhaW5lcj48L2Rpdj5cXFwiLHN0aWNrVG86XFxcInRvcFxcXCIsYW5jaG9yOlxcXCJcXFwiLHRvcEFuY2hvcjpcXFwiXFxcIixidG1BbmNob3I6XFxcIlxcXCIsbWFyZ2luVG9wOjEsbWFyZ2luQm90dG9tOjEsc3RpY2t5T246XFxcIm1lZGl1bVxcXCIsc3RpY2t5Q2xhc3M6XFxcInN0aWNreVxcXCIsY29udGFpbmVyQ2xhc3M6XFxcInN0aWNreS1jb250YWluZXJcXFwiLGNoZWNrRXZlcnk6LTF9LEZvdW5kYXRpb24ucGx1Z2luKGksXFxcIlN0aWNreVxcXCIpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbj1lW2ldO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFxcXCJ2YWx1ZVxcXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbik7fX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlO307fSgpOyFmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PWksdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGUuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksbiksdGhpcy5faW5pdCgpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcXFwiVGFic1xcXCIpLEZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIoXFxcIlRhYnNcXFwiLHtFTlRFUjpcXFwib3BlblxcXCIsU1BBQ0U6XFxcIm9wZW5cXFwiLEFSUk9XX1JJR0hUOlxcXCJuZXh0XFxcIixBUlJPV19VUDpcXFwicHJldmlvdXNcXFwiLEFSUk9XX0RPV046XFxcIm5leHRcXFwiLEFSUk9XX0xFRlQ6XFxcInByZXZpb3VzXFxcIn0pO31yZXR1cm4gX2NyZWF0ZUNsYXNzKGUsW3trZXk6XFxcIl9pbml0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXM7aWYodGhpcy4kdGFiVGl0bGVzPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiLlxcXCIrdGhpcy5vcHRpb25zLmxpbmtDbGFzcyksdGhpcy4kdGFiQ29udGVudD10KCdbZGF0YS10YWJzLWNvbnRlbnQ9XFxcIicrdGhpcy4kZWxlbWVudFswXS5pZCsnXFxcIl0nKSx0aGlzLiR0YWJUaXRsZXMuZWFjaChmdW5jdGlvbigpe3ZhciBpPXQodGhpcyksbj1pLmZpbmQoXFxcImFcXFwiKSxzPWkuaGFzQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpLG89blswXS5oYXNoLnNsaWNlKDEpLGE9blswXS5pZD9uWzBdLmlkOm8rXFxcIi1sYWJlbFxcXCIscj10KFxcXCIjXFxcIitvKTtpLmF0dHIoe3JvbGU6XFxcInByZXNlbnRhdGlvblxcXCJ9KSxuLmF0dHIoe3JvbGU6XFxcInRhYlxcXCIsXFxcImFyaWEtY29udHJvbHNcXFwiOm8sXFxcImFyaWEtc2VsZWN0ZWRcXFwiOnMsaWQ6YX0pLHIuYXR0cih7cm9sZTpcXFwidGFicGFuZWxcXFwiLFxcXCJhcmlhLWhpZGRlblxcXCI6IXMsXFxcImFyaWEtbGFiZWxsZWRieVxcXCI6YX0pLHMmJmUub3B0aW9ucy5hdXRvRm9jdXMmJm4uZm9jdXMoKTt9KSx0aGlzLm9wdGlvbnMubWF0Y2hIZWlnaHQpe3ZhciBpPXRoaXMuJHRhYkNvbnRlbnQuZmluZChcXFwiaW1nXFxcIik7aS5sZW5ndGg/Rm91bmRhdGlvbi5vbkltYWdlc0xvYWRlZChpLHRoaXMuX3NldEhlaWdodC5iaW5kKHRoaXMpKTp0aGlzLl9zZXRIZWlnaHQoKTt9dGhpcy5fZXZlbnRzKCk7fX0se2tleTpcXFwiX2V2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLl9hZGRLZXlIYW5kbGVyKCksdGhpcy5fYWRkQ2xpY2tIYW5kbGVyKCksdGhpcy5fc2V0SGVpZ2h0TXFIYW5kbGVyPW51bGwsdGhpcy5vcHRpb25zLm1hdGNoSGVpZ2h0JiYodGhpcy5fc2V0SGVpZ2h0TXFIYW5kbGVyPXRoaXMuX3NldEhlaWdodC5iaW5kKHRoaXMpLHQod2luZG93KS5vbihcXFwiY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5XFxcIix0aGlzLl9zZXRIZWlnaHRNcUhhbmRsZXIpKTt9fSx7a2V5OlxcXCJfYWRkQ2xpY2tIYW5kbGVyXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXM7dGhpcy4kZWxlbWVudC5vZmYoXFxcImNsaWNrLnpmLnRhYnNcXFwiKS5vbihcXFwiY2xpY2suemYudGFic1xcXCIsXFxcIi5cXFwiK3RoaXMub3B0aW9ucy5saW5rQ2xhc3MsZnVuY3Rpb24oaSl7aS5wcmV2ZW50RGVmYXVsdCgpLGkuc3RvcFByb3BhZ2F0aW9uKCksdCh0aGlzKS5oYXNDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIil8fGUuX2hhbmRsZVRhYkNoYW5nZSh0KHRoaXMpKTt9KTt9fSx7a2V5OlxcXCJfYWRkS2V5SGFuZGxlclxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzO2UuJGVsZW1lbnQuZmluZChcXFwibGk6Zmlyc3Qtb2YtdHlwZVxcXCIpLGUuJGVsZW1lbnQuZmluZChcXFwibGk6bGFzdC1vZi10eXBlXFxcIik7dGhpcy4kdGFiVGl0bGVzLm9mZihcXFwia2V5ZG93bi56Zi50YWJzXFxcIikub24oXFxcImtleWRvd24uemYudGFic1xcXCIsZnVuY3Rpb24oaSl7aWYoOSE9PWkud2hpY2gpe3ZhciBuLHMsbz10KHRoaXMpLGE9by5wYXJlbnQoXFxcInVsXFxcIikuY2hpbGRyZW4oXFxcImxpXFxcIik7YS5lYWNoKGZ1bmN0aW9uKGkpe3JldHVybiB0KHRoaXMpLmlzKG8pP3ZvaWQoZS5vcHRpb25zLndyYXBPbktleXM/KG49MD09PWk/YS5sYXN0KCk6YS5lcShpLTEpLHM9aT09PWEubGVuZ3RoLTE/YS5maXJzdCgpOmEuZXEoaSsxKSk6KG49YS5lcShNYXRoLm1heCgwLGktMSkpLHM9YS5lcShNYXRoLm1pbihpKzEsYS5sZW5ndGgtMSkpKSk6dm9pZCAwO30pLEZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KGksXFxcIlRhYnNcXFwiLHtvcGVuOmZ1bmN0aW9uIG9wZW4oKXtvLmZpbmQoJ1tyb2xlPVxcXCJ0YWJcXFwiXScpLmZvY3VzKCksZS5faGFuZGxlVGFiQ2hhbmdlKG8pO30scHJldmlvdXM6ZnVuY3Rpb24gcHJldmlvdXMoKXtuLmZpbmQoJ1tyb2xlPVxcXCJ0YWJcXFwiXScpLmZvY3VzKCksZS5faGFuZGxlVGFiQ2hhbmdlKG4pO30sbmV4dDpmdW5jdGlvbiBuZXh0KCl7cy5maW5kKCdbcm9sZT1cXFwidGFiXFxcIl0nKS5mb2N1cygpLGUuX2hhbmRsZVRhYkNoYW5nZShzKTt9LGhhbmRsZWQ6ZnVuY3Rpb24gaGFuZGxlZCgpe2kuc3RvcFByb3BhZ2F0aW9uKCksaS5wcmV2ZW50RGVmYXVsdCgpO319KTt9fSk7fX0se2tleTpcXFwiX2hhbmRsZVRhYkNoYW5nZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSl7dmFyIGk9ZS5maW5kKCdbcm9sZT1cXFwidGFiXFxcIl0nKSxuPWlbMF0uaGFzaCxzPXRoaXMuJHRhYkNvbnRlbnQuZmluZChuKSxvPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiLlxcXCIrdGhpcy5vcHRpb25zLmxpbmtDbGFzcytcXFwiLmlzLWFjdGl2ZVxcXCIpLnJlbW92ZUNsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKS5maW5kKCdbcm9sZT1cXFwidGFiXFxcIl0nKS5hdHRyKHtcXFwiYXJpYS1zZWxlY3RlZFxcXCI6XFxcImZhbHNlXFxcIn0pO3QoXFxcIiNcXFwiK28uYXR0cihcXFwiYXJpYS1jb250cm9sc1xcXCIpKS5yZW1vdmVDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIikuYXR0cih7XFxcImFyaWEtaGlkZGVuXFxcIjpcXFwidHJ1ZVxcXCJ9KSxlLmFkZENsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKSxpLmF0dHIoe1xcXCJhcmlhLXNlbGVjdGVkXFxcIjpcXFwidHJ1ZVxcXCJ9KSxzLmFkZENsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKS5hdHRyKHtcXFwiYXJpYS1oaWRkZW5cXFwiOlxcXCJmYWxzZVxcXCJ9KSx0aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcImNoYW5nZS56Zi50YWJzXFxcIixbZV0pO319LHtrZXk6XFxcInNlbGVjdFRhYlxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dmFyIGU7ZT1cXFwib2JqZWN0XFxcIj09KHR5cGVvZiB0PT09XFxcInVuZGVmaW5lZFxcXCI/XFxcInVuZGVmaW5lZFxcXCI6X3R5cGVvZih0KSk/dFswXS5pZDp0LGUuaW5kZXhPZihcXFwiI1xcXCIpPDAmJihlPVxcXCIjXFxcIitlKTt2YXIgaT10aGlzLiR0YWJUaXRsZXMuZmluZCgnW2hyZWY9XFxcIicrZSsnXFxcIl0nKS5wYXJlbnQoXFxcIi5cXFwiK3RoaXMub3B0aW9ucy5saW5rQ2xhc3MpO3RoaXMuX2hhbmRsZVRhYkNoYW5nZShpKTt9fSx7a2V5OlxcXCJfc2V0SGVpZ2h0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPTA7dGhpcy4kdGFiQ29udGVudC5maW5kKFxcXCIuXFxcIit0aGlzLm9wdGlvbnMucGFuZWxDbGFzcykuY3NzKFxcXCJoZWlnaHRcXFwiLFxcXCJcXFwiKS5lYWNoKGZ1bmN0aW9uKCl7dmFyIGk9dCh0aGlzKSxuPWkuaGFzQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpO258fGkuY3NzKHt2aXNpYmlsaXR5OlxcXCJoaWRkZW5cXFwiLGRpc3BsYXk6XFxcImJsb2NrXFxcIn0pO3ZhciBzPXRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O258fGkuY3NzKHt2aXNpYmlsaXR5OlxcXCJcXFwiLGRpc3BsYXk6XFxcIlxcXCJ9KSxlPXM+ZT9zOmU7fSkuY3NzKFxcXCJoZWlnaHRcXFwiLGUrXFxcInB4XFxcIik7fX0se2tleTpcXFwiZGVzdHJveVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLiRlbGVtZW50LmZpbmQoXFxcIi5cXFwiK3RoaXMub3B0aW9ucy5saW5rQ2xhc3MpLm9mZihcXFwiLnpmLnRhYnNcXFwiKS5oaWRlKCkuZW5kKCkuZmluZChcXFwiLlxcXCIrdGhpcy5vcHRpb25zLnBhbmVsQ2xhc3MpLmhpZGUoKSx0aGlzLm9wdGlvbnMubWF0Y2hIZWlnaHQmJm51bGwhPXRoaXMuX3NldEhlaWdodE1xSGFuZGxlciYmdCh3aW5kb3cpLm9mZihcXFwiY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5XFxcIix0aGlzLl9zZXRIZWlnaHRNcUhhbmRsZXIpLEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTt9fV0pLGU7fSgpO2UuZGVmYXVsdHM9e2F1dG9Gb2N1czohMSx3cmFwT25LZXlzOiEwLG1hdGNoSGVpZ2h0OiExLGxpbmtDbGFzczpcXFwidGFicy10aXRsZVxcXCIscGFuZWxDbGFzczpcXFwidGFicy1wYW5lbFxcXCJ9LEZvdW5kYXRpb24ucGx1Z2luKGUsXFxcIlRhYnNcXFwiKTt9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcXFwidmFsdWVcXFwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pO319cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZTt9O30oKTshZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGksbil7X2NsYXNzQ2FsbENoZWNrKHRoaXMsZSksdGhpcy4kZWxlbWVudD1pLHRoaXMub3B0aW9ucz10LmV4dGVuZCh7fSxlLmRlZmF1bHRzLGkuZGF0YSgpLG4pLHRoaXMuY2xhc3NOYW1lPVxcXCJcXFwiLHRoaXMuX2luaXQoKSx0aGlzLl9ldmVudHMoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXFxcIlRvZ2dsZXJcXFwiKTt9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLFt7a2V5OlxcXCJfaW5pdFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZTt0aGlzLm9wdGlvbnMuYW5pbWF0ZT8oZT10aGlzLm9wdGlvbnMuYW5pbWF0ZS5zcGxpdChcXFwiIFxcXCIpLHRoaXMuYW5pbWF0aW9uSW49ZVswXSx0aGlzLmFuaW1hdGlvbk91dD1lWzFdfHxudWxsKTooZT10aGlzLiRlbGVtZW50LmRhdGEoXFxcInRvZ2dsZXJcXFwiKSx0aGlzLmNsYXNzTmFtZT1cXFwiLlxcXCI9PT1lWzBdP2Uuc2xpY2UoMSk6ZSk7dmFyIGk9dGhpcy4kZWxlbWVudFswXS5pZDt0KCdbZGF0YS1vcGVuPVxcXCInK2krJ1xcXCJdLCBbZGF0YS1jbG9zZT1cXFwiJytpKydcXFwiXSwgW2RhdGEtdG9nZ2xlPVxcXCInK2krJ1xcXCJdJykuYXR0cihcXFwiYXJpYS1jb250cm9sc1xcXCIsaSksdGhpcy4kZWxlbWVudC5hdHRyKFxcXCJhcmlhLWV4cGFuZGVkXFxcIiwhdGhpcy4kZWxlbWVudC5pcyhcXFwiOmhpZGRlblxcXCIpKTt9fSx7a2V5OlxcXCJfZXZlbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuJGVsZW1lbnQub2ZmKFxcXCJ0b2dnbGUuemYudHJpZ2dlclxcXCIpLm9uKFxcXCJ0b2dnbGUuemYudHJpZ2dlclxcXCIsdGhpcy50b2dnbGUuYmluZCh0aGlzKSk7fX0se2tleTpcXFwidG9nZ2xlXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXNbdGhpcy5vcHRpb25zLmFuaW1hdGU/XFxcIl90b2dnbGVBbmltYXRlXFxcIjpcXFwiX3RvZ2dsZUNsYXNzXFxcIl0oKTt9fSx7a2V5OlxcXCJfdG9nZ2xlQ2xhc3NcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy4kZWxlbWVudC50b2dnbGVDbGFzcyh0aGlzLmNsYXNzTmFtZSk7dmFyIHQ9dGhpcy4kZWxlbWVudC5oYXNDbGFzcyh0aGlzLmNsYXNzTmFtZSk7dD90aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcIm9uLnpmLnRvZ2dsZXJcXFwiKTp0aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcIm9mZi56Zi50b2dnbGVyXFxcIiksdGhpcy5fdXBkYXRlQVJJQSh0KTt9fSx7a2V5OlxcXCJfdG9nZ2xlQW5pbWF0ZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgdD10aGlzO3RoaXMuJGVsZW1lbnQuaXMoXFxcIjpoaWRkZW5cXFwiKT9Gb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlSW4odGhpcy4kZWxlbWVudCx0aGlzLmFuaW1hdGlvbkluLGZ1bmN0aW9uKCl7dC5fdXBkYXRlQVJJQSghMCksdGhpcy50cmlnZ2VyKFxcXCJvbi56Zi50b2dnbGVyXFxcIik7fSk6Rm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZU91dCh0aGlzLiRlbGVtZW50LHRoaXMuYW5pbWF0aW9uT3V0LGZ1bmN0aW9uKCl7dC5fdXBkYXRlQVJJQSghMSksdGhpcy50cmlnZ2VyKFxcXCJvZmYuemYudG9nZ2xlclxcXCIpO30pO319LHtrZXk6XFxcIl91cGRhdGVBUklBXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt0aGlzLiRlbGVtZW50LmF0dHIoXFxcImFyaWEtZXhwYW5kZWRcXFwiLCEhdCk7fX0se2tleTpcXFwiZGVzdHJveVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLiRlbGVtZW50Lm9mZihcXFwiLnpmLnRvZ2dsZXJcXFwiKSxGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKSxlO30oKTtlLmRlZmF1bHRzPXthbmltYXRlOiExfSxGb3VuZGF0aW9uLnBsdWdpbihlLFxcXCJUb2dnbGVyXFxcIik7fShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXFxcInZhbHVlXFxcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLmtleSxuKTt9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGU7fTt9KCk7IWZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShpLG4pe19jbGFzc0NhbGxDaGVjayh0aGlzLGUpLHRoaXMuJGVsZW1lbnQ9aSx0aGlzLm9wdGlvbnM9dC5leHRlbmQoe30sZS5kZWZhdWx0cyx0aGlzLiRlbGVtZW50LmRhdGEoKSxuKSx0aGlzLmlzQWN0aXZlPSExLHRoaXMuaXNDbGljaz0hMSx0aGlzLl9pbml0KCksRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLFxcXCJUb29sdGlwXFxcIik7fXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcXFwiX2luaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpcy4kZWxlbWVudC5hdHRyKFxcXCJhcmlhLWRlc2NyaWJlZGJ5XFxcIil8fEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNixcXFwidG9vbHRpcFxcXCIpO3RoaXMub3B0aW9ucy5wb3NpdGlvbkNsYXNzPXRoaXMub3B0aW9ucy5wb3NpdGlvbkNsYXNzfHx0aGlzLl9nZXRQb3NpdGlvbkNsYXNzKHRoaXMuJGVsZW1lbnQpLHRoaXMub3B0aW9ucy50aXBUZXh0PXRoaXMub3B0aW9ucy50aXBUZXh0fHx0aGlzLiRlbGVtZW50LmF0dHIoXFxcInRpdGxlXFxcIiksdGhpcy50ZW1wbGF0ZT10aGlzLm9wdGlvbnMudGVtcGxhdGU/dCh0aGlzLm9wdGlvbnMudGVtcGxhdGUpOnRoaXMuX2J1aWxkVGVtcGxhdGUoZSksdGhpcy50ZW1wbGF0ZS5hcHBlbmRUbyhkb2N1bWVudC5ib2R5KS50ZXh0KHRoaXMub3B0aW9ucy50aXBUZXh0KS5oaWRlKCksdGhpcy4kZWxlbWVudC5hdHRyKHt0aXRsZTpcXFwiXFxcIixcXFwiYXJpYS1kZXNjcmliZWRieVxcXCI6ZSxcXFwiZGF0YS15ZXRpLWJveFxcXCI6ZSxcXFwiZGF0YS10b2dnbGVcXFwiOmUsXFxcImRhdGEtcmVzaXplXFxcIjplfSkuYWRkQ2xhc3ModGhpcy50cmlnZ2VyQ2xhc3MpLHRoaXMudXNlZFBvc2l0aW9ucz1bXSx0aGlzLmNvdW50ZXI9NCx0aGlzLmNsYXNzQ2hhbmdlZD0hMSx0aGlzLl9ldmVudHMoKTt9fSx7a2V5OlxcXCJfZ2V0UG9zaXRpb25DbGFzc1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7aWYoIXQpcmV0dXJuXFxcIlxcXCI7dmFyIGU9dFswXS5jbGFzc05hbWUubWF0Y2goL1xcXFxiKHRvcHxsZWZ0fHJpZ2h0KVxcXFxiL2cpO3JldHVybiBlPWU/ZVswXTpcXFwiXFxcIjt9fSx7a2V5OlxcXCJfYnVpbGRUZW1wbGF0ZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSl7dmFyIGk9KHRoaXMub3B0aW9ucy50b29sdGlwQ2xhc3MrXFxcIiBcXFwiK3RoaXMub3B0aW9ucy5wb3NpdGlvbkNsYXNzK1xcXCIgXFxcIit0aGlzLm9wdGlvbnMudGVtcGxhdGVDbGFzc2VzKS50cmltKCksbj10KFxcXCI8ZGl2PjwvZGl2PlxcXCIpLmFkZENsYXNzKGkpLmF0dHIoe3JvbGU6XFxcInRvb2x0aXBcXFwiLFxcXCJhcmlhLWhpZGRlblxcXCI6ITAsXFxcImRhdGEtaXMtYWN0aXZlXFxcIjohMSxcXFwiZGF0YS1pcy1mb2N1c1xcXCI6ITEsaWQ6ZX0pO3JldHVybiBuO319LHtrZXk6XFxcIl9yZXBvc2l0aW9uXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt0aGlzLnVzZWRQb3NpdGlvbnMucHVzaCh0P3Q6XFxcImJvdHRvbVxcXCIpLCF0JiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwidG9wXFxcIik8MD90aGlzLnRlbXBsYXRlLmFkZENsYXNzKFxcXCJ0b3BcXFwiKTpcXFwidG9wXFxcIj09PXQmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJib3R0b21cXFwiKTwwP3RoaXMudGVtcGxhdGUucmVtb3ZlQ2xhc3ModCk6XFxcImxlZnRcXFwiPT09dCYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcInJpZ2h0XFxcIik8MD90aGlzLnRlbXBsYXRlLnJlbW92ZUNsYXNzKHQpLmFkZENsYXNzKFxcXCJyaWdodFxcXCIpOlxcXCJyaWdodFxcXCI9PT10JiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwibGVmdFxcXCIpPDA/dGhpcy50ZW1wbGF0ZS5yZW1vdmVDbGFzcyh0KS5hZGRDbGFzcyhcXFwibGVmdFxcXCIpOiF0JiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwidG9wXFxcIik+LTEmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJsZWZ0XFxcIik8MD90aGlzLnRlbXBsYXRlLmFkZENsYXNzKFxcXCJsZWZ0XFxcIik6XFxcInRvcFxcXCI9PT10JiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwiYm90dG9tXFxcIik+LTEmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJsZWZ0XFxcIik8MD90aGlzLnRlbXBsYXRlLnJlbW92ZUNsYXNzKHQpLmFkZENsYXNzKFxcXCJsZWZ0XFxcIik6XFxcImxlZnRcXFwiPT09dCYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcInJpZ2h0XFxcIik+LTEmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJib3R0b21cXFwiKTwwP3RoaXMudGVtcGxhdGUucmVtb3ZlQ2xhc3ModCk6XFxcInJpZ2h0XFxcIj09PXQmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJsZWZ0XFxcIik+LTEmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJib3R0b21cXFwiKTwwP3RoaXMudGVtcGxhdGUucmVtb3ZlQ2xhc3ModCk6dGhpcy50ZW1wbGF0ZS5yZW1vdmVDbGFzcyh0KSx0aGlzLmNsYXNzQ2hhbmdlZD0hMCx0aGlzLmNvdW50ZXItLTt9fSx7a2V5OlxcXCJfc2V0UG9zaXRpb25cXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIHQ9dGhpcy5fZ2V0UG9zaXRpb25DbGFzcyh0aGlzLnRlbXBsYXRlKSxlPUZvdW5kYXRpb24uQm94LkdldERpbWVuc2lvbnModGhpcy50ZW1wbGF0ZSksaT1Gb3VuZGF0aW9uLkJveC5HZXREaW1lbnNpb25zKHRoaXMuJGVsZW1lbnQpLG49XFxcImxlZnRcXFwiPT09dD9cXFwibGVmdFxcXCI6XFxcInJpZ2h0XFxcIj09PXQ/XFxcImxlZnRcXFwiOlxcXCJ0b3BcXFwiLHM9XFxcInRvcFxcXCI9PT1uP1xcXCJoZWlnaHRcXFwiOlxcXCJ3aWR0aFxcXCI7XFxcImhlaWdodFxcXCI9PT1zP3RoaXMub3B0aW9ucy52T2Zmc2V0OnRoaXMub3B0aW9ucy5oT2Zmc2V0O2lmKGUud2lkdGg+PWUud2luZG93RGltcy53aWR0aHx8IXRoaXMuY291bnRlciYmIUZvdW5kYXRpb24uQm94LkltTm90VG91Y2hpbmdZb3UodGhpcy50ZW1wbGF0ZSkpcmV0dXJuIHRoaXMudGVtcGxhdGUub2Zmc2V0KEZvdW5kYXRpb24uQm94LkdldE9mZnNldHModGhpcy50ZW1wbGF0ZSx0aGlzLiRlbGVtZW50LFxcXCJjZW50ZXIgYm90dG9tXFxcIix0aGlzLm9wdGlvbnMudk9mZnNldCx0aGlzLm9wdGlvbnMuaE9mZnNldCwhMCkpLmNzcyh7d2lkdGg6aS53aW5kb3dEaW1zLndpZHRoLTIqdGhpcy5vcHRpb25zLmhPZmZzZXQsaGVpZ2h0OlxcXCJhdXRvXFxcIn0pLCExO2Zvcih0aGlzLnRlbXBsYXRlLm9mZnNldChGb3VuZGF0aW9uLkJveC5HZXRPZmZzZXRzKHRoaXMudGVtcGxhdGUsdGhpcy4kZWxlbWVudCxcXFwiY2VudGVyIFxcXCIrKHR8fFxcXCJib3R0b21cXFwiKSx0aGlzLm9wdGlvbnMudk9mZnNldCx0aGlzLm9wdGlvbnMuaE9mZnNldCkpOyFGb3VuZGF0aW9uLkJveC5JbU5vdFRvdWNoaW5nWW91KHRoaXMudGVtcGxhdGUpJiZ0aGlzLmNvdW50ZXI7KXt0aGlzLl9yZXBvc2l0aW9uKHQpLHRoaXMuX3NldFBvc2l0aW9uKCk7fX19LHtrZXk6XFxcInNob3dcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7aWYoXFxcImFsbFxcXCIhPT10aGlzLm9wdGlvbnMuc2hvd09uJiYhRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmF0TGVhc3QodGhpcy5vcHRpb25zLnNob3dPbikpcmV0dXJuITE7dmFyIHQ9dGhpczt0aGlzLnRlbXBsYXRlLmNzcyhcXFwidmlzaWJpbGl0eVxcXCIsXFxcImhpZGRlblxcXCIpLnNob3coKSx0aGlzLl9zZXRQb3NpdGlvbigpLHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwiY2xvc2VtZS56Zi50b29sdGlwXFxcIix0aGlzLnRlbXBsYXRlLmF0dHIoXFxcImlkXFxcIikpLHRoaXMudGVtcGxhdGUuYXR0cih7XFxcImRhdGEtaXMtYWN0aXZlXFxcIjohMCxcXFwiYXJpYS1oaWRkZW5cXFwiOiExfSksdC5pc0FjdGl2ZT0hMCx0aGlzLnRlbXBsYXRlLnN0b3AoKS5oaWRlKCkuY3NzKFxcXCJ2aXNpYmlsaXR5XFxcIixcXFwiXFxcIikuZmFkZUluKHRoaXMub3B0aW9ucy5mYWRlSW5EdXJhdGlvbixmdW5jdGlvbigpe30pLHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwic2hvdy56Zi50b29sdGlwXFxcIik7fX0se2tleTpcXFwiaGlkZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgdD10aGlzO3RoaXMudGVtcGxhdGUuc3RvcCgpLmF0dHIoe1xcXCJhcmlhLWhpZGRlblxcXCI6ITAsXFxcImRhdGEtaXMtYWN0aXZlXFxcIjohMX0pLmZhZGVPdXQodGhpcy5vcHRpb25zLmZhZGVPdXREdXJhdGlvbixmdW5jdGlvbigpe3QuaXNBY3RpdmU9ITEsdC5pc0NsaWNrPSExLHQuY2xhc3NDaGFuZ2VkJiYodC50ZW1wbGF0ZS5yZW1vdmVDbGFzcyh0Ll9nZXRQb3NpdGlvbkNsYXNzKHQudGVtcGxhdGUpKS5hZGRDbGFzcyh0Lm9wdGlvbnMucG9zaXRpb25DbGFzcyksdC51c2VkUG9zaXRpb25zPVtdLHQuY291bnRlcj00LHQuY2xhc3NDaGFuZ2VkPSExKTt9KSx0aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcImhpZGUuemYudG9vbHRpcFxcXCIpO319LHtrZXk6XFxcIl9ldmVudHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIHQ9dGhpcyxlPSh0aGlzLnRlbXBsYXRlLCExKTt0aGlzLm9wdGlvbnMuZGlzYWJsZUhvdmVyfHx0aGlzLiRlbGVtZW50Lm9uKFxcXCJtb3VzZWVudGVyLnpmLnRvb2x0aXBcXFwiLGZ1bmN0aW9uKGUpe3QuaXNBY3RpdmV8fCh0LnRpbWVvdXQ9c2V0VGltZW91dChmdW5jdGlvbigpe3Quc2hvdygpO30sdC5vcHRpb25zLmhvdmVyRGVsYXkpKTt9KS5vbihcXFwibW91c2VsZWF2ZS56Zi50b29sdGlwXFxcIixmdW5jdGlvbihpKXtjbGVhclRpbWVvdXQodC50aW1lb3V0KSwoIWV8fHQuaXNDbGljayYmIXQub3B0aW9ucy5jbGlja09wZW4pJiZ0LmhpZGUoKTt9KSx0aGlzLm9wdGlvbnMuY2xpY2tPcGVuP3RoaXMuJGVsZW1lbnQub24oXFxcIm1vdXNlZG93bi56Zi50b29sdGlwXFxcIixmdW5jdGlvbihlKXtlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLHQuaXNDbGlja3x8KHQuaXNDbGljaz0hMCwhdC5vcHRpb25zLmRpc2FibGVIb3ZlciYmdC4kZWxlbWVudC5hdHRyKFxcXCJ0YWJpbmRleFxcXCIpfHx0LmlzQWN0aXZlfHx0LnNob3coKSk7fSk6dGhpcy4kZWxlbWVudC5vbihcXFwibW91c2Vkb3duLnpmLnRvb2x0aXBcXFwiLGZ1bmN0aW9uKGUpe2Uuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksdC5pc0NsaWNrPSEwO30pLHRoaXMub3B0aW9ucy5kaXNhYmxlRm9yVG91Y2h8fHRoaXMuJGVsZW1lbnQub24oXFxcInRhcC56Zi50b29sdGlwIHRvdWNoZW5kLnpmLnRvb2x0aXBcXFwiLGZ1bmN0aW9uKGUpe3QuaXNBY3RpdmU/dC5oaWRlKCk6dC5zaG93KCk7fSksdGhpcy4kZWxlbWVudC5vbih7XFxcImNsb3NlLnpmLnRyaWdnZXJcXFwiOnRoaXMuaGlkZS5iaW5kKHRoaXMpfSksdGhpcy4kZWxlbWVudC5vbihcXFwiZm9jdXMuemYudG9vbHRpcFxcXCIsZnVuY3Rpb24oaSl7cmV0dXJuIGU9ITAsdC5pc0NsaWNrPyh0Lm9wdGlvbnMuY2xpY2tPcGVufHwoZT0hMSksITEpOnZvaWQgdC5zaG93KCk7fSkub24oXFxcImZvY3Vzb3V0LnpmLnRvb2x0aXBcXFwiLGZ1bmN0aW9uKGkpe2U9ITEsdC5pc0NsaWNrPSExLHQuaGlkZSgpO30pLm9uKFxcXCJyZXNpemVtZS56Zi50cmlnZ2VyXFxcIixmdW5jdGlvbigpe3QuaXNBY3RpdmUmJnQuX3NldFBvc2l0aW9uKCk7fSk7fX0se2tleTpcXFwidG9nZ2xlXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuaXNBY3RpdmU/dGhpcy5oaWRlKCk6dGhpcy5zaG93KCk7fX0se2tleTpcXFwiZGVzdHJveVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLiRlbGVtZW50LmF0dHIoXFxcInRpdGxlXFxcIix0aGlzLnRlbXBsYXRlLnRleHQoKSkub2ZmKFxcXCIuemYudHJpZ2dlciAuemYudG9vdGlwXFxcIikucmVtb3ZlQXR0cihcXFwiYXJpYS1kZXNjcmliZWRieVxcXCIpLnJlbW92ZUF0dHIoXFxcImRhdGEteWV0aS1ib3hcXFwiKS5yZW1vdmVBdHRyKFxcXCJkYXRhLXRvZ2dsZVxcXCIpLnJlbW92ZUF0dHIoXFxcImRhdGEtcmVzaXplXFxcIiksdGhpcy50ZW1wbGF0ZS5yZW1vdmUoKSxGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKSxlO30oKTtlLmRlZmF1bHRzPXtkaXNhYmxlRm9yVG91Y2g6ITEsaG92ZXJEZWxheToyMDAsZmFkZUluRHVyYXRpb246MTUwLGZhZGVPdXREdXJhdGlvbjoxNTAsZGlzYWJsZUhvdmVyOiExLHRlbXBsYXRlQ2xhc3NlczpcXFwiXFxcIix0b29sdGlwQ2xhc3M6XFxcInRvb2x0aXBcXFwiLHRyaWdnZXJDbGFzczpcXFwiaGFzLXRpcFxcXCIsc2hvd09uOlxcXCJzbWFsbFxcXCIsdGVtcGxhdGU6XFxcIlxcXCIsdGlwVGV4dDpcXFwiXFxcIix0b3VjaENsb3NlVGV4dDpcXFwiVGFwIHRvIGNsb3NlLlxcXCIsY2xpY2tPcGVuOiEwLHBvc2l0aW9uQ2xhc3M6XFxcIlxcXCIsdk9mZnNldDoxMCxoT2Zmc2V0OjEyfSxGb3VuZGF0aW9uLnBsdWdpbihlLFxcXCJUb29sdGlwXFxcIik7fShqUXVlcnkpO1wiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmF3LWxvYWRlciEuL34vYmFiZWwtbG9hZGVyP3tcInByZXNldHNcIjpbXCJyZWFjdFwiLFwiZXMyMDE1XCIsXCJzdGFnZS0wXCJdfSEuL34vZm91bmRhdGlvbi1zaXRlcy9kaXN0L2ZvdW5kYXRpb24ubWluLmpzXG4gKiogbW9kdWxlIGlkID0gNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xudmFyIHtSb3V0ZSwgUm91dGVyLCBJbmRleFJvdXRlLCBoYXNoSGlzdG9yeX0gPSByZXF1aXJlKCdyZWFjdC1yb3V0ZXInKTtcblxuLy9sb2FkIGZvdW5kYXRpb25cbiQoZG9jdW1lbnQpLmZvdW5kYXRpb24oKTtcblxuLy8gQXBwIGNzc1xucmVxdWlyZSgnc3R5bGUhY3NzIXNhc3MhYXBwbGljYXRpb25TdHlsZXMnKTtcblxuXG5cbi8vIFJlYWN0RE9NLnJlbmRlcihcbi8vICAgPHA+Qm9pbGVycGxhdGUgMyBQcm9qZWN0PC9wPixcbi8vICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJhcHBcIilcbi8vICk7XG5cbi8vIHJlcXVpcmUoJy4vcmVkdXgtZXhhbXBsZS5qc3gnKTtcbnJlcXVpcmUoJy4vcmVkdXgtdG9kby1leGFtcGxlLmpzeCcpO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvYXBwLmpzeFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0galF1ZXJ5O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogZXh0ZXJuYWwgXCJqUXVlcnlcIlxuICoqIG1vZHVsZSBpZCA9IDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9SZWFjdCcpO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L3JlYWN0LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET00gPSByZXF1aXJlKCcuL1JlYWN0RE9NJyk7XG52YXIgUmVhY3RET01TZXJ2ZXIgPSByZXF1aXJlKCcuL1JlYWN0RE9NU2VydmVyJyk7XG52YXIgUmVhY3RJc29tb3JwaGljID0gcmVxdWlyZSgnLi9SZWFjdElzb21vcnBoaWMnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGRlcHJlY2F0ZWQgPSByZXF1aXJlKCcuL2RlcHJlY2F0ZWQnKTtcblxuLy8gYHZlcnNpb25gIHdpbGwgYmUgYWRkZWQgaGVyZSBieSBSZWFjdElzb21vcnBoaWMuXG52YXIgUmVhY3QgPSB7fTtcblxuYXNzaWduKFJlYWN0LCBSZWFjdElzb21vcnBoaWMpO1xuXG5hc3NpZ24oUmVhY3QsIHtcbiAgLy8gUmVhY3RET01cbiAgZmluZERPTU5vZGU6IGRlcHJlY2F0ZWQoJ2ZpbmRET01Ob2RlJywgJ1JlYWN0RE9NJywgJ3JlYWN0LWRvbScsIFJlYWN0RE9NLCBSZWFjdERPTS5maW5kRE9NTm9kZSksXG4gIHJlbmRlcjogZGVwcmVjYXRlZCgncmVuZGVyJywgJ1JlYWN0RE9NJywgJ3JlYWN0LWRvbScsIFJlYWN0RE9NLCBSZWFjdERPTS5yZW5kZXIpLFxuICB1bm1vdW50Q29tcG9uZW50QXROb2RlOiBkZXByZWNhdGVkKCd1bm1vdW50Q29tcG9uZW50QXROb2RlJywgJ1JlYWN0RE9NJywgJ3JlYWN0LWRvbScsIFJlYWN0RE9NLCBSZWFjdERPTS51bm1vdW50Q29tcG9uZW50QXROb2RlKSxcblxuICAvLyBSZWFjdERPTVNlcnZlclxuICByZW5kZXJUb1N0cmluZzogZGVwcmVjYXRlZCgncmVuZGVyVG9TdHJpbmcnLCAnUmVhY3RET01TZXJ2ZXInLCAncmVhY3QtZG9tL3NlcnZlcicsIFJlYWN0RE9NU2VydmVyLCBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZyksXG4gIHJlbmRlclRvU3RhdGljTWFya3VwOiBkZXByZWNhdGVkKCdyZW5kZXJUb1N0YXRpY01hcmt1cCcsICdSZWFjdERPTVNlcnZlcicsICdyZWFjdC1kb20vc2VydmVyJywgUmVhY3RET01TZXJ2ZXIsIFJlYWN0RE9NU2VydmVyLnJlbmRlclRvU3RhdGljTWFya3VwKVxufSk7XG5cblJlYWN0Ll9fU0VDUkVUX0RPTV9ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0gUmVhY3RET007XG5SZWFjdC5fX1NFQ1JFVF9ET01fU0VSVkVSX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQgPSBSZWFjdERPTVNlcnZlcjtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NXG4gKi9cblxuLyogZ2xvYmFscyBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdERPTVRleHRDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RE9NVGV4dENvbXBvbmVudCcpO1xudmFyIFJlYWN0RGVmYXVsdEluamVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3REZWZhdWx0SW5qZWN0aW9uJyk7XG52YXIgUmVhY3RJbnN0YW5jZUhhbmRsZXMgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VIYW5kbGVzJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xudmFyIFJlYWN0VmVyc2lvbiA9IHJlcXVpcmUoJy4vUmVhY3RWZXJzaW9uJyk7XG5cbnZhciBmaW5kRE9NTm9kZSA9IHJlcXVpcmUoJy4vZmluZERPTU5vZGUnKTtcbnZhciByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciA9IHJlcXVpcmUoJy4vcmVuZGVyU3VidHJlZUludG9Db250YWluZXInKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5SZWFjdERlZmF1bHRJbmplY3Rpb24uaW5qZWN0KCk7XG5cbnZhciByZW5kZXIgPSBSZWFjdFBlcmYubWVhc3VyZSgnUmVhY3QnLCAncmVuZGVyJywgUmVhY3RNb3VudC5yZW5kZXIpO1xuXG52YXIgUmVhY3QgPSB7XG4gIGZpbmRET01Ob2RlOiBmaW5kRE9NTm9kZSxcbiAgcmVuZGVyOiByZW5kZXIsXG4gIHVubW91bnRDb21wb25lbnRBdE5vZGU6IFJlYWN0TW91bnQudW5tb3VudENvbXBvbmVudEF0Tm9kZSxcbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuXG4gIC8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlczogUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzLFxuICB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjogcmVuZGVyU3VidHJlZUludG9Db250YWluZXJcbn07XG5cbi8vIEluamVjdCB0aGUgcnVudGltZSBpbnRvIGEgZGV2dG9vbHMgZ2xvYmFsIGhvb2sgcmVnYXJkbGVzcyBvZiBicm93c2VyLlxuLy8gQWxsb3dzIGZvciBkZWJ1Z2dpbmcgd2hlbiB0aGUgaG9vayBpcyBpbmplY3RlZCBvbiB0aGUgcGFnZS5cbi8qIGVzbGludC1lbmFibGUgY2FtZWxjYXNlICovXG5pZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5pbmplY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmluamVjdCh7XG4gICAgQ3VycmVudE93bmVyOiBSZWFjdEN1cnJlbnRPd25lcixcbiAgICBJbnN0YW5jZUhhbmRsZXM6IFJlYWN0SW5zdGFuY2VIYW5kbGVzLFxuICAgIE1vdW50OiBSZWFjdE1vdW50LFxuICAgIFJlY29uY2lsZXI6IFJlYWN0UmVjb25jaWxlcixcbiAgICBUZXh0Q29tcG9uZW50OiBSZWFjdERPTVRleHRDb21wb25lbnRcbiAgfSk7XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG4gIGlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgd2luZG93LnRvcCA9PT0gd2luZG93LnNlbGYpIHtcblxuICAgIC8vIEZpcnN0IGNoZWNrIGlmIGRldnRvb2xzIGlzIG5vdCBpbnN0YWxsZWRcbiAgICBpZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIElmIHdlJ3JlIGluIENocm9tZSBvciBGaXJlZm94LCBwcm92aWRlIGEgZG93bmxvYWQgbGluayBpZiBub3QgaW5zdGFsbGVkLlxuICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgPiAtMSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0VkZ2UnKSA9PT0gLTEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPiAtMSkge1xuICAgICAgICBjb25zb2xlLmRlYnVnKCdEb3dubG9hZCB0aGUgUmVhY3QgRGV2VG9vbHMgZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1kZXZ0b29scycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlJ3JlIGluIElFOCwgY2hlY2sgdG8gc2VlIGlmIHdlIGFyZSBpbiBjb21wYXRpYmlsaXR5IG1vZGUgYW5kIHByb3ZpZGVcbiAgICAvLyBpbmZvcm1hdGlvbiBvbiBwcmV2ZW50aW5nIGNvbXBhdGliaWxpdHkgbW9kZVxuICAgIHZhciBpZUNvbXBhdGliaWxpdHlNb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSA8IDg7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaWVDb21wYXRpYmlsaXR5TW9kZSwgJ0ludGVybmV0IEV4cGxvcmVyIGlzIHJ1bm5pbmcgaW4gY29tcGF0aWJpbGl0eSBtb2RlOyBwbGVhc2UgYWRkIHRoZSAnICsgJ2ZvbGxvd2luZyB0YWcgdG8geW91ciBIVE1MIHRvIHByZXZlbnQgdGhpcyBmcm9tIGhhcHBlbmluZzogJyArICc8bWV0YSBodHRwLWVxdWl2PVwiWC1VQS1Db21wYXRpYmxlXCIgY29udGVudD1cIklFPWVkZ2VcIiAvPicpIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGV4cGVjdGVkRmVhdHVyZXMgPSBbXG4gICAgLy8gc2hpbXNcbiAgICBBcnJheS5pc0FycmF5LCBBcnJheS5wcm90b3R5cGUuZXZlcnksIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiwgQXJyYXkucHJvdG90eXBlLm1hcCwgRGF0ZS5ub3csIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLCBPYmplY3Qua2V5cywgU3RyaW5nLnByb3RvdHlwZS5zcGxpdCwgU3RyaW5nLnByb3RvdHlwZS50cmltLFxuXG4gICAgLy8gc2hhbXNcbiAgICBPYmplY3QuY3JlYXRlLCBPYmplY3QuZnJlZXplXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRGZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFleHBlY3RlZEZlYXR1cmVzW2ldKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ09uZSBvciBtb3JlIEVTNSBzaGltL3NoYW1zIGV4cGVjdGVkIGJ5IFJlYWN0IGFyZSBub3QgYXZhaWxhYmxlOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1wb2x5ZmlsbHMnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3Q7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTS5qc1xuICoqLyIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcHJvY2Vzcy9icm93c2VyLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q3VycmVudE93bmVyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IG93bmVyLlxuICpcbiAqIFRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBjb21wb25lbnQgd2hvIHNob3VsZCBvd24gYW55IGNvbXBvbmVudHMgdGhhdCBhcmVcbiAqIGN1cnJlbnRseSBiZWluZyBjb25zdHJ1Y3RlZC5cbiAqL1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0ge1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q3VycmVudE93bmVyO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RDdXJyZW50T3duZXIuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01UZXh0Q29tcG9uZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTUNoaWxkcmVuT3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NQ2hpbGRyZW5PcGVyYXRpb25zJyk7XG52YXIgRE9NUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnMnKTtcbnZhciBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIgPSByZXF1aXJlKCcuL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlcicpO1xudmFyIHNldFRleHRDb250ZW50ID0gcmVxdWlyZSgnLi9zZXRUZXh0Q29udGVudCcpO1xudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IHJlcXVpcmUoJy4vdmFsaWRhdGVET01OZXN0aW5nJyk7XG5cbi8qKlxuICogVGV4dCBub2RlcyB2aW9sYXRlIGEgY291cGxlIGFzc3VtcHRpb25zIHRoYXQgUmVhY3QgbWFrZXMgYWJvdXQgY29tcG9uZW50czpcbiAqXG4gKiAgLSBXaGVuIG1vdW50aW5nIHRleHQgaW50byB0aGUgRE9NLCBhZGphY2VudCB0ZXh0IG5vZGVzIGFyZSBtZXJnZWQuXG4gKiAgLSBUZXh0IG5vZGVzIGNhbm5vdCBiZSBhc3NpZ25lZCBhIFJlYWN0IHJvb3QgSUQuXG4gKlxuICogVGhpcyBjb21wb25lbnQgaXMgdXNlZCB0byB3cmFwIHN0cmluZ3MgaW4gZWxlbWVudHMgc28gdGhhdCB0aGV5IGNhbiB1bmRlcmdvXG4gKiB0aGUgc2FtZSByZWNvbmNpbGlhdGlvbiB0aGF0IGlzIGFwcGxpZWQgdG8gZWxlbWVudHMuXG4gKlxuICogVE9ETzogSW52ZXN0aWdhdGUgcmVwcmVzZW50aW5nIFJlYWN0IGNvbXBvbmVudHMgaW4gdGhlIERPTSB3aXRoIHRleHQgbm9kZXMuXG4gKlxuICogQGNsYXNzIFJlYWN0RE9NVGV4dENvbXBvbmVudFxuICogQGV4dGVuZHMgUmVhY3RDb21wb25lbnRcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RET01UZXh0Q29tcG9uZW50ID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gIC8vIFRoaXMgY29uc3RydWN0b3IgYW5kIGl0cyBhcmd1bWVudCBpcyBjdXJyZW50bHkgdXNlZCBieSBtb2Nrcy5cbn07XG5cbmFzc2lnbihSZWFjdERPTVRleHRDb21wb25lbnQucHJvdG90eXBlLCB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UmVhY3RUZXh0fSB0ZXh0XG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0OiBmdW5jdGlvbiAodGV4dCkge1xuICAgIC8vIFRPRE86IFRoaXMgaXMgcmVhbGx5IGEgUmVhY3RUZXh0IChSZWFjdE5vZGUpLCBub3QgYSBSZWFjdEVsZW1lbnRcbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IHRleHQ7XG4gICAgdGhpcy5fc3RyaW5nVGV4dCA9ICcnICsgdGV4dDtcblxuICAgIC8vIFByb3BlcnRpZXNcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gbnVsbDtcbiAgICB0aGlzLl9tb3VudEluZGV4ID0gMDtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgbWFya3VwIGZvciB0aGlzIHRleHQgbm9kZS4gVGhpcyBub2RlIGlzIG5vdCBpbnRlbmRlZCB0byBoYXZlXG4gICAqIGFueSBmZWF0dXJlcyBiZXNpZGVzIGNvbnRhaW5pbmcgdGV4dCBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcm9vdElEIERPTSBJRCBvZiB0aGUgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgZm9yIHRoaXMgdGV4dCBub2RlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAocm9vdElELCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoY29udGV4dFt2YWxpZGF0ZURPTU5lc3RpbmcuYW5jZXN0b3JJbmZvQ29udGV4dEtleV0pIHtcbiAgICAgICAgdmFsaWRhdGVET01OZXN0aW5nKCdzcGFuJywgbnVsbCwgY29udGV4dFt2YWxpZGF0ZURPTU5lc3RpbmcuYW5jZXN0b3JJbmZvQ29udGV4dEtleV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSByb290SUQ7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnVzZUNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lckRvY3VtZW50ID0gY29udGV4dFtSZWFjdE1vdW50Lm93bmVyRG9jdW1lbnRDb250ZXh0S2V5XTtcbiAgICAgIHZhciBlbCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldEF0dHJpYnV0ZUZvcklEKGVsLCByb290SUQpO1xuICAgICAgLy8gUG9wdWxhdGUgbm9kZSBjYWNoZVxuICAgICAgUmVhY3RNb3VudC5nZXRJRChlbCk7XG4gICAgICBzZXRUZXh0Q29udGVudChlbCwgdGhpcy5fc3RyaW5nVGV4dCk7XG4gICAgICByZXR1cm4gZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlc2NhcGVkVGV4dCA9IGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlcih0aGlzLl9zdHJpbmdUZXh0KTtcblxuICAgICAgaWYgKHRyYW5zYWN0aW9uLnJlbmRlclRvU3RhdGljTWFya3VwKSB7XG4gICAgICAgIC8vIE5vcm1hbGx5IHdlJ2Qgd3JhcCB0aGlzIGluIGEgYHNwYW5gIGZvciB0aGUgcmVhc29ucyBzdGF0ZWQgYWJvdmUsIGJ1dFxuICAgICAgICAvLyBzaW5jZSB0aGlzIGlzIGEgc2l0dWF0aW9uIHdoZXJlIFJlYWN0IHdvbid0IHRha2Ugb3ZlciAoc3RhdGljIHBhZ2VzKSxcbiAgICAgICAgLy8gd2UgY2FuIHNpbXBseSByZXR1cm4gdGhlIHRleHQgYXMgaXQgaXMuXG4gICAgICAgIHJldHVybiBlc2NhcGVkVGV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICc8c3BhbiAnICsgRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvcklEKHJvb3RJRCkgKyAnPicgKyBlc2NhcGVkVGV4dCArICc8L3NwYW4+JztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhpcyBjb21wb25lbnQgYnkgdXBkYXRpbmcgdGhlIHRleHQgY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFRleHR9IG5leHRUZXh0IFRoZSBuZXh0IHRleHQgY29udGVudFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKG5leHRUZXh0LCB0cmFuc2FjdGlvbikge1xuICAgIGlmIChuZXh0VGV4dCAhPT0gdGhpcy5fY3VycmVudEVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dFRleHQ7XG4gICAgICB2YXIgbmV4dFN0cmluZ1RleHQgPSAnJyArIG5leHRUZXh0O1xuICAgICAgaWYgKG5leHRTdHJpbmdUZXh0ICE9PSB0aGlzLl9zdHJpbmdUZXh0KSB7XG4gICAgICAgIC8vIFRPRE86IFNhdmUgdGhpcyBhcyBwZW5kaW5nIHByb3BzIGFuZCB1c2UgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5XG4gICAgICAgIC8vIGFuZC9vciB1cGRhdGVDb21wb25lbnQgdG8gZG8gdGhlIGFjdHVhbCB1cGRhdGUgZm9yIGNvbnNpc3RlbmN5IHdpdGhcbiAgICAgICAgLy8gb3RoZXIgY29tcG9uZW50IHR5cGVzP1xuICAgICAgICB0aGlzLl9zdHJpbmdUZXh0ID0gbmV4dFN0cmluZ1RleHQ7XG4gICAgICAgIHZhciBub2RlID0gUmVhY3RNb3VudC5nZXROb2RlKHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgICAgICBET01DaGlsZHJlbk9wZXJhdGlvbnMudXBkYXRlVGV4dENvbnRlbnQobm9kZSwgbmV4dFN0cmluZ1RleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQudW5tb3VudElERnJvbUVudmlyb25tZW50KHRoaXMuX3Jvb3ROb2RlSUQpO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NVGV4dENvbXBvbmVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NVGV4dENvbXBvbmVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBET01DaGlsZHJlbk9wZXJhdGlvbnNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRGFuZ2VyID0gcmVxdWlyZSgnLi9EYW5nZXInKTtcbnZhciBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMnKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKCcuL1JlYWN0UGVyZicpO1xuXG52YXIgc2V0SW5uZXJIVE1MID0gcmVxdWlyZSgnLi9zZXRJbm5lckhUTUwnKTtcbnZhciBzZXRUZXh0Q29udGVudCA9IHJlcXVpcmUoJy4vc2V0VGV4dENvbnRlbnQnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBJbnNlcnRzIGBjaGlsZE5vZGVgIGFzIGEgY2hpbGQgb2YgYHBhcmVudE5vZGVgIGF0IHRoZSBgaW5kZXhgLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcGFyZW50Tm9kZSBQYXJlbnQgbm9kZSBpbiB3aGljaCB0byBpbnNlcnQuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNoaWxkTm9kZSBDaGlsZCBub2RlIHRvIGluc2VydC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0byBpbnNlcnQgdGhlIGNoaWxkLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGluc2VydENoaWxkQXQocGFyZW50Tm9kZSwgY2hpbGROb2RlLCBpbmRleCkge1xuICAvLyBCeSBleHBsb2l0aW5nIGFycmF5cyByZXR1cm5pbmcgYHVuZGVmaW5lZGAgZm9yIGFuIHVuZGVmaW5lZCBpbmRleCwgd2UgY2FuXG4gIC8vIHJlbHkgZXhjbHVzaXZlbHkgb24gYGluc2VydEJlZm9yZShub2RlLCBudWxsKWAgaW5zdGVhZCBvZiBhbHNvIHVzaW5nXG4gIC8vIGBhcHBlbmRDaGlsZChub2RlKWAuIEhvd2V2ZXIsIHVzaW5nIGB1bmRlZmluZWRgIGlzIG5vdCBhbGxvd2VkIGJ5IGFsbFxuICAvLyBicm93c2VycyBzbyB3ZSBtdXN0IHJlcGxhY2UgaXQgd2l0aCBgbnVsbGAuXG5cbiAgLy8gZml4IHJlbmRlciBvcmRlciBlcnJvciBpbiBzYWZhcmlcbiAgLy8gSUU4IHdpbGwgdGhyb3cgZXJyb3Igd2hlbiBpbmRleCBvdXQgb2YgbGlzdCBzaXplLlxuICB2YXIgYmVmb3JlQ2hpbGQgPSBpbmRleCA+PSBwYXJlbnROb2RlLmNoaWxkTm9kZXMubGVuZ3RoID8gbnVsbCA6IHBhcmVudE5vZGUuY2hpbGROb2Rlcy5pdGVtKGluZGV4KTtcblxuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZE5vZGUsIGJlZm9yZUNoaWxkKTtcbn1cblxuLyoqXG4gKiBPcGVyYXRpb25zIGZvciB1cGRhdGluZyB3aXRoIERPTSBjaGlsZHJlbi5cbiAqL1xudmFyIERPTUNoaWxkcmVuT3BlcmF0aW9ucyA9IHtcblxuICBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cDogRGFuZ2VyLmRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwLFxuXG4gIHVwZGF0ZVRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcblxuICAvKipcbiAgICogVXBkYXRlcyBhIGNvbXBvbmVudCdzIGNoaWxkcmVuIGJ5IHByb2Nlc3NpbmcgYSBzZXJpZXMgb2YgdXBkYXRlcy4gVGhlXG4gICAqIHVwZGF0ZSBjb25maWd1cmF0aW9ucyBhcmUgZWFjaCBleHBlY3RlZCB0byBoYXZlIGEgYHBhcmVudE5vZGVgIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5PG9iamVjdD59IHVwZGF0ZXMgTGlzdCBvZiB1cGRhdGUgY29uZmlndXJhdGlvbnMuXG4gICAqIEBwYXJhbSB7YXJyYXk8c3RyaW5nPn0gbWFya3VwTGlzdCBMaXN0IG9mIG1hcmt1cCBzdHJpbmdzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByb2Nlc3NVcGRhdGVzOiBmdW5jdGlvbiAodXBkYXRlcywgbWFya3VwTGlzdCkge1xuICAgIHZhciB1cGRhdGU7XG4gICAgLy8gTWFwcGluZyBmcm9tIHBhcmVudCBJRHMgdG8gaW5pdGlhbCBjaGlsZCBvcmRlcmluZ3MuXG4gICAgdmFyIGluaXRpYWxDaGlsZHJlbiA9IG51bGw7XG4gICAgLy8gTGlzdCBvZiBjaGlsZHJlbiB0aGF0IHdpbGwgYmUgbW92ZWQgb3IgcmVtb3ZlZC5cbiAgICB2YXIgdXBkYXRlZENoaWxkcmVuID0gbnVsbDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXBkYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdXBkYXRlID0gdXBkYXRlc1tpXTtcbiAgICAgIGlmICh1cGRhdGUudHlwZSA9PT0gUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuTU9WRV9FWElTVElORyB8fCB1cGRhdGUudHlwZSA9PT0gUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuUkVNT1ZFX05PREUpIHtcbiAgICAgICAgdmFyIHVwZGF0ZWRJbmRleCA9IHVwZGF0ZS5mcm9tSW5kZXg7XG4gICAgICAgIHZhciB1cGRhdGVkQ2hpbGQgPSB1cGRhdGUucGFyZW50Tm9kZS5jaGlsZE5vZGVzW3VwZGF0ZWRJbmRleF07XG4gICAgICAgIHZhciBwYXJlbnRJRCA9IHVwZGF0ZS5wYXJlbnRJRDtcblxuICAgICAgICAhdXBkYXRlZENoaWxkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3Byb2Nlc3NVcGRhdGVzKCk6IFVuYWJsZSB0byBmaW5kIGNoaWxkICVzIG9mIGVsZW1lbnQuIFRoaXMgJyArICdwcm9iYWJseSBtZWFucyB0aGUgRE9NIHdhcyB1bmV4cGVjdGVkbHkgbXV0YXRlZCAoZS5nLiwgYnkgdGhlICcgKyAnYnJvd3NlciksIHVzdWFsbHkgZHVlIHRvIGZvcmdldHRpbmcgYSA8dGJvZHk+IHdoZW4gdXNpbmcgdGFibGVzLCAnICsgJ25lc3RpbmcgdGFncyBsaWtlIDxmb3JtPiwgPHA+LCBvciA8YT4sIG9yIHVzaW5nIG5vbi1TVkcgZWxlbWVudHMgJyArICdpbiBhbiA8c3ZnPiBwYXJlbnQuIFRyeSBpbnNwZWN0aW5nIHRoZSBjaGlsZCBub2RlcyBvZiB0aGUgZWxlbWVudCAnICsgJ3dpdGggUmVhY3QgSUQgYCVzYC4nLCB1cGRhdGVkSW5kZXgsIHBhcmVudElEKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaW5pdGlhbENoaWxkcmVuID0gaW5pdGlhbENoaWxkcmVuIHx8IHt9O1xuICAgICAgICBpbml0aWFsQ2hpbGRyZW5bcGFyZW50SURdID0gaW5pdGlhbENoaWxkcmVuW3BhcmVudElEXSB8fCBbXTtcbiAgICAgICAgaW5pdGlhbENoaWxkcmVuW3BhcmVudElEXVt1cGRhdGVkSW5kZXhdID0gdXBkYXRlZENoaWxkO1xuXG4gICAgICAgIHVwZGF0ZWRDaGlsZHJlbiA9IHVwZGF0ZWRDaGlsZHJlbiB8fCBbXTtcbiAgICAgICAgdXBkYXRlZENoaWxkcmVuLnB1c2godXBkYXRlZENoaWxkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVuZGVyZWRNYXJrdXA7XG4gICAgLy8gbWFya3VwTGlzdCBpcyBlaXRoZXIgYSBsaXN0IG9mIG1hcmt1cCBvciBqdXN0IGEgbGlzdCBvZiBlbGVtZW50c1xuICAgIGlmIChtYXJrdXBMaXN0Lmxlbmd0aCAmJiB0eXBlb2YgbWFya3VwTGlzdFswXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJlbmRlcmVkTWFya3VwID0gRGFuZ2VyLmRhbmdlcm91c2x5UmVuZGVyTWFya3VwKG1hcmt1cExpc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW5kZXJlZE1hcmt1cCA9IG1hcmt1cExpc3Q7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIHVwZGF0ZWQgY2hpbGRyZW4gZmlyc3Qgc28gdGhhdCBgdG9JbmRleGAgaXMgY29uc2lzdGVudC5cbiAgICBpZiAodXBkYXRlZENoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHVwZGF0ZWRDaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICB1cGRhdGVkQ2hpbGRyZW5bal0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh1cGRhdGVkQ2hpbGRyZW5bal0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdXBkYXRlcy5sZW5ndGg7IGsrKykge1xuICAgICAgdXBkYXRlID0gdXBkYXRlc1trXTtcbiAgICAgIHN3aXRjaCAodXBkYXRlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5JTlNFUlRfTUFSS1VQOlxuICAgICAgICAgIGluc2VydENoaWxkQXQodXBkYXRlLnBhcmVudE5vZGUsIHJlbmRlcmVkTWFya3VwW3VwZGF0ZS5tYXJrdXBJbmRleF0sIHVwZGF0ZS50b0luZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5NT1ZFX0VYSVNUSU5HOlxuICAgICAgICAgIGluc2VydENoaWxkQXQodXBkYXRlLnBhcmVudE5vZGUsIGluaXRpYWxDaGlsZHJlblt1cGRhdGUucGFyZW50SURdW3VwZGF0ZS5mcm9tSW5kZXhdLCB1cGRhdGUudG9JbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuU0VUX01BUktVUDpcbiAgICAgICAgICBzZXRJbm5lckhUTUwodXBkYXRlLnBhcmVudE5vZGUsIHVwZGF0ZS5jb250ZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5URVhUX0NPTlRFTlQ6XG4gICAgICAgICAgc2V0VGV4dENvbnRlbnQodXBkYXRlLnBhcmVudE5vZGUsIHVwZGF0ZS5jb250ZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5SRU1PVkVfTk9ERTpcbiAgICAgICAgICAvLyBBbHJlYWR5IHJlbW92ZWQgYnkgdGhlIGZvci1sb29wIGFib3ZlLlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5SZWFjdFBlcmYubWVhc3VyZU1ldGhvZHMoRE9NQ2hpbGRyZW5PcGVyYXRpb25zLCAnRE9NQ2hpbGRyZW5PcGVyYXRpb25zJywge1xuICB1cGRhdGVUZXh0Q29udGVudDogJ3VwZGF0ZVRleHRDb250ZW50J1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NQ2hpbGRyZW5PcGVyYXRpb25zO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvRE9NQ2hpbGRyZW5PcGVyYXRpb25zLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERhbmdlclxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBjcmVhdGVOb2Rlc0Zyb21NYXJrdXAgPSByZXF1aXJlKCdmYmpzL2xpYi9jcmVhdGVOb2Rlc0Zyb21NYXJrdXAnKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGdldE1hcmt1cFdyYXAgPSByZXF1aXJlKCdmYmpzL2xpYi9nZXRNYXJrdXBXcmFwJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBPUEVOX1RBR19OQU1FX0VYUCA9IC9eKDxbXiBcXC8+XSspLztcbnZhciBSRVNVTFRfSU5ERVhfQVRUUiA9ICdkYXRhLWRhbmdlci1pbmRleCc7XG5cbi8qKlxuICogRXh0cmFjdHMgdGhlIGBub2RlTmFtZWAgZnJvbSBhIHN0cmluZyBvZiBtYXJrdXAuXG4gKlxuICogTk9URTogRXh0cmFjdGluZyB0aGUgYG5vZGVOYW1lYCBkb2VzIG5vdCByZXF1aXJlIGEgcmVndWxhciBleHByZXNzaW9uIG1hdGNoXG4gKiBiZWNhdXNlIHdlIG1ha2UgYXNzdW1wdGlvbnMgYWJvdXQgUmVhY3QtZ2VuZXJhdGVkIG1hcmt1cCAoaS5lLiB0aGVyZSBhcmUgbm9cbiAqIHNwYWNlcyBzdXJyb3VuZGluZyB0aGUgb3BlbmluZyB0YWcgYW5kIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBhdHRyaWJ1dGUpLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgU3RyaW5nIG9mIG1hcmt1cC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9kZSBuYW1lIG9mIHRoZSBzdXBwbGllZCBtYXJrdXAuXG4gKiBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2V4dHJhY3Qtbm9kZW5hbWVcbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZU5hbWUobWFya3VwKSB7XG4gIHJldHVybiBtYXJrdXAuc3Vic3RyaW5nKDEsIG1hcmt1cC5pbmRleE9mKCcgJykpO1xufVxuXG52YXIgRGFuZ2VyID0ge1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIG1hcmt1cCBpbnRvIGFuIGFycmF5IG9mIG5vZGVzLiBUaGUgbWFya3VwIGlzIGV4cGVjdGVkIHRvIHJlbmRlclxuICAgKiBpbnRvIGEgbGlzdCBvZiByb290IG5vZGVzLiBBbHNvLCB0aGUgbGVuZ3RoIG9mIGByZXN1bHRMaXN0YCBhbmRcbiAgICogYG1hcmt1cExpc3RgIHNob3VsZCBiZSB0aGUgc2FtZS5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheTxzdHJpbmc+fSBtYXJrdXBMaXN0IExpc3Qgb2YgbWFya3VwIHN0cmluZ3MgdG8gcmVuZGVyLlxuICAgKiBAcmV0dXJuIHthcnJheTxET01FbGVtZW50Pn0gTGlzdCBvZiByZW5kZXJlZCBub2Rlcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBkYW5nZXJvdXNseVJlbmRlck1hcmt1cDogZnVuY3Rpb24gKG1hcmt1cExpc3QpIHtcbiAgICAhRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2Rhbmdlcm91c2x5UmVuZGVyTWFya3VwKC4uLik6IENhbm5vdCByZW5kZXIgbWFya3VwIGluIGEgd29ya2VyICcgKyAndGhyZWFkLiBNYWtlIHN1cmUgYHdpbmRvd2AgYW5kIGBkb2N1bWVudGAgYXJlIGF2YWlsYWJsZSBnbG9iYWxseSAnICsgJ2JlZm9yZSByZXF1aXJpbmcgUmVhY3Qgd2hlbiB1bml0IHRlc3Rpbmcgb3IgdXNlICcgKyAnUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdHJpbmcgZm9yIHNlcnZlciByZW5kZXJpbmcuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIHZhciBub2RlTmFtZTtcbiAgICB2YXIgbWFya3VwQnlOb2RlTmFtZSA9IHt9O1xuICAgIC8vIEdyb3VwIG1hcmt1cCBieSBgbm9kZU5hbWVgIGlmIGEgd3JhcCBpcyBuZWNlc3NhcnksIGVsc2UgYnkgJyonLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya3VwTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgIW1hcmt1cExpc3RbaV0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZGFuZ2Vyb3VzbHlSZW5kZXJNYXJrdXAoLi4uKTogTWlzc2luZyBtYXJrdXAuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgbm9kZU5hbWUgPSBnZXROb2RlTmFtZShtYXJrdXBMaXN0W2ldKTtcbiAgICAgIG5vZGVOYW1lID0gZ2V0TWFya3VwV3JhcChub2RlTmFtZSkgPyBub2RlTmFtZSA6ICcqJztcbiAgICAgIG1hcmt1cEJ5Tm9kZU5hbWVbbm9kZU5hbWVdID0gbWFya3VwQnlOb2RlTmFtZVtub2RlTmFtZV0gfHwgW107XG4gICAgICBtYXJrdXBCeU5vZGVOYW1lW25vZGVOYW1lXVtpXSA9IG1hcmt1cExpc3RbaV07XG4gICAgfVxuICAgIHZhciByZXN1bHRMaXN0ID0gW107XG4gICAgdmFyIHJlc3VsdExpc3RBc3NpZ25tZW50Q291bnQgPSAwO1xuICAgIGZvciAobm9kZU5hbWUgaW4gbWFya3VwQnlOb2RlTmFtZSkge1xuICAgICAgaWYgKCFtYXJrdXBCeU5vZGVOYW1lLmhhc093blByb3BlcnR5KG5vZGVOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBtYXJrdXBMaXN0QnlOb2RlTmFtZSA9IG1hcmt1cEJ5Tm9kZU5hbWVbbm9kZU5hbWVdO1xuXG4gICAgICAvLyBUaGlzIGZvci1pbiBsb29wIHNraXBzIHRoZSBob2xlcyBvZiB0aGUgc3BhcnNlIGFycmF5LiBUaGUgb3JkZXIgb2ZcbiAgICAgIC8vIGl0ZXJhdGlvbiBzaG91bGQgZm9sbG93IHRoZSBvcmRlciBvZiBhc3NpZ25tZW50LCB3aGljaCBoYXBwZW5zIHRvIG1hdGNoXG4gICAgICAvLyBudW1lcmljYWwgaW5kZXggb3JkZXIsIGJ1dCB3ZSBkb24ndCByZWx5IG9uIHRoYXQuXG4gICAgICB2YXIgcmVzdWx0SW5kZXg7XG4gICAgICBmb3IgKHJlc3VsdEluZGV4IGluIG1hcmt1cExpc3RCeU5vZGVOYW1lKSB7XG4gICAgICAgIGlmIChtYXJrdXBMaXN0QnlOb2RlTmFtZS5oYXNPd25Qcm9wZXJ0eShyZXN1bHRJbmRleCkpIHtcbiAgICAgICAgICB2YXIgbWFya3VwID0gbWFya3VwTGlzdEJ5Tm9kZU5hbWVbcmVzdWx0SW5kZXhdO1xuXG4gICAgICAgICAgLy8gUHVzaCB0aGUgcmVxdWVzdGVkIG1hcmt1cCB3aXRoIGFuIGFkZGl0aW9uYWwgUkVTVUxUX0lOREVYX0FUVFJcbiAgICAgICAgICAvLyBhdHRyaWJ1dGUuICBJZiB0aGUgbWFya3VwIGRvZXMgbm90IHN0YXJ0IHdpdGggYSA8IGNoYXJhY3RlciwgaXRcbiAgICAgICAgICAvLyB3aWxsIGJlIGRpc2NhcmRlZCBiZWxvdyAod2l0aCBhbiBhcHByb3ByaWF0ZSBjb25zb2xlLmVycm9yKS5cbiAgICAgICAgICBtYXJrdXBMaXN0QnlOb2RlTmFtZVtyZXN1bHRJbmRleF0gPSBtYXJrdXAucmVwbGFjZShPUEVOX1RBR19OQU1FX0VYUCxcbiAgICAgICAgICAvLyBUaGlzIGluZGV4IHdpbGwgYmUgcGFyc2VkIGJhY2sgb3V0IGJlbG93LlxuICAgICAgICAgICckMSAnICsgUkVTVUxUX0lOREVYX0FUVFIgKyAnPVwiJyArIHJlc3VsdEluZGV4ICsgJ1wiICcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbmRlciBlYWNoIGdyb3VwIG9mIG1hcmt1cCB3aXRoIHNpbWlsYXIgd3JhcHBpbmcgYG5vZGVOYW1lYC5cbiAgICAgIHZhciByZW5kZXJOb2RlcyA9IGNyZWF0ZU5vZGVzRnJvbU1hcmt1cChtYXJrdXBMaXN0QnlOb2RlTmFtZS5qb2luKCcnKSwgZW1wdHlGdW5jdGlvbiAvLyBEbyBub3RoaW5nIHNwZWNpYWwgd2l0aCA8c2NyaXB0PiB0YWdzLlxuICAgICAgKTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZW5kZXJOb2Rlcy5sZW5ndGg7ICsraikge1xuICAgICAgICB2YXIgcmVuZGVyTm9kZSA9IHJlbmRlck5vZGVzW2pdO1xuICAgICAgICBpZiAocmVuZGVyTm9kZS5oYXNBdHRyaWJ1dGUgJiYgcmVuZGVyTm9kZS5oYXNBdHRyaWJ1dGUoUkVTVUxUX0lOREVYX0FUVFIpKSB7XG5cbiAgICAgICAgICByZXN1bHRJbmRleCA9ICtyZW5kZXJOb2RlLmdldEF0dHJpYnV0ZShSRVNVTFRfSU5ERVhfQVRUUik7XG4gICAgICAgICAgcmVuZGVyTm9kZS5yZW1vdmVBdHRyaWJ1dGUoUkVTVUxUX0lOREVYX0FUVFIpO1xuXG4gICAgICAgICAgISFyZXN1bHRMaXN0Lmhhc093blByb3BlcnR5KHJlc3VsdEluZGV4KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdEYW5nZXI6IEFzc2lnbmluZyB0byBhbiBhbHJlYWR5LW9jY3VwaWVkIHJlc3VsdCBpbmRleC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICByZXN1bHRMaXN0W3Jlc3VsdEluZGV4XSA9IHJlbmRlck5vZGU7XG5cbiAgICAgICAgICAvLyBUaGlzIHNob3VsZCBtYXRjaCByZXN1bHRMaXN0Lmxlbmd0aCBhbmQgbWFya3VwTGlzdC5sZW5ndGggd2hlblxuICAgICAgICAgIC8vIHdlJ3JlIGRvbmUuXG4gICAgICAgICAgcmVzdWx0TGlzdEFzc2lnbm1lbnRDb3VudCArPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdEYW5nZXI6IERpc2NhcmRpbmcgdW5leHBlY3RlZCBub2RlOicsIHJlbmRlck5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWx0aG91Z2ggcmVzdWx0TGlzdCB3YXMgcG9wdWxhdGVkIG91dCBvZiBvcmRlciwgaXQgc2hvdWxkIG5vdyBiZSBhIGRlbnNlXG4gICAgLy8gYXJyYXkuXG4gICAgIShyZXN1bHRMaXN0QXNzaWdubWVudENvdW50ID09PSByZXN1bHRMaXN0Lmxlbmd0aCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRGFuZ2VyOiBEaWQgbm90IGFzc2lnbiB0byBldmVyeSBpbmRleCBvZiByZXN1bHRMaXN0LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgICEocmVzdWx0TGlzdC5sZW5ndGggPT09IG1hcmt1cExpc3QubGVuZ3RoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdEYW5nZXI6IEV4cGVjdGVkIG1hcmt1cCB0byByZW5kZXIgJXMgbm9kZXMsIGJ1dCByZW5kZXJlZCAlcy4nLCBtYXJrdXBMaXN0Lmxlbmd0aCwgcmVzdWx0TGlzdC5sZW5ndGgpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIHJldHVybiByZXN1bHRMaXN0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhIG5vZGUgd2l0aCBhIHN0cmluZyBvZiBtYXJrdXAgYXQgaXRzIGN1cnJlbnQgcG9zaXRpb24gd2l0aGluIGl0c1xuICAgKiBwYXJlbnQuIFRoZSBtYXJrdXAgbXVzdCByZW5kZXIgaW50byBhIHNpbmdsZSByb290IG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gb2xkQ2hpbGQgQ2hpbGQgbm9kZSB0byByZXBsYWNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCB0byByZW5kZXIgaW4gcGxhY2Ugb2YgdGhlIGNoaWxkIG5vZGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXA6IGZ1bmN0aW9uIChvbGRDaGlsZCwgbWFya3VwKSB7XG4gICAgIUV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCguLi4pOiBDYW5ub3QgcmVuZGVyIG1hcmt1cCBpbiBhICcgKyAnd29ya2VyIHRocmVhZC4gTWFrZSBzdXJlIGB3aW5kb3dgIGFuZCBgZG9jdW1lbnRgIGFyZSBhdmFpbGFibGUgJyArICdnbG9iYWxseSBiZWZvcmUgcmVxdWlyaW5nIFJlYWN0IHdoZW4gdW5pdCB0ZXN0aW5nIG9yIHVzZSAnICsgJ1JlYWN0RE9NU2VydmVyLnJlbmRlclRvU3RyaW5nKCkgZm9yIHNlcnZlciByZW5kZXJpbmcuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICFtYXJrdXAgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAoLi4uKTogTWlzc2luZyBtYXJrdXAuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICEob2xkQ2hpbGQudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnaHRtbCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2Rhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwKC4uLik6IENhbm5vdCByZXBsYWNlIG1hcmt1cCBvZiB0aGUgJyArICc8aHRtbD4gbm9kZS4gVGhpcyBpcyBiZWNhdXNlIGJyb3dzZXIgcXVpcmtzIG1ha2UgdGhpcyB1bnJlbGlhYmxlICcgKyAnYW5kL29yIHNsb3cuIElmIHlvdSB3YW50IHRvIHJlbmRlciB0byB0aGUgcm9vdCB5b3UgbXVzdCB1c2UgJyArICdzZXJ2ZXIgcmVuZGVyaW5nLiBTZWUgUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdHJpbmcoKS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgbmV3Q2hpbGQ7XG4gICAgaWYgKHR5cGVvZiBtYXJrdXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICBuZXdDaGlsZCA9IGNyZWF0ZU5vZGVzRnJvbU1hcmt1cChtYXJrdXAsIGVtcHR5RnVuY3Rpb24pWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdDaGlsZCA9IG1hcmt1cDtcbiAgICB9XG4gICAgb2xkQ2hpbGQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobmV3Q2hpbGQsIG9sZENoaWxkKTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhbmdlcjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL0Rhbmdlci5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFeGVjdXRpb25FbnZpcm9ubWVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbi8qKlxuICogU2ltcGxlLCBsaWdodHdlaWdodCBtb2R1bGUgYXNzaXN0aW5nIHdpdGggdGhlIGRldGVjdGlvbiBhbmQgY29udGV4dCBvZlxuICogV29ya2VyLiBIZWxwcyBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXMgYW5kIGFsbG93cyBjb2RlIHRvIHJlYXNvbiBhYm91dFxuICogd2hldGhlciBvciBub3QgdGhleSBhcmUgaW4gYSBXb3JrZXIsIGV2ZW4gaWYgdGhleSBuZXZlciBpbmNsdWRlIHRoZSBtYWluXG4gKiBgUmVhY3RXb3JrZXJgIGRlcGVuZGVuY3kuXG4gKi9cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHtcblxuICBjYW5Vc2VET006IGNhblVzZURPTSxcblxuICBjYW5Vc2VXb3JrZXJzOiB0eXBlb2YgV29ya2VyICE9PSAndW5kZWZpbmVkJyxcblxuICBjYW5Vc2VFdmVudExpc3RlbmVyczogY2FuVXNlRE9NICYmICEhKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyIHx8IHdpbmRvdy5hdHRhY2hFdmVudCksXG5cbiAgY2FuVXNlVmlld3BvcnQ6IGNhblVzZURPTSAmJiAhIXdpbmRvdy5zY3JlZW4sXG5cbiAgaXNJbldvcmtlcjogIWNhblVzZURPTSAvLyBGb3Igbm93LCB0aGlzIGlzIHRydWUgLSBtaWdodCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFeGVjdXRpb25FbnZpcm9ubWVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY3JlYXRlTm9kZXNGcm9tTWFya3VwXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qZXNsaW50LWRpc2FibGUgZmItd3d3L3Vuc2FmZS1odG1sKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBjcmVhdGVBcnJheUZyb21NaXhlZCA9IHJlcXVpcmUoJy4vY3JlYXRlQXJyYXlGcm9tTWl4ZWQnKTtcbnZhciBnZXRNYXJrdXBXcmFwID0gcmVxdWlyZSgnLi9nZXRNYXJrdXBXcmFwJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnLi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBEdW1teSBjb250YWluZXIgdXNlZCB0byByZW5kZXIgYWxsIG1hcmt1cC5cbiAqL1xudmFyIGR1bW15Tm9kZSA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpIDogbnVsbDtcblxuLyoqXG4gKiBQYXR0ZXJuIHVzZWQgYnkgYGdldE5vZGVOYW1lYC5cbiAqL1xudmFyIG5vZGVOYW1lUGF0dGVybiA9IC9eXFxzKjwoXFx3KykvO1xuXG4vKipcbiAqIEV4dHJhY3RzIHRoZSBgbm9kZU5hbWVgIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIGEgc3RyaW5nIG9mIG1hcmt1cC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIFN0cmluZyBvZiBtYXJrdXAuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBOb2RlIG5hbWUgb2YgdGhlIHN1cHBsaWVkIG1hcmt1cC5cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZU5hbWUobWFya3VwKSB7XG4gIHZhciBub2RlTmFtZU1hdGNoID0gbWFya3VwLm1hdGNoKG5vZGVOYW1lUGF0dGVybik7XG4gIHJldHVybiBub2RlTmFtZU1hdGNoICYmIG5vZGVOYW1lTWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG5vZGVzIHJlbmRlcmVkIGZyb20gdGhlIHN1cHBsaWVkIG1hcmt1cC4gVGhlXG4gKiBvcHRpb25hbGx5IHN1cHBsaWVkIGBoYW5kbGVTY3JpcHRgIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCBvbmNlIGZvciBlYWNoXG4gKiA8c2NyaXB0PiBlbGVtZW50IHRoYXQgaXMgcmVuZGVyZWQuIElmIG5vIGBoYW5kbGVTY3JpcHRgIGZ1bmN0aW9uIGlzIHN1cHBsaWVkLFxuICogYW4gZXhjZXB0aW9uIGlzIHRocm93biBpZiBhbnkgPHNjcmlwdD4gZWxlbWVudHMgYXJlIHJlbmRlcmVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgQSBzdHJpbmcgb2YgdmFsaWQgSFRNTCBtYXJrdXAuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gaGFuZGxlU2NyaXB0IEludm9rZWQgb25jZSBmb3IgZWFjaCByZW5kZXJlZCA8c2NyaXB0Pi5cbiAqIEByZXR1cm4ge2FycmF5PERPTUVsZW1lbnR8RE9NVGV4dE5vZGU+fSBBbiBhcnJheSBvZiByZW5kZXJlZCBub2Rlcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTm9kZXNGcm9tTWFya3VwKG1hcmt1cCwgaGFuZGxlU2NyaXB0KSB7XG4gIHZhciBub2RlID0gZHVtbXlOb2RlO1xuICAhISFkdW1teU5vZGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnY3JlYXRlTm9kZXNGcm9tTWFya3VwIGR1bW15IG5vdCBpbml0aWFsaXplZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgdmFyIG5vZGVOYW1lID0gZ2V0Tm9kZU5hbWUobWFya3VwKTtcblxuICB2YXIgd3JhcCA9IG5vZGVOYW1lICYmIGdldE1hcmt1cFdyYXAobm9kZU5hbWUpO1xuICBpZiAod3JhcCkge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gd3JhcFsxXSArIG1hcmt1cCArIHdyYXBbMl07XG5cbiAgICB2YXIgd3JhcERlcHRoID0gd3JhcFswXTtcbiAgICB3aGlsZSAod3JhcERlcHRoLS0pIHtcbiAgICAgIG5vZGUgPSBub2RlLmxhc3RDaGlsZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5pbm5lckhUTUwgPSBtYXJrdXA7XG4gIH1cblxuICB2YXIgc2NyaXB0cyA9IG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xuICBpZiAoc2NyaXB0cy5sZW5ndGgpIHtcbiAgICAhaGFuZGxlU2NyaXB0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2NyZWF0ZU5vZGVzRnJvbU1hcmt1cCguLi4pOiBVbmV4cGVjdGVkIDxzY3JpcHQ+IGVsZW1lbnQgcmVuZGVyZWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIGNyZWF0ZUFycmF5RnJvbU1peGVkKHNjcmlwdHMpLmZvckVhY2goaGFuZGxlU2NyaXB0KTtcbiAgfVxuXG4gIHZhciBub2RlcyA9IGNyZWF0ZUFycmF5RnJvbU1peGVkKG5vZGUuY2hpbGROb2Rlcyk7XG4gIHdoaWxlIChub2RlLmxhc3RDaGlsZCkge1xuICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5sYXN0Q2hpbGQpO1xuICB9XG4gIHJldHVybiBub2Rlcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVOb2Rlc0Zyb21NYXJrdXA7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL2NyZWF0ZU5vZGVzRnJvbU1hcmt1cC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBjcmVhdGVBcnJheUZyb21NaXhlZFxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB0b0FycmF5ID0gcmVxdWlyZSgnLi90b0FycmF5Jyk7XG5cbi8qKlxuICogUGVyZm9ybSBhIGhldXJpc3RpYyB0ZXN0IHRvIGRldGVybWluZSBpZiBhbiBvYmplY3QgaXMgXCJhcnJheS1saWtlXCIuXG4gKlxuICogICBBIG1vbmsgYXNrZWQgSm9zaHUsIGEgWmVuIG1hc3RlciwgXCJIYXMgYSBkb2cgQnVkZGhhIG5hdHVyZT9cIlxuICogICBKb3NodSByZXBsaWVkOiBcIk11LlwiXG4gKlxuICogVGhpcyBmdW5jdGlvbiBkZXRlcm1pbmVzIGlmIGl0cyBhcmd1bWVudCBoYXMgXCJhcnJheSBuYXR1cmVcIjogaXQgcmV0dXJuc1xuICogdHJ1ZSBpZiB0aGUgYXJndW1lbnQgaXMgYW4gYWN0dWFsIGFycmF5LCBhbiBgYXJndW1lbnRzJyBvYmplY3QsIG9yIGFuXG4gKiBIVE1MQ29sbGVjdGlvbiAoZS5nLiBub2RlLmNoaWxkTm9kZXMgb3Igbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgpKS5cbiAqXG4gKiBJdCB3aWxsIHJldHVybiBmYWxzZSBmb3Igb3RoZXIgYXJyYXktbGlrZSBvYmplY3RzIGxpa2UgRmlsZWxpc3QuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGhhc0FycmF5TmF0dXJlKG9iaikge1xuICByZXR1cm4oXG4gICAgLy8gbm90IG51bGwvZmFsc2VcbiAgICAhIW9iaiAmJiAoXG4gICAgLy8gYXJyYXlzIGFyZSBvYmplY3RzLCBOb2RlTGlzdHMgYXJlIGZ1bmN0aW9ucyBpbiBTYWZhcmlcbiAgICB0eXBlb2Ygb2JqID09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmogPT0gJ2Z1bmN0aW9uJykgJiZcbiAgICAvLyBxdWFja3MgbGlrZSBhbiBhcnJheVxuICAgICdsZW5ndGgnIGluIG9iaiAmJlxuICAgIC8vIG5vdCB3aW5kb3dcbiAgICAhKCdzZXRJbnRlcnZhbCcgaW4gb2JqKSAmJlxuICAgIC8vIG5vIERPTSBub2RlIHNob3VsZCBiZSBjb25zaWRlcmVkIGFuIGFycmF5LWxpa2VcbiAgICAvLyBhICdzZWxlY3QnIGVsZW1lbnQgaGFzICdsZW5ndGgnIGFuZCAnaXRlbScgcHJvcGVydGllcyBvbiBJRThcbiAgICB0eXBlb2Ygb2JqLm5vZGVUeXBlICE9ICdudW1iZXInICYmIChcbiAgICAvLyBhIHJlYWwgYXJyYXlcbiAgICBBcnJheS5pc0FycmF5KG9iaikgfHxcbiAgICAvLyBhcmd1bWVudHNcbiAgICAnY2FsbGVlJyBpbiBvYmogfHxcbiAgICAvLyBIVE1MQ29sbGVjdGlvbi9Ob2RlTGlzdFxuICAgICdpdGVtJyBpbiBvYmopXG4gICk7XG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgdGhlIGFyZ3VtZW50IGlzIGFuIGFycmF5IGJ5IHdyYXBwaW5nIGl0IGluIGFuIGFycmF5IGlmIGl0IGlzIG5vdC5cbiAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoZSBhcmd1bWVudCBpZiBpdCBpcyBhbHJlYWR5IGFuIGFycmF5LlxuICpcbiAqIFRoaXMgaXMgbW9zdGx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5OlxuICpcbiAqICAgdmFyIGNyZWF0ZUFycmF5RnJvbU1peGVkID0gcmVxdWlyZSgnY3JlYXRlQXJyYXlGcm9tTWl4ZWQnKTtcbiAqXG4gKiAgIGZ1bmN0aW9uIHRha2VzT25lT3JNb3JlVGhpbmdzKHRoaW5ncykge1xuICogICAgIHRoaW5ncyA9IGNyZWF0ZUFycmF5RnJvbU1peGVkKHRoaW5ncyk7XG4gKiAgICAgLi4uXG4gKiAgIH1cbiAqXG4gKiBUaGlzIGFsbG93cyB5b3UgdG8gdHJlYXQgYHRoaW5ncycgYXMgYW4gYXJyYXksIGJ1dCBhY2NlcHQgc2NhbGFycyBpbiB0aGUgQVBJLlxuICpcbiAqIElmIHlvdSBuZWVkIHRvIGNvbnZlcnQgYW4gYXJyYXktbGlrZSBvYmplY3QsIGxpa2UgYGFyZ3VtZW50c2AsIGludG8gYW4gYXJyYXlcbiAqIHVzZSB0b0FycmF5IGluc3RlYWQuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5mdW5jdGlvbiBjcmVhdGVBcnJheUZyb21NaXhlZChvYmopIHtcbiAgaWYgKCFoYXNBcnJheU5hdHVyZShvYmopKSB7XG4gICAgcmV0dXJuIFtvYmpdO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBvYmouc2xpY2UoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdG9BcnJheShvYmopO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQXJyYXlGcm9tTWl4ZWQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL2NyZWF0ZUFycmF5RnJvbU1peGVkLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHRvQXJyYXlcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnLi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBDb252ZXJ0IGFycmF5LWxpa2Ugb2JqZWN0cyB0byBhcnJheXMuXG4gKlxuICogVGhpcyBBUEkgYXNzdW1lcyB0aGUgY2FsbGVyIGtub3dzIHRoZSBjb250ZW50cyBvZiB0aGUgZGF0YSB0eXBlLiBGb3IgbGVzc1xuICogd2VsbCBkZWZpbmVkIGlucHV0cyB1c2UgY3JlYXRlQXJyYXlGcm9tTWl4ZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb258ZmlsZWxpc3R9IG9ialxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gIHZhciBsZW5ndGggPSBvYmoubGVuZ3RoO1xuXG4gIC8vIFNvbWUgYnJvd3NlIGJ1aWx0aW4gb2JqZWN0cyBjYW4gcmVwb3J0IHR5cGVvZiAnZnVuY3Rpb24nIChlLmcuIE5vZGVMaXN0IGluXG4gIC8vIG9sZCB2ZXJzaW9ucyBvZiBTYWZhcmkpLlxuICAhKCFBcnJheS5pc0FycmF5KG9iaikgJiYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0b0FycmF5OiBBcnJheS1saWtlIG9iamVjdCBleHBlY3RlZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAhKHR5cGVvZiBsZW5ndGggPT09ICdudW1iZXInKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0b0FycmF5OiBPYmplY3QgbmVlZHMgYSBsZW5ndGggcHJvcGVydHknKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgIShsZW5ndGggPT09IDAgfHwgbGVuZ3RoIC0gMSBpbiBvYmopID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RvQXJyYXk6IE9iamVjdCBzaG91bGQgaGF2ZSBrZXlzIGZvciBpbmRpY2VzJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gIC8vIE9sZCBJRSBkb2Vzbid0IGdpdmUgY29sbGVjdGlvbnMgYWNjZXNzIHRvIGhhc093blByb3BlcnR5LiBBc3N1bWUgaW5wdXRzXG4gIC8vIHdpdGhvdXQgbWV0aG9kIHdpbGwgdGhyb3cgZHVyaW5nIHRoZSBzbGljZSBjYWxsIGFuZCBza2lwIHN0cmFpZ2h0IHRvIHRoZVxuICAvLyBmYWxsYmFjay5cbiAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBJRSA8IDkgZG9lcyBub3Qgc3VwcG9ydCBBcnJheSNzbGljZSBvbiBjb2xsZWN0aW9ucyBvYmplY3RzXG4gICAgfVxuICB9XG5cbiAgLy8gRmFsbCBiYWNrIHRvIGNvcHlpbmcga2V5IGJ5IGtleS4gVGhpcyBhc3N1bWVzIGFsbCBrZXlzIGhhdmUgYSB2YWx1ZSxcbiAgLy8gc28gd2lsbCBub3QgcHJlc2VydmUgc3BhcnNlbHkgcG9wdWxhdGVkIGlucHV0cy5cbiAgdmFyIHJldCA9IEFycmF5KGxlbmd0aCk7XG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBsZW5ndGg7IGlpKyspIHtcbiAgICByZXRbaWldID0gb2JqW2lpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvQXJyYXk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL3RvQXJyYXkuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaW52YXJpYW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICsgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSkpO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL2ludmFyaWFudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRNYXJrdXBXcmFwXG4gKi9cblxuLyplc2xpbnQtZGlzYWJsZSBmYi13d3cvdW5zYWZlLWh0bWwgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCcuL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIER1bW15IGNvbnRhaW5lciB1c2VkIHRvIGRldGVjdCB3aGljaCB3cmFwcyBhcmUgbmVjZXNzYXJ5LlxuICovXG52YXIgZHVtbXlOb2RlID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykgOiBudWxsO1xuXG4vKipcbiAqIFNvbWUgYnJvd3NlcnMgY2Fubm90IHVzZSBgaW5uZXJIVE1MYCB0byByZW5kZXIgY2VydGFpbiBlbGVtZW50cyBzdGFuZGFsb25lLFxuICogc28gd2Ugd3JhcCB0aGVtLCByZW5kZXIgdGhlIHdyYXBwZWQgbm9kZXMsIHRoZW4gZXh0cmFjdCB0aGUgZGVzaXJlZCBub2RlLlxuICpcbiAqIEluIElFOCwgY2VydGFpbiBlbGVtZW50cyBjYW5ub3QgcmVuZGVyIGFsb25lLCBzbyB3cmFwIGFsbCBlbGVtZW50cyAoJyonKS5cbiAqL1xuXG52YXIgc2hvdWxkV3JhcCA9IHt9O1xuXG52YXIgc2VsZWN0V3JhcCA9IFsxLCAnPHNlbGVjdCBtdWx0aXBsZT1cInRydWVcIj4nLCAnPC9zZWxlY3Q+J107XG52YXIgdGFibGVXcmFwID0gWzEsICc8dGFibGU+JywgJzwvdGFibGU+J107XG52YXIgdHJXcmFwID0gWzMsICc8dGFibGU+PHRib2R5Pjx0cj4nLCAnPC90cj48L3Rib2R5PjwvdGFibGU+J107XG5cbnZhciBzdmdXcmFwID0gWzEsICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj4nLCAnPC9zdmc+J107XG5cbnZhciBtYXJrdXBXcmFwID0ge1xuICAnKic6IFsxLCAnPzxkaXY+JywgJzwvZGl2PiddLFxuXG4gICdhcmVhJzogWzEsICc8bWFwPicsICc8L21hcD4nXSxcbiAgJ2NvbCc6IFsyLCAnPHRhYmxlPjx0Ym9keT48L3Rib2R5Pjxjb2xncm91cD4nLCAnPC9jb2xncm91cD48L3RhYmxlPiddLFxuICAnbGVnZW5kJzogWzEsICc8ZmllbGRzZXQ+JywgJzwvZmllbGRzZXQ+J10sXG4gICdwYXJhbSc6IFsxLCAnPG9iamVjdD4nLCAnPC9vYmplY3Q+J10sXG4gICd0cic6IFsyLCAnPHRhYmxlPjx0Ym9keT4nLCAnPC90Ym9keT48L3RhYmxlPiddLFxuXG4gICdvcHRncm91cCc6IHNlbGVjdFdyYXAsXG4gICdvcHRpb24nOiBzZWxlY3RXcmFwLFxuXG4gICdjYXB0aW9uJzogdGFibGVXcmFwLFxuICAnY29sZ3JvdXAnOiB0YWJsZVdyYXAsXG4gICd0Ym9keSc6IHRhYmxlV3JhcCxcbiAgJ3Rmb290JzogdGFibGVXcmFwLFxuICAndGhlYWQnOiB0YWJsZVdyYXAsXG5cbiAgJ3RkJzogdHJXcmFwLFxuICAndGgnOiB0cldyYXBcbn07XG5cbi8vIEluaXRpYWxpemUgdGhlIFNWRyBlbGVtZW50cyBzaW5jZSB3ZSBrbm93IHRoZXknbGwgYWx3YXlzIG5lZWQgdG8gYmUgd3JhcHBlZFxuLy8gY29uc2lzdGVudGx5LiBJZiB0aGV5IGFyZSBjcmVhdGVkIGluc2lkZSBhIDxkaXY+IHRoZXkgd2lsbCBiZSBpbml0aWFsaXplZCBpblxuLy8gdGhlIHdyb25nIG5hbWVzcGFjZSAoYW5kIHdpbGwgbm90IGRpc3BsYXkpLlxudmFyIHN2Z0VsZW1lbnRzID0gWydjaXJjbGUnLCAnY2xpcFBhdGgnLCAnZGVmcycsICdlbGxpcHNlJywgJ2cnLCAnaW1hZ2UnLCAnbGluZScsICdsaW5lYXJHcmFkaWVudCcsICdtYXNrJywgJ3BhdGgnLCAncGF0dGVybicsICdwb2x5Z29uJywgJ3BvbHlsaW5lJywgJ3JhZGlhbEdyYWRpZW50JywgJ3JlY3QnLCAnc3RvcCcsICd0ZXh0JywgJ3RzcGFuJ107XG5zdmdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlTmFtZSkge1xuICBtYXJrdXBXcmFwW25vZGVOYW1lXSA9IHN2Z1dyYXA7XG4gIHNob3VsZFdyYXBbbm9kZU5hbWVdID0gdHJ1ZTtcbn0pO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcmt1cCB3cmFwIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBzdXBwbGllZCBgbm9kZU5hbWVgLlxuICpcbiAqIE5PVEU6IFRoaXMgbGF6aWx5IGRldGVjdHMgd2hpY2ggd3JhcHMgYXJlIG5lY2Vzc2FyeSBmb3IgdGhlIGN1cnJlbnQgYnJvd3Nlci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbm9kZU5hbWUgTG93ZXJjYXNlIGBub2RlTmFtZWAuXG4gKiBAcmV0dXJuIHs/YXJyYXl9IE1hcmt1cCB3cmFwIGNvbmZpZ3VyYXRpb24sIGlmIGFwcGxpY2FibGUuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcmt1cFdyYXAobm9kZU5hbWUpIHtcbiAgISEhZHVtbXlOb2RlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ01hcmt1cCB3cmFwcGluZyBub2RlIG5vdCBpbml0aWFsaXplZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgaWYgKCFtYXJrdXBXcmFwLmhhc093blByb3BlcnR5KG5vZGVOYW1lKSkge1xuICAgIG5vZGVOYW1lID0gJyonO1xuICB9XG4gIGlmICghc2hvdWxkV3JhcC5oYXNPd25Qcm9wZXJ0eShub2RlTmFtZSkpIHtcbiAgICBpZiAobm9kZU5hbWUgPT09ICcqJykge1xuICAgICAgZHVtbXlOb2RlLmlubmVySFRNTCA9ICc8bGluayAvPic7XG4gICAgfSBlbHNlIHtcbiAgICAgIGR1bW15Tm9kZS5pbm5lckhUTUwgPSAnPCcgKyBub2RlTmFtZSArICc+PC8nICsgbm9kZU5hbWUgKyAnPic7XG4gICAgfVxuICAgIHNob3VsZFdyYXBbbm9kZU5hbWVdID0gIWR1bW15Tm9kZS5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBzaG91bGRXcmFwW25vZGVOYW1lXSA/IG1hcmt1cFdyYXBbbm9kZU5hbWVdIDogbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXJrdXBXcmFwO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9nZXRNYXJrdXBXcmFwLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGVtcHR5RnVuY3Rpb25cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xuICogcHJpbWFyaWx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5IGZvciBvdmVycmlkYWJsZSBmdW5jdGlvbiBlbmRwb2ludHMgd2hpY2hcbiAqIGFsd2F5cyBuZWVkIHRvIGJlIGNhbGxhYmxlLCBzaW5jZSBKUyBsYWNrcyBhIG51bGwtY2FsbCBpZGlvbSBhbGEgQ29jb2EuXG4gKi9cbmZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24oKSB7fVxuXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zID0gbWFrZUVtcHR5RnVuY3Rpb247XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UgPSBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKHRydWUpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwgPSBtYWtlRW1wdHlGdW5jdGlvbihudWxsKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiBhcmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5RnVuY3Rpb247XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBrZXlNaXJyb3IgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlNaXJyb3InKTtcblxuLyoqXG4gKiBXaGVuIGEgY29tcG9uZW50J3MgY2hpbGRyZW4gYXJlIHVwZGF0ZWQsIGEgc2VyaWVzIG9mIHVwZGF0ZSBjb25maWd1cmF0aW9uXG4gKiBvYmplY3RzIGFyZSBjcmVhdGVkIGluIG9yZGVyIHRvIGJhdGNoIGFuZCBzZXJpYWxpemUgdGhlIHJlcXVpcmVkIGNoYW5nZXMuXG4gKlxuICogRW51bWVyYXRlcyBhbGwgdGhlIHBvc3NpYmxlIHR5cGVzIG9mIHVwZGF0ZSBjb25maWd1cmF0aW9ucy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzID0ga2V5TWlycm9yKHtcbiAgSU5TRVJUX01BUktVUDogbnVsbCxcbiAgTU9WRV9FWElTVElORzogbnVsbCxcbiAgUkVNT1ZFX05PREU6IG51bGwsXG4gIFNFVF9NQVJLVVA6IG51bGwsXG4gIFRFWFRfQ09OVEVOVDogbnVsbFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXM7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBrZXlNaXJyb3JcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnLi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGFuIGVudW1lcmF0aW9uIHdpdGgga2V5cyBlcXVhbCB0byB0aGVpciB2YWx1ZS5cbiAqXG4gKiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgIHZhciBDT0xPUlMgPSBrZXlNaXJyb3Ioe2JsdWU6IG51bGwsIHJlZDogbnVsbH0pO1xuICogICB2YXIgbXlDb2xvciA9IENPTE9SUy5ibHVlO1xuICogICB2YXIgaXNDb2xvclZhbGlkID0gISFDT0xPUlNbbXlDb2xvcl07XG4gKlxuICogVGhlIGxhc3QgbGluZSBjb3VsZCBub3QgYmUgcGVyZm9ybWVkIGlmIHRoZSB2YWx1ZXMgb2YgdGhlIGdlbmVyYXRlZCBlbnVtIHdlcmVcbiAqIG5vdCBlcXVhbCB0byB0aGVpciBrZXlzLlxuICpcbiAqICAgSW5wdXQ6ICB7a2V5MTogdmFsMSwga2V5MjogdmFsMn1cbiAqICAgT3V0cHV0OiB7a2V5MToga2V5MSwga2V5Mjoga2V5Mn1cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbnZhciBrZXlNaXJyb3IgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXQgPSB7fTtcbiAgdmFyIGtleTtcbiAgIShvYmogaW5zdGFuY2VvZiBPYmplY3QgJiYgIUFycmF5LmlzQXJyYXkob2JqKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAna2V5TWlycm9yKC4uLik6IEFyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgaWYgKCFvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJldFtrZXldID0ga2V5O1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtleU1pcnJvcjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIva2V5TWlycm9yLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UGVyZlxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUmVhY3RQZXJmIGlzIGEgZ2VuZXJhbCBBT1Agc3lzdGVtIGRlc2lnbmVkIHRvIG1lYXN1cmUgcGVyZm9ybWFuY2UuIFRoaXNcbiAqIG1vZHVsZSBvbmx5IGhhcyB0aGUgaG9va3M6IHNlZSBSZWFjdERlZmF1bHRQZXJmIGZvciB0aGUgYW5hbHlzaXMgdG9vbC5cbiAqL1xudmFyIFJlYWN0UGVyZiA9IHtcbiAgLyoqXG4gICAqIEJvb2xlYW4gdG8gZW5hYmxlL2Rpc2FibGUgbWVhc3VyZW1lbnQuIFNldCB0byBmYWxzZSBieSBkZWZhdWx0IHRvIHByZXZlbnRcbiAgICogYWNjaWRlbnRhbCBsb2dnaW5nIGFuZCBwZXJmIGxvc3MuXG4gICAqL1xuICBlbmFibGVNZWFzdXJlOiBmYWxzZSxcblxuICAvKipcbiAgICogSG9sZHMgb250byB0aGUgbWVhc3VyZSBmdW5jdGlvbiBpbiB1c2UuIEJ5IGRlZmF1bHQsIGRvbid0IG1lYXN1cmVcbiAgICogYW55dGhpbmcsIGJ1dCB3ZSdsbCBvdmVycmlkZSB0aGlzIGlmIHdlIGluamVjdCBhIG1lYXN1cmUgZnVuY3Rpb24uXG4gICAqL1xuICBzdG9yZWRNZWFzdXJlOiBfbm9NZWFzdXJlLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvYmplY3ROYW1lXG4gICAqIEBwYXJhbSB7b2JqZWN0PHN0cmluZz59IG1ldGhvZE5hbWVzXG4gICAqL1xuICBtZWFzdXJlTWV0aG9kczogZnVuY3Rpb24gKG9iamVjdCwgb2JqZWN0TmFtZSwgbWV0aG9kTmFtZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZm9yICh2YXIga2V5IGluIG1ldGhvZE5hbWVzKSB7XG4gICAgICAgIGlmICghbWV0aG9kTmFtZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdFtrZXldID0gUmVhY3RQZXJmLm1lYXN1cmUob2JqZWN0TmFtZSwgbWV0aG9kTmFtZXNba2V5XSwgb2JqZWN0W2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVXNlIHRoaXMgdG8gd3JhcCBtZXRob2RzIHlvdSB3YW50IHRvIG1lYXN1cmUuIFplcm8gb3ZlcmhlYWQgaW4gcHJvZHVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9iak5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZuTmFtZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICAgKi9cbiAgbWVhc3VyZTogZnVuY3Rpb24gKG9iak5hbWUsIGZuTmFtZSwgZnVuYykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWVhc3VyZWRGdW5jID0gbnVsbDtcbiAgICAgIHZhciB3cmFwcGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoUmVhY3RQZXJmLmVuYWJsZU1lYXN1cmUpIHtcbiAgICAgICAgICBpZiAoIW1lYXN1cmVkRnVuYykge1xuICAgICAgICAgICAgbWVhc3VyZWRGdW5jID0gUmVhY3RQZXJmLnN0b3JlZE1lYXN1cmUob2JqTmFtZSwgZm5OYW1lLCBmdW5jKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lYXN1cmVkRnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgd3JhcHBlci5kaXNwbGF5TmFtZSA9IG9iak5hbWUgKyAnXycgKyBmbk5hbWU7XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0sXG5cbiAgaW5qZWN0aW9uOiB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gbWVhc3VyZVxuICAgICAqL1xuICAgIGluamVjdE1lYXN1cmU6IGZ1bmN0aW9uIChtZWFzdXJlKSB7XG4gICAgICBSZWFjdFBlcmYuc3RvcmVkTWVhc3VyZSA9IG1lYXN1cmU7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFNpbXBseSBwYXNzZXMgdGhyb3VnaCB0aGUgbWVhc3VyZWQgZnVuY3Rpb24sIHdpdGhvdXQgbWVhc3VyaW5nIGl0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBvYmpOYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gZm5OYW1lXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gX25vTWVhc3VyZShvYmpOYW1lLCBmbk5hbWUsIGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQZXJmO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RQZXJmLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHNldElubmVySFRNTFxuICovXG5cbi8qIGdsb2JhbHMgTVNBcHAgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgV0hJVEVTUEFDRV9URVNUID0gL15bIFxcclxcblxcdFxcZl0vO1xudmFyIE5PTlZJU0lCTEVfVEVTVCA9IC88KCEtLXxsaW5rfG5vc2NyaXB0fG1ldGF8c2NyaXB0fHN0eWxlKVsgXFxyXFxuXFx0XFxmXFwvPl0vO1xuXG4vKipcbiAqIFNldCB0aGUgaW5uZXJIVE1MIHByb3BlcnR5IG9mIGEgbm9kZSwgZW5zdXJpbmcgdGhhdCB3aGl0ZXNwYWNlIGlzIHByZXNlcnZlZFxuICogZXZlbiBpbiBJRTguXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRJbm5lckhUTUwgPSBmdW5jdGlvbiAobm9kZSwgaHRtbCkge1xuICBub2RlLmlubmVySFRNTCA9IGh0bWw7XG59O1xuXG4vLyBXaW44IGFwcHM6IEFsbG93IGFsbCBodG1sIHRvIGJlIGluc2VydGVkXG5pZiAodHlwZW9mIE1TQXBwICE9PSAndW5kZWZpbmVkJyAmJiBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbikge1xuICBzZXRJbm5lckhUTUwgPSBmdW5jdGlvbiAobm9kZSwgaHRtbCkge1xuICAgIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgICB9KTtcbiAgfTtcbn1cblxuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAvLyBJRTg6IFdoZW4gdXBkYXRpbmcgYSBqdXN0IGNyZWF0ZWQgbm9kZSB3aXRoIGlubmVySFRNTCBvbmx5IGxlYWRpbmdcbiAgLy8gd2hpdGVzcGFjZSBpcyByZW1vdmVkLiBXaGVuIHVwZGF0aW5nIGFuIGV4aXN0aW5nIG5vZGUgd2l0aCBpbm5lckhUTUxcbiAgLy8gd2hpdGVzcGFjZSBpbiByb290IFRleHROb2RlcyBpcyBhbHNvIGNvbGxhcHNlZC5cbiAgLy8gQHNlZSBxdWlya3Ntb2RlLm9yZy9idWdyZXBvcnRzL2FyY2hpdmVzLzIwMDQvMTEvaW5uZXJodG1sX2FuZF90Lmh0bWxcblxuICAvLyBGZWF0dXJlIGRldGVjdGlvbjsgb25seSBJRTggaXMga25vd24gdG8gYmVoYXZlIGltcHJvcGVybHkgbGlrZSB0aGlzLlxuICB2YXIgdGVzdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGVzdEVsZW1lbnQuaW5uZXJIVE1MID0gJyAnO1xuICBpZiAodGVzdEVsZW1lbnQuaW5uZXJIVE1MID09PSAnJykge1xuICAgIHNldElubmVySFRNTCA9IGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gICAgICAvLyBNYWdpYyB0aGVvcnk6IElFOCBzdXBwb3NlZGx5IGRpZmZlcmVudGlhdGVzIGJldHdlZW4gYWRkZWQgYW5kIHVwZGF0ZWRcbiAgICAgIC8vIG5vZGVzIHdoZW4gcHJvY2Vzc2luZyBpbm5lckhUTUwsIGlubmVySFRNTCBvbiB1cGRhdGVkIG5vZGVzIHN1ZmZlcnNcbiAgICAgIC8vIGZyb20gd29yc2Ugd2hpdGVzcGFjZSBiZWhhdmlvci4gUmUtYWRkaW5nIGEgbm9kZSBsaWtlIHRoaXMgdHJpZ2dlcnNcbiAgICAgIC8vIHRoZSBpbml0aWFsIGFuZCBtb3JlIGZhdm9yYWJsZSB3aGl0ZXNwYWNlIGJlaGF2aW9yLlxuICAgICAgLy8gVE9ETzogV2hhdCB0byBkbyBvbiBhIGRldGFjaGVkIG5vZGU/XG4gICAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobm9kZSwgbm9kZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIGFsc28gaW1wbGVtZW50IGEgd29ya2Fyb3VuZCBmb3Igbm9uLXZpc2libGUgdGFncyBkaXNhcHBlYXJpbmcgaW50b1xuICAgICAgLy8gdGhpbiBhaXIgb24gSUU4LCB0aGlzIG9ubHkgaGFwcGVucyBpZiB0aGVyZSBpcyBubyB2aXNpYmxlIHRleHRcbiAgICAgIC8vIGluLWZyb250IG9mIHRoZSBub24tdmlzaWJsZSB0YWdzLiBQaWdneWJhY2sgb24gdGhlIHdoaXRlc3BhY2UgZml4XG4gICAgICAvLyBhbmQgc2ltcGx5IGNoZWNrIGlmIGFueSBub24tdmlzaWJsZSB0YWdzIGFwcGVhciBpbiB0aGUgc291cmNlLlxuICAgICAgaWYgKFdISVRFU1BBQ0VfVEVTVC50ZXN0KGh0bWwpIHx8IGh0bWxbMF0gPT09ICc8JyAmJiBOT05WSVNJQkxFX1RFU1QudGVzdChodG1sKSkge1xuICAgICAgICAvLyBSZWNvdmVyIGxlYWRpbmcgd2hpdGVzcGFjZSBieSB0ZW1wb3JhcmlseSBwcmVwZW5kaW5nIGFueSBjaGFyYWN0ZXIuXG4gICAgICAgIC8vIFxcdUZFRkYgaGFzIHRoZSBwb3RlbnRpYWwgYWR2YW50YWdlIG9mIGJlaW5nIHplcm8td2lkdGgvaW52aXNpYmxlLlxuICAgICAgICAvLyBVZ2xpZnlKUyBkcm9wcyBVK0ZFRkYgY2hhcnMgd2hlbiBwYXJzaW5nLCBzbyB1c2UgU3RyaW5nLmZyb21DaGFyQ29kZVxuICAgICAgICAvLyBpbiBob3BlcyB0aGF0IHRoaXMgaXMgcHJlc2VydmVkIGV2ZW4gaWYgXCJcXHVGRUZGXCIgaXMgdHJhbnNmb3JtZWQgdG9cbiAgICAgICAgLy8gdGhlIGFjdHVhbCBVbmljb2RlIGNoYXJhY3RlciAoYnkgQmFiZWwsIGZvciBleGFtcGxlKS5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzIvYmxvYi92Mi40LjIwL2xpYi9wYXJzZS5qcyNMMjE2XG4gICAgICAgIG5vZGUuaW5uZXJIVE1MID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEZFRkYpICsgaHRtbDtcblxuICAgICAgICAvLyBkZWxldGVEYXRhIGxlYXZlcyBhbiBlbXB0eSBgVGV4dE5vZGVgIHdoaWNoIG9mZnNldHMgdGhlIGluZGV4IG9mIGFsbFxuICAgICAgICAvLyBjaGlsZHJlbi4gRGVmaW5pdGVseSB3YW50IHRvIGF2b2lkIHRoaXMuXG4gICAgICAgIHZhciB0ZXh0Tm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKHRleHROb2RlLmRhdGEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgbm9kZS5yZW1vdmVDaGlsZCh0ZXh0Tm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dE5vZGUuZGVsZXRlRGF0YSgwLCAxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRJbm5lckhUTUw7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9zZXRJbm5lckhUTUwuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgc2V0VGV4dENvbnRlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xuXG4vKipcbiAqIFNldCB0aGUgdGV4dENvbnRlbnQgcHJvcGVydHkgb2YgYSBub2RlLCBlbnN1cmluZyB0aGF0IHdoaXRlc3BhY2UgaXMgcHJlc2VydmVkXG4gKiBldmVuIGluIElFOC4gaW5uZXJUZXh0IGlzIGEgcG9vciBzdWJzdGl0dXRlIGZvciB0ZXh0Q29udGVudCBhbmQsIGFtb25nIG1hbnlcbiAqIGlzc3VlcywgaW5zZXJ0cyA8YnI+IGluc3RlYWQgb2YgdGhlIGxpdGVyYWwgbmV3bGluZSBjaGFycy4gaW5uZXJIVE1MIGJlaGF2ZXNcbiAqIGFzIGl0IHNob3VsZC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIHNldFRleHRDb250ZW50ID0gZnVuY3Rpb24gKG5vZGUsIHRleHQpIHtcbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59O1xuXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIGlmICghKCd0ZXh0Q29udGVudCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSkge1xuICAgIHNldFRleHRDb250ZW50ID0gZnVuY3Rpb24gKG5vZGUsIHRleHQpIHtcbiAgICAgIHNldElubmVySFRNTChub2RlLCBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIodGV4dCkpO1xuICAgIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUZXh0Q29udGVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL3NldFRleHRDb250ZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEVTQ0FQRV9MT09LVVAgPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJz4nOiAnJmd0OycsXG4gICc8JzogJyZsdDsnLFxuICAnXCInOiAnJnF1b3Q7JyxcbiAgJ1xcJyc6ICcmI3gyNzsnXG59O1xuXG52YXIgRVNDQVBFX1JFR0VYID0gL1smPjxcIiddL2c7XG5cbmZ1bmN0aW9uIGVzY2FwZXIobWF0Y2gpIHtcbiAgcmV0dXJuIEVTQ0FQRV9MT09LVVBbbWF0Y2hdO1xufVxuXG4vKipcbiAqIEVzY2FwZXMgdGV4dCB0byBwcmV2ZW50IHNjcmlwdGluZyBhdHRhY2tzLlxuICpcbiAqIEBwYXJhbSB7Kn0gdGV4dCBUZXh0IHZhbHVlIHRvIGVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXNjYXBlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlcih0ZXh0KSB7XG4gIHJldHVybiAoJycgKyB0ZXh0KS5yZXBsYWNlKEVTQ0FQRV9SRUdFWCwgZXNjYXBlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERPTVByb3BlcnR5T3BlcmF0aW9uc1xuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKCcuL1JlYWN0UGVyZicpO1xuXG52YXIgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIgPSByZXF1aXJlKCcuL3F1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLy8gU2ltcGxpZmllZCBzdWJzZXRcbnZhciBWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWCA9IC9eW2EtekEtWl9dW1xcd1xcLlxcLV0qJC87XG52YXIgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xudmFyIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiBpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgaWYgKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZS5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWC50ZXN0KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lOiBgJXNgJywgYXR0cmlidXRlTmFtZSkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCBwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlICYmICF2YWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzTnVtZXJpY1ZhbHVlICYmIGlzTmFOKHZhbHVlKSB8fCBwcm9wZXJ0eUluZm8uaGFzUG9zaXRpdmVOdW1lcmljVmFsdWUgJiYgdmFsdWUgPCAxIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSBmYWxzZTtcbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHJlYWN0UHJvcHMgPSB7XG4gICAgY2hpbGRyZW46IHRydWUsXG4gICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHRydWUsXG4gICAga2V5OiB0cnVlLFxuICAgIHJlZjogdHJ1ZVxuICB9O1xuICB2YXIgd2FybmVkUHJvcGVydGllcyA9IHt9O1xuXG4gIHZhciB3YXJuVW5rbm93blByb3BlcnR5ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAocmVhY3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiByZWFjdFByb3BzW25hbWVdIHx8IHdhcm5lZFByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkUHJvcGVydGllc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgIC8vIGRhdGEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uXG4gICAgdmFyIHN0YW5kYXJkTmFtZSA9IERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKGxvd2VyQ2FzZWROYW1lKSA/IGxvd2VyQ2FzZWROYW1lIDogRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWUuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWVbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcblxuICAgIC8vIEZvciBub3csIG9ubHkgd2FybiB3aGVuIHdlIGhhdmUgYSBzdWdnZXN0ZWQgY29ycmVjdGlvbi4gVGhpcyBwcmV2ZW50c1xuICAgIC8vIGxvZ2dpbmcgdG9vIG11Y2ggd2hlbiB1c2luZyB0cmFuc2ZlclByb3BzVG8uXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoc3RhbmRhcmROYW1lID09IG51bGwsICdVbmtub3duIERPTSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPycsIG5hbWUsIHN0YW5kYXJkTmFtZSkgOiB1bmRlZmluZWQ7XG4gIH07XG59XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIERPTSBwcm9wZXJ0aWVzLlxuICovXG52YXIgRE9NUHJvcGVydHlPcGVyYXRpb25zID0ge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgdGhlIElEIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVW5lc2NhcGVkIElELlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBzdHJpbmcuXG4gICAqL1xuICBjcmVhdGVNYXJrdXBGb3JJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIoaWQpO1xuICB9LFxuXG4gIHNldEF0dHJpYnV0ZUZvcklEOiBmdW5jdGlvbiAobm9kZSwgaWQpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShET01Qcm9wZXJ0eS5JRF9BVFRSSUJVVEVfTkFNRSwgaWQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgYSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBNYXJrdXAgc3RyaW5nLCBvciBudWxsIGlmIHRoZSBwcm9wZXJ0eSB3YXMgaW52YWxpZC5cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvclByb3BlcnR5OiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgcHJvcGVydHlJbmZvID0gRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IERPTVByb3BlcnR5LnByb3BlcnRpZXNbbmFtZV0gOiBudWxsO1xuICAgIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICAgIGlmIChzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lO1xuICAgICAgaWYgKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgfHwgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgJiYgdmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZU5hbWUgKyAnPVwiXCInO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF0dHJpYnV0ZU5hbWUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hbWUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuVW5rbm93blByb3BlcnR5KG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIGEgY3VzdG9tIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZywgb3IgZW1wdHkgc3RyaW5nIGlmIHRoZSBwcm9wZXJ0eSB3YXMgaW52YWxpZC5cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvckN1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIG5hbWUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICovXG4gIHNldFZhbHVlRm9yUHJvcGVydHk6IGZ1bmN0aW9uIChub2RlLCBuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gRE9NUHJvcGVydHkucHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG4gICAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgICAgdmFyIG11dGF0aW9uTWV0aG9kID0gcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kO1xuICAgICAgaWYgKG11dGF0aW9uTWV0aG9kKSB7XG4gICAgICAgIG11dGF0aW9uTWV0aG9kKG5vZGUsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5kZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZUF0dHJpYnV0ZSkge1xuICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lO1xuICAgICAgICB2YXIgbmFtZXNwYWNlID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWVzcGFjZTtcbiAgICAgICAgLy8gYHNldEF0dHJpYnV0ZWAgd2l0aCBvYmplY3RzIGJlY29tZXMgb25seSBgW29iamVjdF1gIGluIElFOC85LFxuICAgICAgICAvLyAoJycgKyB2YWx1ZSkgbWFrZXMgaXQgb3V0cHV0IHRoZSBjb3JyZWN0IHRvU3RyaW5nKCktdmFsdWUuXG4gICAgICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZSwgYXR0cmlidXRlTmFtZSwgJycgKyB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHByb3BOYW1lID0gcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZTtcbiAgICAgICAgLy8gTXVzdCBleHBsaWNpdGx5IGNhc3QgdmFsdWVzIGZvciBIQVNfU0lERV9FRkZFQ1RTLXByb3BlcnRpZXMgdG8gdGhlXG4gICAgICAgIC8vIHByb3BlcnR5IHR5cGUgYmVmb3JlIGNvbXBhcmluZzsgb25seSBgdmFsdWVgIGRvZXMgYW5kIGlzIHN0cmluZy5cbiAgICAgICAgaWYgKCFwcm9wZXJ0eUluZm8uaGFzU2lkZUVmZmVjdHMgfHwgJycgKyBub2RlW3Byb3BOYW1lXSAhPT0gJycgKyB2YWx1ZSkge1xuICAgICAgICAgIC8vIENvbnRyYXJ5IHRvIGBzZXRBdHRyaWJ1dGVgLCBvYmplY3QgcHJvcGVydGllcyBhcmUgcHJvcGVybHlcbiAgICAgICAgICAvLyBgdG9TdHJpbmdgZWQgYnkgSUU4LzkuXG4gICAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvckF0dHJpYnV0ZShub2RlLCBuYW1lLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuVW5rbm93blByb3BlcnR5KG5hbWUpO1xuICAgIH1cbiAgfSxcblxuICBzZXRWYWx1ZUZvckF0dHJpYnV0ZTogZnVuY3Rpb24gKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgJycgKyB2YWx1ZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKi9cbiAgZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eTogZnVuY3Rpb24gKG5vZGUsIG5hbWUpIHtcbiAgICB2YXIgcHJvcGVydHlJbmZvID0gRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IERPTVByb3BlcnR5LnByb3BlcnRpZXNbbmFtZV0gOiBudWxsO1xuICAgIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICAgIGlmIChtdXRhdGlvbk1ldGhvZCkge1xuICAgICAgICBtdXRhdGlvbk1ldGhvZChub2RlLCB1bmRlZmluZWQpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZUF0dHJpYnV0ZSkge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcHJvcE5hbWUgPSBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lO1xuICAgICAgICB2YXIgZGVmYXVsdFZhbHVlID0gRE9NUHJvcGVydHkuZ2V0RGVmYXVsdFZhbHVlRm9yUHJvcGVydHkobm9kZS5ub2RlTmFtZSwgcHJvcE5hbWUpO1xuICAgICAgICBpZiAoIXByb3BlcnR5SW5mby5oYXNTaWRlRWZmZWN0cyB8fCAnJyArIG5vZGVbcHJvcE5hbWVdICE9PSBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICBub2RlW3Byb3BOYW1lXSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FyblVua25vd25Qcm9wZXJ0eShuYW1lKTtcbiAgICB9XG4gIH1cblxufTtcblxuUmVhY3RQZXJmLm1lYXN1cmVNZXRob2RzKERPTVByb3BlcnR5T3BlcmF0aW9ucywgJ0RPTVByb3BlcnR5T3BlcmF0aW9ucycsIHtcbiAgc2V0VmFsdWVGb3JQcm9wZXJ0eTogJ3NldFZhbHVlRm9yUHJvcGVydHknLFxuICBzZXRWYWx1ZUZvckF0dHJpYnV0ZTogJ3NldFZhbHVlRm9yQXR0cmlidXRlJyxcbiAgZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eTogJ2RlbGV0ZVZhbHVlRm9yUHJvcGVydHknXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01Qcm9wZXJ0eU9wZXJhdGlvbnM7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnMuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRE9NUHJvcGVydHlcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbmZ1bmN0aW9uIGNoZWNrTWFzayh2YWx1ZSwgYml0bWFzaykge1xuICByZXR1cm4gKHZhbHVlICYgYml0bWFzaykgPT09IGJpdG1hc2s7XG59XG5cbnZhciBET01Qcm9wZXJ0eUluamVjdGlvbiA9IHtcbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBub3JtYWxpemVkLCBjYW1lbGNhc2VkIHByb3BlcnR5IG5hbWVzIHRvIGEgY29uZmlndXJhdGlvbiB0aGF0XG4gICAqIHNwZWNpZmllcyBob3cgdGhlIGFzc29jaWF0ZWQgRE9NIHByb3BlcnR5IHNob3VsZCBiZSBhY2Nlc3NlZCBvciByZW5kZXJlZC5cbiAgICovXG4gIE1VU1RfVVNFX0FUVFJJQlVURTogMHgxLFxuICBNVVNUX1VTRV9QUk9QRVJUWTogMHgyLFxuICBIQVNfU0lERV9FRkZFQ1RTOiAweDQsXG4gIEhBU19CT09MRUFOX1ZBTFVFOiAweDgsXG4gIEhBU19OVU1FUklDX1ZBTFVFOiAweDEwLFxuICBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRTogMHgyMCB8IDB4MTAsXG4gIEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUU6IDB4NDAsXG5cbiAgLyoqXG4gICAqIEluamVjdCBzb21lIHNwZWNpYWxpemVkIGtub3dsZWRnZSBhYm91dCB0aGUgRE9NLiBUaGlzIHRha2VzIGEgY29uZmlnIG9iamVjdFxuICAgKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogaXNDdXN0b21BdHRyaWJ1dGU6IGZ1bmN0aW9uIHRoYXQgZ2l2ZW4gYW4gYXR0cmlidXRlIG5hbWUgd2lsbCByZXR1cm4gdHJ1ZVxuICAgKiBpZiBpdCBjYW4gYmUgaW5zZXJ0ZWQgaW50byB0aGUgRE9NIHZlcmJhdGltLiBVc2VmdWwgZm9yIGRhdGEtKiBvciBhcmlhLSpcbiAgICogYXR0cmlidXRlcyB3aGVyZSBpdCdzIGltcG9zc2libGUgdG8gZW51bWVyYXRlIGFsbCBvZiB0aGUgcG9zc2libGVcbiAgICogYXR0cmlidXRlIG5hbWVzLFxuICAgKlxuICAgKiBQcm9wZXJ0aWVzOiBvYmplY3QgbWFwcGluZyBET00gcHJvcGVydHkgbmFtZSB0byBvbmUgb2YgdGhlXG4gICAqIERPTVByb3BlcnR5SW5qZWN0aW9uIGNvbnN0YW50cyBvciBudWxsLiBJZiB5b3VyIGF0dHJpYnV0ZSBpc24ndCBpbiBoZXJlLFxuICAgKiBpdCB3b24ndCBnZXQgd3JpdHRlbiB0byB0aGUgRE9NLlxuICAgKlxuICAgKiBET01BdHRyaWJ1dGVOYW1lczogb2JqZWN0IG1hcHBpbmcgUmVhY3QgYXR0cmlidXRlIG5hbWUgdG8gdGhlIERPTVxuICAgKiBhdHRyaWJ1dGUgbmFtZS4gQXR0cmlidXRlIG5hbWVzIG5vdCBzcGVjaWZpZWQgdXNlIHRoZSAqKmxvd2VyY2FzZSoqXG4gICAqIG5vcm1hbGl6ZWQgbmFtZS5cbiAgICpcbiAgICogRE9NQXR0cmlidXRlTmFtZXNwYWNlczogb2JqZWN0IG1hcHBpbmcgUmVhY3QgYXR0cmlidXRlIG5hbWUgdG8gdGhlIERPTVxuICAgKiBhdHRyaWJ1dGUgbmFtZXNwYWNlIFVSTC4gKEF0dHJpYnV0ZSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSBubyBuYW1lc3BhY2UuKVxuICAgKlxuICAgKiBET01Qcm9wZXJ0eU5hbWVzOiBzaW1pbGFyIHRvIERPTUF0dHJpYnV0ZU5hbWVzIGJ1dCBmb3IgRE9NIHByb3BlcnRpZXMuXG4gICAqIFByb3BlcnR5IG5hbWVzIG5vdCBzcGVjaWZpZWQgdXNlIHRoZSBub3JtYWxpemVkIG5hbWUuXG4gICAqXG4gICAqIERPTU11dGF0aW9uTWV0aG9kczogUHJvcGVydGllcyB0aGF0IHJlcXVpcmUgc3BlY2lhbCBtdXRhdGlvbiBtZXRob2RzLiBJZlxuICAgKiBgdmFsdWVgIGlzIHVuZGVmaW5lZCwgdGhlIG11dGF0aW9uIG1ldGhvZCBzaG91bGQgdW5zZXQgdGhlIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZG9tUHJvcGVydHlDb25maWcgdGhlIGNvbmZpZyBhcyBkZXNjcmliZWQgYWJvdmUuXG4gICAqL1xuICBpbmplY3RET01Qcm9wZXJ0eUNvbmZpZzogZnVuY3Rpb24gKGRvbVByb3BlcnR5Q29uZmlnKSB7XG4gICAgdmFyIEluamVjdGlvbiA9IERPTVByb3BlcnR5SW5qZWN0aW9uO1xuICAgIHZhciBQcm9wZXJ0aWVzID0gZG9tUHJvcGVydHlDb25maWcuUHJvcGVydGllcyB8fCB7fTtcbiAgICB2YXIgRE9NQXR0cmlidXRlTmFtZXNwYWNlcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzcGFjZXMgfHwge307XG4gICAgdmFyIERPTUF0dHJpYnV0ZU5hbWVzID0gZG9tUHJvcGVydHlDb25maWcuRE9NQXR0cmlidXRlTmFtZXMgfHwge307XG4gICAgdmFyIERPTVByb3BlcnR5TmFtZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01Qcm9wZXJ0eU5hbWVzIHx8IHt9O1xuICAgIHZhciBET01NdXRhdGlvbk1ldGhvZHMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01NdXRhdGlvbk1ldGhvZHMgfHwge307XG5cbiAgICBpZiAoZG9tUHJvcGVydHlDb25maWcuaXNDdXN0b21BdHRyaWJ1dGUpIHtcbiAgICAgIERPTVByb3BlcnR5Ll9pc0N1c3RvbUF0dHJpYnV0ZUZ1bmN0aW9ucy5wdXNoKGRvbVByb3BlcnR5Q29uZmlnLmlzQ3VzdG9tQXR0cmlidXRlKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBQcm9wZXJ0aWVzKSB7XG4gICAgICAhIURPTVByb3BlcnR5LnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2luamVjdERPTVByb3BlcnR5Q29uZmlnKC4uLik6IFlvdVxcJ3JlIHRyeWluZyB0byBpbmplY3QgRE9NIHByb3BlcnR5ICcgKyAnXFwnJXNcXCcgd2hpY2ggaGFzIGFscmVhZHkgYmVlbiBpbmplY3RlZC4gWW91IG1heSBiZSBhY2NpZGVudGFsbHkgJyArICdpbmplY3RpbmcgdGhlIHNhbWUgRE9NIHByb3BlcnR5IGNvbmZpZyB0d2ljZSwgb3IgeW91IG1heSBiZSAnICsgJ2luamVjdGluZyB0d28gY29uZmlncyB0aGF0IGhhdmUgY29uZmxpY3RpbmcgcHJvcGVydHkgbmFtZXMuJywgcHJvcE5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgICAgdmFyIGxvd2VyQ2FzZWQgPSBwcm9wTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHByb3BDb25maWcgPSBQcm9wZXJ0aWVzW3Byb3BOYW1lXTtcblxuICAgICAgdmFyIHByb3BlcnR5SW5mbyA9IHtcbiAgICAgICAgYXR0cmlidXRlTmFtZTogbG93ZXJDYXNlZCxcbiAgICAgICAgYXR0cmlidXRlTmFtZXNwYWNlOiBudWxsLFxuICAgICAgICBwcm9wZXJ0eU5hbWU6IHByb3BOYW1lLFxuICAgICAgICBtdXRhdGlvbk1ldGhvZDogbnVsbCxcblxuICAgICAgICBtdXN0VXNlQXR0cmlidXRlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLk1VU1RfVVNFX0FUVFJJQlVURSksXG4gICAgICAgIG11c3RVc2VQcm9wZXJ0eTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5NVVNUX1VTRV9QUk9QRVJUWSksXG4gICAgICAgIGhhc1NpZGVFZmZlY3RzOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19TSURFX0VGRkVDVFMpLFxuICAgICAgICBoYXNCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX0JPT0xFQU5fVkFMVUUpLFxuICAgICAgICBoYXNOdW1lcmljVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX05VTUVSSUNfVkFMVUUpLFxuICAgICAgICBoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSksXG4gICAgICAgIGhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSlcbiAgICAgIH07XG5cbiAgICAgICEoIXByb3BlcnR5SW5mby5tdXN0VXNlQXR0cmlidXRlIHx8ICFwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdET01Qcm9wZXJ0eTogQ2Fubm90IHJlcXVpcmUgdXNpbmcgYm90aCBhdHRyaWJ1dGUgYW5kIHByb3BlcnR5OiAlcycsIHByb3BOYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICAhKHByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHkgfHwgIXByb3BlcnR5SW5mby5oYXNTaWRlRWZmZWN0cykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRE9NUHJvcGVydHk6IFByb3BlcnRpZXMgdGhhdCBoYXZlIHNpZGUgZWZmZWN0cyBtdXN0IHVzZSBwcm9wZXJ0eTogJXMnLCBwcm9wTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgIShwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlICsgcHJvcGVydHlJbmZvLmhhc051bWVyaWNWYWx1ZSArIHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlIDw9IDEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0RPTVByb3BlcnR5OiBWYWx1ZSBjYW4gYmUgb25lIG9mIGJvb2xlYW4sIG92ZXJsb2FkZWQgYm9vbGVhbiwgb3IgJyArICdudW1lcmljIHZhbHVlLCBidXQgbm90IGEgY29tYmluYXRpb246ICVzJywgcHJvcE5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWVbbG93ZXJDYXNlZF0gPSBwcm9wTmFtZTtcbiAgICAgIH1cblxuICAgICAgaWYgKERPTUF0dHJpYnV0ZU5hbWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IERPTUF0dHJpYnV0ZU5hbWVzW3Byb3BOYW1lXTtcbiAgICAgICAgcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGVOYW1lO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lW2F0dHJpYnV0ZU5hbWVdID0gcHJvcE5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKERPTUF0dHJpYnV0ZU5hbWVzcGFjZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lc3BhY2UgPSBET01BdHRyaWJ1dGVOYW1lc3BhY2VzW3Byb3BOYW1lXTtcbiAgICAgIH1cblxuICAgICAgaWYgKERPTVByb3BlcnR5TmFtZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWUgPSBET01Qcm9wZXJ0eU5hbWVzW3Byb3BOYW1lXTtcbiAgICAgIH1cblxuICAgICAgaWYgKERPTU11dGF0aW9uTWV0aG9kcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kID0gRE9NTXV0YXRpb25NZXRob2RzW3Byb3BOYW1lXTtcbiAgICAgIH1cblxuICAgICAgRE9NUHJvcGVydHkucHJvcGVydGllc1twcm9wTmFtZV0gPSBwcm9wZXJ0eUluZm87XG4gICAgfVxuICB9XG59O1xudmFyIGRlZmF1bHRWYWx1ZUNhY2hlID0ge307XG5cbi8qKlxuICogRE9NUHJvcGVydHkgZXhwb3J0cyBsb29rdXAgb2JqZWN0cyB0aGF0IGNhbiBiZSB1c2VkIGxpa2UgZnVuY3Rpb25zOlxuICpcbiAqICAgPiBET01Qcm9wZXJ0eS5pc1ZhbGlkWydpZCddXG4gKiAgIHRydWVcbiAqICAgPiBET01Qcm9wZXJ0eS5pc1ZhbGlkWydmb29iYXInXVxuICogICB1bmRlZmluZWRcbiAqXG4gKiBBbHRob3VnaCB0aGlzIG1heSBiZSBjb25mdXNpbmcsIGl0IHBlcmZvcm1zIGJldHRlciBpbiBnZW5lcmFsLlxuICpcbiAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20va2V5LWV4aXN0c1xuICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9rZXktbWlzc2luZ1xuICovXG52YXIgRE9NUHJvcGVydHkgPSB7XG5cbiAgSURfQVRUUklCVVRFX05BTUU6ICdkYXRhLXJlYWN0aWQnLFxuXG4gIC8qKlxuICAgKiBNYXAgZnJvbSBwcm9wZXJ0eSBcInN0YW5kYXJkIG5hbWVcIiB0byBhbiBvYmplY3Qgd2l0aCBpbmZvIGFib3V0IGhvdyB0byBzZXRcbiAgICogdGhlIHByb3BlcnR5IGluIHRoZSBET00uIEVhY2ggb2JqZWN0IGNvbnRhaW5zOlxuICAgKlxuICAgKiBhdHRyaWJ1dGVOYW1lOlxuICAgKiAgIFVzZWQgd2hlbiByZW5kZXJpbmcgbWFya3VwIG9yIHdpdGggYCpBdHRyaWJ1dGUoKWAuXG4gICAqIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICAgKiBwcm9wZXJ0eU5hbWU6XG4gICAqICAgVXNlZCBvbiBET00gbm9kZSBpbnN0YW5jZXMuIChUaGlzIGluY2x1ZGVzIHByb3BlcnRpZXMgdGhhdCBtdXRhdGUgZHVlIHRvXG4gICAqICAgZXh0ZXJuYWwgZmFjdG9ycy4pXG4gICAqIG11dGF0aW9uTWV0aG9kOlxuICAgKiAgIElmIG5vbi1udWxsLCB1c2VkIGluc3RlYWQgb2YgdGhlIHByb3BlcnR5IG9yIGBzZXRBdHRyaWJ1dGUoKWAgYWZ0ZXJcbiAgICogICBpbml0aWFsIHJlbmRlci5cbiAgICogbXVzdFVzZUF0dHJpYnV0ZTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIGFjY2Vzc2VkIGFuZCBtdXRhdGVkIHVzaW5nIGAqQXR0cmlidXRlKClgLlxuICAgKiAgIChUaGlzIGluY2x1ZGVzIGFueXRoaW5nIHRoYXQgZmFpbHMgYDxwcm9wTmFtZT4gaW4gPGVsZW1lbnQ+YC4pXG4gICAqIG11c3RVc2VQcm9wZXJ0eTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIGFjY2Vzc2VkIGFuZCBtdXRhdGVkIGFzIGFuIG9iamVjdCBwcm9wZXJ0eS5cbiAgICogaGFzU2lkZUVmZmVjdHM6XG4gICAqICAgV2hldGhlciBvciBub3Qgc2V0dGluZyBhIHZhbHVlIGNhdXNlcyBzaWRlIGVmZmVjdHMgc3VjaCBhcyB0cmlnZ2VyaW5nXG4gICAqICAgcmVzb3VyY2VzIHRvIGJlIGxvYWRlZCBvciB0ZXh0IHNlbGVjdGlvbiBjaGFuZ2VzLiBJZiB0cnVlLCB3ZSByZWFkIGZyb21cbiAgICogICB0aGUgRE9NIGJlZm9yZSB1cGRhdGluZyB0byBlbnN1cmUgdGhhdCB0aGUgdmFsdWUgaXMgb25seSBzZXQgaWYgaXQgaGFzXG4gICAqICAgY2hhbmdlZC5cbiAgICogaGFzQm9vbGVhblZhbHVlOlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IHNob3VsZCBiZSByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICAgKiBoYXNOdW1lcmljVmFsdWU6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgbXVzdCBiZSBudW1lcmljIG9yIHBhcnNlIGFzIGEgbnVtZXJpYyBhbmQgc2hvdWxkIGJlXG4gICAqICAgcmVtb3ZlZCB3aGVuIHNldCB0byBhIGZhbHNleSB2YWx1ZS5cbiAgICogaGFzUG9zaXRpdmVOdW1lcmljVmFsdWU6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgbXVzdCBiZSBwb3NpdGl2ZSBudW1lcmljIG9yIHBhcnNlIGFzIGEgcG9zaXRpdmVcbiAgICogICBudW1lcmljIGFuZCBzaG91bGQgYmUgcmVtb3ZlZCB3aGVuIHNldCB0byBhIGZhbHNleSB2YWx1ZS5cbiAgICogaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBjYW4gYmUgdXNlZCBhcyBhIGZsYWcgYXMgd2VsbCBhcyB3aXRoIGEgdmFsdWUuXG4gICAqICAgUmVtb3ZlZCB3aGVuIHN0cmljdGx5IGVxdWFsIHRvIGZhbHNlOyBwcmVzZW50IHdpdGhvdXQgYSB2YWx1ZSB3aGVuXG4gICAqICAgc3RyaWN0bHkgZXF1YWwgdG8gdHJ1ZTsgcHJlc2VudCB3aXRoIGEgdmFsdWUgb3RoZXJ3aXNlLlxuICAgKi9cbiAgcHJvcGVydGllczoge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBsb3dlcmNhc2UgcHJvcGVydHkgbmFtZXMgdG8gdGhlIHByb3Blcmx5IGNhc2VkIHZlcnNpb24sIHVzZWRcbiAgICogdG8gd2FybiBpbiB0aGUgY2FzZSBvZiBtaXNzaW5nIHByb3BlcnRpZXMuIEF2YWlsYWJsZSBvbmx5IGluIF9fREVWX18uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBnZXRQb3NzaWJsZVN0YW5kYXJkTmFtZTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHt9IDogbnVsbCxcblxuICAvKipcbiAgICogQWxsIG9mIHRoZSBpc0N1c3RvbUF0dHJpYnV0ZSgpIGZ1bmN0aW9ucyB0aGF0IGhhdmUgYmVlbiBpbmplY3RlZC5cbiAgICovXG4gIF9pc0N1c3RvbUF0dHJpYnV0ZUZ1bmN0aW9uczogW10sXG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIGEgcHJvcGVydHkgbmFtZSBpcyBhIGN1c3RvbSBhdHRyaWJ1dGUuXG4gICAqIEBtZXRob2RcbiAgICovXG4gIGlzQ3VzdG9tQXR0cmlidXRlOiBmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgRE9NUHJvcGVydHkuX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXNDdXN0b21BdHRyaWJ1dGVGbiA9IERPTVByb3BlcnR5Ll9pc0N1c3RvbUF0dHJpYnV0ZUZ1bmN0aW9uc1tpXTtcbiAgICAgIGlmIChpc0N1c3RvbUF0dHJpYnV0ZUZuKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRlZmF1bHQgcHJvcGVydHkgdmFsdWUgZm9yIGEgRE9NIHByb3BlcnR5IChpLmUuLCBub3QgYW5cbiAgICogYXR0cmlidXRlKS4gTW9zdCBkZWZhdWx0IHZhbHVlcyBhcmUgJycgb3IgZmFsc2UsIGJ1dCBub3QgYWxsLiBXb3JzZSB5ZXQsXG4gICAqIHNvbWUgKGluIHBhcnRpY3VsYXIsIGB0eXBlYCkgdmFyeSBkZXBlbmRpbmcgb24gdGhlIHR5cGUgb2YgZWxlbWVudC5cbiAgICpcbiAgICogVE9ETzogSXMgaXQgYmV0dGVyIHRvIGdyYWIgYWxsIHRoZSBwb3NzaWJsZSBwcm9wZXJ0aWVzIHdoZW4gY3JlYXRpbmcgYW5cbiAgICogZWxlbWVudCB0byBhdm9pZCBoYXZpbmcgdG8gY3JlYXRlIHRoZSBzYW1lIGVsZW1lbnQgdHdpY2U/XG4gICAqL1xuICBnZXREZWZhdWx0VmFsdWVGb3JQcm9wZXJ0eTogZnVuY3Rpb24gKG5vZGVOYW1lLCBwcm9wKSB7XG4gICAgdmFyIG5vZGVEZWZhdWx0cyA9IGRlZmF1bHRWYWx1ZUNhY2hlW25vZGVOYW1lXTtcbiAgICB2YXIgdGVzdEVsZW1lbnQ7XG4gICAgaWYgKCFub2RlRGVmYXVsdHMpIHtcbiAgICAgIGRlZmF1bHRWYWx1ZUNhY2hlW25vZGVOYW1lXSA9IG5vZGVEZWZhdWx0cyA9IHt9O1xuICAgIH1cbiAgICBpZiAoIShwcm9wIGluIG5vZGVEZWZhdWx0cykpIHtcbiAgICAgIHRlc3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChub2RlTmFtZSk7XG4gICAgICBub2RlRGVmYXVsdHNbcHJvcF0gPSB0ZXN0RWxlbWVudFtwcm9wXTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVEZWZhdWx0c1twcm9wXTtcbiAgfSxcblxuICBpbmplY3Rpb246IERPTVByb3BlcnR5SW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTVByb3BlcnR5O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvRE9NUHJvcGVydHkuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIgPSByZXF1aXJlKCcuL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlcicpO1xuXG4vKipcbiAqIEVzY2FwZXMgYXR0cmlidXRlIHZhbHVlIHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBlc2NhcGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEFuIGVzY2FwZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSkge1xuICByZXR1cm4gJ1wiJyArIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlcih2YWx1ZSkgKyAnXCInO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgd2FybmluZ1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB3YXJuaW5nID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdC5pbmRleE9mKCdGYWlsZWQgQ29tcG9zaXRlIHByb3BUeXBlOiAnKSA9PT0gMCkge1xuICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgQ29tcG9zaXRlQ29tcG9uZW50IHByb3B0eXBlIGNoZWNrLlxuICAgIH1cblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfSBjYXRjaCAoeCkge31cbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvd2FybmluZy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NSURPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9SZWFjdERPTUlET3BlcmF0aW9ucycpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcblxuLyoqXG4gKiBBYnN0cmFjdHMgYXdheSBhbGwgZnVuY3Rpb25hbGl0eSBvZiB0aGUgcmVjb25jaWxlciB0aGF0IHJlcXVpcmVzIGtub3dsZWRnZSBvZlxuICogdGhlIGJyb3dzZXIgY29udGV4dC4gVE9ETzogVGhlc2UgY2FsbGVycyBzaG91bGQgYmUgcmVmYWN0b3JlZCB0byBhdm9pZCB0aGVcbiAqIG5lZWQgZm9yIHRoaXMgaW5qZWN0aW9uLlxuICovXG52YXIgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQgPSB7XG5cbiAgcHJvY2Vzc0NoaWxkcmVuVXBkYXRlczogUmVhY3RET01JRE9wZXJhdGlvbnMuZGFuZ2Vyb3VzbHlQcm9jZXNzQ2hpbGRyZW5VcGRhdGVzLFxuXG4gIHJlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQ6IFJlYWN0RE9NSURPcGVyYXRpb25zLmRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRCxcblxuICAvKipcbiAgICogSWYgYSBwYXJ0aWN1bGFyIGVudmlyb25tZW50IHJlcXVpcmVzIHRoYXQgc29tZSByZXNvdXJjZXMgYmUgY2xlYW5lZCB1cCxcbiAgICogc3BlY2lmeSB0aGlzIGluIHRoZSBpbmplY3RlZCBNaXhpbi4gSW4gdGhlIERPTSwgd2Ugd291bGQgbGlrZWx5IHdhbnQgdG9cbiAgICogcHVyZ2UgYW55IGNhY2hlZCBub2RlIElEIGxvb2t1cHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1bm1vdW50SURGcm9tRW52aXJvbm1lbnQ6IGZ1bmN0aW9uIChyb290Tm9kZUlEKSB7XG4gICAgUmVhY3RNb3VudC5wdXJnZUlEKHJvb3ROb2RlSUQpO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUlET3BlcmF0aW9uc1xuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01DaGlsZHJlbk9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTUNoaWxkcmVuT3BlcmF0aW9ucycpO1xudmFyIERPTVByb3BlcnR5T3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHlPcGVyYXRpb25zJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBFcnJvcnMgZm9yIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgbm90IGJlIHVwZGF0ZWQgd2l0aCBgdXBkYXRlUHJvcGVydHlCeUlEKClgLlxuICpcbiAqIEB0eXBlIHtvYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgSU5WQUxJRF9QUk9QRVJUWV9FUlJPUlMgPSB7XG4gIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiAnYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIHNldCB1c2luZyBgdXBkYXRlSW5uZXJIVE1MQnlJRCgpYC4nLFxuICBzdHlsZTogJ2BzdHlsZWAgbXVzdCBiZSBzZXQgdXNpbmcgYHVwZGF0ZVN0eWxlc0J5SUQoKWAuJ1xufTtcblxuLyoqXG4gKiBPcGVyYXRpb25zIHVzZWQgdG8gcHJvY2VzcyB1cGRhdGVzIHRvIERPTSBub2Rlcy5cbiAqL1xudmFyIFJlYWN0RE9NSURPcGVyYXRpb25zID0ge1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgRE9NIG5vZGUgd2l0aCBuZXcgcHJvcGVydHkgdmFsdWVzLiBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgdG9cbiAgICogdXBkYXRlIERPTSBwcm9wZXJ0aWVzIGluIGBET01Qcm9wZXJ0eWAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgbm9kZSB0byB1cGRhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEEgdmFsaWQgcHJvcGVydHkgbmFtZSwgc2VlIGBET01Qcm9wZXJ0eWAuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgTmV3IHZhbHVlIG9mIHRoZSBwcm9wZXJ0eS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB1cGRhdGVQcm9wZXJ0eUJ5SUQ6IGZ1bmN0aW9uIChpZCwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZShpZCk7XG4gICAgISFJTlZBTElEX1BST1BFUlRZX0VSUk9SUy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd1cGRhdGVQcm9wZXJ0eUJ5SUQoLi4uKTogJXMnLCBJTlZBTElEX1BST1BFUlRZX0VSUk9SU1tuYW1lXSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgLy8gSWYgd2UncmUgdXBkYXRpbmcgdG8gbnVsbCBvciB1bmRlZmluZWQsIHdlIHNob3VsZCByZW1vdmUgdGhlIHByb3BlcnR5XG4gICAgLy8gZnJvbSB0aGUgRE9NIG5vZGUgaW5zdGVhZCBvZiBpbmFkdmVydGFudGx5IHNldHRpbmcgdG8gYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBicmluZ3MgdXMgaW4gbGluZSB3aXRoIHRoZSBzYW1lIGJlaGF2aW9yIHdlIGhhdmUgb24gaW5pdGlhbCByZW5kZXIuXG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLmRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhIERPTSBub2RlIHRoYXQgZXhpc3RzIGluIHRoZSBkb2N1bWVudCB3aXRoIG1hcmt1cC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIGNoaWxkIHRvIGJlIHJlcGxhY2VkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIERhbmdlcm91cyBtYXJrdXAgdG8gaW5qZWN0IGluIHBsYWNlIG9mIGNoaWxkLlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHNlZSB7RGFuZ2VyLmRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwfVxuICAgKi9cbiAgZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEOiBmdW5jdGlvbiAoaWQsIG1hcmt1cCkge1xuICAgIHZhciBub2RlID0gUmVhY3RNb3VudC5nZXROb2RlKGlkKTtcbiAgICBET01DaGlsZHJlbk9wZXJhdGlvbnMuZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAobm9kZSwgbWFya3VwKTtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyBhIGNvbXBvbmVudCdzIGNoaWxkcmVuIGJ5IHByb2Nlc3NpbmcgYSBzZXJpZXMgb2YgdXBkYXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheTxvYmplY3Q+fSB1cGRhdGVzIExpc3Qgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25zLlxuICAgKiBAcGFyYW0ge2FycmF5PHN0cmluZz59IG1hcmt1cCBMaXN0IG9mIG1hcmt1cCBzdHJpbmdzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGRhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlczogZnVuY3Rpb24gKHVwZGF0ZXMsIG1hcmt1cCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXBkYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdXBkYXRlc1tpXS5wYXJlbnROb2RlID0gUmVhY3RNb3VudC5nZXROb2RlKHVwZGF0ZXNbaV0ucGFyZW50SUQpO1xuICAgIH1cbiAgICBET01DaGlsZHJlbk9wZXJhdGlvbnMucHJvY2Vzc1VwZGF0ZXModXBkYXRlcywgbWFya3VwKTtcbiAgfVxufTtcblxuUmVhY3RQZXJmLm1lYXN1cmVNZXRob2RzKFJlYWN0RE9NSURPcGVyYXRpb25zLCAnUmVhY3RET01JRE9wZXJhdGlvbnMnLCB7XG4gIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRDogJ2Rhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRCcsXG4gIGRhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlczogJ2Rhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlcydcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NSURPcGVyYXRpb25zO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01JRE9wZXJhdGlvbnMuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RNb3VudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyJyk7XG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RET01GZWF0dXJlRmxhZ3MgPSByZXF1aXJlKCcuL1JlYWN0RE9NRmVhdHVyZUZsYWdzJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50UmVnaXN0cnkgPSByZXF1aXJlKCcuL1JlYWN0RW1wdHlDb21wb25lbnRSZWdpc3RyeScpO1xudmFyIFJlYWN0SW5zdGFuY2VIYW5kbGVzID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlSGFuZGxlcycpO1xudmFyIFJlYWN0SW5zdGFuY2VNYXAgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VNYXAnKTtcbnZhciBSZWFjdE1hcmt1cENoZWNrc3VtID0gcmVxdWlyZSgnLi9SZWFjdE1hcmt1cENoZWNrc3VtJyk7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZSgnLi9SZWFjdFBlcmYnKTtcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xudmFyIFJlYWN0VXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlUXVldWUnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGNvbnRhaW5zTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2NvbnRhaW5zTm9kZScpO1xudmFyIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xudmFyIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IHJlcXVpcmUoJy4vdmFsaWRhdGVET01OZXN0aW5nJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIEFUVFJfTkFNRSA9IERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FO1xudmFyIG5vZGVDYWNoZSA9IHt9O1xuXG52YXIgRUxFTUVOVF9OT0RFX1RZUEUgPSAxO1xudmFyIERPQ19OT0RFX1RZUEUgPSA5O1xudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSA9IDExO1xuXG52YXIgb3duZXJEb2N1bWVudENvbnRleHRLZXkgPSAnX19SZWFjdE1vdW50X293bmVyRG9jdW1lbnQkJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuXG4vKiogTWFwcGluZyBmcm9tIHJlYWN0Um9vdElEIHRvIFJlYWN0IGNvbXBvbmVudCBpbnN0YW5jZS4gKi9cbnZhciBpbnN0YW5jZXNCeVJlYWN0Um9vdElEID0ge307XG5cbi8qKiBNYXBwaW5nIGZyb20gcmVhY3RSb290SUQgdG8gYGNvbnRhaW5lcmAgbm9kZXMuICovXG52YXIgY29udGFpbmVyc0J5UmVhY3RSb290SUQgPSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgLyoqIF9fREVWX18tb25seSBtYXBwaW5nIGZyb20gcmVhY3RSb290SUQgdG8gcm9vdCBlbGVtZW50cy4gKi9cbiAgdmFyIHJvb3RFbGVtZW50c0J5UmVhY3RSb290SUQgPSB7fTtcbn1cblxuLy8gVXNlZCB0byBzdG9yZSBicmVhZHRoLWZpcnN0IHNlYXJjaCBzdGF0ZSBpbiBmaW5kQ29tcG9uZW50Um9vdC5cbnZhciBmaW5kQ29tcG9uZW50Um9vdFJldXNhYmxlQXJyYXkgPSBbXTtcblxuLyoqXG4gKiBGaW5kcyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGNoYXJhY3RlclxuICogdGhhdCdzIG5vdCBjb21tb24gYmV0d2VlbiB0aGUgdHdvIGdpdmVuIHN0cmluZ3MuXG4gKlxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgaW5kZXggb2YgdGhlIGNoYXJhY3RlciB3aGVyZSB0aGUgc3RyaW5ncyBkaXZlcmdlXG4gKi9cbmZ1bmN0aW9uIGZpcnN0RGlmZmVyZW5jZUluZGV4KHN0cmluZzEsIHN0cmluZzIpIHtcbiAgdmFyIG1pbkxlbiA9IE1hdGgubWluKHN0cmluZzEubGVuZ3RoLCBzdHJpbmcyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWluTGVuOyBpKyspIHtcbiAgICBpZiAoc3RyaW5nMS5jaGFyQXQoaSkgIT09IHN0cmluZzIuY2hhckF0KGkpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cmluZzEubGVuZ3RoID09PSBzdHJpbmcyLmxlbmd0aCA/IC0xIDogbWluTGVuO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01Eb2N1bWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRoYXQgbWF5IGNvbnRhaW5cbiAqIGEgUmVhY3QgY29tcG9uZW50XG4gKiBAcmV0dXJuIHs/Kn0gRE9NIGVsZW1lbnQgdGhhdCBtYXkgaGF2ZSB0aGUgcmVhY3RSb290IElELCBvciBudWxsLlxuICovXG5mdW5jdGlvbiBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKSB7XG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5kb2N1bWVudEVsZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5maXJzdENoaWxkO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdGhhdCBtYXkgY29udGFpbiBhIFJlYWN0IGNvbXBvbmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IEEgXCJyZWFjdFJvb3RcIiBJRCwgaWYgYSBSZWFjdCBjb21wb25lbnQgaXMgcmVuZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIGdldFJlYWN0Um9vdElEKGNvbnRhaW5lcikge1xuICB2YXIgcm9vdEVsZW1lbnQgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgcmV0dXJuIHJvb3RFbGVtZW50ICYmIFJlYWN0TW91bnQuZ2V0SUQocm9vdEVsZW1lbnQpO1xufVxuXG4vKipcbiAqIEFjY2Vzc2luZyBub2RlW0FUVFJfTkFNRV0gb3IgY2FsbGluZyBnZXRBdHRyaWJ1dGUoQVRUUl9OQU1FKSBvbiBhIGZvcm1cbiAqIGVsZW1lbnQgY2FuIHJldHVybiBpdHMgY29udHJvbCB3aG9zZSBuYW1lIG9yIElEIGVxdWFscyBBVFRSX05BTUUuIEFsbFxuICogRE9NIG5vZGVzIHN1cHBvcnQgYGdldEF0dHJpYnV0ZU5vZGVgIGJ1dCB0aGlzIGNhbiBhbHNvIGdldCBjYWxsZWQgb25cbiAqIG90aGVyIG9iamVjdHMgc28ganVzdCByZXR1cm4gJycgaWYgd2UncmUgZ2l2ZW4gc29tZXRoaW5nIG90aGVyIHRoYW4gYVxuICogRE9NIG5vZGUgKHN1Y2ggYXMgd2luZG93KS5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fERPTVdpbmRvd3xET01Eb2N1bWVudHxET01UZXh0Tm9kZX0gbm9kZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gSUQgb2YgdGhlIHN1cHBsaWVkIGBkb21Ob2RlYC5cbiAqL1xuZnVuY3Rpb24gZ2V0SUQobm9kZSkge1xuICB2YXIgaWQgPSBpbnRlcm5hbEdldElEKG5vZGUpO1xuICBpZiAoaWQpIHtcbiAgICBpZiAobm9kZUNhY2hlLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgdmFyIGNhY2hlZCA9IG5vZGVDYWNoZVtpZF07XG4gICAgICBpZiAoY2FjaGVkICE9PSBub2RlKSB7XG4gICAgICAgICEhaXNWYWxpZChjYWNoZWQsIGlkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdE1vdW50OiBUd28gdmFsaWQgYnV0IHVuZXF1YWwgbm9kZXMgd2l0aCB0aGUgc2FtZSBgJXNgOiAlcycsIEFUVFJfTkFNRSwgaWQpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBub2RlQ2FjaGVbaWRdID0gbm9kZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZUNhY2hlW2lkXSA9IG5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGlkO1xufVxuXG5mdW5jdGlvbiBpbnRlcm5hbEdldElEKG5vZGUpIHtcbiAgLy8gSWYgbm9kZSBpcyBzb21ldGhpbmcgbGlrZSBhIHdpbmRvdywgZG9jdW1lbnQsIG9yIHRleHQgbm9kZSwgbm9uZSBvZlxuICAvLyB3aGljaCBzdXBwb3J0IGF0dHJpYnV0ZXMgb3IgYSAuZ2V0QXR0cmlidXRlIG1ldGhvZCwgZ3JhY2VmdWxseSByZXR1cm5cbiAgLy8gdGhlIGVtcHR5IHN0cmluZywgYXMgaWYgdGhlIGF0dHJpYnV0ZSB3ZXJlIG1pc3NpbmcuXG4gIHJldHVybiBub2RlICYmIG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKEFUVFJfTkFNRSkgfHwgJyc7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgUmVhY3Qtc3BlY2lmaWMgSUQgb2YgdGhlIGdpdmVuIG5vZGUuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlIFRoZSBET00gbm9kZSB3aG9zZSBJRCB3aWxsIGJlIHNldC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgdmFsdWUgb2YgdGhlIElEIGF0dHJpYnV0ZS5cbiAqL1xuZnVuY3Rpb24gc2V0SUQobm9kZSwgaWQpIHtcbiAgdmFyIG9sZElEID0gaW50ZXJuYWxHZXRJRChub2RlKTtcbiAgaWYgKG9sZElEICE9PSBpZCkge1xuICAgIGRlbGV0ZSBub2RlQ2FjaGVbb2xkSURdO1xuICB9XG4gIG5vZGUuc2V0QXR0cmlidXRlKEFUVFJfTkFNRSwgaWQpO1xuICBub2RlQ2FjaGVbaWRdID0gbm9kZTtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgbm9kZSB3aXRoIHRoZSBzdXBwbGllZCBSZWFjdC1nZW5lcmF0ZWQgRE9NIElELlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBBIFJlYWN0LWdlbmVyYXRlZCBET00gSUQuXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fSBET00gbm9kZSB3aXRoIHRoZSBzdXBwbGVkIGBpZGAuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZShpZCkge1xuICBpZiAoIW5vZGVDYWNoZS5oYXNPd25Qcm9wZXJ0eShpZCkgfHwgIWlzVmFsaWQobm9kZUNhY2hlW2lkXSwgaWQpKSB7XG4gICAgbm9kZUNhY2hlW2lkXSA9IFJlYWN0TW91bnQuZmluZFJlYWN0Tm9kZUJ5SUQoaWQpO1xuICB9XG4gIHJldHVybiBub2RlQ2FjaGVbaWRdO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBub2RlIHdpdGggdGhlIHN1cHBsaWVkIHB1YmxpYyBSZWFjdCBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0geyp9IGluc3RhbmNlIEEgcHVibGljIFJlYWN0IGluc3RhbmNlLlxuICogQHJldHVybiB7P0RPTUVsZW1lbnR9IERPTSBub2RlIHdpdGggdGhlIHN1cHBsZWQgYGlkYC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXROb2RlRnJvbUluc3RhbmNlKGluc3RhbmNlKSB7XG4gIHZhciBpZCA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KGluc3RhbmNlKS5fcm9vdE5vZGVJRDtcbiAgaWYgKFJlYWN0RW1wdHlDb21wb25lbnRSZWdpc3RyeS5pc051bGxDb21wb25lbnRJRChpZCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoIW5vZGVDYWNoZS5oYXNPd25Qcm9wZXJ0eShpZCkgfHwgIWlzVmFsaWQobm9kZUNhY2hlW2lkXSwgaWQpKSB7XG4gICAgbm9kZUNhY2hlW2lkXSA9IFJlYWN0TW91bnQuZmluZFJlYWN0Tm9kZUJ5SUQoaWQpO1xuICB9XG4gIHJldHVybiBub2RlQ2FjaGVbaWRdO1xufVxuXG4vKipcbiAqIEEgbm9kZSBpcyBcInZhbGlkXCIgaWYgaXQgaXMgY29udGFpbmVkIGJ5IGEgY3VycmVudGx5IG1vdW50ZWQgY29udGFpbmVyLlxuICpcbiAqIFRoaXMgbWVhbnMgdGhhdCB0aGUgbm9kZSBkb2VzIG5vdCBoYXZlIHRvIGJlIGNvbnRhaW5lZCBieSBhIGRvY3VtZW50IGluXG4gKiBvcmRlciB0byBiZSBjb25zaWRlcmVkIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgZXhwZWN0ZWQgSUQgb2YgdGhlIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBub2RlIGlzIGNvbnRhaW5lZCBieSBhIG1vdW50ZWQgY29udGFpbmVyLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkKG5vZGUsIGlkKSB7XG4gIGlmIChub2RlKSB7XG4gICAgIShpbnRlcm5hbEdldElEKG5vZGUpID09PSBpZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RNb3VudDogVW5leHBlY3RlZCBtb2RpZmljYXRpb24gb2YgYCVzYCcsIEFUVFJfTkFNRSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGNvbnRhaW5lciA9IFJlYWN0TW91bnQuZmluZFJlYWN0Q29udGFpbmVyRm9ySUQoaWQpO1xuICAgIGlmIChjb250YWluZXIgJiYgY29udGFpbnNOb2RlKGNvbnRhaW5lciwgbm9kZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDYXVzZXMgdGhlIGNhY2hlIHRvIGZvcmdldCBhYm91dCBvbmUgUmVhY3Qtc3BlY2lmaWMgSUQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBJRCB0byBmb3JnZXQuXG4gKi9cbmZ1bmN0aW9uIHB1cmdlSUQoaWQpIHtcbiAgZGVsZXRlIG5vZGVDYWNoZVtpZF07XG59XG5cbnZhciBkZWVwZXN0Tm9kZVNvRmFyID0gbnVsbDtcbmZ1bmN0aW9uIGZpbmREZWVwZXN0Q2FjaGVkQW5jZXN0b3JJbXBsKGFuY2VzdG9ySUQpIHtcbiAgdmFyIGFuY2VzdG9yID0gbm9kZUNhY2hlW2FuY2VzdG9ySURdO1xuICBpZiAoYW5jZXN0b3IgJiYgaXNWYWxpZChhbmNlc3RvciwgYW5jZXN0b3JJRCkpIHtcbiAgICBkZWVwZXN0Tm9kZVNvRmFyID0gYW5jZXN0b3I7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBub2RlIGlzbid0IHBvcHVsYXRlZCBpbiB0aGUgY2FjaGUsIHNvIHByZXN1bWFibHkgbm9uZSBvZiBpdHNcbiAgICAvLyBkZXNjZW5kYW50cyBhcmUuIEJyZWFrIG91dCBvZiB0aGUgbG9vcC5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGRlZXBlc3QgY2FjaGVkIG5vZGUgd2hvc2UgSUQgaXMgYSBwcmVmaXggb2YgYHRhcmdldElEYC5cbiAqL1xuZnVuY3Rpb24gZmluZERlZXBlc3RDYWNoZWRBbmNlc3Rvcih0YXJnZXRJRCkge1xuICBkZWVwZXN0Tm9kZVNvRmFyID0gbnVsbDtcbiAgUmVhY3RJbnN0YW5jZUhhbmRsZXMudHJhdmVyc2VBbmNlc3RvcnModGFyZ2V0SUQsIGZpbmREZWVwZXN0Q2FjaGVkQW5jZXN0b3JJbXBsKTtcblxuICB2YXIgZm91bmROb2RlID0gZGVlcGVzdE5vZGVTb0ZhcjtcbiAgZGVlcGVzdE5vZGVTb0ZhciA9IG51bGw7XG4gIHJldHVybiBmb3VuZE5vZGU7XG59XG5cbi8qKlxuICogTW91bnRzIHRoaXMgY29tcG9uZW50IGFuZCBpbnNlcnRzIGl0IGludG8gdGhlIERPTS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnRJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gbW91bnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gcm9vdElEIERPTSBJRCBvZiB0aGUgcm9vdCBub2RlLlxuICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gbW91bnQgaW50by5cbiAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkUmV1c2VNYXJrdXAgSWYgdHJ1ZSwgZG8gbm90IGluc2VydCBtYXJrdXBcbiAqL1xuZnVuY3Rpb24gbW91bnRDb21wb25lbnRJbnRvTm9kZShjb21wb25lbnRJbnN0YW5jZSwgcm9vdElELCBjb250YWluZXIsIHRyYW5zYWN0aW9uLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCkge1xuICBpZiAoUmVhY3RET01GZWF0dXJlRmxhZ3MudXNlQ3JlYXRlRWxlbWVudCkge1xuICAgIGNvbnRleHQgPSBhc3NpZ24oe30sIGNvbnRleHQpO1xuICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUpIHtcbiAgICAgIGNvbnRleHRbb3duZXJEb2N1bWVudENvbnRleHRLZXldID0gY29udGFpbmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0W293bmVyRG9jdW1lbnRDb250ZXh0S2V5XSA9IGNvbnRhaW5lci5vd25lckRvY3VtZW50O1xuICAgIH1cbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChjb250ZXh0ID09PSBlbXB0eU9iamVjdCkge1xuICAgICAgY29udGV4dCA9IHt9O1xuICAgIH1cbiAgICB2YXIgdGFnID0gY29udGFpbmVyLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgY29udGV4dFt2YWxpZGF0ZURPTU5lc3RpbmcuYW5jZXN0b3JJbmZvQ29udGV4dEtleV0gPSB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyhudWxsLCB0YWcsIG51bGwpO1xuICB9XG4gIHZhciBtYXJrdXAgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICBjb21wb25lbnRJbnN0YW5jZS5fcmVuZGVyZWRDb21wb25lbnQuX3RvcExldmVsV3JhcHBlciA9IGNvbXBvbmVudEluc3RhbmNlO1xuICBSZWFjdE1vdW50Ll9tb3VudEltYWdlSW50b05vZGUobWFya3VwLCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCB0cmFuc2FjdGlvbik7XG59XG5cbi8qKlxuICogQmF0Y2hlZCBtb3VudC5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnRJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gbW91bnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gcm9vdElEIERPTSBJRCBvZiB0aGUgcm9vdCBub2RlLlxuICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gbW91bnQgaW50by5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkUmV1c2VNYXJrdXAgSWYgdHJ1ZSwgZG8gbm90IGluc2VydCBtYXJrdXBcbiAqL1xuZnVuY3Rpb24gYmF0Y2hlZE1vdW50Q29tcG9uZW50SW50b05vZGUoY29tcG9uZW50SW5zdGFuY2UsIHJvb3RJRCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCkge1xuICB2YXIgdHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5nZXRQb29sZWQoXG4gIC8qIGZvcmNlSFRNTCAqL3Nob3VsZFJldXNlTWFya3VwKTtcbiAgdHJhbnNhY3Rpb24ucGVyZm9ybShtb3VudENvbXBvbmVudEludG9Ob2RlLCBudWxsLCBjb21wb25lbnRJbnN0YW5jZSwgcm9vdElELCBjb250YWluZXIsIHRyYW5zYWN0aW9uLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCk7XG4gIFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLnJlbGVhc2UodHJhbnNhY3Rpb24pO1xufVxuXG4vKipcbiAqIFVubW91bnRzIGEgY29tcG9uZW50IGFuZCByZW1vdmVzIGl0IGZyb20gdGhlIERPTS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnN0YW5jZSBSZWFjdCBjb21wb25lbnQgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byB1bm1vdW50IGZyb20uXG4gKiBAZmluYWxcbiAqIEBpbnRlcm5hbFxuICogQHNlZSB7UmVhY3RNb3VudC51bm1vdW50Q29tcG9uZW50QXROb2RlfVxuICovXG5mdW5jdGlvbiB1bm1vdW50Q29tcG9uZW50RnJvbU5vZGUoaW5zdGFuY2UsIGNvbnRhaW5lcikge1xuICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChpbnN0YW5jZSk7XG5cbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSkge1xuICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lci5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICAvLyBodHRwOi8vanNwZXJmLmNvbS9lbXB0eWluZy1hLW5vZGVcbiAgd2hpbGUgKGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY29udGFpbmVyLmxhc3RDaGlsZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBET00gbm9kZSBoYXMgYSBkaXJlY3QgUmVhY3QtcmVuZGVyZWQgY2hpbGQgdGhhdCBpc1xuICogbm90IGEgUmVhY3Qgcm9vdCBlbGVtZW50LiBVc2VmdWwgZm9yIHdhcm5pbmcgaW4gYHJlbmRlcmAsXG4gKiBgdW5tb3VudENvbXBvbmVudEF0Tm9kZWAsIGV0Yy5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlIFRoZSBjYW5kaWRhdGUgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBET00gZWxlbWVudCBjb250YWlucyBhIGRpcmVjdCBjaGlsZCB0aGF0IHdhc1xuICogcmVuZGVyZWQgYnkgUmVhY3QgYnV0IGlzIG5vdCBhIHJvb3QgZWxlbWVudC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBoYXNOb25Sb290UmVhY3RDaGlsZChub2RlKSB7XG4gIHZhciByZWFjdFJvb3RJRCA9IGdldFJlYWN0Um9vdElEKG5vZGUpO1xuICByZXR1cm4gcmVhY3RSb290SUQgPyByZWFjdFJvb3RJRCAhPT0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuZ2V0UmVhY3RSb290SURGcm9tTm9kZUlEKHJlYWN0Um9vdElEKSA6IGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IChkZWVwZXN0KSBhbmNlc3RvciBvZiBhIG5vZGUgd2hpY2ggaXMgcmVuZGVyZWQgYnkgdGhpcyBjb3B5XG4gKiBvZiBSZWFjdC5cbiAqL1xuZnVuY3Rpb24gZmluZEZpcnN0UmVhY3RET01JbXBsKG5vZGUpIHtcbiAgLy8gVGhpcyBub2RlIG1pZ2h0IGJlIGZyb20gYW5vdGhlciBSZWFjdCBpbnN0YW5jZSwgc28gd2UgbWFrZSBzdXJlIG5vdCB0b1xuICAvLyBleGFtaW5lIHRoZSBub2RlIGNhY2hlIGhlcmVcbiAgZm9yICg7IG5vZGUgJiYgbm9kZS5wYXJlbnROb2RlICE9PSBub2RlOyBub2RlID0gbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IDEpIHtcbiAgICAgIC8vIE5vdCBhIERPTUVsZW1lbnQsIHRoZXJlZm9yZSBub3QgYSBSZWFjdCBjb21wb25lbnRcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgbm9kZUlEID0gaW50ZXJuYWxHZXRJRChub2RlKTtcbiAgICBpZiAoIW5vZGVJRCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciByZWFjdFJvb3RJRCA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLmdldFJlYWN0Um9vdElERnJvbU5vZGVJRChub2RlSUQpO1xuXG4gICAgLy8gSWYgY29udGFpbmVyc0J5UmVhY3RSb290SUQgY29udGFpbnMgdGhlIGNvbnRhaW5lciB3ZSBmaW5kIGJ5IGNyYXdsaW5nIHVwXG4gICAgLy8gdGhlIHRyZWUsIHdlIGtub3cgdGhhdCB0aGlzIGluc3RhbmNlIG9mIFJlYWN0IHJlbmRlcmVkIHRoZSBub2RlLlxuICAgIC8vIG5iLiBpc1ZhbGlkJ3Mgc3RyYXRlZ3kgKHdpdGggY29udGFpbnNOb2RlKSBkb2VzIG5vdCB3b3JrIGJlY2F1c2UgcmVuZGVyXG4gICAgLy8gdHJlZXMgbWF5IGJlIG5lc3RlZCBhbmQgd2UgZG9uJ3Qgd2FudCBhIGZhbHNlIHBvc2l0aXZlIGluIHRoYXQgY2FzZS5cbiAgICB2YXIgY3VycmVudCA9IG5vZGU7XG4gICAgdmFyIGxhc3RJRDtcbiAgICBkbyB7XG4gICAgICBsYXN0SUQgPSBpbnRlcm5hbEdldElEKGN1cnJlbnQpO1xuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZTtcbiAgICAgIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICAgICAgLy8gVGhlIHBhc3NlZC1pbiBub2RlIGhhcyBiZWVuIGRldGFjaGVkIGZyb20gdGhlIGNvbnRhaW5lciBpdCB3YXNcbiAgICAgICAgLy8gb3JpZ2luYWxseSByZW5kZXJlZCBpbnRvLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9IHdoaWxlIChsYXN0SUQgIT09IHJlYWN0Um9vdElEKTtcblxuICAgIGlmIChjdXJyZW50ID09PSBjb250YWluZXJzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF0pIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBUZW1wb3JhcnkgKD8pIGhhY2sgc28gdGhhdCB3ZSBjYW4gc3RvcmUgYWxsIHRvcC1sZXZlbCBwZW5kaW5nIHVwZGF0ZXMgb25cbiAqIGNvbXBvc2l0ZXMgaW5zdGVhZCBvZiBoYXZpbmcgdG8gd29ycnkgYWJvdXQgZGlmZmVyZW50IHR5cGVzIG9mIGNvbXBvbmVudHNcbiAqIGhlcmUuXG4gKi9cbnZhciBUb3BMZXZlbFdyYXBwZXIgPSBmdW5jdGlvbiAoKSB7fTtcblRvcExldmVsV3JhcHBlci5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgVG9wTGV2ZWxXcmFwcGVyLmRpc3BsYXlOYW1lID0gJ1RvcExldmVsV3JhcHBlcic7XG59XG5Ub3BMZXZlbFdyYXBwZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gdGhpcy5wcm9wcyBpcyBhY3R1YWxseSBhIFJlYWN0RWxlbWVudFxuICByZXR1cm4gdGhpcy5wcm9wcztcbn07XG5cbi8qKlxuICogTW91bnRpbmcgaXMgdGhlIHByb2Nlc3Mgb2YgaW5pdGlhbGl6aW5nIGEgUmVhY3QgY29tcG9uZW50IGJ5IGNyZWF0aW5nIGl0c1xuICogcmVwcmVzZW50YXRpdmUgRE9NIGVsZW1lbnRzIGFuZCBpbnNlcnRpbmcgdGhlbSBpbnRvIGEgc3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gKiBBbnkgcHJpb3IgY29udGVudCBpbnNpZGUgYGNvbnRhaW5lcmAgaXMgZGVzdHJveWVkIGluIHRoZSBwcm9jZXNzLlxuICpcbiAqICAgUmVhY3RNb3VudC5yZW5kZXIoXG4gKiAgICAgY29tcG9uZW50LFxuICogICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250YWluZXInKVxuICogICApO1xuICpcbiAqICAgPGRpdiBpZD1cImNvbnRhaW5lclwiPiAgICAgICAgICAgICAgICAgICA8LS0gU3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gKiAgICAgPGRpdiBkYXRhLXJlYWN0aWQ9XCIuM1wiPiAgICAgICAgICAgICAgPC0tIFJlbmRlcmVkIHJlYWN0Um9vdCBvZiBSZWFjdFxuICogICAgICAgLy8gLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LlxuICogICAgIDwvZGl2PlxuICogICA8L2Rpdj5cbiAqXG4gKiBJbnNpZGUgb2YgYGNvbnRhaW5lcmAsIHRoZSBmaXJzdCBlbGVtZW50IHJlbmRlcmVkIGlzIHRoZSBcInJlYWN0Um9vdFwiLlxuICovXG52YXIgUmVhY3RNb3VudCA9IHtcblxuICBUb3BMZXZlbFdyYXBwZXI6IFRvcExldmVsV3JhcHBlcixcblxuICAvKiogRXhwb3NlZCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzICoqL1xuICBfaW5zdGFuY2VzQnlSZWFjdFJvb3RJRDogaW5zdGFuY2VzQnlSZWFjdFJvb3RJRCxcblxuICAvKipcbiAgICogVGhpcyBpcyBhIGhvb2sgcHJvdmlkZWQgdG8gc3VwcG9ydCByZW5kZXJpbmcgUmVhY3QgY29tcG9uZW50cyB3aGlsZVxuICAgKiBlbnN1cmluZyB0aGF0IHRoZSBhcHBhcmVudCBzY3JvbGwgcG9zaXRpb24gb2YgaXRzIGBjb250YWluZXJgIGRvZXMgbm90XG4gICAqIGNoYW5nZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgVGhlIGBjb250YWluZXJgIGJlaW5nIHJlbmRlcmVkIGludG8uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHJlbmRlckNhbGxiYWNrIFRoaXMgbXVzdCBiZSBjYWxsZWQgb25jZSB0byBkbyB0aGUgcmVuZGVyLlxuICAgKi9cbiAgc2Nyb2xsTW9uaXRvcjogZnVuY3Rpb24gKGNvbnRhaW5lciwgcmVuZGVyQ2FsbGJhY2spIHtcbiAgICByZW5kZXJDYWxsYmFjaygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUYWtlIGEgY29tcG9uZW50IHRoYXQncyBhbHJlYWR5IG1vdW50ZWQgaW50byB0aGUgRE9NIGFuZCByZXBsYWNlIGl0cyBwcm9wc1xuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBwcmV2Q29tcG9uZW50IGNvbXBvbmVudCBpbnN0YW5jZSBhbHJlYWR5IGluIHRoZSBET01cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IGNvbXBvbmVudCBpbnN0YW5jZSB0byByZW5kZXJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyIHRvIHJlbmRlciBpbnRvXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0cmlnZ2VyZWQgb24gY29tcGxldGlvblxuICAgKi9cbiAgX3VwZGF0ZVJvb3RDb21wb25lbnQ6IGZ1bmN0aW9uIChwcmV2Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgIFJlYWN0TW91bnQuc2Nyb2xsTW9uaXRvcihjb250YWluZXIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZUVsZW1lbnRJbnRlcm5hbChwcmV2Q29tcG9uZW50LCBuZXh0RWxlbWVudCk7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlQ2FsbGJhY2tJbnRlcm5hbChwcmV2Q29tcG9uZW50LCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gUmVjb3JkIHRoZSByb290IGVsZW1lbnQgaW4gY2FzZSBpdCBsYXRlciBnZXRzIHRyYW5zcGxhbnRlZC5cbiAgICAgIHJvb3RFbGVtZW50c0J5UmVhY3RSb290SURbZ2V0UmVhY3RSb290SUQoY29udGFpbmVyKV0gPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJldkNvbXBvbmVudDtcbiAgfSxcblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBjb21wb25lbnQgaW50byB0aGUgaW5zdGFuY2UgbWFwIGFuZCBzdGFydHMgc2Nyb2xsIHZhbHVlXG4gICAqIG1vbml0b3JpbmdcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gbmV4dENvbXBvbmVudCBjb21wb25lbnQgaW5zdGFuY2UgdG8gcmVuZGVyXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lciB0byByZW5kZXIgaW50b1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHJlYWN0Um9vdCBJRCBwcmVmaXhcbiAgICovXG4gIF9yZWdpc3RlckNvbXBvbmVudDogZnVuY3Rpb24gKG5leHRDb21wb25lbnQsIGNvbnRhaW5lcikge1xuICAgICEoY29udGFpbmVyICYmIChjb250YWluZXIubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERV9UWVBFIHx8IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSB8fCBjb250YWluZXIubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ19yZWdpc3RlckNvbXBvbmVudCguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5lbnN1cmVTY3JvbGxWYWx1ZU1vbml0b3JpbmcoKTtcblxuICAgIHZhciByZWFjdFJvb3RJRCA9IFJlYWN0TW91bnQucmVnaXN0ZXJDb250YWluZXIoY29udGFpbmVyKTtcbiAgICBpbnN0YW5jZXNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXSA9IG5leHRDb21wb25lbnQ7XG4gICAgcmV0dXJuIHJlYWN0Um9vdElEO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSBuZXcgY29tcG9uZW50IGludG8gdGhlIERPTS5cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IGVsZW1lbnQgdG8gcmVuZGVyXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lciB0byByZW5kZXIgaW50b1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFJldXNlTWFya3VwIGlmIHdlIHNob3VsZCBza2lwIHRoZSBtYXJrdXAgaW5zZXJ0aW9uXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSBuZXh0Q29tcG9uZW50XG4gICAqL1xuICBfcmVuZGVyTmV3Um9vdENvbXBvbmVudDogZnVuY3Rpb24gKG5leHRFbGVtZW50LCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KSB7XG4gICAgLy8gVmFyaW91cyBwYXJ0cyBvZiBvdXIgY29kZSAoc3VjaCBhcyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCdzXG4gICAgLy8gX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCkgYXNzdW1lIHRoYXQgY2FsbHMgdG8gcmVuZGVyIGFyZW4ndCBuZXN0ZWQ7XG4gICAgLy8gdmVyaWZ5IHRoYXQgdGhhdCdzIHRoZSBjYXNlLlxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPT0gbnVsbCwgJ19yZW5kZXJOZXdSb290Q29tcG9uZW50KCk6IFJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gJyArICdvZiBwcm9wcyBhbmQgc3RhdGU7IHRyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gJyArICdyZW5kZXIgaXMgbm90IGFsbG93ZWQuIElmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZS4gQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJXMuJywgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcblxuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQobmV4dEVsZW1lbnQsIG51bGwpO1xuICAgIHZhciByZWFjdFJvb3RJRCA9IFJlYWN0TW91bnQuX3JlZ2lzdGVyQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCBjb250YWluZXIpO1xuXG4gICAgLy8gVGhlIGluaXRpYWwgcmVuZGVyIGlzIHN5bmNocm9ub3VzIGJ1dCBhbnkgdXBkYXRlcyB0aGF0IGhhcHBlbiBkdXJpbmdcbiAgICAvLyByZW5kZXJpbmcsIGluIGNvbXBvbmVudFdpbGxNb3VudCBvciBjb21wb25lbnREaWRNb3VudCwgd2lsbCBiZSBiYXRjaGVkXG4gICAgLy8gYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IGJhdGNoaW5nIHN0cmF0ZWd5LlxuXG4gICAgUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzKGJhdGNoZWRNb3VudENvbXBvbmVudEludG9Ob2RlLCBjb21wb25lbnRJbnN0YW5jZSwgcmVhY3RSb290SUQsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFJlY29yZCB0aGUgcm9vdCBlbGVtZW50IGluIGNhc2UgaXQgbGF0ZXIgZ2V0cyB0cmFuc3BsYW50ZWQuXG4gICAgICByb290RWxlbWVudHNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXSA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBjb21wb25lbnRJbnN0YW5jZTtcbiAgfSxcblxuICAvKipcbiAgICogUmVuZGVycyBhIFJlYWN0IGNvbXBvbmVudCBpbnRvIHRoZSBET00gaW4gdGhlIHN1cHBsaWVkIGBjb250YWluZXJgLlxuICAgKlxuICAgKiBJZiB0aGUgUmVhY3QgY29tcG9uZW50IHdhcyBwcmV2aW91c2x5IHJlbmRlcmVkIGludG8gYGNvbnRhaW5lcmAsIHRoaXMgd2lsbFxuICAgKiBwZXJmb3JtIGFuIHVwZGF0ZSBvbiBpdCBhbmQgb25seSBtdXRhdGUgdGhlIERPTSBhcyBuZWNlc3NhcnkgdG8gcmVmbGVjdCB0aGVcbiAgICogbGF0ZXN0IFJlYWN0IGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gcGFyZW50Q29tcG9uZW50IFRoZSBjb25jZXB0dWFsIHBhcmVudCBvZiB0aGlzIHJlbmRlciB0cmVlLlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgQ29tcG9uZW50IGVsZW1lbnQgdG8gcmVuZGVyLlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byByZW5kZXIgaW50by5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRyaWdnZXJlZCBvbiBjb21wbGV0aW9uXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSBDb21wb25lbnQgaW5zdGFuY2UgcmVuZGVyZWQgaW4gYGNvbnRhaW5lcmAuXG4gICAqL1xuICByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjogZnVuY3Rpb24gKHBhcmVudENvbXBvbmVudCwgbmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICAhKHBhcmVudENvbXBvbmVudCAhPSBudWxsICYmIHBhcmVudENvbXBvbmVudC5fcmVhY3RJbnRlcm5hbEluc3RhbmNlICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3BhcmVudENvbXBvbmVudCBtdXN0IGJlIGEgdmFsaWQgUmVhY3QgQ29tcG9uZW50JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiBSZWFjdE1vdW50Ll9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKTtcbiAgfSxcblxuICBfcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6IGZ1bmN0aW9uIChwYXJlbnRDb21wb25lbnQsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChuZXh0RWxlbWVudCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET00ucmVuZGVyKCk6IEludmFsaWQgY29tcG9uZW50IGVsZW1lbnQuJXMnLCB0eXBlb2YgbmV4dEVsZW1lbnQgPT09ICdzdHJpbmcnID8gJyBJbnN0ZWFkIG9mIHBhc3NpbmcgYW4gZWxlbWVudCBzdHJpbmcsIG1ha2Ugc3VyZSB0byBpbnN0YW50aWF0ZSAnICsgJ2l0IGJ5IHBhc3NpbmcgaXQgdG8gUmVhY3QuY3JlYXRlRWxlbWVudC4nIDogdHlwZW9mIG5leHRFbGVtZW50ID09PSAnZnVuY3Rpb24nID8gJyBJbnN0ZWFkIG9mIHBhc3NpbmcgYSBjb21wb25lbnQgY2xhc3MsIG1ha2Ugc3VyZSB0byBpbnN0YW50aWF0ZSAnICsgJ2l0IGJ5IHBhc3NpbmcgaXQgdG8gUmVhY3QuY3JlYXRlRWxlbWVudC4nIDpcbiAgICAvLyBDaGVjayBpZiBpdCBxdWFja3MgbGlrZSBhbiBlbGVtZW50XG4gICAgbmV4dEVsZW1lbnQgIT0gbnVsbCAmJiBuZXh0RWxlbWVudC5wcm9wcyAhPT0gdW5kZWZpbmVkID8gJyBUaGlzIG1heSBiZSBjYXVzZWQgYnkgdW5pbnRlbnRpb25hbGx5IGxvYWRpbmcgdHdvIGluZGVwZW5kZW50ICcgKyAnY29waWVzIG9mIFJlYWN0LicgOiAnJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWNvbnRhaW5lciB8fCAhY29udGFpbmVyLnRhZ05hbWUgfHwgY29udGFpbmVyLnRhZ05hbWUudG9VcHBlckNhc2UoKSAhPT0gJ0JPRFknLCAncmVuZGVyKCk6IFJlbmRlcmluZyBjb21wb25lbnRzIGRpcmVjdGx5IGludG8gZG9jdW1lbnQuYm9keSBpcyAnICsgJ2Rpc2NvdXJhZ2VkLCBzaW5jZSBpdHMgY2hpbGRyZW4gYXJlIG9mdGVuIG1hbmlwdWxhdGVkIGJ5IHRoaXJkLXBhcnR5ICcgKyAnc2NyaXB0cyBhbmQgYnJvd3NlciBleHRlbnNpb25zLiBUaGlzIG1heSBsZWFkIHRvIHN1YnRsZSAnICsgJ3JlY29uY2lsaWF0aW9uIGlzc3Vlcy4gVHJ5IHJlbmRlcmluZyBpbnRvIGEgY29udGFpbmVyIGVsZW1lbnQgY3JlYXRlZCAnICsgJ2ZvciB5b3VyIGFwcC4nKSA6IHVuZGVmaW5lZDtcblxuICAgIHZhciBuZXh0V3JhcHBlZEVsZW1lbnQgPSBuZXcgUmVhY3RFbGVtZW50KFRvcExldmVsV3JhcHBlciwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbmV4dEVsZW1lbnQpO1xuXG4gICAgdmFyIHByZXZDb21wb25lbnQgPSBpbnN0YW5jZXNCeVJlYWN0Um9vdElEW2dldFJlYWN0Um9vdElEKGNvbnRhaW5lcildO1xuXG4gICAgaWYgKHByZXZDb21wb25lbnQpIHtcbiAgICAgIHZhciBwcmV2V3JhcHBlZEVsZW1lbnQgPSBwcmV2Q29tcG9uZW50Ll9jdXJyZW50RWxlbWVudDtcbiAgICAgIHZhciBwcmV2RWxlbWVudCA9IHByZXZXcmFwcGVkRWxlbWVudC5wcm9wcztcbiAgICAgIGlmIChzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpKSB7XG4gICAgICAgIHZhciBwdWJsaWNJbnN0ID0gcHJldkNvbXBvbmVudC5fcmVuZGVyZWRDb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICAgICAgdmFyIHVwZGF0ZWRDYWxsYmFjayA9IGNhbGxiYWNrICYmIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjYWxsYmFjay5jYWxsKHB1YmxpY0luc3QpO1xuICAgICAgICB9O1xuICAgICAgICBSZWFjdE1vdW50Ll91cGRhdGVSb290Q29tcG9uZW50KHByZXZDb21wb25lbnQsIG5leHRXcmFwcGVkRWxlbWVudCwgY29udGFpbmVyLCB1cGRhdGVkQ2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gcHVibGljSW5zdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFJlYWN0TW91bnQudW5tb3VudENvbXBvbmVudEF0Tm9kZShjb250YWluZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZWFjdFJvb3RFbGVtZW50ID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgdmFyIGNvbnRhaW5lckhhc1JlYWN0TWFya3VwID0gcmVhY3RSb290RWxlbWVudCAmJiAhIWludGVybmFsR2V0SUQocmVhY3RSb290RWxlbWVudCk7XG4gICAgdmFyIGNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkID0gaGFzTm9uUm9vdFJlYWN0Q2hpbGQoY29udGFpbmVyKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQsICdyZW5kZXIoLi4uKTogUmVwbGFjaW5nIFJlYWN0LXJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSBuZXcgcm9vdCAnICsgJ2NvbXBvbmVudC4gSWYgeW91IGludGVuZGVkIHRvIHVwZGF0ZSB0aGUgY2hpbGRyZW4gb2YgdGhpcyBub2RlLCAnICsgJ3lvdSBzaG91bGQgaW5zdGVhZCBoYXZlIHRoZSBleGlzdGluZyBjaGlsZHJlbiB1cGRhdGUgdGhlaXIgc3RhdGUgJyArICdhbmQgcmVuZGVyIHRoZSBuZXcgY29tcG9uZW50cyBpbnN0ZWFkIG9mIGNhbGxpbmcgUmVhY3RET00ucmVuZGVyLicpIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoIWNvbnRhaW5lckhhc1JlYWN0TWFya3VwIHx8IHJlYWN0Um9vdEVsZW1lbnQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgdmFyIHJvb3RFbGVtZW50U2libGluZyA9IHJlYWN0Um9vdEVsZW1lbnQ7XG4gICAgICAgIHdoaWxlIChyb290RWxlbWVudFNpYmxpbmcpIHtcbiAgICAgICAgICBpZiAoaW50ZXJuYWxHZXRJRChyb290RWxlbWVudFNpYmxpbmcpKSB7XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ3JlbmRlcigpOiBUYXJnZXQgbm9kZSBoYXMgbWFya3VwIHJlbmRlcmVkIGJ5IFJlYWN0LCBidXQgdGhlcmUgJyArICdhcmUgdW5yZWxhdGVkIG5vZGVzIGFzIHdlbGwuIFRoaXMgaXMgbW9zdCBjb21tb25seSBjYXVzZWQgYnkgJyArICd3aGl0ZS1zcGFjZSBpbnNlcnRlZCBhcm91bmQgc2VydmVyLXJlbmRlcmVkIG1hcmt1cC4nKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByb290RWxlbWVudFNpYmxpbmcgPSByb290RWxlbWVudFNpYmxpbmcubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2hvdWxkUmV1c2VNYXJrdXAgPSBjb250YWluZXJIYXNSZWFjdE1hcmt1cCAmJiAhcHJldkNvbXBvbmVudCAmJiAhY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQ7XG4gICAgdmFyIGNvbXBvbmVudCA9IFJlYWN0TW91bnQuX3JlbmRlck5ld1Jvb3RDb21wb25lbnQobmV4dFdyYXBwZWRFbGVtZW50LCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCBwYXJlbnRDb21wb25lbnQgIT0gbnVsbCA/IHBhcmVudENvbXBvbmVudC5fcmVhY3RJbnRlcm5hbEluc3RhbmNlLl9wcm9jZXNzQ2hpbGRDb250ZXh0KHBhcmVudENvbXBvbmVudC5fcmVhY3RJbnRlcm5hbEluc3RhbmNlLl9jb250ZXh0KSA6IGVtcHR5T2JqZWN0KS5fcmVuZGVyZWRDb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwoY29tcG9uZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgfSxcblxuICAvKipcbiAgICogUmVuZGVycyBhIFJlYWN0IGNvbXBvbmVudCBpbnRvIHRoZSBET00gaW4gdGhlIHN1cHBsaWVkIGBjb250YWluZXJgLlxuICAgKlxuICAgKiBJZiB0aGUgUmVhY3QgY29tcG9uZW50IHdhcyBwcmV2aW91c2x5IHJlbmRlcmVkIGludG8gYGNvbnRhaW5lcmAsIHRoaXMgd2lsbFxuICAgKiBwZXJmb3JtIGFuIHVwZGF0ZSBvbiBpdCBhbmQgb25seSBtdXRhdGUgdGhlIERPTSBhcyBuZWNlc3NhcnkgdG8gcmVmbGVjdCB0aGVcbiAgICogbGF0ZXN0IFJlYWN0IGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IENvbXBvbmVudCBlbGVtZW50IHRvIHJlbmRlci5cbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gcmVuZGVyIGludG8uXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0cmlnZ2VyZWQgb24gY29tcGxldGlvblxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gQ29tcG9uZW50IGluc3RhbmNlIHJlbmRlcmVkIGluIGBjb250YWluZXJgLlxuICAgKi9cbiAgcmVuZGVyOiBmdW5jdGlvbiAobmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gUmVhY3RNb3VudC5fcmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgbmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBjb250YWluZXIgbm9kZSBpbnRvIHdoaWNoIFJlYWN0IGNvbXBvbmVudHMgd2lsbCBiZSByZW5kZXJlZC5cbiAgICogVGhpcyBhbHNvIGNyZWF0ZXMgdGhlIFwicmVhY3RSb290XCIgSUQgdGhhdCB3aWxsIGJlIGFzc2lnbmVkIHRvIHRoZSBlbGVtZW50XG4gICAqIHJlbmRlcmVkIHdpdGhpbi5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gcmVnaXN0ZXIgYXMgYSBjb250YWluZXIuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFwicmVhY3RSb290XCIgSUQgb2YgZWxlbWVudHMgcmVuZGVyZWQgd2l0aGluLlxuICAgKi9cbiAgcmVnaXN0ZXJDb250YWluZXI6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICB2YXIgcmVhY3RSb290SUQgPSBnZXRSZWFjdFJvb3RJRChjb250YWluZXIpO1xuICAgIGlmIChyZWFjdFJvb3RJRCkge1xuICAgICAgLy8gSWYgb25lIGV4aXN0cywgbWFrZSBzdXJlIGl0IGlzIGEgdmFsaWQgXCJyZWFjdFJvb3RcIiBJRC5cbiAgICAgIHJlYWN0Um9vdElEID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuZ2V0UmVhY3RSb290SURGcm9tTm9kZUlEKHJlYWN0Um9vdElEKTtcbiAgICB9XG4gICAgaWYgKCFyZWFjdFJvb3RJRCkge1xuICAgICAgLy8gTm8gdmFsaWQgXCJyZWFjdFJvb3RcIiBJRCBmb3VuZCwgY3JlYXRlIG9uZS5cbiAgICAgIHJlYWN0Um9vdElEID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuY3JlYXRlUmVhY3RSb290SUQoKTtcbiAgICB9XG4gICAgY29udGFpbmVyc0J5UmVhY3RSb290SURbcmVhY3RSb290SURdID0gY29udGFpbmVyO1xuICAgIHJldHVybiByZWFjdFJvb3RJRDtcbiAgfSxcblxuICAvKipcbiAgICogVW5tb3VudHMgYW5kIGRlc3Ryb3lzIHRoZSBSZWFjdCBjb21wb25lbnQgcmVuZGVyZWQgaW4gdGhlIGBjb250YWluZXJgLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCBjb250YWluaW5nIGEgUmVhY3QgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGEgY29tcG9uZW50IHdhcyBmb3VuZCBpbiBhbmQgdW5tb3VudGVkIGZyb21cbiAgICogICAgICAgICAgICAgICAgICAgYGNvbnRhaW5lcmBcbiAgICovXG4gIHVubW91bnRDb21wb25lbnRBdE5vZGU6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAvLyBWYXJpb3VzIHBhcnRzIG9mIG91ciBjb2RlIChzdWNoIGFzIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50J3NcbiAgICAvLyBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KSBhc3N1bWUgdGhhdCBjYWxscyB0byByZW5kZXIgYXJlbid0IG5lc3RlZDtcbiAgICAvLyB2ZXJpZnkgdGhhdCB0aGF0J3MgdGhlIGNhc2UuIChTdHJpY3RseSBzcGVha2luZywgdW5tb3VudGluZyB3b24ndCBjYXVzZSBhXG4gICAgLy8gcmVuZGVyIGJ1dCB3ZSBzdGlsbCBkb24ndCBleHBlY3QgdG8gYmUgaW4gYSByZW5kZXIgY2FsbCBoZXJlLilcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID09IG51bGwsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gJyArICdvZiBwcm9wcyBhbmQgc3RhdGU7IHRyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gcmVuZGVyICcgKyAnaXMgbm90IGFsbG93ZWQuIElmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZS4gQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJXMuJywgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcblxuICAgICEoY29udGFpbmVyICYmIChjb250YWluZXIubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERV9UWVBFIHx8IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSB8fCBjb250YWluZXIubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3VubW91bnRDb21wb25lbnRBdE5vZGUoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgcmVhY3RSb290SUQgPSBnZXRSZWFjdFJvb3RJRChjb250YWluZXIpO1xuICAgIHZhciBjb21wb25lbnQgPSBpbnN0YW5jZXNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXTtcbiAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhlIG5vZGUgYmVpbmcgdW5tb3VudGVkIHdhcyByZW5kZXJlZCBieSBSZWFjdCwgYnV0IGlzbid0IGFcbiAgICAgIC8vIHJvb3Qgbm9kZS5cbiAgICAgIHZhciBjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCA9IGhhc05vblJvb3RSZWFjdENoaWxkKGNvbnRhaW5lcik7XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBjb250YWluZXIgaXRzZWxmIGlzIGEgUmVhY3Qgcm9vdCBub2RlLlxuICAgICAgdmFyIGNvbnRhaW5lcklEID0gaW50ZXJuYWxHZXRJRChjb250YWluZXIpO1xuICAgICAgdmFyIGlzQ29udGFpbmVyUmVhY3RSb290ID0gY29udGFpbmVySUQgJiYgY29udGFpbmVySUQgPT09IFJlYWN0SW5zdGFuY2VIYW5kbGVzLmdldFJlYWN0Um9vdElERnJvbU5vZGVJRChjb250YWluZXJJRCk7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCwgJ3VubW91bnRDb21wb25lbnRBdE5vZGUoKTogVGhlIG5vZGUgeW91XFwncmUgYXR0ZW1wdGluZyB0byB1bm1vdW50ICcgKyAnd2FzIHJlbmRlcmVkIGJ5IFJlYWN0IGFuZCBpcyBub3QgYSB0b3AtbGV2ZWwgY29udGFpbmVyLiAlcycsIGlzQ29udGFpbmVyUmVhY3RSb290ID8gJ1lvdSBtYXkgaGF2ZSBhY2NpZGVudGFsbHkgcGFzc2VkIGluIGEgUmVhY3Qgcm9vdCBub2RlIGluc3RlYWQgJyArICdvZiBpdHMgY29udGFpbmVyLicgOiAnSW5zdGVhZCwgaGF2ZSB0aGUgcGFyZW50IGNvbXBvbmVudCB1cGRhdGUgaXRzIHN0YXRlIGFuZCAnICsgJ3JlcmVuZGVyIGluIG9yZGVyIHRvIHJlbW92ZSB0aGlzIGNvbXBvbmVudC4nKSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXModW5tb3VudENvbXBvbmVudEZyb21Ob2RlLCBjb21wb25lbnQsIGNvbnRhaW5lcik7XG4gICAgZGVsZXRlIGluc3RhbmNlc0J5UmVhY3RSb290SURbcmVhY3RSb290SURdO1xuICAgIGRlbGV0ZSBjb250YWluZXJzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGRlbGV0ZSByb290RWxlbWVudHNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBjb250YWluZXIgRE9NIGVsZW1lbnQgdGhhdCBjb250YWlucyBSZWFjdCBjb21wb25lbnQgdG8gd2hpY2ggdGhlXG4gICAqIHN1cHBsaWVkIERPTSBgaWRgIGJlbG9uZ3MuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgSUQgb2YgYW4gZWxlbWVudCByZW5kZXJlZCBieSBhIFJlYWN0IGNvbXBvbmVudC5cbiAgICogQHJldHVybiB7P0RPTUVsZW1lbnR9IERPTSBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIGBpZGAuXG4gICAqL1xuICBmaW5kUmVhY3RDb250YWluZXJGb3JJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIHJlYWN0Um9vdElEID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuZ2V0UmVhY3RSb290SURGcm9tTm9kZUlEKGlkKTtcbiAgICB2YXIgY29udGFpbmVyID0gY29udGFpbmVyc0J5UmVhY3RSb290SURbcmVhY3RSb290SURdO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciByb290RWxlbWVudCA9IHJvb3RFbGVtZW50c0J5UmVhY3RSb290SURbcmVhY3RSb290SURdO1xuICAgICAgaWYgKHJvb3RFbGVtZW50ICYmIHJvb3RFbGVtZW50LnBhcmVudE5vZGUgIT09IGNvbnRhaW5lcikge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhcbiAgICAgICAgLy8gQ2FsbCBpbnRlcm5hbEdldElEIGhlcmUgYmVjYXVzZSBnZXRJRCBjYWxscyBpc1ZhbGlkIHdoaWNoIGNhbGxzXG4gICAgICAgIC8vIGZpbmRSZWFjdENvbnRhaW5lckZvcklEICh0aGlzIGZ1bmN0aW9uKS5cbiAgICAgICAgaW50ZXJuYWxHZXRJRChyb290RWxlbWVudCkgPT09IHJlYWN0Um9vdElELCAnUmVhY3RNb3VudDogUm9vdCBlbGVtZW50IElEIGRpZmZlcmVkIGZyb20gcmVhY3RSb290SUQuJykgOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBjb250YWluZXJDaGlsZCA9IGNvbnRhaW5lci5maXJzdENoaWxkO1xuICAgICAgICBpZiAoY29udGFpbmVyQ2hpbGQgJiYgcmVhY3RSb290SUQgPT09IGludGVybmFsR2V0SUQoY29udGFpbmVyQ2hpbGQpKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGNvbnRhaW5lciBoYXMgYSBuZXcgY2hpbGQgd2l0aCB0aGUgc2FtZSBJRCBhcyB0aGUgb2xkXG4gICAgICAgICAgLy8gcm9vdCBlbGVtZW50LCB0aGVuIHJvb3RFbGVtZW50c0J5UmVhY3RSb290SURbcmVhY3RSb290SURdIGlzXG4gICAgICAgICAgLy8ganVzdCBzdGFsZSBhbmQgbmVlZHMgdG8gYmUgdXBkYXRlZC4gVGhlIGNhc2UgdGhhdCBkZXNlcnZlcyBhXG4gICAgICAgICAgLy8gd2FybmluZyBpcyB3aGVuIHRoZSBjb250YWluZXIgaXMgZW1wdHkuXG4gICAgICAgICAgcm9vdEVsZW1lbnRzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF0gPSBjb250YWluZXJDaGlsZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1JlYWN0TW91bnQ6IFJvb3QgZWxlbWVudCBoYXMgYmVlbiByZW1vdmVkIGZyb20gaXRzIG9yaWdpbmFsICcgKyAnY29udGFpbmVyLiBOZXcgY29udGFpbmVyOiAlcycsIHJvb3RFbGVtZW50LnBhcmVudE5vZGUpIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfSxcblxuICAvKipcbiAgICogRmluZHMgYW4gZWxlbWVudCByZW5kZXJlZCBieSBSZWFjdCB3aXRoIHRoZSBzdXBwbGllZCBJRC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIGEgRE9NIG5vZGUgaW4gdGhlIFJlYWN0IGNvbXBvbmVudC5cbiAgICogQHJldHVybiB7RE9NRWxlbWVudH0gUm9vdCBET00gbm9kZSBvZiB0aGUgUmVhY3QgY29tcG9uZW50LlxuICAgKi9cbiAgZmluZFJlYWN0Tm9kZUJ5SUQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciByZWFjdFJvb3QgPSBSZWFjdE1vdW50LmZpbmRSZWFjdENvbnRhaW5lckZvcklEKGlkKTtcbiAgICByZXR1cm4gUmVhY3RNb3VudC5maW5kQ29tcG9uZW50Um9vdChyZWFjdFJvb3QsIGlkKTtcbiAgfSxcblxuICAvKipcbiAgICogVHJhdmVyc2VzIHVwIHRoZSBhbmNlc3RvcnMgb2YgdGhlIHN1cHBsaWVkIG5vZGUgdG8gZmluZCBhIG5vZGUgdGhhdCBpcyBhXG4gICAqIERPTSByZXByZXNlbnRhdGlvbiBvZiBhIFJlYWN0IGNvbXBvbmVudCByZW5kZXJlZCBieSB0aGlzIGNvcHkgb2YgUmVhY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gbm9kZVxuICAgKiBAcmV0dXJuIHs/RE9NRXZlbnRUYXJnZXR9XG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0Rmlyc3RSZWFjdERPTTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gZmluZEZpcnN0UmVhY3RET01JbXBsKG5vZGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaW5kcyBhIG5vZGUgd2l0aCB0aGUgc3VwcGxpZWQgYHRhcmdldElEYCBpbnNpZGUgb2YgdGhlIHN1cHBsaWVkXG4gICAqIGBhbmNlc3Rvck5vZGVgLiAgRXhwbG9pdHMgdGhlIElEIG5hbWluZyBzY2hlbWUgdG8gcGVyZm9ybSB0aGUgc2VhcmNoXG4gICAqIHF1aWNrbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IGFuY2VzdG9yTm9kZSBTZWFyY2ggZnJvbSB0aGlzIHJvb3QuXG4gICAqIEBwYXJhcm0ge3N0cmluZ30gdGFyZ2V0SUQgSUQgb2YgdGhlIERPTSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHtET01FdmVudFRhcmdldH0gRE9NIG5vZGUgd2l0aCB0aGUgc3VwcGxpZWQgYHRhcmdldElEYC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBmaW5kQ29tcG9uZW50Um9vdDogZnVuY3Rpb24gKGFuY2VzdG9yTm9kZSwgdGFyZ2V0SUQpIHtcbiAgICB2YXIgZmlyc3RDaGlsZHJlbiA9IGZpbmRDb21wb25lbnRSb290UmV1c2FibGVBcnJheTtcbiAgICB2YXIgY2hpbGRJbmRleCA9IDA7XG5cbiAgICB2YXIgZGVlcGVzdEFuY2VzdG9yID0gZmluZERlZXBlc3RDYWNoZWRBbmNlc3Rvcih0YXJnZXRJRCkgfHwgYW5jZXN0b3JOb2RlO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBvbiB0aGUgbmV4dCBsaW5lOyBnaXZlIGFuIGVhcmx5IHdhcm5pbmdcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGRlZXBlc3RBbmNlc3RvciAhPSBudWxsLCAnUmVhY3QgY2FuXFwndCBmaW5kIHRoZSByb290IGNvbXBvbmVudCBub2RlIGZvciBkYXRhLXJlYWN0aWQgdmFsdWUgJyArICdgJXNgLiBJZiB5b3VcXCdyZSBzZWVpbmcgdGhpcyBtZXNzYWdlLCBpdCBwcm9iYWJseSBtZWFucyB0aGF0ICcgKyAneW91XFwndmUgbG9hZGVkIHR3byBjb3BpZXMgb2YgUmVhY3Qgb24gdGhlIHBhZ2UuIEF0IHRoaXMgdGltZSwgb25seSAnICsgJ2Egc2luZ2xlIGNvcHkgb2YgUmVhY3QgY2FuIGJlIGxvYWRlZCBhdCBhIHRpbWUuJywgdGFyZ2V0SUQpIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGZpcnN0Q2hpbGRyZW5bMF0gPSBkZWVwZXN0QW5jZXN0b3IuZmlyc3RDaGlsZDtcbiAgICBmaXJzdENoaWxkcmVuLmxlbmd0aCA9IDE7XG5cbiAgICB3aGlsZSAoY2hpbGRJbmRleCA8IGZpcnN0Q2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICB2YXIgY2hpbGQgPSBmaXJzdENoaWxkcmVuW2NoaWxkSW5kZXgrK107XG4gICAgICB2YXIgdGFyZ2V0Q2hpbGQ7XG5cbiAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICB2YXIgY2hpbGRJRCA9IFJlYWN0TW91bnQuZ2V0SUQoY2hpbGQpO1xuICAgICAgICBpZiAoY2hpbGRJRCkge1xuICAgICAgICAgIC8vIEV2ZW4gaWYgd2UgZmluZCB0aGUgbm9kZSB3ZSdyZSBsb29raW5nIGZvciwgd2UgZmluaXNoIGxvb3BpbmdcbiAgICAgICAgICAvLyB0aHJvdWdoIGl0cyBzaWJsaW5ncyB0byBlbnN1cmUgdGhleSdyZSBjYWNoZWQgc28gdGhhdCB3ZSBkb24ndCBoYXZlXG4gICAgICAgICAgLy8gdG8gcmV2aXNpdCB0aGlzIG5vZGUgYWdhaW4uIE90aGVyd2lzZSwgd2UgbWFrZSBuXjIgY2FsbHMgdG8gZ2V0SURcbiAgICAgICAgICAvLyB3aGVuIHZpc2l0aW5nIHRoZSBtYW55IGNoaWxkcmVuIG9mIGEgc2luZ2xlIG5vZGUgaW4gb3JkZXIuXG5cbiAgICAgICAgICBpZiAodGFyZ2V0SUQgPT09IGNoaWxkSUQpIHtcbiAgICAgICAgICAgIHRhcmdldENoaWxkID0gY2hpbGQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChSZWFjdEluc3RhbmNlSGFuZGxlcy5pc0FuY2VzdG9ySURPZihjaGlsZElELCB0YXJnZXRJRCkpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGZpbmQgYSBjaGlsZCB3aG9zZSBJRCBpcyBhbiBhbmNlc3RvciBvZiB0aGUgZ2l2ZW4gSUQsXG4gICAgICAgICAgICAvLyB0aGVuIHdlIGNhbiBiZSBzdXJlIHRoYXQgd2Ugb25seSB3YW50IHRvIHNlYXJjaCB0aGUgc3VidHJlZVxuICAgICAgICAgICAgLy8gcm9vdGVkIGF0IHRoaXMgY2hpbGQsIHNvIHdlIGNhbiB0aHJvdyBvdXQgdGhlIHJlc3Qgb2YgdGhlXG4gICAgICAgICAgICAvLyBzZWFyY2ggc3RhdGUuXG4gICAgICAgICAgICBmaXJzdENoaWxkcmVuLmxlbmd0aCA9IGNoaWxkSW5kZXggPSAwO1xuICAgICAgICAgICAgZmlyc3RDaGlsZHJlbi5wdXNoKGNoaWxkLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIGNoaWxkIGhhZCBubyBJRCwgdGhlbiB0aGVyZSdzIGEgY2hhbmNlIHRoYXQgaXQgd2FzXG4gICAgICAgICAgLy8gaW5qZWN0ZWQgYXV0b21hdGljYWxseSBieSB0aGUgYnJvd3NlciwgYXMgd2hlbiBhIGA8dGFibGU+YFxuICAgICAgICAgIC8vIGVsZW1lbnQgc3Byb3V0cyBhbiBleHRyYSBgPHRib2R5PmAgY2hpbGQgYXMgYSBzaWRlIGVmZmVjdCBvZlxuICAgICAgICAgIC8vIGAuaW5uZXJIVE1MYCBwYXJzaW5nLiBPcHRpbWlzdGljYWxseSBjb250aW51ZSBkb3duIHRoaXNcbiAgICAgICAgICAvLyBicmFuY2gsIGJ1dCBub3QgYmVmb3JlIGV4YW1pbmluZyB0aGUgb3RoZXIgc2libGluZ3MuXG4gICAgICAgICAgZmlyc3RDaGlsZHJlbi5wdXNoKGNoaWxkLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcbiAgICAgIH1cblxuICAgICAgaWYgKHRhcmdldENoaWxkKSB7XG4gICAgICAgIC8vIEVtcHR5aW5nIGZpcnN0Q2hpbGRyZW4vZmluZENvbXBvbmVudFJvb3RSZXVzYWJsZUFycmF5IGlzXG4gICAgICAgIC8vIG5vdCBuZWNlc3NhcnkgZm9yIGNvcnJlY3RuZXNzLCBidXQgaXQgaGVscHMgdGhlIEdDIHJlY2xhaW1cbiAgICAgICAgLy8gYW55IG5vZGVzIHRoYXQgd2VyZSBsZWZ0IGF0IHRoZSBlbmQgb2YgdGhlIHNlYXJjaC5cbiAgICAgICAgZmlyc3RDaGlsZHJlbi5sZW5ndGggPSAwO1xuXG4gICAgICAgIHJldHVybiB0YXJnZXRDaGlsZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmaXJzdENoaWxkcmVuLmxlbmd0aCA9IDA7XG5cbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZmluZENvbXBvbmVudFJvb3QoLi4uLCAlcyk6IFVuYWJsZSB0byBmaW5kIGVsZW1lbnQuIFRoaXMgcHJvYmFibHkgJyArICdtZWFucyB0aGUgRE9NIHdhcyB1bmV4cGVjdGVkbHkgbXV0YXRlZCAoZS5nLiwgYnkgdGhlIGJyb3dzZXIpLCAnICsgJ3VzdWFsbHkgZHVlIHRvIGZvcmdldHRpbmcgYSA8dGJvZHk+IHdoZW4gdXNpbmcgdGFibGVzLCBuZXN0aW5nIHRhZ3MgJyArICdsaWtlIDxmb3JtPiwgPHA+LCBvciA8YT4sIG9yIHVzaW5nIG5vbi1TVkcgZWxlbWVudHMgaW4gYW4gPHN2Zz4gJyArICdwYXJlbnQuICcgKyAnVHJ5IGluc3BlY3RpbmcgdGhlIGNoaWxkIG5vZGVzIG9mIHRoZSBlbGVtZW50IHdpdGggUmVhY3QgSUQgYCVzYC4nLCB0YXJnZXRJRCwgUmVhY3RNb3VudC5nZXRJRChhbmNlc3Rvck5vZGUpKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIH0sXG5cbiAgX21vdW50SW1hZ2VJbnRvTm9kZTogZnVuY3Rpb24gKG1hcmt1cCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgdHJhbnNhY3Rpb24pIHtcbiAgICAhKGNvbnRhaW5lciAmJiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSB8fCBjb250YWluZXIubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUgfHwgY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdtb3VudENvbXBvbmVudEludG9Ob2RlKC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IHZhbGlkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChzaG91bGRSZXVzZU1hcmt1cCkge1xuICAgICAgdmFyIHJvb3RFbGVtZW50ID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICBpZiAoUmVhY3RNYXJrdXBDaGVja3N1bS5jYW5SZXVzZU1hcmt1cChtYXJrdXAsIHJvb3RFbGVtZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY2hlY2tzdW0gPSByb290RWxlbWVudC5nZXRBdHRyaWJ1dGUoUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUpO1xuICAgICAgICByb290RWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUpO1xuXG4gICAgICAgIHZhciByb290TWFya3VwID0gcm9vdEVsZW1lbnQub3V0ZXJIVE1MO1xuICAgICAgICByb290RWxlbWVudC5zZXRBdHRyaWJ1dGUoUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUsIGNoZWNrc3VtKTtcblxuICAgICAgICB2YXIgbm9ybWFsaXplZE1hcmt1cCA9IG1hcmt1cDtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAvLyBiZWNhdXNlIHJvb3RNYXJrdXAgaXMgcmV0cmlldmVkIGZyb20gdGhlIERPTSwgdmFyaW91cyBub3JtYWxpemF0aW9uc1xuICAgICAgICAgIC8vIHdpbGwgaGF2ZSBvY2N1cnJlZCB3aGljaCB3aWxsIG5vdCBiZSBwcmVzZW50IGluIGBtYXJrdXBgLiBIZXJlLFxuICAgICAgICAgIC8vIGluc2VydCBtYXJrdXAgaW50byBhIDxkaXY+IG9yIDxpZnJhbWU+IGRlcGVuZGluZyBvbiB0aGUgY29udGFpbmVyXG4gICAgICAgICAgLy8gdHlwZSB0byBwZXJmb3JtIHRoZSBzYW1lIG5vcm1hbGl6YXRpb25zIGJlZm9yZSBjb21wYXJpbmcuXG4gICAgICAgICAgdmFyIG5vcm1hbGl6ZXI7XG4gICAgICAgICAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZXIuaW5uZXJIVE1MID0gbWFya3VwO1xuICAgICAgICAgICAgbm9ybWFsaXplZE1hcmt1cCA9IG5vcm1hbGl6ZXIuaW5uZXJIVE1MO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub3JtYWxpemVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG5vcm1hbGl6ZXIpO1xuICAgICAgICAgICAgbm9ybWFsaXplci5jb250ZW50RG9jdW1lbnQud3JpdGUobWFya3VwKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRNYXJrdXAgPSBub3JtYWxpemVyLmNvbnRlbnREb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub3V0ZXJIVE1MO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChub3JtYWxpemVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGlmZkluZGV4ID0gZmlyc3REaWZmZXJlbmNlSW5kZXgobm9ybWFsaXplZE1hcmt1cCwgcm9vdE1hcmt1cCk7XG4gICAgICAgIHZhciBkaWZmZXJlbmNlID0gJyAoY2xpZW50KSAnICsgbm9ybWFsaXplZE1hcmt1cC5zdWJzdHJpbmcoZGlmZkluZGV4IC0gMjAsIGRpZmZJbmRleCArIDIwKSArICdcXG4gKHNlcnZlcikgJyArIHJvb3RNYXJrdXAuc3Vic3RyaW5nKGRpZmZJbmRleCAtIDIwLCBkaWZmSW5kZXggKyAyMCk7XG5cbiAgICAgICAgIShjb250YWluZXIubm9kZVR5cGUgIT09IERPQ19OT0RFX1RZUEUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1lvdVxcJ3JlIHRyeWluZyB0byByZW5kZXIgYSBjb21wb25lbnQgdG8gdGhlIGRvY3VtZW50IHVzaW5nICcgKyAnc2VydmVyIHJlbmRlcmluZyBidXQgdGhlIGNoZWNrc3VtIHdhcyBpbnZhbGlkLiBUaGlzIHVzdWFsbHkgJyArICdtZWFucyB5b3UgcmVuZGVyZWQgYSBkaWZmZXJlbnQgY29tcG9uZW50IHR5cGUgb3IgcHJvcHMgb24gJyArICd0aGUgY2xpZW50IGZyb20gdGhlIG9uZSBvbiB0aGUgc2VydmVyLCBvciB5b3VyIHJlbmRlcigpICcgKyAnbWV0aG9kcyBhcmUgaW1wdXJlLiBSZWFjdCBjYW5ub3QgaGFuZGxlIHRoaXMgY2FzZSBkdWUgdG8gJyArICdjcm9zcy1icm93c2VyIHF1aXJrcyBieSByZW5kZXJpbmcgYXQgdGhlIGRvY3VtZW50IHJvb3QuIFlvdSAnICsgJ3Nob3VsZCBsb29rIGZvciBlbnZpcm9ubWVudCBkZXBlbmRlbnQgY29kZSBpbiB5b3VyIGNvbXBvbmVudHMgJyArICdhbmQgZW5zdXJlIHRoZSBwcm9wcyBhcmUgdGhlIHNhbWUgY2xpZW50IGFuZCBzZXJ2ZXIgc2lkZTpcXG4lcycsIGRpZmZlcmVuY2UpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3QgYXR0ZW1wdGVkIHRvIHJldXNlIG1hcmt1cCBpbiBhIGNvbnRhaW5lciBidXQgdGhlICcgKyAnY2hlY2tzdW0gd2FzIGludmFsaWQuIFRoaXMgZ2VuZXJhbGx5IG1lYW5zIHRoYXQgeW91IGFyZSAnICsgJ3VzaW5nIHNlcnZlciByZW5kZXJpbmcgYW5kIHRoZSBtYXJrdXAgZ2VuZXJhdGVkIG9uIHRoZSAnICsgJ3NlcnZlciB3YXMgbm90IHdoYXQgdGhlIGNsaWVudCB3YXMgZXhwZWN0aW5nLiBSZWFjdCBpbmplY3RlZCAnICsgJ25ldyBtYXJrdXAgdG8gY29tcGVuc2F0ZSB3aGljaCB3b3JrcyBidXQgeW91IGhhdmUgbG9zdCBtYW55ICcgKyAnb2YgdGhlIGJlbmVmaXRzIG9mIHNlcnZlciByZW5kZXJpbmcuIEluc3RlYWQsIGZpZ3VyZSBvdXQgJyArICd3aHkgdGhlIG1hcmt1cCBiZWluZyBnZW5lcmF0ZWQgaXMgZGlmZmVyZW50IG9uIHRoZSBjbGllbnQgJyArICdvciBzZXJ2ZXI6XFxuJXMnLCBkaWZmZXJlbmNlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgICEoY29udGFpbmVyLm5vZGVUeXBlICE9PSBET0NfTk9ERV9UWVBFKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdZb3VcXCdyZSB0cnlpbmcgdG8gcmVuZGVyIGEgY29tcG9uZW50IHRvIHRoZSBkb2N1bWVudCBidXQgJyArICd5b3UgZGlkblxcJ3QgdXNlIHNlcnZlciByZW5kZXJpbmcuIFdlIGNhblxcJ3QgZG8gdGhpcyAnICsgJ3dpdGhvdXQgdXNpbmcgc2VydmVyIHJlbmRlcmluZyBkdWUgdG8gY3Jvc3MtYnJvd3NlciBxdWlya3MuICcgKyAnU2VlIFJlYWN0RE9NU2VydmVyLnJlbmRlclRvU3RyaW5nKCkgZm9yIHNlcnZlciByZW5kZXJpbmcuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKHRyYW5zYWN0aW9uLnVzZUNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIHdoaWxlIChjb250YWluZXIubGFzdENoaWxkKSB7XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjb250YWluZXIubGFzdENoaWxkKTtcbiAgICAgIH1cbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChtYXJrdXApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRJbm5lckhUTUwoY29udGFpbmVyLCBtYXJrdXApO1xuICAgIH1cbiAgfSxcblxuICBvd25lckRvY3VtZW50Q29udGV4dEtleTogb3duZXJEb2N1bWVudENvbnRleHRLZXksXG5cbiAgLyoqXG4gICAqIFJlYWN0IElEIHV0aWxpdGllcy5cbiAgICovXG5cbiAgZ2V0UmVhY3RSb290SUQ6IGdldFJlYWN0Um9vdElELFxuXG4gIGdldElEOiBnZXRJRCxcblxuICBzZXRJRDogc2V0SUQsXG5cbiAgZ2V0Tm9kZTogZ2V0Tm9kZSxcblxuICBnZXROb2RlRnJvbUluc3RhbmNlOiBnZXROb2RlRnJvbUluc3RhbmNlLFxuXG4gIGlzVmFsaWQ6IGlzVmFsaWQsXG5cbiAgcHVyZ2VJRDogcHVyZ2VJRFxufTtcblxuUmVhY3RQZXJmLm1lYXN1cmVNZXRob2RzKFJlYWN0TW91bnQsICdSZWFjdE1vdW50Jywge1xuICBfcmVuZGVyTmV3Um9vdENvbXBvbmVudDogJ19yZW5kZXJOZXdSb290Q29tcG9uZW50JyxcbiAgX21vdW50SW1hZ2VJbnRvTm9kZTogJ19tb3VudEltYWdlSW50b05vZGUnXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE1vdW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RNb3VudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luSHViJyk7XG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5SZWdpc3RyeScpO1xudmFyIFJlYWN0RXZlbnRFbWl0dGVyTWl4aW4gPSByZXF1aXJlKCcuL1JlYWN0RXZlbnRFbWl0dGVyTWl4aW4nKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKCcuL1JlYWN0UGVyZicpO1xudmFyIFZpZXdwb3J0TWV0cmljcyA9IHJlcXVpcmUoJy4vVmlld3BvcnRNZXRyaWNzJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBpc0V2ZW50U3VwcG9ydGVkID0gcmVxdWlyZSgnLi9pc0V2ZW50U3VwcG9ydGVkJyk7XG5cbi8qKlxuICogU3VtbWFyeSBvZiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBldmVudCBoYW5kbGluZzpcbiAqXG4gKiAgLSBUb3AtbGV2ZWwgZGVsZWdhdGlvbiBpcyB1c2VkIHRvIHRyYXAgbW9zdCBuYXRpdmUgYnJvd3NlciBldmVudHMuIFRoaXNcbiAqICAgIG1heSBvbmx5IG9jY3VyIGluIHRoZSBtYWluIHRocmVhZCBhbmQgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mXG4gKiAgICBSZWFjdEV2ZW50TGlzdGVuZXIsIHdoaWNoIGlzIGluamVjdGVkIGFuZCBjYW4gdGhlcmVmb3JlIHN1cHBvcnQgcGx1Z2dhYmxlXG4gKiAgICBldmVudCBzb3VyY2VzLiBUaGlzIGlzIHRoZSBvbmx5IHdvcmsgdGhhdCBvY2N1cnMgaW4gdGhlIG1haW4gdGhyZWFkLlxuICpcbiAqICAtIFdlIG5vcm1hbGl6ZSBhbmQgZGUtZHVwbGljYXRlIGV2ZW50cyB0byBhY2NvdW50IGZvciBicm93c2VyIHF1aXJrcy4gVGhpc1xuICogICAgbWF5IGJlIGRvbmUgaW4gdGhlIHdvcmtlciB0aHJlYWQuXG4gKlxuICogIC0gRm9yd2FyZCB0aGVzZSBuYXRpdmUgZXZlbnRzICh3aXRoIHRoZSBhc3NvY2lhdGVkIHRvcC1sZXZlbCB0eXBlIHVzZWQgdG9cbiAqICAgIHRyYXAgaXQpIHRvIGBFdmVudFBsdWdpbkh1YmAsIHdoaWNoIGluIHR1cm4gd2lsbCBhc2sgcGx1Z2lucyBpZiB0aGV5IHdhbnRcbiAqICAgIHRvIGV4dHJhY3QgYW55IHN5bnRoZXRpYyBldmVudHMuXG4gKlxuICogIC0gVGhlIGBFdmVudFBsdWdpbkh1YmAgd2lsbCB0aGVuIHByb2Nlc3MgZWFjaCBldmVudCBieSBhbm5vdGF0aW5nIHRoZW0gd2l0aFxuICogICAgXCJkaXNwYXRjaGVzXCIsIGEgc2VxdWVuY2Ugb2YgbGlzdGVuZXJzIGFuZCBJRHMgdGhhdCBjYXJlIGFib3V0IHRoYXQgZXZlbnQuXG4gKlxuICogIC0gVGhlIGBFdmVudFBsdWdpbkh1YmAgdGhlbiBkaXNwYXRjaGVzIHRoZSBldmVudHMuXG4gKlxuICogT3ZlcnZpZXcgb2YgUmVhY3QgYW5kIHRoZSBldmVudCBzeXN0ZW06XG4gKlxuICogKy0tLS0tLS0tLS0tLSsgICAgLlxuICogfCAgICBET00gICAgIHwgICAgLlxuICogKy0tLS0tLS0tLS0tLSsgICAgLlxuICogICAgICAgfCAgICAgICAgICAgLlxuICogICAgICAgdiAgICAgICAgICAgLlxuICogKy0tLS0tLS0tLS0tLSsgICAgLlxuICogfCBSZWFjdEV2ZW50IHwgICAgLlxuICogfCAgTGlzdGVuZXIgIHwgICAgLlxuICogKy0tLS0tLS0tLS0tLSsgICAgLiAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgKy0tLS0tLS0tK3xTaW1wbGVFdmVudHxcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICB8ICAgICAgICAgfFBsdWdpbiAgICAgfFxuICogKy0tLS0tfC0tLS0tLSsgICAgLiAgICAgICAgICAgICAgIHYgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiB8ICAgICB8ICAgICAgfCAgICAuICAgICstLS0tLS0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0rXG4gKiB8ICAgICArLS0tLS0tLS0tLS0uLS0tPnxFdmVudFBsdWdpbkh1YnwgICAgICAgICAgICAgICAgICAgIHwgICAgRXZlbnQgICB8XG4gKiB8ICAgICAgICAgICAgfCAgICAuICAgIHwgICAgICAgICAgICAgIHwgICAgICstLS0tLS0tLS0tLSsgIHwgUHJvcGFnYXRvcnN8XG4gKiB8IFJlYWN0RXZlbnQgfCAgICAuICAgIHwgICAgICAgICAgICAgIHwgICAgIHxUYXBFdmVudCAgIHwgIHwtLS0tLS0tLS0tLS18XG4gKiB8ICBFbWl0dGVyICAgfCAgICAuICAgIHwgICAgICAgICAgICAgIHw8LS0tK3xQbHVnaW4gICAgIHwgIHxvdGhlciBwbHVnaW58XG4gKiB8ICAgICAgICAgICAgfCAgICAuICAgIHwgICAgICAgICAgICAgIHwgICAgICstLS0tLS0tLS0tLSsgIHwgIHV0aWxpdGllcyB8XG4gKiB8ICAgICArLS0tLS0tLS0tLS0uLS0tPnwgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0rXG4gKiB8ICAgICB8ICAgICAgfCAgICAuICAgICstLS0tLS0tLS0tLS0tLStcbiAqICstLS0tLXwtLS0tLS0rICAgIC4gICAgICAgICAgICAgICAgXiAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgICB8ICAgICAgICB8RW50ZXIvTGVhdmV8XG4gKiAgICAgICArICAgICAgICAgICAuICAgICAgICAgICAgICAgICstLS0tLS0tK3xQbHVnaW4gICAgIHxcbiAqICstLS0tLS0tLS0tLS0tKyAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogfCBhcHBsaWNhdGlvbiB8ICAgLlxuICogfC0tLS0tLS0tLS0tLS18ICAgLlxuICogfCAgICAgICAgICAgICB8ICAgLlxuICogfCAgICAgICAgICAgICB8ICAgLlxuICogKy0tLS0tLS0tLS0tLS0rICAgLlxuICogICAgICAgICAgICAgICAgICAgLlxuICogICAgUmVhY3QgQ29yZSAgICAgLiAgR2VuZXJhbCBQdXJwb3NlIEV2ZW50IFBsdWdpbiBTeXN0ZW1cbiAqL1xuXG52YXIgYWxyZWFkeUxpc3RlbmluZ1RvID0ge307XG52YXIgaXNNb25pdG9yaW5nU2Nyb2xsVmFsdWUgPSBmYWxzZTtcbnZhciByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIgPSAwO1xuXG4vLyBGb3IgZXZlbnRzIGxpa2UgJ3N1Ym1pdCcgd2hpY2ggZG9uJ3QgY29uc2lzdGVudGx5IGJ1YmJsZSAod2hpY2ggd2UgdHJhcCBhdCBhXG4vLyBsb3dlciBub2RlIHRoYW4gYGRvY3VtZW50YCksIGJpbmRpbmcgYXQgYGRvY3VtZW50YCB3b3VsZCBjYXVzZSBkdXBsaWNhdGVcbi8vIGV2ZW50cyBzbyB3ZSBkb24ndCBpbmNsdWRlIHRoZW0gaGVyZVxudmFyIHRvcEV2ZW50TWFwcGluZyA9IHtcbiAgdG9wQWJvcnQ6ICdhYm9ydCcsXG4gIHRvcEJsdXI6ICdibHVyJyxcbiAgdG9wQ2FuUGxheTogJ2NhbnBsYXknLFxuICB0b3BDYW5QbGF5VGhyb3VnaDogJ2NhbnBsYXl0aHJvdWdoJyxcbiAgdG9wQ2hhbmdlOiAnY2hhbmdlJyxcbiAgdG9wQ2xpY2s6ICdjbGljaycsXG4gIHRvcENvbXBvc2l0aW9uRW5kOiAnY29tcG9zaXRpb25lbmQnLFxuICB0b3BDb21wb3NpdGlvblN0YXJ0OiAnY29tcG9zaXRpb25zdGFydCcsXG4gIHRvcENvbXBvc2l0aW9uVXBkYXRlOiAnY29tcG9zaXRpb251cGRhdGUnLFxuICB0b3BDb250ZXh0TWVudTogJ2NvbnRleHRtZW51JyxcbiAgdG9wQ29weTogJ2NvcHknLFxuICB0b3BDdXQ6ICdjdXQnLFxuICB0b3BEb3VibGVDbGljazogJ2RibGNsaWNrJyxcbiAgdG9wRHJhZzogJ2RyYWcnLFxuICB0b3BEcmFnRW5kOiAnZHJhZ2VuZCcsXG4gIHRvcERyYWdFbnRlcjogJ2RyYWdlbnRlcicsXG4gIHRvcERyYWdFeGl0OiAnZHJhZ2V4aXQnLFxuICB0b3BEcmFnTGVhdmU6ICdkcmFnbGVhdmUnLFxuICB0b3BEcmFnT3ZlcjogJ2RyYWdvdmVyJyxcbiAgdG9wRHJhZ1N0YXJ0OiAnZHJhZ3N0YXJ0JyxcbiAgdG9wRHJvcDogJ2Ryb3AnLFxuICB0b3BEdXJhdGlvbkNoYW5nZTogJ2R1cmF0aW9uY2hhbmdlJyxcbiAgdG9wRW1wdGllZDogJ2VtcHRpZWQnLFxuICB0b3BFbmNyeXB0ZWQ6ICdlbmNyeXB0ZWQnLFxuICB0b3BFbmRlZDogJ2VuZGVkJyxcbiAgdG9wRXJyb3I6ICdlcnJvcicsXG4gIHRvcEZvY3VzOiAnZm9jdXMnLFxuICB0b3BJbnB1dDogJ2lucHV0JyxcbiAgdG9wS2V5RG93bjogJ2tleWRvd24nLFxuICB0b3BLZXlQcmVzczogJ2tleXByZXNzJyxcbiAgdG9wS2V5VXA6ICdrZXl1cCcsXG4gIHRvcExvYWRlZERhdGE6ICdsb2FkZWRkYXRhJyxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6ICdsb2FkZWRtZXRhZGF0YScsXG4gIHRvcExvYWRTdGFydDogJ2xvYWRzdGFydCcsXG4gIHRvcE1vdXNlRG93bjogJ21vdXNlZG93bicsXG4gIHRvcE1vdXNlTW92ZTogJ21vdXNlbW92ZScsXG4gIHRvcE1vdXNlT3V0OiAnbW91c2VvdXQnLFxuICB0b3BNb3VzZU92ZXI6ICdtb3VzZW92ZXInLFxuICB0b3BNb3VzZVVwOiAnbW91c2V1cCcsXG4gIHRvcFBhc3RlOiAncGFzdGUnLFxuICB0b3BQYXVzZTogJ3BhdXNlJyxcbiAgdG9wUGxheTogJ3BsYXknLFxuICB0b3BQbGF5aW5nOiAncGxheWluZycsXG4gIHRvcFByb2dyZXNzOiAncHJvZ3Jlc3MnLFxuICB0b3BSYXRlQ2hhbmdlOiAncmF0ZWNoYW5nZScsXG4gIHRvcFNjcm9sbDogJ3Njcm9sbCcsXG4gIHRvcFNlZWtlZDogJ3NlZWtlZCcsXG4gIHRvcFNlZWtpbmc6ICdzZWVraW5nJyxcbiAgdG9wU2VsZWN0aW9uQ2hhbmdlOiAnc2VsZWN0aW9uY2hhbmdlJyxcbiAgdG9wU3RhbGxlZDogJ3N0YWxsZWQnLFxuICB0b3BTdXNwZW5kOiAnc3VzcGVuZCcsXG4gIHRvcFRleHRJbnB1dDogJ3RleHRJbnB1dCcsXG4gIHRvcFRpbWVVcGRhdGU6ICd0aW1ldXBkYXRlJyxcbiAgdG9wVG91Y2hDYW5jZWw6ICd0b3VjaGNhbmNlbCcsXG4gIHRvcFRvdWNoRW5kOiAndG91Y2hlbmQnLFxuICB0b3BUb3VjaE1vdmU6ICd0b3VjaG1vdmUnLFxuICB0b3BUb3VjaFN0YXJ0OiAndG91Y2hzdGFydCcsXG4gIHRvcFZvbHVtZUNoYW5nZTogJ3ZvbHVtZWNoYW5nZScsXG4gIHRvcFdhaXRpbmc6ICd3YWl0aW5nJyxcbiAgdG9wV2hlZWw6ICd3aGVlbCdcbn07XG5cbi8qKlxuICogVG8gZW5zdXJlIG5vIGNvbmZsaWN0cyB3aXRoIG90aGVyIHBvdGVudGlhbCBSZWFjdCBpbnN0YW5jZXMgb24gdGhlIHBhZ2VcbiAqL1xudmFyIHRvcExpc3RlbmVyc0lES2V5ID0gJ19yZWFjdExpc3RlbmVyc0lEJyArIFN0cmluZyhNYXRoLnJhbmRvbSgpKS5zbGljZSgyKTtcblxuZnVuY3Rpb24gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCkge1xuICAvLyBJbiBJRTgsIGBtb3VudEF0YCBpcyBhIGhvc3Qgb2JqZWN0IGFuZCBkb2Vzbid0IGhhdmUgYGhhc093blByb3BlcnR5YFxuICAvLyBkaXJlY3RseS5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW91bnRBdCwgdG9wTGlzdGVuZXJzSURLZXkpKSB7XG4gICAgbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV0gPSByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIrKztcbiAgICBhbHJlYWR5TGlzdGVuaW5nVG9bbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV1dID0ge307XG4gIH1cbiAgcmV0dXJuIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV07XG59XG5cbi8qKlxuICogYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgaXMgdXNlZCB0byBhdHRhY2ggdG9wLWxldmVsIGV2ZW50IGxpc3RlbmVycy4gRm9yXG4gKiBleGFtcGxlOlxuICpcbiAqICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnB1dExpc3RlbmVyKCdteUlEJywgJ29uQ2xpY2snLCBteUZ1bmN0aW9uKTtcbiAqXG4gKiBUaGlzIHdvdWxkIGFsbG9jYXRlIGEgXCJyZWdpc3RyYXRpb25cIiBvZiBgKCdvbkNsaWNrJywgbXlGdW5jdGlvbilgIG9uICdteUlEJy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IGFzc2lnbih7fSwgUmVhY3RFdmVudEVtaXR0ZXJNaXhpbiwge1xuXG4gIC8qKlxuICAgKiBJbmplY3RhYmxlIGV2ZW50IGJhY2tlbmRcbiAgICovXG4gIFJlYWN0RXZlbnRMaXN0ZW5lcjogbnVsbCxcblxuICBpbmplY3Rpb246IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gUmVhY3RFdmVudExpc3RlbmVyXG4gICAgICovXG4gICAgaW5qZWN0UmVhY3RFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoUmVhY3RFdmVudExpc3RlbmVyKSB7XG4gICAgICBSZWFjdEV2ZW50TGlzdGVuZXIuc2V0SGFuZGxlVG9wTGV2ZWwoUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmhhbmRsZVRvcExldmVsKTtcbiAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIgPSBSZWFjdEV2ZW50TGlzdGVuZXI7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHdoZXRoZXIgb3Igbm90IGFueSBjcmVhdGVkIGNhbGxiYWNrcyBzaG91bGQgYmUgZW5hYmxlZC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkIFRydWUgaWYgY2FsbGJhY2tzIHNob3VsZCBiZSBlbmFibGVkLlxuICAgKi9cbiAgc2V0RW5hYmxlZDogZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICBpZiAoUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lcikge1xuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5zZXRFbmFibGVkKGVuYWJsZWQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBjYWxsYmFja3MgYXJlIGVuYWJsZWQuXG4gICAqL1xuICBpc0VuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISEoUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lciAmJiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLmlzRW5hYmxlZCgpKTtcbiAgfSxcblxuICAvKipcbiAgICogV2UgbGlzdGVuIGZvciBidWJibGVkIHRvdWNoIGV2ZW50cyBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LlxuICAgKlxuICAgKiBGaXJlZm94IHY4LjAxIChhbmQgcG9zc2libHkgb3RoZXJzKSBleGhpYml0ZWQgc3RyYW5nZSBiZWhhdmlvciB3aGVuXG4gICAqIG1vdW50aW5nIGBvbm1vdXNlbW92ZWAgZXZlbnRzIGF0IHNvbWUgbm9kZSB0aGF0IHdhcyBub3QgdGhlIGRvY3VtZW50XG4gICAqIGVsZW1lbnQuIFRoZSBzeW1wdG9tcyB3ZXJlIHRoYXQgaWYgeW91ciBtb3VzZSBpcyBub3QgbW92aW5nIG92ZXIgc29tZXRoaW5nXG4gICAqIGNvbnRhaW5lZCB3aXRoaW4gdGhhdCBtb3VudCBwb2ludCAoZm9yIGV4YW1wbGUgb24gdGhlIGJhY2tncm91bmQpIHRoZVxuICAgKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIGZvciBgb25tb3VzZW1vdmVgIHdvbid0IGJlIGNhbGxlZC4gSG93ZXZlciwgaWYgeW91XG4gICAqIHJlZ2lzdGVyIHRoZSBgbW91c2Vtb3ZlYCBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LCB0aGVuIGl0IHdpbGwgb2YgY291cnNlXG4gICAqIGNhdGNoIGFsbCBgbW91c2Vtb3ZlYHMuIFRoaXMgYWxvbmcgd2l0aCBpT1MgcXVpcmtzLCBqdXN0aWZpZXMgcmVzdHJpY3RpbmdcbiAgICogdG9wLWxldmVsIGxpc3RlbmVycyB0byB0aGUgZG9jdW1lbnQgb2JqZWN0IG9ubHksIGF0IGxlYXN0IGZvciB0aGVzZVxuICAgKiBtb3ZlbWVudCB0eXBlcyBvZiBldmVudHMgYW5kIHBvc3NpYmx5IGFsbCBldmVudHMuXG4gICAqXG4gICAqIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAgICpcbiAgICogQWxzbywgYGtleXVwYC9ga2V5cHJlc3NgL2BrZXlkb3duYCBkbyBub3QgYnViYmxlIHRvIHRoZSB3aW5kb3cgb24gSUUsIGJ1dFxuICAgKiB0aGV5IGJ1YmJsZSB0byBkb2N1bWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGVudERvY3VtZW50SGFuZGxlIERvY3VtZW50IHdoaWNoIG93bnMgdGhlIGNvbnRhaW5lclxuICAgKi9cbiAgbGlzdGVuVG86IGZ1bmN0aW9uIChyZWdpc3RyYXRpb25OYW1lLCBjb250ZW50RG9jdW1lbnRIYW5kbGUpIHtcbiAgICB2YXIgbW91bnRBdCA9IGNvbnRlbnREb2N1bWVudEhhbmRsZTtcbiAgICB2YXIgaXNMaXN0ZW5pbmcgPSBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KTtcbiAgICB2YXIgZGVwZW5kZW5jaWVzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuXG4gICAgdmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY2llc1tpXTtcbiAgICAgIGlmICghKGlzTGlzdGVuaW5nLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpICYmIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldKSkge1xuICAgICAgICBpZiAoZGVwZW5kZW5jeSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BXaGVlbCkge1xuICAgICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCd3aGVlbCcpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BXaGVlbCwgJ3doZWVsJywgbW91bnRBdCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdtb3VzZXdoZWVsJykpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcFdoZWVsLCAnbW91c2V3aGVlbCcsIG1vdW50QXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGaXJlZm94IG5lZWRzIHRvIGNhcHR1cmUgYSBkaWZmZXJlbnQgbW91c2Ugc2Nyb2xsIGV2ZW50LlxuICAgICAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2RvbS9ldmVudHMvdGVzdHMvc2Nyb2xsLmh0bWxcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcFdoZWVsLCAnRE9NTW91c2VTY3JvbGwnLCBtb3VudEF0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BTY3JvbGwpIHtcblxuICAgICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdzY3JvbGwnLCB0cnVlKSkge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcFNjcm9sbCwgJ3Njcm9sbCcsIG1vdW50QXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BTY3JvbGwsICdzY3JvbGwnLCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLldJTkRPV19IQU5ETEUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChkZXBlbmRlbmN5ID09PSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzIHx8IGRlcGVuZGVuY3kgPT09IHRvcExldmVsVHlwZXMudG9wQmx1cikge1xuXG4gICAgICAgICAgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ2ZvY3VzJywgdHJ1ZSkpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcENhcHR1cmVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BGb2N1cywgJ2ZvY3VzJywgbW91bnRBdCk7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wQmx1ciwgJ2JsdXInLCBtb3VudEF0KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ2ZvY3VzaW4nKSkge1xuICAgICAgICAgICAgLy8gSUUgaGFzIGBmb2N1c2luYCBhbmQgYGZvY3Vzb3V0YCBldmVudHMgd2hpY2ggYnViYmxlLlxuICAgICAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAwOC8wNC9kZWxlZ2F0aW5nX3RoZS5odG1sXG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BGb2N1cywgJ2ZvY3VzaW4nLCBtb3VudEF0KTtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcEJsdXIsICdmb2N1c291dCcsIG1vdW50QXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHRvIG1ha2Ugc3VyZSBibHVyIGFuZCBmb2N1cyBldmVudCBsaXN0ZW5lcnMgYXJlIG9ubHkgYXR0YWNoZWQgb25jZVxuICAgICAgICAgIGlzTGlzdGVuaW5nW3RvcExldmVsVHlwZXMudG9wQmx1cl0gPSB0cnVlO1xuICAgICAgICAgIGlzTGlzdGVuaW5nW3RvcExldmVsVHlwZXMudG9wRm9jdXNdID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0b3BFdmVudE1hcHBpbmcuaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeSkpIHtcbiAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoZGVwZW5kZW5jeSwgdG9wRXZlbnRNYXBwaW5nW2RlcGVuZGVuY3ldLCBtb3VudEF0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdHJhcEJ1YmJsZWRFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpIHtcbiAgICByZXR1cm4gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpO1xuICB9LFxuXG4gIHRyYXBDYXB0dXJlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSkge1xuICAgIHJldHVybiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBMaXN0ZW5zIHRvIHdpbmRvdyBzY3JvbGwgYW5kIHJlc2l6ZSBldmVudHMuIFdlIGNhY2hlIHNjcm9sbCB2YWx1ZXMgc28gdGhhdFxuICAgKiBhcHBsaWNhdGlvbiBjb2RlIGNhbiBhY2Nlc3MgdGhlbSB3aXRob3V0IHRyaWdnZXJpbmcgcmVmbG93cy5cbiAgICpcbiAgICogTk9URTogU2Nyb2xsIGV2ZW50cyBkbyBub3QgYnViYmxlLlxuICAgKlxuICAgKiBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvZG9tL2V2ZW50cy9zY3JvbGwuaHRtbFxuICAgKi9cbiAgZW5zdXJlU2Nyb2xsVmFsdWVNb25pdG9yaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFpc01vbml0b3JpbmdTY3JvbGxWYWx1ZSkge1xuICAgICAgdmFyIHJlZnJlc2ggPSBWaWV3cG9ydE1ldHJpY3MucmVmcmVzaFNjcm9sbFZhbHVlcztcbiAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIubW9uaXRvclNjcm9sbFZhbHVlKHJlZnJlc2gpO1xuICAgICAgaXNNb25pdG9yaW5nU2Nyb2xsVmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfSxcblxuICBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3M6IEV2ZW50UGx1Z2luSHViLmV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyxcblxuICByZWdpc3RyYXRpb25OYW1lTW9kdWxlczogRXZlbnRQbHVnaW5IdWIucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMsXG5cbiAgcHV0TGlzdGVuZXI6IEV2ZW50UGx1Z2luSHViLnB1dExpc3RlbmVyLFxuXG4gIGdldExpc3RlbmVyOiBFdmVudFBsdWdpbkh1Yi5nZXRMaXN0ZW5lcixcblxuICBkZWxldGVMaXN0ZW5lcjogRXZlbnRQbHVnaW5IdWIuZGVsZXRlTGlzdGVuZXIsXG5cbiAgZGVsZXRlQWxsTGlzdGVuZXJzOiBFdmVudFBsdWdpbkh1Yi5kZWxldGVBbGxMaXN0ZW5lcnNcblxufSk7XG5cblJlYWN0UGVyZi5tZWFzdXJlTWV0aG9kcyhSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIsICdSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInLCB7XG4gIHB1dExpc3RlbmVyOiAncHV0TGlzdGVuZXInLFxuICBkZWxldGVMaXN0ZW5lcjogJ2RlbGV0ZUxpc3RlbmVyJ1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50Q29uc3RhbnRzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5TWlycm9yID0gcmVxdWlyZSgnZmJqcy9saWIva2V5TWlycm9yJyk7XG5cbnZhciBQcm9wYWdhdGlvblBoYXNlcyA9IGtleU1pcnJvcih7IGJ1YmJsZWQ6IG51bGwsIGNhcHR1cmVkOiBudWxsIH0pO1xuXG4vKipcbiAqIFR5cGVzIG9mIHJhdyBzaWduYWxzIGZyb20gdGhlIGJyb3dzZXIgY2F1Z2h0IGF0IHRoZSB0b3AgbGV2ZWwuXG4gKi9cbnZhciB0b3BMZXZlbFR5cGVzID0ga2V5TWlycm9yKHtcbiAgdG9wQWJvcnQ6IG51bGwsXG4gIHRvcEJsdXI6IG51bGwsXG4gIHRvcENhblBsYXk6IG51bGwsXG4gIHRvcENhblBsYXlUaHJvdWdoOiBudWxsLFxuICB0b3BDaGFuZ2U6IG51bGwsXG4gIHRvcENsaWNrOiBudWxsLFxuICB0b3BDb21wb3NpdGlvbkVuZDogbnVsbCxcbiAgdG9wQ29tcG9zaXRpb25TdGFydDogbnVsbCxcbiAgdG9wQ29tcG9zaXRpb25VcGRhdGU6IG51bGwsXG4gIHRvcENvbnRleHRNZW51OiBudWxsLFxuICB0b3BDb3B5OiBudWxsLFxuICB0b3BDdXQ6IG51bGwsXG4gIHRvcERvdWJsZUNsaWNrOiBudWxsLFxuICB0b3BEcmFnOiBudWxsLFxuICB0b3BEcmFnRW5kOiBudWxsLFxuICB0b3BEcmFnRW50ZXI6IG51bGwsXG4gIHRvcERyYWdFeGl0OiBudWxsLFxuICB0b3BEcmFnTGVhdmU6IG51bGwsXG4gIHRvcERyYWdPdmVyOiBudWxsLFxuICB0b3BEcmFnU3RhcnQ6IG51bGwsXG4gIHRvcERyb3A6IG51bGwsXG4gIHRvcER1cmF0aW9uQ2hhbmdlOiBudWxsLFxuICB0b3BFbXB0aWVkOiBudWxsLFxuICB0b3BFbmNyeXB0ZWQ6IG51bGwsXG4gIHRvcEVuZGVkOiBudWxsLFxuICB0b3BFcnJvcjogbnVsbCxcbiAgdG9wRm9jdXM6IG51bGwsXG4gIHRvcElucHV0OiBudWxsLFxuICB0b3BLZXlEb3duOiBudWxsLFxuICB0b3BLZXlQcmVzczogbnVsbCxcbiAgdG9wS2V5VXA6IG51bGwsXG4gIHRvcExvYWQ6IG51bGwsXG4gIHRvcExvYWRlZERhdGE6IG51bGwsXG4gIHRvcExvYWRlZE1ldGFkYXRhOiBudWxsLFxuICB0b3BMb2FkU3RhcnQ6IG51bGwsXG4gIHRvcE1vdXNlRG93bjogbnVsbCxcbiAgdG9wTW91c2VNb3ZlOiBudWxsLFxuICB0b3BNb3VzZU91dDogbnVsbCxcbiAgdG9wTW91c2VPdmVyOiBudWxsLFxuICB0b3BNb3VzZVVwOiBudWxsLFxuICB0b3BQYXN0ZTogbnVsbCxcbiAgdG9wUGF1c2U6IG51bGwsXG4gIHRvcFBsYXk6IG51bGwsXG4gIHRvcFBsYXlpbmc6IG51bGwsXG4gIHRvcFByb2dyZXNzOiBudWxsLFxuICB0b3BSYXRlQ2hhbmdlOiBudWxsLFxuICB0b3BSZXNldDogbnVsbCxcbiAgdG9wU2Nyb2xsOiBudWxsLFxuICB0b3BTZWVrZWQ6IG51bGwsXG4gIHRvcFNlZWtpbmc6IG51bGwsXG4gIHRvcFNlbGVjdGlvbkNoYW5nZTogbnVsbCxcbiAgdG9wU3RhbGxlZDogbnVsbCxcbiAgdG9wU3VibWl0OiBudWxsLFxuICB0b3BTdXNwZW5kOiBudWxsLFxuICB0b3BUZXh0SW5wdXQ6IG51bGwsXG4gIHRvcFRpbWVVcGRhdGU6IG51bGwsXG4gIHRvcFRvdWNoQ2FuY2VsOiBudWxsLFxuICB0b3BUb3VjaEVuZDogbnVsbCxcbiAgdG9wVG91Y2hNb3ZlOiBudWxsLFxuICB0b3BUb3VjaFN0YXJ0OiBudWxsLFxuICB0b3BWb2x1bWVDaGFuZ2U6IG51bGwsXG4gIHRvcFdhaXRpbmc6IG51bGwsXG4gIHRvcFdoZWVsOiBudWxsXG59KTtcblxudmFyIEV2ZW50Q29uc3RhbnRzID0ge1xuICB0b3BMZXZlbFR5cGVzOiB0b3BMZXZlbFR5cGVzLFxuICBQcm9wYWdhdGlvblBoYXNlczogUHJvcGFnYXRpb25QaGFzZXNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRDb25zdGFudHM7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9FdmVudENvbnN0YW50cy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudFBsdWdpbkh1YlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luUmVnaXN0cnknKTtcbnZhciBFdmVudFBsdWdpblV0aWxzID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblV0aWxzJyk7XG52YXIgUmVhY3RFcnJvclV0aWxzID0gcmVxdWlyZSgnLi9SZWFjdEVycm9yVXRpbHMnKTtcblxudmFyIGFjY3VtdWxhdGVJbnRvID0gcmVxdWlyZSgnLi9hY2N1bXVsYXRlSW50bycpO1xudmFyIGZvckVhY2hBY2N1bXVsYXRlZCA9IHJlcXVpcmUoJy4vZm9yRWFjaEFjY3VtdWxhdGVkJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBJbnRlcm5hbCBzdG9yZSBmb3IgZXZlbnQgbGlzdGVuZXJzXG4gKi9cbnZhciBsaXN0ZW5lckJhbmsgPSB7fTtcblxuLyoqXG4gKiBJbnRlcm5hbCBxdWV1ZSBvZiBldmVudHMgdGhhdCBoYXZlIGFjY3VtdWxhdGVkIHRoZWlyIGRpc3BhdGNoZXMgYW5kIGFyZVxuICogd2FpdGluZyB0byBoYXZlIHRoZWlyIGRpc3BhdGNoZXMgZXhlY3V0ZWQuXG4gKi9cbnZhciBldmVudFF1ZXVlID0gbnVsbDtcblxuLyoqXG4gKiBEaXNwYXRjaGVzIGFuIGV2ZW50IGFuZCByZWxlYXNlcyBpdCBiYWNrIGludG8gdGhlIHBvb2wsIHVubGVzcyBwZXJzaXN0ZW50LlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gZXZlbnQgU3ludGhldGljIGV2ZW50IHRvIGJlIGRpc3BhdGNoZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbXVsYXRlZCBJZiB0aGUgZXZlbnQgaXMgc2ltdWxhdGVkIChjaGFuZ2VzIGV4biBiZWhhdmlvcilcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UgPSBmdW5jdGlvbiAoZXZlbnQsIHNpbXVsYXRlZCkge1xuICBpZiAoZXZlbnQpIHtcbiAgICBFdmVudFBsdWdpblV0aWxzLmV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCwgc2ltdWxhdGVkKTtcblxuICAgIGlmICghZXZlbnQuaXNQZXJzaXN0ZW50KCkpIHtcbiAgICAgIGV2ZW50LmNvbnN0cnVjdG9yLnJlbGVhc2UoZXZlbnQpO1xuICAgIH1cbiAgfVxufTtcbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQgPSBmdW5jdGlvbiAoZSkge1xuICByZXR1cm4gZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlKGUsIHRydWUpO1xufTtcbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VUb3BMZXZlbCA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UoZSwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiAtIGBJbnN0YW5jZUhhbmRsZWA6IFtyZXF1aXJlZF0gTW9kdWxlIHRoYXQgcGVyZm9ybXMgbG9naWNhbCB0cmF2ZXJzYWxzIG9mIERPTVxuICogICBoaWVyYXJjaHkgZ2l2ZW4gaWRzIG9mIHRoZSBsb2dpY2FsIERPTSBlbGVtZW50cyBpbnZvbHZlZC5cbiAqL1xudmFyIEluc3RhbmNlSGFuZGxlID0gbnVsbDtcblxuZnVuY3Rpb24gdmFsaWRhdGVJbnN0YW5jZUhhbmRsZSgpIHtcbiAgdmFyIHZhbGlkID0gSW5zdGFuY2VIYW5kbGUgJiYgSW5zdGFuY2VIYW5kbGUudHJhdmVyc2VUd29QaGFzZSAmJiBJbnN0YW5jZUhhbmRsZS50cmF2ZXJzZUVudGVyTGVhdmU7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHZhbGlkLCAnSW5zdGFuY2VIYW5kbGUgbm90IGluamVjdGVkIGJlZm9yZSB1c2UhJykgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogVGhpcyBpcyBhIHVuaWZpZWQgaW50ZXJmYWNlIGZvciBldmVudCBwbHVnaW5zIHRvIGJlIGluc3RhbGxlZCBhbmQgY29uZmlndXJlZC5cbiAqXG4gKiBFdmVudCBwbHVnaW5zIGNhbiBpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgYGV4dHJhY3RFdmVudHNgIHtmdW5jdGlvbihzdHJpbmcsIERPTUV2ZW50VGFyZ2V0LCBzdHJpbmcsIG9iamVjdCk6ICp9XG4gKiAgICAgUmVxdWlyZWQuIFdoZW4gYSB0b3AtbGV2ZWwgZXZlbnQgaXMgZmlyZWQsIHRoaXMgbWV0aG9kIGlzIGV4cGVjdGVkIHRvXG4gKiAgICAgZXh0cmFjdCBzeW50aGV0aWMgZXZlbnRzIHRoYXQgd2lsbCBpbiB0dXJuIGJlIHF1ZXVlZCBhbmQgZGlzcGF0Y2hlZC5cbiAqXG4gKiAgIGBldmVudFR5cGVzYCB7b2JqZWN0fVxuICogICAgIE9wdGlvbmFsLCBwbHVnaW5zIHRoYXQgZmlyZSBldmVudHMgbXVzdCBwdWJsaXNoIGEgbWFwcGluZyBvZiByZWdpc3RyYXRpb25cbiAqICAgICBuYW1lcyB0aGF0IGFyZSB1c2VkIHRvIHJlZ2lzdGVyIGxpc3RlbmVycy4gVmFsdWVzIG9mIHRoaXMgbWFwcGluZyBtdXN0XG4gKiAgICAgYmUgb2JqZWN0cyB0aGF0IGNvbnRhaW4gYHJlZ2lzdHJhdGlvbk5hbWVgIG9yIGBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc2AuXG4gKlxuICogICBgZXhlY3V0ZURpc3BhdGNoYCB7ZnVuY3Rpb24ob2JqZWN0LCBmdW5jdGlvbiwgc3RyaW5nKX1cbiAqICAgICBPcHRpb25hbCwgYWxsb3dzIHBsdWdpbnMgdG8gb3ZlcnJpZGUgaG93IGFuIGV2ZW50IGdldHMgZGlzcGF0Y2hlZC4gQnlcbiAqICAgICBkZWZhdWx0LCB0aGUgbGlzdGVuZXIgaXMgc2ltcGx5IGludm9rZWQuXG4gKlxuICogRWFjaCBwbHVnaW4gdGhhdCBpcyBpbmplY3RlZCBpbnRvIGBFdmVudHNQbHVnaW5IdWJgIGlzIGltbWVkaWF0ZWx5IG9wZXJhYmxlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIEV2ZW50UGx1Z2luSHViID0ge1xuXG4gIC8qKlxuICAgKiBNZXRob2RzIGZvciBpbmplY3RpbmcgZGVwZW5kZW5jaWVzLlxuICAgKi9cbiAgaW5qZWN0aW9uOiB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gSW5qZWN0ZWRNb3VudFxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBpbmplY3RNb3VudDogRXZlbnRQbHVnaW5VdGlscy5pbmplY3Rpb24uaW5qZWN0TW91bnQsXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gSW5qZWN0ZWRJbnN0YW5jZUhhbmRsZVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBpbmplY3RJbnN0YW5jZUhhbmRsZTogZnVuY3Rpb24gKEluamVjdGVkSW5zdGFuY2VIYW5kbGUpIHtcbiAgICAgIEluc3RhbmNlSGFuZGxlID0gSW5qZWN0ZWRJbnN0YW5jZUhhbmRsZTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhbGlkYXRlSW5zdGFuY2VIYW5kbGUoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0SW5zdGFuY2VIYW5kbGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhbGlkYXRlSW5zdGFuY2VIYW5kbGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBJbnN0YW5jZUhhbmRsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHthcnJheX0gSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGluamVjdEV2ZW50UGx1Z2luT3JkZXI6IEV2ZW50UGx1Z2luUmVnaXN0cnkuaW5qZWN0RXZlbnRQbHVnaW5PcmRlcixcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxuICAgICAqL1xuICAgIGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTogRXZlbnRQbHVnaW5SZWdpc3RyeS5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWVcblxuICB9LFxuXG4gIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnczogRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MsXG5cbiAgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM6IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMsXG5cbiAgLyoqXG4gICAqIFN0b3JlcyBgbGlzdGVuZXJgIGF0IGBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV1baWRdYC4gSXMgaWRlbXBvdGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBET00gZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGNhbGxiYWNrIHRvIHN0b3JlLlxuICAgKi9cbiAgcHV0TGlzdGVuZXI6IGZ1bmN0aW9uIChpZCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICAhKHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgJXMgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgdHlwZSAlcycsIHJlZ2lzdHJhdGlvbk5hbWUsIHR5cGVvZiBsaXN0ZW5lcikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lID0gbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdIHx8IChsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV0gPSB7fSk7XG4gICAgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWVbaWRdID0gbGlzdGVuZXI7XG5cbiAgICB2YXIgUGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICBpZiAoUGx1Z2luTW9kdWxlICYmIFBsdWdpbk1vZHVsZS5kaWRQdXRMaXN0ZW5lcikge1xuICAgICAgUGx1Z2luTW9kdWxlLmRpZFB1dExpc3RlbmVyKGlkLCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgdGhlIERPTSBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn0gVGhlIHN0b3JlZCBjYWxsYmFjay5cbiAgICovXG4gIGdldExpc3RlbmVyOiBmdW5jdGlvbiAoaWQsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICB2YXIgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgPSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgcmV0dXJuIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lICYmIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lW2lkXTtcbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyBhIGxpc3RlbmVyIGZyb20gdGhlIHJlZ2lzdHJhdGlvbiBiYW5rLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgdGhlIERPTSBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqL1xuICBkZWxldGVMaXN0ZW5lcjogZnVuY3Rpb24gKGlkLCByZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgdmFyIFBsdWdpbk1vZHVsZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgaWYgKFBsdWdpbk1vZHVsZSAmJiBQbHVnaW5Nb2R1bGUud2lsbERlbGV0ZUxpc3RlbmVyKSB7XG4gICAgICBQbHVnaW5Nb2R1bGUud2lsbERlbGV0ZUxpc3RlbmVyKGlkLCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgPSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgLy8gVE9ETzogVGhpcyBzaG91bGQgbmV2ZXIgYmUgbnVsbCAtLSB3aGVuIGlzIGl0P1xuICAgIGlmIChiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSkge1xuICAgICAgZGVsZXRlIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lW2lkXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgYWxsIGxpc3RlbmVycyBmb3IgdGhlIERPTSBlbGVtZW50IHdpdGggdGhlIHN1cHBsaWVkIElELlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgdGhlIERPTSBlbGVtZW50LlxuICAgKi9cbiAgZGVsZXRlQWxsTGlzdGVuZXJzOiBmdW5jdGlvbiAoaWQpIHtcbiAgICBmb3IgKHZhciByZWdpc3RyYXRpb25OYW1lIGluIGxpc3RlbmVyQmFuaykge1xuICAgICAgaWYgKCFsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV1baWRdKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgUGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICAgIGlmIChQbHVnaW5Nb2R1bGUgJiYgUGx1Z2luTW9kdWxlLndpbGxEZWxldGVMaXN0ZW5lcikge1xuICAgICAgICBQbHVnaW5Nb2R1bGUud2lsbERlbGV0ZUxpc3RlbmVyKGlkLCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXVtpZF07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBbGxvd3MgcmVnaXN0ZXJlZCBwbHVnaW5zIGFuIG9wcG9ydHVuaXR5IHRvIGV4dHJhY3QgZXZlbnRzIGZyb20gdG9wLWxldmVsXG4gICAqIG5hdGl2ZSBicm93c2VyIGV2ZW50cy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBldmVudHM7XG4gICAgdmFyIHBsdWdpbnMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBOb3QgZXZlcnkgcGx1Z2luIGluIHRoZSBvcmRlcmluZyBtYXkgYmUgbG9hZGVkIGF0IHJ1bnRpbWUuXG4gICAgICB2YXIgcG9zc2libGVQbHVnaW4gPSBwbHVnaW5zW2ldO1xuICAgICAgaWYgKHBvc3NpYmxlUGx1Z2luKSB7XG4gICAgICAgIHZhciBleHRyYWN0ZWRFdmVudHMgPSBwb3NzaWJsZVBsdWdpbi5leHRyYWN0RXZlbnRzKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICAgIGlmIChleHRyYWN0ZWRFdmVudHMpIHtcbiAgICAgICAgICBldmVudHMgPSBhY2N1bXVsYXRlSW50byhldmVudHMsIGV4dHJhY3RlZEV2ZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50cztcbiAgfSxcblxuICAvKipcbiAgICogRW5xdWV1ZXMgYSBzeW50aGV0aWMgZXZlbnQgdGhhdCBzaG91bGQgYmUgZGlzcGF0Y2hlZCB3aGVuXG4gICAqIGBwcm9jZXNzRXZlbnRRdWV1ZWAgaXMgaW52b2tlZC5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBldmVudHMgQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUV2ZW50czogZnVuY3Rpb24gKGV2ZW50cykge1xuICAgIGlmIChldmVudHMpIHtcbiAgICAgIGV2ZW50UXVldWUgPSBhY2N1bXVsYXRlSW50byhldmVudFF1ZXVlLCBldmVudHMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhbGwgc3ludGhldGljIGV2ZW50cyBvbiB0aGUgZXZlbnQgcXVldWUuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvY2Vzc0V2ZW50UXVldWU6IGZ1bmN0aW9uIChzaW11bGF0ZWQpIHtcbiAgICAvLyBTZXQgYGV2ZW50UXVldWVgIHRvIG51bGwgYmVmb3JlIHByb2Nlc3NpbmcgaXQgc28gdGhhdCB3ZSBjYW4gdGVsbCBpZiBtb3JlXG4gICAgLy8gZXZlbnRzIGdldCBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nLlxuICAgIHZhciBwcm9jZXNzaW5nRXZlbnRRdWV1ZSA9IGV2ZW50UXVldWU7XG4gICAgZXZlbnRRdWV1ZSA9IG51bGw7XG4gICAgaWYgKHNpbXVsYXRlZCkge1xuICAgICAgZm9yRWFjaEFjY3VtdWxhdGVkKHByb2Nlc3NpbmdFdmVudFF1ZXVlLCBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsKTtcbiAgICB9XG4gICAgISFldmVudFF1ZXVlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3Byb2Nlc3NFdmVudFF1ZXVlKCk6IEFkZGl0aW9uYWwgZXZlbnRzIHdlcmUgZW5xdWV1ZWQgd2hpbGUgcHJvY2Vzc2luZyAnICsgJ2FuIGV2ZW50IHF1ZXVlLiBTdXBwb3J0IGZvciB0aGlzIGhhcyBub3QgeWV0IGJlZW4gaW1wbGVtZW50ZWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIC8vIFRoaXMgd291bGQgYmUgYSBnb29kIHRpbWUgdG8gcmV0aHJvdyBpZiBhbnkgb2YgdGhlIGV2ZW50IGhhbmRsZXJzIHRocmV3LlxuICAgIFJlYWN0RXJyb3JVdGlscy5yZXRocm93Q2F1Z2h0RXJyb3IoKTtcbiAgfSxcblxuICAvKipcbiAgICogVGhlc2UgYXJlIG5lZWRlZCBmb3IgdGVzdHMgb25seS4gRG8gbm90IHVzZSFcbiAgICovXG4gIF9fcHVyZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICBsaXN0ZW5lckJhbmsgPSB7fTtcbiAgfSxcblxuICBfX2dldExpc3RlbmVyQmFuazogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBsaXN0ZW5lckJhbms7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFBsdWdpbkh1YjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL0V2ZW50UGx1Z2luSHViLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50UGx1Z2luUmVnaXN0cnlcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogSW5qZWN0YWJsZSBvcmRlcmluZyBvZiBldmVudCBwbHVnaW5zLlxuICovXG52YXIgRXZlbnRQbHVnaW5PcmRlciA9IG51bGw7XG5cbi8qKlxuICogSW5qZWN0YWJsZSBtYXBwaW5nIGZyb20gbmFtZXMgdG8gZXZlbnQgcGx1Z2luIG1vZHVsZXMuXG4gKi9cbnZhciBuYW1lc1RvUGx1Z2lucyA9IHt9O1xuXG4vKipcbiAqIFJlY29tcHV0ZXMgdGhlIHBsdWdpbiBsaXN0IHVzaW5nIHRoZSBpbmplY3RlZCBwbHVnaW5zIGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKSB7XG4gIGlmICghRXZlbnRQbHVnaW5PcmRlcikge1xuICAgIC8vIFdhaXQgdW50aWwgYW4gYEV2ZW50UGx1Z2luT3JkZXJgIGlzIGluamVjdGVkLlxuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIG5hbWVzVG9QbHVnaW5zKSB7XG4gICAgdmFyIFBsdWdpbk1vZHVsZSA9IG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgIHZhciBwbHVnaW5JbmRleCA9IEV2ZW50UGx1Z2luT3JkZXIuaW5kZXhPZihwbHVnaW5OYW1lKTtcbiAgICAhKHBsdWdpbkluZGV4ID4gLTEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2lucyB0aGF0IGRvIG5vdCBleGlzdCBpbiAnICsgJ3RoZSBwbHVnaW4gb3JkZXJpbmcsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIGlmIChFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnNbcGx1Z2luSW5kZXhdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgIVBsdWdpbk1vZHVsZS5leHRyYWN0RXZlbnRzID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEV2ZW50IHBsdWdpbnMgbXVzdCBpbXBsZW1lbnQgYW4gYGV4dHJhY3RFdmVudHNgICcgKyAnbWV0aG9kLCBidXQgYCVzYCBkb2VzIG5vdC4nLCBwbHVnaW5OYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zW3BsdWdpbkluZGV4XSA9IFBsdWdpbk1vZHVsZTtcbiAgICB2YXIgcHVibGlzaGVkRXZlbnRzID0gUGx1Z2luTW9kdWxlLmV2ZW50VHlwZXM7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHB1Ymxpc2hlZEV2ZW50cykge1xuICAgICAgIXB1Ymxpc2hFdmVudEZvclBsdWdpbihwdWJsaXNoZWRFdmVudHNbZXZlbnROYW1lXSwgUGx1Z2luTW9kdWxlLCBldmVudE5hbWUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEZhaWxlZCB0byBwdWJsaXNoIGV2ZW50IGAlc2AgZm9yIHBsdWdpbiBgJXNgLicsIGV2ZW50TmFtZSwgcGx1Z2luTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFB1Ymxpc2hlcyBhbiBldmVudCBzbyB0aGF0IGl0IGNhbiBiZSBkaXNwYXRjaGVkIGJ5IHRoZSBzdXBwbGllZCBwbHVnaW4uXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIERpc3BhdGNoIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBldmVudC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBQbHVnaW5Nb2R1bGUgUGx1Z2luIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgd2FzIHN1Y2Nlc3NmdWxseSBwdWJsaXNoZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdWJsaXNoRXZlbnRGb3JQbHVnaW4oZGlzcGF0Y2hDb25maWcsIFBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSB7XG4gICEhRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpbkh1YjogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgJyArICdldmVudCBuYW1lLCBgJXNgLicsIGV2ZW50TmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICBFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlnc1tldmVudE5hbWVdID0gZGlzcGF0Y2hDb25maWc7XG5cbiAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzID0gZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM7XG4gIGlmIChwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIGZvciAodmFyIHBoYXNlTmFtZSBpbiBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgICAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KHBoYXNlTmFtZSkpIHtcbiAgICAgICAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUgPSBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc1twaGFzZU5hbWVdO1xuICAgICAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShwaGFzZWRSZWdpc3RyYXRpb25OYW1lLCBQbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lLCBQbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFB1Ymxpc2hlcyBhIHJlZ2lzdHJhdGlvbiBuYW1lIHRoYXQgaXMgdXNlZCB0byBpZGVudGlmeSBkaXNwYXRjaGVkIGV2ZW50cyBhbmRcbiAqIGNhbiBiZSB1c2VkIHdpdGggYEV2ZW50UGx1Z2luSHViLnB1dExpc3RlbmVyYCB0byByZWdpc3RlciBsaXN0ZW5lcnMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgUmVnaXN0cmF0aW9uIG5hbWUgdG8gYWRkLlxuICogQHBhcmFtIHtvYmplY3R9IFBsdWdpbk1vZHVsZSBQbHVnaW4gcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShyZWdpc3RyYXRpb25OYW1lLCBQbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkge1xuICAhIUV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5IdWI6IE1vcmUgdGhhbiBvbmUgcGx1Z2luIGF0dGVtcHRlZCB0byBwdWJsaXNoIHRoZSBzYW1lICcgKyAncmVnaXN0cmF0aW9uIG5hbWUsIGAlc2AuJywgcmVnaXN0cmF0aW9uTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gUGx1Z2luTW9kdWxlO1xuICBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV0gPSBQbHVnaW5Nb2R1bGUuZXZlbnRUeXBlc1tldmVudE5hbWVdLmRlcGVuZGVuY2llcztcbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgcGx1Z2lucyBzbyB0aGF0IHRoZXkgY2FuIGV4dHJhY3QgYW5kIGRpc3BhdGNoIGV2ZW50cy5cbiAqXG4gKiBAc2VlIHtFdmVudFBsdWdpbkh1Yn1cbiAqL1xudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSB7XG5cbiAgLyoqXG4gICAqIE9yZGVyZWQgbGlzdCBvZiBpbmplY3RlZCBwbHVnaW5zLlxuICAgKi9cbiAgcGx1Z2luczogW10sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBldmVudCBuYW1lIHRvIGRpc3BhdGNoIGNvbmZpZ1xuICAgKi9cbiAgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIHJlZ2lzdHJhdGlvbiBuYW1lIHRvIHBsdWdpbiBtb2R1bGVcbiAgICovXG4gIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIHJlZ2lzdHJhdGlvbiBuYW1lIHRvIGV2ZW50IG5hbWVcbiAgICovXG4gIHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXM6IHt9LFxuXG4gIC8qKlxuICAgKiBJbmplY3RzIGFuIG9yZGVyaW5nIG9mIHBsdWdpbnMgKGJ5IHBsdWdpbiBuYW1lKS4gVGhpcyBhbGxvd3MgdGhlIG9yZGVyaW5nXG4gICAqIHRvIGJlIGRlY291cGxlZCBmcm9tIGluamVjdGlvbiBvZiB0aGUgYWN0dWFsIHBsdWdpbnMgc28gdGhhdCBvcmRlcmluZyBpc1xuICAgKiBhbHdheXMgZGV0ZXJtaW5pc3RpYyByZWdhcmRsZXNzIG9mIHBhY2thZ2luZywgb24tdGhlLWZseSBpbmplY3Rpb24sIGV0Yy5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheX0gSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5PcmRlcn1cbiAgICovXG4gIGluamVjdEV2ZW50UGx1Z2luT3JkZXI6IGZ1bmN0aW9uIChJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIpIHtcbiAgICAhIUV2ZW50UGx1Z2luT3JkZXIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCBldmVudCBwbHVnaW4gb3JkZXJpbmcgbW9yZSB0aGFuICcgKyAnb25jZS4gWW91IGFyZSBsaWtlbHkgdHJ5aW5nIHRvIGxvYWQgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAvLyBDbG9uZSB0aGUgb3JkZXJpbmcgc28gaXQgY2Fubm90IGJlIGR5bmFtaWNhbGx5IG11dGF0ZWQuXG4gICAgRXZlbnRQbHVnaW5PcmRlciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKEluamVjdGVkRXZlbnRQbHVnaW5PcmRlcik7XG4gICAgcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKTtcbiAgfSxcblxuICAvKipcbiAgICogSW5qZWN0cyBwbHVnaW5zIHRvIGJlIHVzZWQgYnkgYEV2ZW50UGx1Z2luSHViYC4gVGhlIHBsdWdpbiBuYW1lcyBtdXN0IGJlXG4gICAqIGluIHRoZSBvcmRlcmluZyBpbmplY3RlZCBieSBgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcmAuXG4gICAqXG4gICAqIFBsdWdpbnMgY2FuIGJlIGluamVjdGVkIGFzIHBhcnQgb2YgcGFnZSBpbml0aWFsaXphdGlvbiBvciBvbi10aGUtZmx5LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyBNYXAgZnJvbSBuYW1lcyB0byBwbHVnaW4gbW9kdWxlcy5cbiAgICogQGludGVybmFsXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWV9XG4gICAqL1xuICBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWU6IGZ1bmN0aW9uIChpbmplY3RlZE5hbWVzVG9QbHVnaW5zKSB7XG4gICAgdmFyIGlzT3JkZXJpbmdEaXJ0eSA9IGZhbHNlO1xuICAgIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICAgICAgaWYgKCFpbmplY3RlZE5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIFBsdWdpbk1vZHVsZSA9IGluamVjdGVkTmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgICBpZiAoIW5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpIHx8IG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdICE9PSBQbHVnaW5Nb2R1bGUpIHtcbiAgICAgICAgISFuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IHR3byBkaWZmZXJlbnQgZXZlbnQgcGx1Z2lucyAnICsgJ3VzaW5nIHRoZSBzYW1lIG5hbWUsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgICBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA9IFBsdWdpbk1vZHVsZTtcbiAgICAgICAgaXNPcmRlcmluZ0RpcnR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzT3JkZXJpbmdEaXJ0eSkge1xuICAgICAgcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIExvb2tzIHVwIHRoZSBwbHVnaW4gZm9yIHRoZSBzdXBwbGllZCBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IEEgc3ludGhldGljIGV2ZW50LlxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBUaGUgcGx1Z2luIHRoYXQgY3JlYXRlZCB0aGUgc3VwcGxpZWQgZXZlbnQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0UGx1Z2luTW9kdWxlRm9yRXZlbnQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBkaXNwYXRjaENvbmZpZyA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnO1xuICAgIGlmIChkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgICByZXR1cm4gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lXSB8fCBudWxsO1xuICAgIH1cbiAgICBmb3IgKHZhciBwaGFzZSBpbiBkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgICAgaWYgKCFkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShwaGFzZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgUGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lc1twaGFzZV1dO1xuICAgICAgaWYgKFBsdWdpbk1vZHVsZSkge1xuICAgICAgICByZXR1cm4gUGx1Z2luTW9kdWxlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogRXhwb3NlZCBmb3IgdW5pdCB0ZXN0aW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Jlc2V0RXZlbnRQbHVnaW5zOiBmdW5jdGlvbiAoKSB7XG4gICAgRXZlbnRQbHVnaW5PcmRlciA9IG51bGw7XG4gICAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBuYW1lc1RvUGx1Z2lucykge1xuICAgICAgaWYgKG5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpKSB7XG4gICAgICAgIGRlbGV0ZSBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zLmxlbmd0aCA9IDA7XG5cbiAgICB2YXIgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3M7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncykge1xuICAgICAgaWYgKGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSB7XG4gICAgICAgIGRlbGV0ZSBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3NbZXZlbnROYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzO1xuICAgIGZvciAodmFyIHJlZ2lzdHJhdGlvbk5hbWUgaW4gcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMpIHtcbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShyZWdpc3RyYXRpb25OYW1lKSkge1xuICAgICAgICBkZWxldGUgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQbHVnaW5SZWdpc3RyeTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL0V2ZW50UGx1Z2luUmVnaXN0cnkuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXZlbnRQbHVnaW5VdGlsc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIFJlYWN0RXJyb3JVdGlscyA9IHJlcXVpcmUoJy4vUmVhY3RFcnJvclV0aWxzJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIEluamVjdGVkIGRlcGVuZGVuY2llczpcbiAqL1xuXG4vKipcbiAqIC0gYE1vdW50YDogW3JlcXVpcmVkXSBNb2R1bGUgdGhhdCBjYW4gY29udmVydCBiZXR3ZWVuIFJlYWN0IGRvbSBJRHMgYW5kXG4gKiAgIGFjdHVhbCBub2RlIHJlZmVyZW5jZXMuXG4gKi9cbnZhciBpbmplY3Rpb24gPSB7XG4gIE1vdW50OiBudWxsLFxuICBpbmplY3RNb3VudDogZnVuY3Rpb24gKEluamVjdGVkTW91bnQpIHtcbiAgICBpbmplY3Rpb24uTW91bnQgPSBJbmplY3RlZE1vdW50O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhJbmplY3RlZE1vdW50ICYmIEluamVjdGVkTW91bnQuZ2V0Tm9kZSAmJiBJbmplY3RlZE1vdW50LmdldElELCAnRXZlbnRQbHVnaW5VdGlscy5pbmplY3Rpb24uaW5qZWN0TW91bnQoLi4uKTogSW5qZWN0ZWQgTW91bnQgJyArICdtb2R1bGUgaXMgbWlzc2luZyBnZXROb2RlIG9yIGdldElELicpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG5mdW5jdGlvbiBpc0VuZGlzaCh0b3BMZXZlbFR5cGUpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZVVwIHx8IHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BUb3VjaEVuZCB8fCB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wVG91Y2hDYW5jZWw7XG59XG5cbmZ1bmN0aW9uIGlzTW92ZWlzaCh0b3BMZXZlbFR5cGUpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU1vdmUgfHwgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoTW92ZTtcbn1cbmZ1bmN0aW9uIGlzU3RhcnRpc2godG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duIHx8IHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BUb3VjaFN0YXJ0O1xufVxuXG52YXIgdmFsaWRhdGVFdmVudERpc3BhdGNoZXM7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgICB2YXIgZGlzcGF0Y2hJRHMgPSBldmVudC5fZGlzcGF0Y2hJRHM7XG5cbiAgICB2YXIgbGlzdGVuZXJzSXNBcnIgPSBBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXJzKTtcbiAgICB2YXIgaWRzSXNBcnIgPSBBcnJheS5pc0FycmF5KGRpc3BhdGNoSURzKTtcbiAgICB2YXIgSURzTGVuID0gaWRzSXNBcnIgPyBkaXNwYXRjaElEcy5sZW5ndGggOiBkaXNwYXRjaElEcyA/IDEgOiAwO1xuICAgIHZhciBsaXN0ZW5lcnNMZW4gPSBsaXN0ZW5lcnNJc0FyciA/IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aCA6IGRpc3BhdGNoTGlzdGVuZXJzID8gMSA6IDA7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhpZHNJc0FyciA9PT0gbGlzdGVuZXJzSXNBcnIgJiYgSURzTGVuID09PSBsaXN0ZW5lcnNMZW4sICdFdmVudFBsdWdpblV0aWxzOiBJbnZhbGlkIGBldmVudGAuJykgOiB1bmRlZmluZWQ7XG4gIH07XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggdGhlIGV2ZW50IHRvIHRoZSBsaXN0ZW5lci5cbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IFN5bnRoZXRpY0V2ZW50IHRvIGhhbmRsZVxuICogQHBhcmFtIHtib29sZWFufSBzaW11bGF0ZWQgSWYgdGhlIGV2ZW50IGlzIHNpbXVsYXRlZCAoY2hhbmdlcyBleG4gYmVoYXZpb3IpXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciBBcHBsaWNhdGlvbi1sZXZlbCBjYWxsYmFja1xuICogQHBhcmFtIHtzdHJpbmd9IGRvbUlEIERPTSBpZCB0byBwYXNzIHRvIHRoZSBjYWxsYmFjay5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGxpc3RlbmVyLCBkb21JRCkge1xuICB2YXIgdHlwZSA9IGV2ZW50LnR5cGUgfHwgJ3Vua25vd24tZXZlbnQnO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gaW5qZWN0aW9uLk1vdW50LmdldE5vZGUoZG9tSUQpO1xuICBpZiAoc2ltdWxhdGVkKSB7XG4gICAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFja1dpdGhDYXRjaCh0eXBlLCBsaXN0ZW5lciwgZXZlbnQsIGRvbUlEKTtcbiAgfSBlbHNlIHtcbiAgICBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrKHR5cGUsIGxpc3RlbmVyLCBldmVudCwgZG9tSUQpO1xuICB9XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBudWxsO1xufVxuXG4vKipcbiAqIFN0YW5kYXJkL3NpbXBsZSBpdGVyYXRpb24gdGhyb3VnaCBhbiBldmVudCdzIGNvbGxlY3RlZCBkaXNwYXRjaGVzLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIoZXZlbnQsIHNpbXVsYXRlZCkge1xuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaElEcyA9IGV2ZW50Ll9kaXNwYXRjaElEcztcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBMaXN0ZW5lcnMgYW5kIElEcyBhcmUgdHdvIHBhcmFsbGVsIGFycmF5cyB0aGF0IGFyZSBhbHdheXMgaW4gc3luYy5cbiAgICAgIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBkaXNwYXRjaExpc3RlbmVyc1tpXSwgZGlzcGF0Y2hJRHNbaV0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChkaXNwYXRjaExpc3RlbmVycykge1xuICAgIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBkaXNwYXRjaExpc3RlbmVycywgZGlzcGF0Y2hJRHMpO1xuICB9XG4gIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaElEcyA9IG51bGw7XG59XG5cbi8qKlxuICogU3RhbmRhcmQvc2ltcGxlIGl0ZXJhdGlvbiB0aHJvdWdoIGFuIGV2ZW50J3MgY29sbGVjdGVkIGRpc3BhdGNoZXMsIGJ1dCBzdG9wc1xuICogYXQgdGhlIGZpcnN0IGRpc3BhdGNoIGV4ZWN1dGlvbiByZXR1cm5pbmcgdHJ1ZSwgYW5kIHJldHVybnMgdGhhdCBpZC5cbiAqXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBpZCBvZiB0aGUgZmlyc3QgZGlzcGF0Y2ggZXhlY3V0aW9uIHdobydzIGxpc3RlbmVyIHJldHVybnNcbiAqIHRydWUsIG9yIG51bGwgaWYgbm8gbGlzdGVuZXIgcmV0dXJuZWQgdHJ1ZS5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGwoZXZlbnQpIHtcbiAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICB2YXIgZGlzcGF0Y2hJRHMgPSBldmVudC5fZGlzcGF0Y2hJRHM7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMoZXZlbnQpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXJzKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gTGlzdGVuZXJzIGFuZCBJRHMgYXJlIHR3byBwYXJhbGxlbCBhcnJheXMgdGhhdCBhcmUgYWx3YXlzIGluIHN5bmMuXG4gICAgICBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnNbaV0oZXZlbnQsIGRpc3BhdGNoSURzW2ldKSkge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hJRHNbaV07XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKSB7XG4gICAgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKGV2ZW50LCBkaXNwYXRjaElEcykpIHtcbiAgICAgIHJldHVybiBkaXNwYXRjaElEcztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQHNlZSBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlSW1wbFxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlKGV2ZW50KSB7XG4gIHZhciByZXQgPSBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlSW1wbChldmVudCk7XG4gIGV2ZW50Ll9kaXNwYXRjaElEcyA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IG51bGw7XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogRXhlY3V0aW9uIG9mIGEgXCJkaXJlY3RcIiBkaXNwYXRjaCAtIHRoZXJlIG11c3QgYmUgYXQgbW9zdCBvbmUgZGlzcGF0Y2hcbiAqIGFjY3VtdWxhdGVkIG9uIHRoZSBldmVudCBvciBpdCBpcyBjb25zaWRlcmVkIGFuIGVycm9yLiBJdCBkb2Vzbid0IHJlYWxseSBtYWtlXG4gKiBzZW5zZSBmb3IgYW4gZXZlbnQgd2l0aCBtdWx0aXBsZSBkaXNwYXRjaGVzIChidWJibGVkKSB0byBrZWVwIHRyYWNrIG9mIHRoZVxuICogcmV0dXJuIHZhbHVlcyBhdCBlYWNoIGRpc3BhdGNoIGV4ZWN1dGlvbiwgYnV0IGl0IGRvZXMgdGVuZCB0byBtYWtlIHNlbnNlIHdoZW5cbiAqIGRlYWxpbmcgd2l0aCBcImRpcmVjdFwiIGRpc3BhdGNoZXMuXG4gKlxuICogQHJldHVybiB7Kn0gVGhlIHJldHVybiB2YWx1ZSBvZiBleGVjdXRpbmcgdGhlIHNpbmdsZSBkaXNwYXRjaC5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpcmVjdERpc3BhdGNoKGV2ZW50KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMoZXZlbnQpO1xuICB9XG4gIHZhciBkaXNwYXRjaExpc3RlbmVyID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICB2YXIgZGlzcGF0Y2hJRCA9IGV2ZW50Ll9kaXNwYXRjaElEcztcbiAgISFBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2V4ZWN1dGVEaXJlY3REaXNwYXRjaCguLi4pOiBJbnZhbGlkIGBldmVudGAuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICB2YXIgcmVzID0gZGlzcGF0Y2hMaXN0ZW5lciA/IGRpc3BhdGNoTGlzdGVuZXIoZXZlbnQsIGRpc3BhdGNoSUQpIDogbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoSURzID0gbnVsbDtcbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZmYgbnVtYmVyIG9mIGRpc3BhdGNoZXMgYWNjdW11bGF0ZWQgaXMgZ3JlYXRlciB0aGFuIDAuXG4gKi9cbmZ1bmN0aW9uIGhhc0Rpc3BhdGNoZXMoZXZlbnQpIHtcbiAgcmV0dXJuICEhZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xufVxuXG4vKipcbiAqIEdlbmVyYWwgdXRpbGl0aWVzIHRoYXQgYXJlIHVzZWZ1bCBpbiBjcmVhdGluZyBjdXN0b20gRXZlbnQgUGx1Z2lucy5cbiAqL1xudmFyIEV2ZW50UGx1Z2luVXRpbHMgPSB7XG4gIGlzRW5kaXNoOiBpc0VuZGlzaCxcbiAgaXNNb3ZlaXNoOiBpc01vdmVpc2gsXG4gIGlzU3RhcnRpc2g6IGlzU3RhcnRpc2gsXG5cbiAgZXhlY3V0ZURpcmVjdERpc3BhdGNoOiBleGVjdXRlRGlyZWN0RGlzcGF0Y2gsXG4gIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcjogZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyLFxuICBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlOiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlLFxuICBoYXNEaXNwYXRjaGVzOiBoYXNEaXNwYXRjaGVzLFxuXG4gIGdldE5vZGU6IGZ1bmN0aW9uIChpZCkge1xuICAgIHJldHVybiBpbmplY3Rpb24uTW91bnQuZ2V0Tm9kZShpZCk7XG4gIH0sXG4gIGdldElEOiBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBpbmplY3Rpb24uTW91bnQuZ2V0SUQobm9kZSk7XG4gIH0sXG5cbiAgaW5qZWN0aW9uOiBpbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQbHVnaW5VdGlscztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL0V2ZW50UGx1Z2luVXRpbHMuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFcnJvclV0aWxzXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhdWdodEVycm9yID0gbnVsbDtcblxuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gd2hpbGUgZ3VhcmRpbmcgYWdhaW5zdCBlcnJvcnMgdGhhdCBoYXBwZW5zIHdpdGhpbiBpdC5cbiAqXG4gKiBAcGFyYW0gez9TdHJpbmd9IG5hbWUgb2YgdGhlIGd1YXJkIHRvIHVzZSBmb3IgbG9nZ2luZyBvciBkZWJ1Z2dpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZVxuICogQHBhcmFtIHsqfSBhIEZpcnN0IGFyZ3VtZW50XG4gKiBAcGFyYW0geyp9IGIgU2Vjb25kIGFyZ3VtZW50XG4gKi9cbmZ1bmN0aW9uIGludm9rZUd1YXJkZWRDYWxsYmFjayhuYW1lLCBmdW5jLCBhLCBiKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZ1bmMoYSwgYik7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICBpZiAoY2F1Z2h0RXJyb3IgPT09IG51bGwpIHtcbiAgICAgIGNhdWdodEVycm9yID0geDtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG52YXIgUmVhY3RFcnJvclV0aWxzID0ge1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2s6IGludm9rZUd1YXJkZWRDYWxsYmFjayxcblxuICAvKipcbiAgICogSW52b2tlZCBieSBSZWFjdFRlc3RVdGlscy5TaW11bGF0ZSBzbyB0aGF0IGFueSBlcnJvcnMgdGhyb3duIGJ5IHRoZSBldmVudFxuICAgKiBoYW5kbGVyIGFyZSBzdXJlIHRvIGJlIHJldGhyb3duIGJ5IHJldGhyb3dDYXVnaHRFcnJvci5cbiAgICovXG4gIGludm9rZUd1YXJkZWRDYWxsYmFja1dpdGhDYXRjaDogaW52b2tlR3VhcmRlZENhbGxiYWNrLFxuXG4gIC8qKlxuICAgKiBEdXJpbmcgZXhlY3V0aW9uIG9mIGd1YXJkZWQgZnVuY3Rpb25zIHdlIHdpbGwgY2FwdHVyZSB0aGUgZmlyc3QgZXJyb3Igd2hpY2hcbiAgICogd2Ugd2lsbCByZXRocm93IHRvIGJlIGhhbmRsZWQgYnkgdGhlIHRvcCBsZXZlbCBlcnJvciBoYW5kbGVyLlxuICAgKi9cbiAgcmV0aHJvd0NhdWdodEVycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhdWdodEVycm9yKSB7XG4gICAgICB2YXIgZXJyb3IgPSBjYXVnaHRFcnJvcjtcbiAgICAgIGNhdWdodEVycm9yID0gbnVsbDtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxufTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgLyoqXG4gICAqIFRvIGhlbHAgZGV2ZWxvcG1lbnQgd2UgY2FuIGdldCBiZXR0ZXIgZGV2dG9vbHMgaW50ZWdyYXRpb24gYnkgc2ltdWxhdGluZyBhXG4gICAqIHJlYWwgYnJvd3NlciBldmVudC5cbiAgICovXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRpc3BhdGNoRXZlbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZmFrZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdyZWFjdCcpO1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiAobmFtZSwgZnVuYywgYSwgYikge1xuICAgICAgdmFyIGJvdW5kRnVuYyA9IGZ1bmMuYmluZChudWxsLCBhLCBiKTtcbiAgICAgIHZhciBldnRUeXBlID0gJ3JlYWN0LScgKyBuYW1lO1xuICAgICAgZmFrZU5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBib3VuZEZ1bmMsIGZhbHNlKTtcbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIGV2dC5pbml0RXZlbnQoZXZ0VHlwZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIGZha2VOb2RlLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICAgIGZha2VOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgYm91bmRGdW5jLCBmYWxzZSk7XG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RXJyb3JVdGlscztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RXJyb3JVdGlscy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBhY2N1bXVsYXRlSW50b1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqXG4gKiBBY2N1bXVsYXRlcyBpdGVtcyB0aGF0IG11c3Qgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkIGludG8gdGhlIGZpcnN0IG9uZS4gVGhpc1xuICogaXMgdXNlZCB0byBjb25zZXJ2ZSBtZW1vcnkgYnkgYXZvaWRpbmcgYXJyYXkgYWxsb2NhdGlvbnMsIGFuZCB0aHVzIHNhY3JpZmljZXNcbiAqIEFQSSBjbGVhbm5lc3MuIFNpbmNlIGBjdXJyZW50YCBjYW4gYmUgbnVsbCBiZWZvcmUgYmVpbmcgcGFzc2VkIGluIGFuZCBub3RcbiAqIG51bGwgYWZ0ZXIgdGhpcyBmdW5jdGlvbiwgbWFrZSBzdXJlIHRvIGFzc2lnbiBpdCBiYWNrIHRvIGBjdXJyZW50YDpcbiAqXG4gKiBgYSA9IGFjY3VtdWxhdGVJbnRvKGEsIGIpO2BcbiAqXG4gKiBUaGlzIEFQSSBzaG91bGQgYmUgc3BhcmluZ2x5IHVzZWQuIFRyeSBgYWNjdW11bGF0ZWAgZm9yIHNvbWV0aGluZyBjbGVhbmVyLlxuICpcbiAqIEByZXR1cm4geyp8YXJyYXk8Kj59IEFuIGFjY3VtdWxhdGlvbiBvZiBpdGVtcy5cbiAqL1xuXG5mdW5jdGlvbiBhY2N1bXVsYXRlSW50byhjdXJyZW50LCBuZXh0KSB7XG4gICEobmV4dCAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdhY2N1bXVsYXRlSW50byguLi4pOiBBY2N1bXVsYXRlZCBpdGVtcyBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIC8vIEJvdGggYXJlIG5vdCBlbXB0eS4gV2FybmluZzogTmV2ZXIgY2FsbCB4LmNvbmNhdCh5KSB3aGVuIHlvdSBhcmUgbm90XG4gIC8vIGNlcnRhaW4gdGhhdCB4IGlzIGFuIEFycmF5ICh4IGNvdWxkIGJlIGEgc3RyaW5nIHdpdGggY29uY2F0IG1ldGhvZCkuXG4gIHZhciBjdXJyZW50SXNBcnJheSA9IEFycmF5LmlzQXJyYXkoY3VycmVudCk7XG4gIHZhciBuZXh0SXNBcnJheSA9IEFycmF5LmlzQXJyYXkobmV4dCk7XG5cbiAgaWYgKGN1cnJlbnRJc0FycmF5ICYmIG5leHRJc0FycmF5KSB7XG4gICAgY3VycmVudC5wdXNoLmFwcGx5KGN1cnJlbnQsIG5leHQpO1xuICAgIHJldHVybiBjdXJyZW50O1xuICB9XG5cbiAgaWYgKGN1cnJlbnRJc0FycmF5KSB7XG4gICAgY3VycmVudC5wdXNoKG5leHQpO1xuICAgIHJldHVybiBjdXJyZW50O1xuICB9XG5cbiAgaWYgKG5leHRJc0FycmF5KSB7XG4gICAgLy8gQSBiaXQgdG9vIGRhbmdlcm91cyB0byBtdXRhdGUgYG5leHRgLlxuICAgIHJldHVybiBbY3VycmVudF0uY29uY2F0KG5leHQpO1xuICB9XG5cbiAgcmV0dXJuIFtjdXJyZW50LCBuZXh0XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhY2N1bXVsYXRlSW50bztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL2FjY3VtdWxhdGVJbnRvLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGZvckVhY2hBY2N1bXVsYXRlZFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAcGFyYW0ge2FycmF5fSBhcnIgYW4gXCJhY2N1bXVsYXRpb25cIiBvZiBpdGVtcyB3aGljaCBpcyBlaXRoZXIgYW4gQXJyYXkgb3JcbiAqIGEgc2luZ2xlIGl0ZW0uIFVzZWZ1bCB3aGVuIHBhaXJlZCB3aXRoIHRoZSBgYWNjdW11bGF0ZWAgbW9kdWxlLiBUaGlzIGlzIGFcbiAqIHNpbXBsZSB1dGlsaXR5IHRoYXQgYWxsb3dzIHVzIHRvIHJlYXNvbiBhYm91dCBhIGNvbGxlY3Rpb24gb2YgaXRlbXMsIGJ1dFxuICogaGFuZGxpbmcgdGhlIGNhc2Ugd2hlbiB0aGVyZSBpcyBleGFjdGx5IG9uZSBpdGVtIChhbmQgd2UgZG8gbm90IG5lZWQgdG9cbiAqIGFsbG9jYXRlIGFuIGFycmF5KS5cbiAqL1xudmFyIGZvckVhY2hBY2N1bXVsYXRlZCA9IGZ1bmN0aW9uIChhcnIsIGNiLCBzY29wZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgYXJyLmZvckVhY2goY2IsIHNjb3BlKTtcbiAgfSBlbHNlIGlmIChhcnIpIHtcbiAgICBjYi5jYWxsKHNjb3BlLCBhcnIpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZvckVhY2hBY2N1bXVsYXRlZDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL2ZvckVhY2hBY2N1bXVsYXRlZC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEV2ZW50RW1pdHRlck1peGluXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luSHViJyk7XG5cbmZ1bmN0aW9uIHJ1bkV2ZW50UXVldWVJbkJhdGNoKGV2ZW50cykge1xuICBFdmVudFBsdWdpbkh1Yi5lbnF1ZXVlRXZlbnRzKGV2ZW50cyk7XG4gIEV2ZW50UGx1Z2luSHViLnByb2Nlc3NFdmVudFF1ZXVlKGZhbHNlKTtcbn1cblxudmFyIFJlYWN0RXZlbnRFbWl0dGVyTWl4aW4gPSB7XG5cbiAgLyoqXG4gICAqIFN0cmVhbXMgYSBmaXJlZCB0b3AtbGV2ZWwgZXZlbnQgdG8gYEV2ZW50UGx1Z2luSHViYCB3aGVyZSBwbHVnaW5zIGhhdmUgdGhlXG4gICAqIG9wcG9ydHVuaXR5IHRvIGNyZWF0ZSBgUmVhY3RFdmVudGBzIHRvIGJlIGRpc3BhdGNoZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtvYmplY3R9IHRvcExldmVsVGFyZ2V0IFRoZSBsaXN0ZW5pbmcgY29tcG9uZW50IHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVGFyZ2V0SUQgSUQgb2YgYHRvcExldmVsVGFyZ2V0YC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBlbnZpcm9ubWVudCBldmVudC5cbiAgICovXG4gIGhhbmRsZVRvcExldmVsOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGV2ZW50cyA9IEV2ZW50UGx1Z2luSHViLmV4dHJhY3RFdmVudHModG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBydW5FdmVudFF1ZXVlSW5CYXRjaChldmVudHMpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RXZlbnRFbWl0dGVyTWl4aW47XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEV2ZW50RW1pdHRlck1peGluLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFZpZXdwb3J0TWV0cmljc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFZpZXdwb3J0TWV0cmljcyA9IHtcblxuICBjdXJyZW50U2Nyb2xsTGVmdDogMCxcblxuICBjdXJyZW50U2Nyb2xsVG9wOiAwLFxuXG4gIHJlZnJlc2hTY3JvbGxWYWx1ZXM6IGZ1bmN0aW9uIChzY3JvbGxQb3NpdGlvbikge1xuICAgIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsTGVmdCA9IHNjcm9sbFBvc2l0aW9uLng7XG4gICAgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxUb3AgPSBzY3JvbGxQb3NpdGlvbi55O1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmlld3BvcnRNZXRyaWNzO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvVmlld3BvcnRNZXRyaWNzLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIE9iamVjdC5hc3NpZ25cbiAqL1xuXG4vLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtb2JqZWN0LmFzc2lnblxuXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZXMpIHtcbiAgaWYgKHRhcmdldCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiB0YXJnZXQgY2Fubm90IGJlIG51bGwgb3IgdW5kZWZpbmVkJyk7XG4gIH1cblxuICB2YXIgdG8gPSBPYmplY3QodGFyZ2V0KTtcbiAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICBmb3IgKHZhciBuZXh0SW5kZXggPSAxOyBuZXh0SW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBuZXh0SW5kZXgrKykge1xuICAgIHZhciBuZXh0U291cmNlID0gYXJndW1lbnRzW25leHRJbmRleF07XG4gICAgaWYgKG5leHRTb3VyY2UgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGZyb20gPSBPYmplY3QobmV4dFNvdXJjZSk7XG5cbiAgICAvLyBXZSBkb24ndCBjdXJyZW50bHkgc3VwcG9ydCBhY2Nlc3NvcnMgbm9yIHByb3hpZXMuIFRoZXJlZm9yZSB0aGlzXG4gICAgLy8gY29weSBjYW5ub3QgdGhyb3cuIElmIHdlIGV2ZXIgc3VwcG9ydGVkIHRoaXMgdGhlbiB3ZSBtdXN0IGhhbmRsZVxuICAgIC8vIGV4Y2VwdGlvbnMgYW5kIHNpZGUtZWZmZWN0cy4gV2UgZG9uJ3Qgc3VwcG9ydCBzeW1ib2xzIHNvIHRoZXkgd29uJ3RcbiAgICAvLyBiZSB0cmFuc2ZlcnJlZC5cblxuICAgIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG4gICAgICAgIHRvW2tleV0gPSBmcm9tW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnbjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL09iamVjdC5hc3NpZ24uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaXNFdmVudFN1cHBvcnRlZFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIHVzZUhhc0ZlYXR1cmU7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHVzZUhhc0ZlYXR1cmUgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbiAmJiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlICYmXG4gIC8vIGFsd2F5cyByZXR1cm5zIHRydWUgaW4gbmV3ZXIgYnJvd3NlcnMgYXMgcGVyIHRoZSBzdGFuZGFyZC5cbiAgLy8gQHNlZSBodHRwOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWRvbWltcGxlbWVudGF0aW9uLWhhc2ZlYXR1cmVcbiAgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgnJywgJycpICE9PSB0cnVlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBldmVudCBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGVudmlyb25tZW50LlxuICpcbiAqIE5PVEU6IFRoaXMgd2lsbCBub3Qgd29yayBjb3JyZWN0bHkgZm9yIG5vbi1nZW5lcmljIGV2ZW50cyBzdWNoIGFzIGBjaGFuZ2VgLFxuICogYHJlc2V0YCwgYGxvYWRgLCBgZXJyb3JgLCBhbmQgYHNlbGVjdGAuXG4gKlxuICogQm9ycm93cyBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lU3VmZml4IEV2ZW50IG5hbWUsIGUuZy4gXCJjbGlja1wiLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gY2FwdHVyZSBDaGVjayBpZiB0aGUgY2FwdHVyZSBwaGFzZSBpcyBzdXBwb3J0ZWQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBpcyBzdXBwb3J0ZWQuXG4gKiBAaW50ZXJuYWxcbiAqIEBsaWNlbnNlIE1vZGVybml6ciAzLjAuMHByZSAoQ3VzdG9tIEJ1aWxkKSB8IE1JVFxuICovXG5mdW5jdGlvbiBpc0V2ZW50U3VwcG9ydGVkKGV2ZW50TmFtZVN1ZmZpeCwgY2FwdHVyZSkge1xuICBpZiAoIUV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSB8fCBjYXB0dXJlICYmICEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIGRvY3VtZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBldmVudE5hbWUgPSAnb24nICsgZXZlbnROYW1lU3VmZml4O1xuICB2YXIgaXNTdXBwb3J0ZWQgPSAoZXZlbnROYW1lIGluIGRvY3VtZW50KTtcblxuICBpZiAoIWlzU3VwcG9ydGVkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShldmVudE5hbWUsICdyZXR1cm47Jyk7XG4gICAgaXNTdXBwb3J0ZWQgPSB0eXBlb2YgZWxlbWVudFtldmVudE5hbWVdID09PSAnZnVuY3Rpb24nO1xuICB9XG5cbiAgaWYgKCFpc1N1cHBvcnRlZCAmJiB1c2VIYXNGZWF0dXJlICYmIGV2ZW50TmFtZVN1ZmZpeCA9PT0gJ3doZWVsJykge1xuICAgIC8vIFRoaXMgaXMgdGhlIG9ubHkgd2F5IHRvIHRlc3Qgc3VwcG9ydCBmb3IgdGhlIGB3aGVlbGAgZXZlbnQgaW4gSUU5Ky5cbiAgICBpc1N1cHBvcnRlZCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoJ0V2ZW50cy53aGVlbCcsICczLjAnKTtcbiAgfVxuXG4gIHJldHVybiBpc1N1cHBvcnRlZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0V2ZW50U3VwcG9ydGVkO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvaXNFdmVudFN1cHBvcnRlZC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUZlYXR1cmVGbGFnc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NRmVhdHVyZUZsYWdzID0ge1xuICB1c2VDcmVhdGVFbGVtZW50OiBmYWxzZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUZlYXR1cmVGbGFncztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NRmVhdHVyZUZsYWdzLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RWxlbWVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL2NhbkRlZmluZVByb3BlcnR5Jyk7XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudCB0eXBlLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2xbJ2ZvciddICYmIFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmVsZW1lbnQnKSB8fCAweGVhYzc7XG5cbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG5cbi8qKlxuICogQmFzZSBjb25zdHJ1Y3RvciBmb3IgYWxsIFJlYWN0IGVsZW1lbnRzLiBUaGlzIGlzIG9ubHkgdXNlZCB0byBtYWtlIHRoaXNcbiAqIHdvcmsgd2l0aCBhIGR5bmFtaWMgaW5zdGFuY2VvZiBjaGVjay4gTm90aGluZyBzaG91bGQgbGl2ZSBvbiB0aGlzIHByb3RvdHlwZS5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93IHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcblxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcblxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307XG5cbiAgICAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG4gICAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBzZWxmXG4gICAgICB9KTtcbiAgICAgIC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IHNvdXJjZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IGZhbHNlO1xuICAgICAgZWxlbWVudC5fc2VsZiA9IHNlbGY7XG4gICAgICBlbGVtZW50Ll9zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7XG5cbiAgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuICB2YXIgcHJvcHMgPSB7fTtcblxuICB2YXIga2V5ID0gbnVsbDtcbiAgdmFyIHJlZiA9IG51bGw7XG4gIHZhciBzZWxmID0gbnVsbDtcbiAgdmFyIHNvdXJjZSA9IG51bGw7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgcmVmID0gY29uZmlnLnJlZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5yZWY7XG4gICAga2V5ID0gY29uZmlnLmtleSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6ICcnICsgY29uZmlnLmtleTtcbiAgICBzZWxmID0gY29uZmlnLl9fc2VsZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NlbGY7XG4gICAgc291cmNlID0gY29uZmlnLl9fc291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc291cmNlO1xuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcbiAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wc1twcm9wTmFtZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG59O1xuXG5SZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHZhciBmYWN0b3J5ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQuYmluZChudWxsLCB0eXBlKTtcbiAgLy8gRXhwb3NlIHRoZSB0eXBlIG9uIHRoZSBmYWN0b3J5IGFuZCB0aGUgcHJvdG90eXBlIHNvIHRoYXQgaXQgY2FuIGJlXG4gIC8vIGVhc2lseSBhY2Nlc3NlZCBvbiBlbGVtZW50cy4gRS5nLiBgPEZvbyAvPi50eXBlID09PSBGb29gLlxuICAvLyBUaGlzIHNob3VsZCBub3QgYmUgbmFtZWQgYGNvbnN0cnVjdG9yYCBzaW5jZSB0aGlzIG1heSBub3QgYmUgdGhlIGZ1bmN0aW9uXG4gIC8vIHRoYXQgY3JlYXRlZCB0aGUgZWxlbWVudCwgYW5kIGl0IG1heSBub3QgZXZlbiBiZSBhIGNvbnN0cnVjdG9yLlxuICAvLyBMZWdhY3kgaG9vayBUT0RPOiBXYXJuIGlmIHRoaXMgaXMgYWNjZXNzZWRcbiAgZmFjdG9yeS50eXBlID0gdHlwZTtcbiAgcmV0dXJuIGZhY3Rvcnk7XG59O1xuXG5SZWFjdEVsZW1lbnQuY2xvbmVBbmRSZXBsYWNlS2V5ID0gZnVuY3Rpb24gKG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudChvbGRFbGVtZW50LnR5cGUsIG5ld0tleSwgb2xkRWxlbWVudC5yZWYsIG9sZEVsZW1lbnQuX3NlbGYsIG9sZEVsZW1lbnQuX3NvdXJjZSwgb2xkRWxlbWVudC5fb3duZXIsIG9sZEVsZW1lbnQucHJvcHMpO1xuXG4gIHJldHVybiBuZXdFbGVtZW50O1xufTtcblxuUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZVByb3BzID0gZnVuY3Rpb24gKG9sZEVsZW1lbnQsIG5ld1Byb3BzKSB7XG4gIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50KG9sZEVsZW1lbnQudHlwZSwgb2xkRWxlbWVudC5rZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBuZXdQcm9wcyk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBJZiB0aGUga2V5IG9uIHRoZSBvcmlnaW5hbCBpcyB2YWxpZCwgdGhlbiB0aGUgY2xvbmUgaXMgdmFsaWRcbiAgICBuZXdFbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSBvbGRFbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQ7XG4gIH1cblxuICByZXR1cm4gbmV3RWxlbWVudDtcbn07XG5cblJlYWN0RWxlbWVudC5jbG9uZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7XG5cbiAgLy8gT3JpZ2luYWwgcHJvcHMgYXJlIGNvcGllZFxuICB2YXIgcHJvcHMgPSBhc3NpZ24oe30sIGVsZW1lbnQucHJvcHMpO1xuXG4gIC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7XG4gIC8vIFNlbGYgaXMgcHJlc2VydmVkIHNpbmNlIHRoZSBvd25lciBpcyBwcmVzZXJ2ZWQuXG4gIHZhciBzZWxmID0gZWxlbWVudC5fc2VsZjtcbiAgLy8gU291cmNlIGlzIHByZXNlcnZlZCBzaW5jZSBjbG9uZUVsZW1lbnQgaXMgdW5saWtlbHkgdG8gYmUgdGFyZ2V0ZWQgYnkgYVxuICAvLyB0cmFuc3BpbGVyLCBhbmQgdGhlIG9yaWdpbmFsIHNvdXJjZSBpcyBwcm9iYWJseSBhIGJldHRlciBpbmRpY2F0b3Igb2YgdGhlXG4gIC8vIHRydWUgb3duZXIuXG4gIHZhciBzb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG5cbiAgLy8gT3duZXIgd2lsbCBiZSBwcmVzZXJ2ZWQsIHVubGVzcyByZWYgaXMgb3ZlcnJpZGRlblxuICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBTaWxlbnRseSBzdGVhbCB0aGUgcmVmIGZyb20gdGhlIHBhcmVudC5cbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgfVxuICAgIGlmIChjb25maWcua2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG4gICAgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgb3ZlcnJpZGUgZXhpc3RpbmcgcHJvcHNcbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQoZWxlbWVudC50eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIHZhbGlkIGNvbXBvbmVudC5cbiAqIEBmaW5hbFxuICovXG5SZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RWxlbWVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RWxlbWVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBjYW5EZWZpbmVQcm9wZXJ0eVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gZmFsc2U7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3gnLCB7IGdldDogZnVuY3Rpb24gKCkge30gfSk7XG4gICAgY2FuRGVmaW5lUHJvcGVydHkgPSB0cnVlO1xuICB9IGNhdGNoICh4KSB7XG4gICAgLy8gSUUgd2lsbCBmYWlsIG9uIGRlZmluZVByb3BlcnR5XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW5EZWZpbmVQcm9wZXJ0eTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL2NhbkRlZmluZVByb3BlcnR5LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RW1wdHlDb21wb25lbnRSZWdpc3RyeVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gVGhpcyByZWdpc3RyeSBrZWVwcyB0cmFjayBvZiB0aGUgUmVhY3QgSURzIG9mIHRoZSBjb21wb25lbnRzIHRoYXQgcmVuZGVyZWQgdG9cbi8vIGBudWxsYCAoaW4gcmVhbGl0eSBhIHBsYWNlaG9sZGVyIHN1Y2ggYXMgYG5vc2NyaXB0YClcbnZhciBudWxsQ29tcG9uZW50SURzUmVnaXN0cnkgPSB7fTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgQ29tcG9uZW50J3MgYF9yb290Tm9kZUlEYC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNvbXBvbmVudCBpcyByZW5kZXJlZCB0byBudWxsLlxuICovXG5mdW5jdGlvbiBpc051bGxDb21wb25lbnRJRChpZCkge1xuICByZXR1cm4gISFudWxsQ29tcG9uZW50SURzUmVnaXN0cnlbaWRdO1xufVxuXG4vKipcbiAqIE1hcmsgdGhlIGNvbXBvbmVudCBhcyBoYXZpbmcgcmVuZGVyZWQgdG8gbnVsbC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBDb21wb25lbnQncyBgX3Jvb3ROb2RlSURgLlxuICovXG5mdW5jdGlvbiByZWdpc3Rlck51bGxDb21wb25lbnRJRChpZCkge1xuICBudWxsQ29tcG9uZW50SURzUmVnaXN0cnlbaWRdID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBVbm1hcmsgdGhlIGNvbXBvbmVudCBhcyBoYXZpbmcgcmVuZGVyZWQgdG8gbnVsbDogaXQgcmVuZGVycyB0byBzb21ldGhpbmcgbm93LlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIENvbXBvbmVudCdzIGBfcm9vdE5vZGVJRGAuXG4gKi9cbmZ1bmN0aW9uIGRlcmVnaXN0ZXJOdWxsQ29tcG9uZW50SUQoaWQpIHtcbiAgZGVsZXRlIG51bGxDb21wb25lbnRJRHNSZWdpc3RyeVtpZF07XG59XG5cbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50UmVnaXN0cnkgPSB7XG4gIGlzTnVsbENvbXBvbmVudElEOiBpc051bGxDb21wb25lbnRJRCxcbiAgcmVnaXN0ZXJOdWxsQ29tcG9uZW50SUQ6IHJlZ2lzdGVyTnVsbENvbXBvbmVudElELFxuICBkZXJlZ2lzdGVyTnVsbENvbXBvbmVudElEOiBkZXJlZ2lzdGVyTnVsbENvbXBvbmVudElEXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RW1wdHlDb21wb25lbnRSZWdpc3RyeTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RW1wdHlDb21wb25lbnRSZWdpc3RyeS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEluc3RhbmNlSGFuZGxlc1xuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFJvb3RJbmRleCA9IHJlcXVpcmUoJy4vUmVhY3RSb290SW5kZXgnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgU0VQQVJBVE9SID0gJy4nO1xudmFyIFNFUEFSQVRPUl9MRU5HVEggPSBTRVBBUkFUT1IubGVuZ3RoO1xuXG4vKipcbiAqIE1heGltdW0gZGVwdGggb2YgdHJhdmVyc2FscyBiZWZvcmUgd2UgY29uc2lkZXIgdGhlIHBvc3NpYmlsaXR5IG9mIGEgYmFkIElELlxuICovXG52YXIgTUFYX1RSRUVfREVQVEggPSAxMDAwMDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgRE9NIElEIHByZWZpeCB0byB1c2Ugd2hlbiBtb3VudGluZyBSZWFjdCBjb21wb25lbnRzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBBIHVuaXF1ZSBpbnRlZ2VyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFJlYWN0IHJvb3QgSUQuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0UmVhY3RSb290SURTdHJpbmcoaW5kZXgpIHtcbiAgcmV0dXJuIFNFUEFSQVRPUiArIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBjaGFyYWN0ZXIgaW4gdGhlIHN1cHBsaWVkIElEIGlzIGEgc2VwYXJhdG9yIG9yIHRoZSBlbmQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIEEgUmVhY3QgRE9NIElELlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IG9mIHRoZSBjaGFyYWN0ZXIgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBjaGFyYWN0ZXIgaXMgYSBzZXBhcmF0b3Igb3IgZW5kIG9mIHRoZSBJRC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzQm91bmRhcnkoaWQsIGluZGV4KSB7XG4gIHJldHVybiBpZC5jaGFyQXQoaW5kZXgpID09PSBTRVBBUkFUT1IgfHwgaW5kZXggPT09IGlkLmxlbmd0aDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHN1cHBsaWVkIHN0cmluZyBpcyBhIHZhbGlkIFJlYWN0IERPTSBJRC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgQSBSZWFjdCBET00gSUQsIG1heWJlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3RyaW5nIGlzIGEgdmFsaWQgUmVhY3QgRE9NIElELlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZElEKGlkKSB7XG4gIHJldHVybiBpZCA9PT0gJycgfHwgaWQuY2hhckF0KDApID09PSBTRVBBUkFUT1IgJiYgaWQuY2hhckF0KGlkLmxlbmd0aCAtIDEpICE9PSBTRVBBUkFUT1I7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBmaXJzdCBJRCBpcyBhbiBhbmNlc3RvciBvZiBvciBlcXVhbCB0byB0aGUgc2Vjb25kIElELlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhbmNlc3RvcklEXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzY2VuZGFudElEXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBhbmNlc3RvcklEYCBpcyBhbiBhbmNlc3RvciBvZiBgZGVzY2VuZGFudElEYC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBpc0FuY2VzdG9ySURPZihhbmNlc3RvcklELCBkZXNjZW5kYW50SUQpIHtcbiAgcmV0dXJuIGRlc2NlbmRhbnRJRC5pbmRleE9mKGFuY2VzdG9ySUQpID09PSAwICYmIGlzQm91bmRhcnkoZGVzY2VuZGFudElELCBhbmNlc3RvcklELmxlbmd0aCk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgcGFyZW50IElEIG9mIHRoZSBzdXBwbGllZCBSZWFjdCBET00gSUQsIGBpZGAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIGEgY29tcG9uZW50LlxuICogQHJldHVybiB7c3RyaW5nfSBJRCBvZiB0aGUgcGFyZW50LCBvciBhbiBlbXB0eSBzdHJpbmcuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRQYXJlbnRJRChpZCkge1xuICByZXR1cm4gaWQgPyBpZC5zdWJzdHIoMCwgaWQubGFzdEluZGV4T2YoU0VQQVJBVE9SKSkgOiAnJztcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuZXh0IERPTSBJRCBvbiB0aGUgdHJlZSBwYXRoIGZyb20gdGhlIHN1cHBsaWVkIGBhbmNlc3RvcklEYCB0byB0aGVcbiAqIHN1cHBsaWVkIGBkZXN0aW5hdGlvbklEYC4gSWYgdGhleSBhcmUgZXF1YWwsIHRoZSBJRCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYW5jZXN0b3JJRCBJRCBvZiBhbiBhbmNlc3RvciBub2RlIG9mIGBkZXN0aW5hdGlvbklEYC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkZXN0aW5hdGlvbklEIElEIG9mIHRoZSBkZXN0aW5hdGlvbiBub2RlLlxuICogQHJldHVybiB7c3RyaW5nfSBOZXh0IElEIG9uIHRoZSBwYXRoIGZyb20gYGFuY2VzdG9ySURgIHRvIGBkZXN0aW5hdGlvbklEYC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldE5leHREZXNjZW5kYW50SUQoYW5jZXN0b3JJRCwgZGVzdGluYXRpb25JRCkge1xuICAhKGlzVmFsaWRJRChhbmNlc3RvcklEKSAmJiBpc1ZhbGlkSUQoZGVzdGluYXRpb25JRCkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2dldE5leHREZXNjZW5kYW50SUQoJXMsICVzKTogUmVjZWl2ZWQgYW4gaW52YWxpZCBSZWFjdCBET00gSUQuJywgYW5jZXN0b3JJRCwgZGVzdGluYXRpb25JRCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAhaXNBbmNlc3RvcklET2YoYW5jZXN0b3JJRCwgZGVzdGluYXRpb25JRCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZ2V0TmV4dERlc2NlbmRhbnRJRCguLi4pOiBSZWFjdCBoYXMgbWFkZSBhbiBpbnZhbGlkIGFzc3VtcHRpb24gYWJvdXQgJyArICd0aGUgRE9NIGhpZXJhcmNoeS4gRXhwZWN0ZWQgYCVzYCB0byBiZSBhbiBhbmNlc3RvciBvZiBgJXNgLicsIGFuY2VzdG9ySUQsIGRlc3RpbmF0aW9uSUQpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgaWYgKGFuY2VzdG9ySUQgPT09IGRlc3RpbmF0aW9uSUQpIHtcbiAgICByZXR1cm4gYW5jZXN0b3JJRDtcbiAgfVxuICAvLyBTa2lwIG92ZXIgdGhlIGFuY2VzdG9yIGFuZCB0aGUgaW1tZWRpYXRlIHNlcGFyYXRvci4gVHJhdmVyc2UgdW50aWwgd2UgaGl0XG4gIC8vIGFub3RoZXIgc2VwYXJhdG9yIG9yIHdlIHJlYWNoIHRoZSBlbmQgb2YgYGRlc3RpbmF0aW9uSURgLlxuICB2YXIgc3RhcnQgPSBhbmNlc3RvcklELmxlbmd0aCArIFNFUEFSQVRPUl9MRU5HVEg7XG4gIHZhciBpO1xuICBmb3IgKGkgPSBzdGFydDsgaSA8IGRlc3RpbmF0aW9uSUQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaXNCb3VuZGFyeShkZXN0aW5hdGlvbklELCBpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZXN0aW5hdGlvbklELnN1YnN0cigwLCBpKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuZWFyZXN0IGNvbW1vbiBhbmNlc3RvciBJRCBvZiB0d28gSURzLlxuICpcbiAqIFVzaW5nIHRoaXMgSUQgc2NoZW1lLCB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgSUQgaXMgdGhlIGxvbmdlc3QgY29tbW9uXG4gKiBwcmVmaXggb2YgdGhlIHR3byBJRHMgdGhhdCBpbW1lZGlhdGVseSBwcmVjZWRlZCBhIFwibWFya2VyXCIgaW4gYm90aCBzdHJpbmdzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBvbmVJRFxuICogQHBhcmFtIHtzdHJpbmd9IHR3b0lEXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIElELCBvciB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vbmUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRGaXJzdENvbW1vbkFuY2VzdG9ySUQob25lSUQsIHR3b0lEKSB7XG4gIHZhciBtaW5MZW5ndGggPSBNYXRoLm1pbihvbmVJRC5sZW5ndGgsIHR3b0lELmxlbmd0aCk7XG4gIGlmIChtaW5MZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgdmFyIGxhc3RDb21tb25NYXJrZXJJbmRleCA9IDA7XG4gIC8vIFVzZSBgPD1gIHRvIHRyYXZlcnNlIHVudGlsIHRoZSBcIkVPTFwiIG9mIHRoZSBzaG9ydGVyIHN0cmluZy5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbWluTGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaXNCb3VuZGFyeShvbmVJRCwgaSkgJiYgaXNCb3VuZGFyeSh0d29JRCwgaSkpIHtcbiAgICAgIGxhc3RDb21tb25NYXJrZXJJbmRleCA9IGk7XG4gICAgfSBlbHNlIGlmIChvbmVJRC5jaGFyQXQoaSkgIT09IHR3b0lELmNoYXJBdChpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHZhciBsb25nZXN0Q29tbW9uSUQgPSBvbmVJRC5zdWJzdHIoMCwgbGFzdENvbW1vbk1hcmtlckluZGV4KTtcbiAgIWlzVmFsaWRJRChsb25nZXN0Q29tbW9uSUQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2dldEZpcnN0Q29tbW9uQW5jZXN0b3JJRCglcywgJXMpOiBFeHBlY3RlZCBhIHZhbGlkIFJlYWN0IERPTSBJRDogJXMnLCBvbmVJRCwgdHdvSUQsIGxvbmdlc3RDb21tb25JRCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbG9uZ2VzdENvbW1vbklEO1xufVxuXG4vKipcbiAqIFRyYXZlcnNlcyB0aGUgcGFyZW50IHBhdGggYmV0d2VlbiB0d28gSURzIChlaXRoZXIgdXAgb3IgZG93bikuIFRoZSBJRHMgbXVzdFxuICogbm90IGJlIHRoZSBzYW1lLCBhbmQgdGhlcmUgbXVzdCBleGlzdCBhIHBhcmVudCBwYXRoIGJldHdlZW4gdGhlbS4gSWYgdGhlXG4gKiBjYWxsYmFjayByZXR1cm5zIGBmYWxzZWAsIHRyYXZlcnNhbCBpcyBzdG9wcGVkLlxuICpcbiAqIEBwYXJhbSB7P3N0cmluZ30gc3RhcnQgSUQgYXQgd2hpY2ggdG8gc3RhcnQgdHJhdmVyc2FsLlxuICogQHBhcmFtIHs/c3RyaW5nfSBzdG9wIElEIGF0IHdoaWNoIHRvIGVuZCB0cmF2ZXJzYWwuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiBDYWxsYmFjayB0byBpbnZva2UgZWFjaCBJRCB3aXRoLlxuICogQHBhcmFtIHsqfSBhcmcgQXJndW1lbnQgdG8gaW52b2tlIHRoZSBjYWxsYmFjayB3aXRoLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gc2tpcEZpcnN0IFdoZXRoZXIgb3Igbm90IHRvIHNraXAgdGhlIGZpcnN0IG5vZGUuXG4gKiBAcGFyYW0gez9ib29sZWFufSBza2lwTGFzdCBXaGV0aGVyIG9yIG5vdCB0byBza2lwIHRoZSBsYXN0IG5vZGUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZVBhcmVudFBhdGgoc3RhcnQsIHN0b3AsIGNiLCBhcmcsIHNraXBGaXJzdCwgc2tpcExhc3QpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAnJztcbiAgc3RvcCA9IHN0b3AgfHwgJyc7XG4gICEoc3RhcnQgIT09IHN0b3ApID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RyYXZlcnNlUGFyZW50UGF0aCguLi4pOiBDYW5ub3QgdHJhdmVyc2UgZnJvbSBhbmQgdG8gdGhlIHNhbWUgSUQsIGAlc2AuJywgc3RhcnQpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgdmFyIHRyYXZlcnNlVXAgPSBpc0FuY2VzdG9ySURPZihzdG9wLCBzdGFydCk7XG4gICEodHJhdmVyc2VVcCB8fCBpc0FuY2VzdG9ySURPZihzdGFydCwgc3RvcCkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RyYXZlcnNlUGFyZW50UGF0aCglcywgJXMsIC4uLik6IENhbm5vdCB0cmF2ZXJzZSBmcm9tIHR3byBJRHMgdGhhdCBkbyAnICsgJ25vdCBoYXZlIGEgcGFyZW50IHBhdGguJywgc3RhcnQsIHN0b3ApIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgLy8gVHJhdmVyc2UgZnJvbSBgc3RhcnRgIHRvIGBzdG9wYCBvbmUgZGVwdGggYXQgYSB0aW1lLlxuICB2YXIgZGVwdGggPSAwO1xuICB2YXIgdHJhdmVyc2UgPSB0cmF2ZXJzZVVwID8gZ2V0UGFyZW50SUQgOiBnZXROZXh0RGVzY2VuZGFudElEO1xuICBmb3IgKHZhciBpZCA9IHN0YXJ0OzsgLyogdW50aWwgYnJlYWsgKi9pZCA9IHRyYXZlcnNlKGlkLCBzdG9wKSkge1xuICAgIHZhciByZXQ7XG4gICAgaWYgKCghc2tpcEZpcnN0IHx8IGlkICE9PSBzdGFydCkgJiYgKCFza2lwTGFzdCB8fCBpZCAhPT0gc3RvcCkpIHtcbiAgICAgIHJldCA9IGNiKGlkLCB0cmF2ZXJzZVVwLCBhcmcpO1xuICAgIH1cbiAgICBpZiAocmV0ID09PSBmYWxzZSB8fCBpZCA9PT0gc3RvcCkge1xuICAgICAgLy8gT25seSBicmVhayAvL2FmdGVyLy8gdmlzaXRpbmcgYHN0b3BgLlxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICEoZGVwdGgrKyA8IE1BWF9UUkVFX0RFUFRIKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0cmF2ZXJzZVBhcmVudFBhdGgoJXMsICVzLCAuLi4pOiBEZXRlY3RlZCBhbiBpbmZpbml0ZSBsb29wIHdoaWxlICcgKyAndHJhdmVyc2luZyB0aGUgUmVhY3QgRE9NIElEIHRyZWUuIFRoaXMgbWF5IGJlIGR1ZSB0byBtYWxmb3JtZWQgSURzOiAlcycsIHN0YXJ0LCBzdG9wLCBpZCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogTWFuYWdlcyB0aGUgSURzIGFzc2lnbmVkIHRvIERPTSByZXByZXNlbnRhdGlvbnMgb2YgUmVhY3QgY29tcG9uZW50cy4gVGhpc1xuICogdXNlcyBhIHNwZWNpZmljIHNjaGVtZSBpbiBvcmRlciB0byB0cmF2ZXJzZSB0aGUgRE9NIGVmZmljaWVudGx5IChlLmcuIGluXG4gKiBvcmRlciB0byBzaW11bGF0ZSBldmVudHMpLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RJbnN0YW5jZUhhbmRsZXMgPSB7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBSZWFjdCByb290IElEXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQSBSZWFjdCByb290IElELlxuICAgKi9cbiAgY3JlYXRlUmVhY3RSb290SUQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0UmVhY3RSb290SURTdHJpbmcoUmVhY3RSb290SW5kZXguY3JlYXRlUmVhY3RSb290SW5kZXgoKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBSZWFjdCBJRCBieSBqb2luaW5nIGEgcm9vdCBJRCB3aXRoIGEgbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJvb3RJRCBSb290IElEIG9mIGEgcGFyZW50IGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQSBjb21wb25lbnQncyBuYW1lIChhcyBmbGF0dGVuZWQgY2hpbGRyZW4pLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEEgUmVhY3QgSUQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY3JlYXRlUmVhY3RJRDogZnVuY3Rpb24gKHJvb3RJRCwgbmFtZSkge1xuICAgIHJldHVybiByb290SUQgKyBuYW1lO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBET00gSUQgb2YgdGhlIFJlYWN0IGNvbXBvbmVudCB0aGF0IGlzIHRoZSByb290IG9mIHRoZSB0cmVlIHRoYXRcbiAgICogY29udGFpbnMgdGhlIFJlYWN0IGNvbXBvbmVudCB3aXRoIHRoZSBzdXBwbGllZCBET00gSUQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBET00gSUQgb2YgYSBSZWFjdCBjb21wb25lbnQuXG4gICAqIEByZXR1cm4gez9zdHJpbmd9IERPTSBJRCBvZiB0aGUgUmVhY3QgY29tcG9uZW50IHRoYXQgaXMgdGhlIHJvb3QuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0UmVhY3RSb290SURGcm9tTm9kZUlEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICBpZiAoaWQgJiYgaWQuY2hhckF0KDApID09PSBTRVBBUkFUT1IgJiYgaWQubGVuZ3RoID4gMSkge1xuICAgICAgdmFyIGluZGV4ID0gaWQuaW5kZXhPZihTRVBBUkFUT1IsIDEpO1xuICAgICAgcmV0dXJuIGluZGV4ID4gLTEgPyBpZC5zdWJzdHIoMCwgaW5kZXgpIDogaWQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmF2ZXJzZXMgdGhlIElEIGhpZXJhcmNoeSBhbmQgaW52b2tlcyB0aGUgc3VwcGxpZWQgYGNiYCBvbiBhbnkgSURzIHRoYXRcbiAgICogc2hvdWxkIHdvdWxkIHJlY2VpdmUgYSBgbW91c2VFbnRlcmAgb3IgYG1vdXNlTGVhdmVgIGV2ZW50LlxuICAgKlxuICAgKiBOT1RFOiBEb2VzIG5vdCBpbnZva2UgdGhlIGNhbGxiYWNrIG9uIHRoZSBuZWFyZXN0IGNvbW1vbiBhbmNlc3RvciBiZWNhdXNlXG4gICAqIG5vdGhpbmcgXCJlbnRlcmVkXCIgb3IgXCJsZWZ0XCIgdGhhdCBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGVhdmVJRCBJRCBiZWluZyBsZWZ0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZW50ZXJJRCBJRCBiZWluZyBlbnRlcmVkLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiBDYWxsYmFjayB0byBpbnZva2Ugb24gZWFjaCBlbnRlcmVkL2xlZnQgSUQuXG4gICAqIEBwYXJhbSB7Kn0gdXBBcmcgQXJndW1lbnQgdG8gaW52b2tlIHRoZSBjYWxsYmFjayB3aXRoIG9uIGxlZnQgSURzLlxuICAgKiBAcGFyYW0geyp9IGRvd25BcmcgQXJndW1lbnQgdG8gaW52b2tlIHRoZSBjYWxsYmFjayB3aXRoIG9uIGVudGVyZWQgSURzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRyYXZlcnNlRW50ZXJMZWF2ZTogZnVuY3Rpb24gKGxlYXZlSUQsIGVudGVySUQsIGNiLCB1cEFyZywgZG93bkFyZykge1xuICAgIHZhciBhbmNlc3RvcklEID0gZ2V0Rmlyc3RDb21tb25BbmNlc3RvcklEKGxlYXZlSUQsIGVudGVySUQpO1xuICAgIGlmIChhbmNlc3RvcklEICE9PSBsZWF2ZUlEKSB7XG4gICAgICB0cmF2ZXJzZVBhcmVudFBhdGgobGVhdmVJRCwgYW5jZXN0b3JJRCwgY2IsIHVwQXJnLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChhbmNlc3RvcklEICE9PSBlbnRlcklEKSB7XG4gICAgICB0cmF2ZXJzZVBhcmVudFBhdGgoYW5jZXN0b3JJRCwgZW50ZXJJRCwgY2IsIGRvd25BcmcsIHRydWUsIGZhbHNlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNpbXVsYXRlcyB0aGUgdHJhdmVyc2FsIG9mIGEgdHdvLXBoYXNlLCBjYXB0dXJlL2J1YmJsZSBldmVudCBkaXNwYXRjaC5cbiAgICpcbiAgICogTk9URTogVGhpcyB0cmF2ZXJzYWwgaGFwcGVucyBvbiBJRHMgd2l0aG91dCB0b3VjaGluZyB0aGUgRE9NLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0SUQgSUQgb2YgdGhlIHRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiBDYWxsYmFjayB0byBpbnZva2UuXG4gICAqIEBwYXJhbSB7Kn0gYXJnIEFyZ3VtZW50IHRvIGludm9rZSB0aGUgY2FsbGJhY2sgd2l0aC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB0cmF2ZXJzZVR3b1BoYXNlOiBmdW5jdGlvbiAodGFyZ2V0SUQsIGNiLCBhcmcpIHtcbiAgICBpZiAodGFyZ2V0SUQpIHtcbiAgICAgIHRyYXZlcnNlUGFyZW50UGF0aCgnJywgdGFyZ2V0SUQsIGNiLCBhcmcsIHRydWUsIGZhbHNlKTtcbiAgICAgIHRyYXZlcnNlUGFyZW50UGF0aCh0YXJnZXRJRCwgJycsIGNiLCBhcmcsIGZhbHNlLCB0cnVlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNhbWUgYXMgYHRyYXZlcnNlVHdvUGhhc2VgIGJ1dCBza2lwcyB0aGUgYHRhcmdldElEYC5cbiAgICovXG4gIHRyYXZlcnNlVHdvUGhhc2VTa2lwVGFyZ2V0OiBmdW5jdGlvbiAodGFyZ2V0SUQsIGNiLCBhcmcpIHtcbiAgICBpZiAodGFyZ2V0SUQpIHtcbiAgICAgIHRyYXZlcnNlUGFyZW50UGF0aCgnJywgdGFyZ2V0SUQsIGNiLCBhcmcsIHRydWUsIHRydWUpO1xuICAgICAgdHJhdmVyc2VQYXJlbnRQYXRoKHRhcmdldElELCAnJywgY2IsIGFyZywgdHJ1ZSwgdHJ1ZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBUcmF2ZXJzZSBhIG5vZGUgSUQsIGNhbGxpbmcgdGhlIHN1cHBsaWVkIGBjYmAgZm9yIGVhY2ggYW5jZXN0b3IgSUQuIEZvclxuICAgKiBleGFtcGxlLCBwYXNzaW5nIGAuMC4kcm93LTAuMWAgd291bGQgcmVzdWx0IGluIGBjYmAgZ2V0dGluZyBjYWxsZWRcbiAgICogd2l0aCBgLjBgLCBgLjAuJHJvdy0wYCwgYW5kIGAuMC4kcm93LTAuMWAuXG4gICAqXG4gICAqIE5PVEU6IFRoaXMgdHJhdmVyc2FsIGhhcHBlbnMgb24gSURzIHdpdGhvdXQgdG91Y2hpbmcgdGhlIERPTS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldElEIElEIG9mIHRoZSB0YXJnZXQgbm9kZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgQ2FsbGJhY2sgdG8gaW52b2tlLlxuICAgKiBAcGFyYW0geyp9IGFyZyBBcmd1bWVudCB0byBpbnZva2UgdGhlIGNhbGxiYWNrIHdpdGguXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdHJhdmVyc2VBbmNlc3RvcnM6IGZ1bmN0aW9uICh0YXJnZXRJRCwgY2IsIGFyZykge1xuICAgIHRyYXZlcnNlUGFyZW50UGF0aCgnJywgdGFyZ2V0SUQsIGNiLCBhcmcsIHRydWUsIGZhbHNlKTtcbiAgfSxcblxuICBnZXRGaXJzdENvbW1vbkFuY2VzdG9ySUQ6IGdldEZpcnN0Q29tbW9uQW5jZXN0b3JJRCxcblxuICAvKipcbiAgICogRXhwb3NlZCBmb3IgdW5pdCB0ZXN0aW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldE5leHREZXNjZW5kYW50SUQ6IGdldE5leHREZXNjZW5kYW50SUQsXG5cbiAgaXNBbmNlc3RvcklET2Y6IGlzQW5jZXN0b3JJRE9mLFxuXG4gIFNFUEFSQVRPUjogU0VQQVJBVE9SXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RJbnN0YW5jZUhhbmRsZXM7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEluc3RhbmNlSGFuZGxlcy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFJvb3RJbmRleFxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFJvb3RJbmRleEluamVjdGlvbiA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IF9jcmVhdGVSZWFjdFJvb3RJbmRleFxuICAgKi9cbiAgaW5qZWN0Q3JlYXRlUmVhY3RSb290SW5kZXg6IGZ1bmN0aW9uIChfY3JlYXRlUmVhY3RSb290SW5kZXgpIHtcbiAgICBSZWFjdFJvb3RJbmRleC5jcmVhdGVSZWFjdFJvb3RJbmRleCA9IF9jcmVhdGVSZWFjdFJvb3RJbmRleDtcbiAgfVxufTtcblxudmFyIFJlYWN0Um9vdEluZGV4ID0ge1xuICBjcmVhdGVSZWFjdFJvb3RJbmRleDogbnVsbCxcbiAgaW5qZWN0aW9uOiBSZWFjdFJvb3RJbmRleEluamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFJvb3RJbmRleDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Um9vdEluZGV4LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0SW5zdGFuY2VNYXBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogYFJlYWN0SW5zdGFuY2VNYXBgIG1haW50YWlucyBhIG1hcHBpbmcgZnJvbSBhIHB1YmxpYyBmYWNpbmcgc3RhdGVmdWxcbiAqIGluc3RhbmNlIChrZXkpIGFuZCB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gKHZhbHVlKS4gVGhpcyBhbGxvd3MgcHVibGljXG4gKiBtZXRob2RzIHRvIGFjY2VwdCB0aGUgdXNlciBmYWNpbmcgaW5zdGFuY2UgYXMgYW4gYXJndW1lbnQgYW5kIG1hcCB0aGVtIGJhY2tcbiAqIHRvIGludGVybmFsIG1ldGhvZHMuXG4gKi9cblxuLy8gVE9ETzogUmVwbGFjZSB0aGlzIHdpdGggRVM2OiB2YXIgUmVhY3RJbnN0YW5jZU1hcCA9IG5ldyBNYXAoKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0ge1xuXG4gIC8qKlxuICAgKiBUaGlzIEFQSSBzaG91bGQgYmUgY2FsbGVkIGBkZWxldGVgIGJ1dCB3ZSdkIGhhdmUgdG8gbWFrZSBzdXJlIHRvIGFsd2F5c1xuICAgKiB0cmFuc2Zvcm0gdGhlc2UgdG8gc3RyaW5ncyBmb3IgSUUgc3VwcG9ydC4gV2hlbiB0aGlzIHRyYW5zZm9ybSBpcyBmdWxseVxuICAgKiBzdXBwb3J0ZWQgd2UgY2FuIHJlbmFtZSBpdC5cbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gKGtleSkge1xuICAgIGtleS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICB9LFxuXG4gIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZTtcbiAgfSxcblxuICBoYXM6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgIT09IHVuZGVmaW5lZDtcbiAgfSxcblxuICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgPSB2YWx1ZTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5zdGFuY2VNYXA7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEluc3RhbmNlTWFwLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0TWFya3VwQ2hlY2tzdW1cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhZGxlcjMyID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG5cbnZhciBUQUdfRU5EID0gL1xcLz8+LztcblxudmFyIFJlYWN0TWFya3VwQ2hlY2tzdW0gPSB7XG4gIENIRUNLU1VNX0FUVFJfTkFNRTogJ2RhdGEtcmVhY3QtY2hlY2tzdW0nLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCBzdHJpbmdcbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgc3RyaW5nIHdpdGggY2hlY2tzdW0gYXR0cmlidXRlIGF0dGFjaGVkXG4gICAqL1xuICBhZGRDaGVja3N1bVRvTWFya3VwOiBmdW5jdGlvbiAobWFya3VwKSB7XG4gICAgdmFyIGNoZWNrc3VtID0gYWRsZXIzMihtYXJrdXApO1xuXG4gICAgLy8gQWRkIGNoZWNrc3VtIChoYW5kbGUgYm90aCBwYXJlbnQgdGFncyBhbmQgc2VsZi1jbG9zaW5nIHRhZ3MpXG4gICAgcmV0dXJuIG1hcmt1cC5yZXBsYWNlKFRBR19FTkQsICcgJyArIFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FICsgJz1cIicgKyBjaGVja3N1bSArICdcIiQmJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgdG8gdXNlXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudCByb290IFJlYWN0IGVsZW1lbnRcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgb3Igbm90IHRoZSBtYXJrdXAgaXMgdGhlIHNhbWVcbiAgICovXG4gIGNhblJldXNlTWFya3VwOiBmdW5jdGlvbiAobWFya3VwLCBlbGVtZW50KSB7XG4gICAgdmFyIGV4aXN0aW5nQ2hlY2tzdW0gPSBlbGVtZW50LmdldEF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSk7XG4gICAgZXhpc3RpbmdDaGVja3N1bSA9IGV4aXN0aW5nQ2hlY2tzdW0gJiYgcGFyc2VJbnQoZXhpc3RpbmdDaGVja3N1bSwgMTApO1xuICAgIHZhciBtYXJrdXBDaGVja3N1bSA9IGFkbGVyMzIobWFya3VwKTtcbiAgICByZXR1cm4gbWFya3VwQ2hlY2tzdW0gPT09IGV4aXN0aW5nQ2hlY2tzdW07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNYXJrdXBDaGVja3N1bTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0TWFya3VwQ2hlY2tzdW0uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgYWRsZXIzMlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIE1PRCA9IDY1NTIxO1xuXG4vLyBhZGxlcjMyIGlzIG5vdCBjcnlwdG9ncmFwaGljYWxseSBzdHJvbmcsIGFuZCBpcyBvbmx5IHVzZWQgdG8gc2FuaXR5IGNoZWNrIHRoYXRcbi8vIG1hcmt1cCBnZW5lcmF0ZWQgb24gdGhlIHNlcnZlciBtYXRjaGVzIHRoZSBtYXJrdXAgZ2VuZXJhdGVkIG9uIHRoZSBjbGllbnQuXG4vLyBUaGlzIGltcGxlbWVudGF0aW9uIChhIG1vZGlmaWVkIHZlcnNpb24gb2YgdGhlIFNoZWV0SlMgdmVyc2lvbikgaGFzIGJlZW4gb3B0aW1pemVkXG4vLyBmb3Igb3VyIHVzZSBjYXNlLCBhdCB0aGUgZXhwZW5zZSBvZiBjb25mb3JtaW5nIHRvIHRoZSBhZGxlcjMyIHNwZWNpZmljYXRpb25cbi8vIGZvciBub24tYXNjaWkgaW5wdXRzLlxuZnVuY3Rpb24gYWRsZXIzMihkYXRhKSB7XG4gIHZhciBhID0gMTtcbiAgdmFyIGIgPSAwO1xuICB2YXIgaSA9IDA7XG4gIHZhciBsID0gZGF0YS5sZW5ndGg7XG4gIHZhciBtID0gbCAmIH4weDM7XG4gIHdoaWxlIChpIDwgbSkge1xuICAgIGZvciAoOyBpIDwgTWF0aC5taW4oaSArIDQwOTYsIG0pOyBpICs9IDQpIHtcbiAgICAgIGIgKz0gKGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkpKSArIChhICs9IGRhdGEuY2hhckNvZGVBdChpICsgMSkpICsgKGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkgKyAyKSkgKyAoYSArPSBkYXRhLmNoYXJDb2RlQXQoaSArIDMpKTtcbiAgICB9XG4gICAgYSAlPSBNT0Q7XG4gICAgYiAlPSBNT0Q7XG4gIH1cbiAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICBiICs9IGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIGEgJT0gTU9EO1xuICBiICU9IE1PRDtcbiAgcmV0dXJuIGEgfCBiIDw8IDE2O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkbGVyMzI7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9hZGxlcjMyLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UmVjb25jaWxlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UmVmID0gcmVxdWlyZSgnLi9SZWFjdFJlZicpO1xuXG4vKipcbiAqIEhlbHBlciB0byBjYWxsIFJlYWN0UmVmLmF0dGFjaFJlZnMgd2l0aCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQsIHNwbGl0IG91dFxuICogdG8gYXZvaWQgYWxsb2NhdGlvbnMgaW4gdGhlIHRyYW5zYWN0aW9uIG1vdW50LXJlYWR5IHF1ZXVlLlxuICovXG5mdW5jdGlvbiBhdHRhY2hSZWZzKCkge1xuICBSZWFjdFJlZi5hdHRhY2hSZWZzKHRoaXMsIHRoaXMuX2N1cnJlbnRFbGVtZW50KTtcbn1cblxudmFyIFJlYWN0UmVjb25jaWxlciA9IHtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbXBvbmVudCwgcmVuZGVycyBtYXJrdXAsIGFuZCByZWdpc3RlcnMgZXZlbnQgbGlzdGVuZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnRlcm5hbEluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb290SUQgRE9NIElEIG9mIHRoZSByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBSZW5kZXJlZCBtYXJrdXAgdG8gYmUgaW5zZXJ0ZWQgaW50byB0aGUgRE9NLlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgbWFya3VwID0gaW50ZXJuYWxJbnN0YW5jZS5tb3VudENvbXBvbmVudChyb290SUQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQgJiYgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQucmVmICE9IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoYXR0YWNoUmVmcywgaW50ZXJuYWxJbnN0YW5jZSk7XG4gICAgfVxuICAgIHJldHVybiBtYXJrdXA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIGFueSByZXNvdXJjZXMgYWxsb2NhdGVkIGJ5IGBtb3VudENvbXBvbmVudGAuXG4gICAqXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgUmVhY3RSZWYuZGV0YWNoUmVmcyhpbnRlcm5hbEluc3RhbmNlLCBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCk7XG4gICAgaW50ZXJuYWxJbnN0YW5jZS51bm1vdW50Q29tcG9uZW50KCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhIGNvbXBvbmVudCB1c2luZyBhIG5ldyBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnRlcm5hbEluc3RhbmNlXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBwcmV2RWxlbWVudCA9IGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50O1xuXG4gICAgaWYgKG5leHRFbGVtZW50ID09PSBwcmV2RWxlbWVudCAmJiBjb250ZXh0ID09PSBpbnRlcm5hbEluc3RhbmNlLl9jb250ZXh0KSB7XG4gICAgICAvLyBTaW5jZSBlbGVtZW50cyBhcmUgaW1tdXRhYmxlIGFmdGVyIHRoZSBvd25lciBpcyByZW5kZXJlZCxcbiAgICAgIC8vIHdlIGNhbiBkbyBhIGNoZWFwIGlkZW50aXR5IGNvbXBhcmUgaGVyZSB0byBkZXRlcm1pbmUgaWYgdGhpcyBpcyBhXG4gICAgICAvLyBzdXBlcmZsdW91cyByZWNvbmNpbGUuIEl0J3MgcG9zc2libGUgZm9yIHN0YXRlIHRvIGJlIG11dGFibGUgYnV0IHN1Y2hcbiAgICAgIC8vIGNoYW5nZSBzaG91bGQgdHJpZ2dlciBhbiB1cGRhdGUgb2YgdGhlIG93bmVyIHdoaWNoIHdvdWxkIHJlY3JlYXRlXG4gICAgICAvLyB0aGUgZWxlbWVudC4gV2UgZXhwbGljaXRseSBjaGVjayBmb3IgdGhlIGV4aXN0ZW5jZSBvZiBhbiBvd25lciBzaW5jZVxuICAgICAgLy8gaXQncyBwb3NzaWJsZSBmb3IgYW4gZWxlbWVudCBjcmVhdGVkIG91dHNpZGUgYSBjb21wb3NpdGUgdG8gYmVcbiAgICAgIC8vIGRlZXBseSBtdXRhdGVkIGFuZCByZXVzZWQuXG5cbiAgICAgIC8vIFRPRE86IEJhaWxpbmcgb3V0IGVhcmx5IGlzIGp1c3QgYSBwZXJmIG9wdGltaXphdGlvbiByaWdodD9cbiAgICAgIC8vIFRPRE86IFJlbW92aW5nIHRoZSByZXR1cm4gc3RhdGVtZW50IHNob3VsZCBhZmZlY3QgY29ycmVjdG5lc3M/XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHJlZnNDaGFuZ2VkID0gUmVhY3RSZWYuc2hvdWxkVXBkYXRlUmVmcyhwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpO1xuXG4gICAgaWYgKHJlZnNDaGFuZ2VkKSB7XG4gICAgICBSZWFjdFJlZi5kZXRhY2hSZWZzKGludGVybmFsSW5zdGFuY2UsIHByZXZFbGVtZW50KTtcbiAgICB9XG5cbiAgICBpbnRlcm5hbEluc3RhbmNlLnJlY2VpdmVDb21wb25lbnQobmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcblxuICAgIGlmIChyZWZzQ2hhbmdlZCAmJiBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCAmJiBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5yZWYgIT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShhdHRhY2hSZWZzLCBpbnRlcm5hbEluc3RhbmNlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZsdXNoIGFueSBkaXJ0eSBjaGFuZ2VzIGluIGEgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnRlcm5hbEluc3RhbmNlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwZXJmb3JtVXBkYXRlSWZOZWNlc3Nhcnk6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCB0cmFuc2FjdGlvbikge1xuICAgIGludGVybmFsSW5zdGFuY2UucGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5KHRyYW5zYWN0aW9uKTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UmVjb25jaWxlcjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0UmVjb25jaWxlci5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFJlZlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0T3duZXInKTtcblxudmFyIFJlYWN0UmVmID0ge307XG5cbmZ1bmN0aW9uIGF0dGFjaFJlZihyZWYsIGNvbXBvbmVudCwgb3duZXIpIHtcbiAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZWYoY29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCkpO1xuICB9IGVsc2Uge1xuICAgIC8vIExlZ2FjeSByZWZcbiAgICBSZWFjdE93bmVyLmFkZENvbXBvbmVudEFzUmVmVG8oY29tcG9uZW50LCByZWYsIG93bmVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXRhY2hSZWYocmVmLCBjb21wb25lbnQsIG93bmVyKSB7XG4gIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmVmKG51bGwpO1xuICB9IGVsc2Uge1xuICAgIC8vIExlZ2FjeSByZWZcbiAgICBSZWFjdE93bmVyLnJlbW92ZUNvbXBvbmVudEFzUmVmRnJvbShjb21wb25lbnQsIHJlZiwgb3duZXIpO1xuICB9XG59XG5cblJlYWN0UmVmLmF0dGFjaFJlZnMgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICBpZiAocmVmICE9IG51bGwpIHtcbiAgICBhdHRhY2hSZWYocmVmLCBpbnN0YW5jZSwgZWxlbWVudC5fb3duZXIpO1xuICB9XG59O1xuXG5SZWFjdFJlZi5zaG91bGRVcGRhdGVSZWZzID0gZnVuY3Rpb24gKHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCkge1xuICAvLyBJZiBlaXRoZXIgdGhlIG93bmVyIG9yIGEgYHJlZmAgaGFzIGNoYW5nZWQsIG1ha2Ugc3VyZSB0aGUgbmV3ZXN0IG93bmVyXG4gIC8vIGhhcyBzdG9yZWQgYSByZWZlcmVuY2UgdG8gYHRoaXNgLCBhbmQgdGhlIHByZXZpb3VzIG93bmVyIChpZiBkaWZmZXJlbnQpXG4gIC8vIGhhcyBmb3Jnb3R0ZW4gdGhlIHJlZmVyZW5jZSB0byBgdGhpc2AuIFdlIHVzZSB0aGUgZWxlbWVudCBpbnN0ZWFkXG4gIC8vIG9mIHRoZSBwdWJsaWMgdGhpcy5wcm9wcyBiZWNhdXNlIHRoZSBwb3N0IHByb2Nlc3NpbmcgY2Fubm90IGRldGVybWluZVxuICAvLyBhIHJlZi4gVGhlIHJlZiBjb25jZXB0dWFsbHkgbGl2ZXMgb24gdGhlIGVsZW1lbnQuXG5cbiAgLy8gVE9ETzogU2hvdWxkIHRoaXMgZXZlbiBiZSBwb3NzaWJsZT8gVGhlIG93bmVyIGNhbm5vdCBjaGFuZ2UgYmVjYXVzZVxuICAvLyBpdCdzIGZvcmJpZGRlbiBieSBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudC4gVGhlIHJlZiBjYW4gY2hhbmdlXG4gIC8vIGlmIHlvdSBzd2FwIHRoZSBrZXlzIG9mIGJ1dCBub3QgdGhlIHJlZnMuIFJlY29uc2lkZXIgd2hlcmUgdGhpcyBjaGVja1xuICAvLyBpcyBtYWRlLiBJdCBwcm9iYWJseSBiZWxvbmdzIHdoZXJlIHRoZSBrZXkgY2hlY2tpbmcgYW5kXG4gIC8vIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgaXMgZG9uZS5cblxuICB2YXIgcHJldkVtcHR5ID0gcHJldkVsZW1lbnQgPT09IG51bGwgfHwgcHJldkVsZW1lbnQgPT09IGZhbHNlO1xuICB2YXIgbmV4dEVtcHR5ID0gbmV4dEVsZW1lbnQgPT09IG51bGwgfHwgbmV4dEVsZW1lbnQgPT09IGZhbHNlO1xuXG4gIHJldHVybihcbiAgICAvLyBUaGlzIGhhcyBhIGZldyBmYWxzZSBwb3NpdGl2ZXMgdy9yL3QgZW1wdHkgY29tcG9uZW50cy5cbiAgICBwcmV2RW1wdHkgfHwgbmV4dEVtcHR5IHx8IG5leHRFbGVtZW50Ll9vd25lciAhPT0gcHJldkVsZW1lbnQuX293bmVyIHx8IG5leHRFbGVtZW50LnJlZiAhPT0gcHJldkVsZW1lbnQucmVmXG4gICk7XG59O1xuXG5SZWFjdFJlZi5kZXRhY2hSZWZzID0gZnVuY3Rpb24gKGluc3RhbmNlLCBlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjtcbiAgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgZGV0YWNoUmVmKHJlZiwgaW5zdGFuY2UsIGVsZW1lbnQuX293bmVyKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFJlZjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0UmVmLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0T3duZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBSZWFjdE93bmVycyBhcmUgY2FwYWJsZSBvZiBzdG9yaW5nIHJlZmVyZW5jZXMgdG8gb3duZWQgY29tcG9uZW50cy5cbiAqXG4gKiBBbGwgY29tcG9uZW50cyBhcmUgY2FwYWJsZSBvZiAvL2JlaW5nLy8gcmVmZXJlbmNlZCBieSBvd25lciBjb21wb25lbnRzLCBidXRcbiAqIG9ubHkgUmVhY3RPd25lciBjb21wb25lbnRzIGFyZSBjYXBhYmxlIG9mIC8vcmVmZXJlbmNpbmcvLyBvd25lZCBjb21wb25lbnRzLlxuICogVGhlIG5hbWVkIHJlZmVyZW5jZSBpcyBrbm93biBhcyBhIFwicmVmXCIuXG4gKlxuICogUmVmcyBhcmUgYXZhaWxhYmxlIHdoZW4gbW91bnRlZCBhbmQgdXBkYXRlZCBkdXJpbmcgcmVjb25jaWxpYXRpb24uXG4gKlxuICogICB2YXIgTXlDb21wb25lbnQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHJldHVybiAoXG4gKiAgICAgICAgIDxkaXYgb25DbGljaz17dGhpcy5oYW5kbGVDbGlja30+XG4gKiAgICAgICAgICAgPEN1c3RvbUNvbXBvbmVudCByZWY9XCJjdXN0b21cIiAvPlxuICogICAgICAgICA8L2Rpdj5cbiAqICAgICAgICk7XG4gKiAgICAgfSxcbiAqICAgICBoYW5kbGVDbGljazogZnVuY3Rpb24oKSB7XG4gKiAgICAgICB0aGlzLnJlZnMuY3VzdG9tLmhhbmRsZUNsaWNrKCk7XG4gKiAgICAgfSxcbiAqICAgICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24oKSB7XG4gKiAgICAgICB0aGlzLnJlZnMuY3VzdG9tLmluaXRpYWxpemUoKTtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIFJlZnMgc2hvdWxkIHJhcmVseSBiZSB1c2VkLiBXaGVuIHJlZnMgYXJlIHVzZWQsIHRoZXkgc2hvdWxkIG9ubHkgYmUgZG9uZSB0b1xuICogY29udHJvbCBkYXRhIHRoYXQgaXMgbm90IGhhbmRsZWQgYnkgUmVhY3QncyBkYXRhIGZsb3cuXG4gKlxuICogQGNsYXNzIFJlYWN0T3duZXJcbiAqL1xudmFyIFJlYWN0T3duZXIgPSB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSB2YWxpZCBvd25lci5cbiAgICogQGZpbmFsXG4gICAqL1xuICBpc1ZhbGlkT3duZXI6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gISEob2JqZWN0ICYmIHR5cGVvZiBvYmplY3QuYXR0YWNoUmVmID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmplY3QuZGV0YWNoUmVmID09PSAnZnVuY3Rpb24nKTtcbiAgfSxcblxuICAvKipcbiAgICogQWRkcyBhIGNvbXBvbmVudCBieSByZWYgdG8gYW4gb3duZXIgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IHRvIHJlZmVyZW5jZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBOYW1lIGJ5IHdoaWNoIHRvIHJlZmVyIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7UmVhY3RPd25lcn0gb3duZXIgQ29tcG9uZW50IG9uIHdoaWNoIHRvIHJlY29yZCB0aGUgcmVmLlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhZGRDb21wb25lbnRBc1JlZlRvOiBmdW5jdGlvbiAoY29tcG9uZW50LCByZWYsIG93bmVyKSB7XG4gICAgIVJlYWN0T3duZXIuaXNWYWxpZE93bmVyKG93bmVyKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdhZGRDb21wb25lbnRBc1JlZlRvKC4uLik6IE9ubHkgYSBSZWFjdE93bmVyIGNhbiBoYXZlIHJlZnMuIFlvdSBtaWdodCAnICsgJ2JlIGFkZGluZyBhIHJlZiB0byBhIGNvbXBvbmVudCB0aGF0IHdhcyBub3QgY3JlYXRlZCBpbnNpZGUgYSBjb21wb25lbnRcXCdzICcgKyAnYHJlbmRlcmAgbWV0aG9kLCBvciB5b3UgaGF2ZSBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgbG9hZGVkICcgKyAnKGRldGFpbHM6IGh0dHBzOi8vZmIubWUvcmVhY3QtcmVmcy1tdXN0LWhhdmUtb3duZXIpLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICBvd25lci5hdHRhY2hSZWYocmVmLCBjb21wb25lbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY29tcG9uZW50IGJ5IHJlZiBmcm9tIGFuIG93bmVyIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50IENvbXBvbmVudCB0byBkZXJlZmVyZW5jZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBOYW1lIG9mIHRoZSByZWYgdG8gcmVtb3ZlLlxuICAgKiBAcGFyYW0ge1JlYWN0T3duZXJ9IG93bmVyIENvbXBvbmVudCBvbiB3aGljaCB0aGUgcmVmIGlzIHJlY29yZGVkLlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICByZW1vdmVDb21wb25lbnRBc1JlZkZyb206IGZ1bmN0aW9uIChjb21wb25lbnQsIHJlZiwgb3duZXIpIHtcbiAgICAhUmVhY3RPd25lci5pc1ZhbGlkT3duZXIob3duZXIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3JlbW92ZUNvbXBvbmVudEFzUmVmRnJvbSguLi4pOiBPbmx5IGEgUmVhY3RPd25lciBjYW4gaGF2ZSByZWZzLiBZb3UgbWlnaHQgJyArICdiZSByZW1vdmluZyBhIHJlZiB0byBhIGNvbXBvbmVudCB0aGF0IHdhcyBub3QgY3JlYXRlZCBpbnNpZGUgYSBjb21wb25lbnRcXCdzICcgKyAnYHJlbmRlcmAgbWV0aG9kLCBvciB5b3UgaGF2ZSBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgbG9hZGVkICcgKyAnKGRldGFpbHM6IGh0dHBzOi8vZmIubWUvcmVhY3QtcmVmcy1tdXN0LWhhdmUtb3duZXIpLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAvLyBDaGVjayB0aGF0IGBjb21wb25lbnRgIGlzIHN0aWxsIHRoZSBjdXJyZW50IHJlZiBiZWNhdXNlIHdlIGRvIG5vdCB3YW50IHRvXG4gICAgLy8gZGV0YWNoIHRoZSByZWYgaWYgYW5vdGhlciBjb21wb25lbnQgc3RvbGUgaXQuXG4gICAgaWYgKG93bmVyLmdldFB1YmxpY0luc3RhbmNlKCkucmVmc1tyZWZdID09PSBjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKSkge1xuICAgICAgb3duZXIuZGV0YWNoUmVmKHJlZik7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RPd25lcjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0T3duZXIuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0VXBkYXRlUXVldWVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0SW5zdGFuY2VNYXAgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VNYXAnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKSB7XG4gIFJlYWN0VXBkYXRlcy5lbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xufVxuXG5mdW5jdGlvbiBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBSZWFjdEluc3RhbmNlTWFwLmdldChwdWJsaWNJbnN0YW5jZSk7XG4gIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBPbmx5IHdhcm4gd2hlbiB3ZSBoYXZlIGEgY2FsbGVyTmFtZS4gT3RoZXJ3aXNlIHdlIHNob3VsZCBiZSBzaWxlbnQuXG4gICAgICAvLyBXZSdyZSBwcm9iYWJseSBjYWxsaW5nIGZyb20gZW5xdWV1ZUNhbGxiYWNrLiBXZSBkb24ndCB3YW50IHRvIHdhcm5cbiAgICAgIC8vIHRoZXJlIGJlY2F1c2Ugd2UgYWxyZWFkeSB3YXJuZWQgZm9yIHRoZSBjb3JyZXNwb25kaW5nIGxpZmVjeWNsZSBtZXRob2QuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghY2FsbGVyTmFtZSwgJyVzKC4uLik6IENhbiBvbmx5IHVwZGF0ZSBhIG1vdW50ZWQgb3IgbW91bnRpbmcgY29tcG9uZW50LiAnICsgJ1RoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkICVzKCkgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4gJyArICdUaGlzIGlzIGEgbm8tb3AuIFBsZWFzZSBjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjYWxsZXJOYW1lLCBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSkgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID09IG51bGwsICclcyguLi4pOiBDYW5ub3QgdXBkYXRlIGR1cmluZyBhbiBleGlzdGluZyBzdGF0ZSB0cmFuc2l0aW9uICcgKyAnKHN1Y2ggYXMgd2l0aGluIGByZW5kZXJgKS4gUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiAnICsgJ29mIHByb3BzIGFuZCBzdGF0ZS4nLCBjYWxsZXJOYW1lKSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiBpbnRlcm5hbEluc3RhbmNlO1xufVxuXG4vKipcbiAqIFJlYWN0VXBkYXRlUXVldWUgYWxsb3dzIGZvciBzdGF0ZSB1cGRhdGVzIHRvIGJlIHNjaGVkdWxlZCBpbnRvIGEgbGF0ZXJcbiAqIHJlY29uY2lsaWF0aW9uIHN0ZXAuXG4gKi9cbnZhciBSZWFjdFVwZGF0ZVF1ZXVlID0ge1xuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgICAgaWYgKG93bmVyICE9PSBudWxsKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKG93bmVyLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciwgJyVzIGlzIGFjY2Vzc2luZyBpc01vdW50ZWQgaW5zaWRlIGl0cyByZW5kZXIoKSBmdW5jdGlvbi4gJyArICdyZW5kZXIoKSBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4gSXQgc2hvdWxkICcgKyAnbmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgJyArICdyZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLicsIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgb3duZXIuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBSZWFjdEluc3RhbmNlTWFwLmdldChwdWJsaWNJbnN0YW5jZSk7XG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIC8vIER1cmluZyBjb21wb25lbnRXaWxsTW91bnQgYW5kIHJlbmRlciB0aGlzIHdpbGwgc3RpbGwgYmUgbnVsbCBidXQgYWZ0ZXJcbiAgICAgIC8vIHRoYXQgd2lsbCBhbHdheXMgcmVuZGVyIHRvIHNvbWV0aGluZy4gQXQgbGVhc3QgZm9yIG5vdy4gU28gd2UgY2FuIHVzZVxuICAgICAgLy8gdGhpcyBoYWNrLlxuICAgICAgcmV0dXJuICEhaW50ZXJuYWxJbnN0YW5jZS5fcmVuZGVyZWRDb21wb25lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVucXVldWUgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgYWxsIHRoZSBwZW5kaW5nIHVwZGF0ZXNcbiAgICogaGF2ZSBwcm9jZXNzZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIHVzZSBhcyBgdGhpc2AgY29udGV4dC5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVDYWxsYmFjazogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaykge1xuICAgICEodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdlbnF1ZXVlQ2FsbGJhY2soLi4uKTogWW91IGNhbGxlZCBgc2V0UHJvcHNgLCBgcmVwbGFjZVByb3BzYCwgJyArICdgc2V0U3RhdGVgLCBgcmVwbGFjZVN0YXRlYCwgb3IgYGZvcmNlVXBkYXRlYCB3aXRoIGEgY2FsbGJhY2sgdGhhdCAnICsgJ2lzblxcJ3QgY2FsbGFibGUuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlKTtcblxuICAgIC8vIFByZXZpb3VzbHkgd2Ugd291bGQgdGhyb3cgYW4gZXJyb3IgaWYgd2UgZGlkbid0IGhhdmUgYW4gaW50ZXJuYWxcbiAgICAvLyBpbnN0YW5jZS4gU2luY2Ugd2Ugd2FudCB0byBtYWtlIGl0IGEgbm8tb3AgaW5zdGVhZCwgd2UgbWlycm9yIHRoZSBzYW1lXG4gICAgLy8gYmVoYXZpb3Igd2UgaGF2ZSBpbiBvdGhlciBlbnF1ZXVlKiBtZXRob2RzLlxuICAgIC8vIFdlIGFsc28gbmVlZCB0byBpZ25vcmUgY2FsbGJhY2tzIGluIGNvbXBvbmVudFdpbGxNb3VudC4gU2VlXG4gICAgLy8gZW5xdWV1ZVVwZGF0ZXMuXG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcykge1xuICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcyA9IFtjYWxsYmFja107XG4gICAgfVxuICAgIC8vIFRPRE86IFRoZSBjYWxsYmFjayBoZXJlIGlzIGlnbm9yZWQgd2hlbiBzZXRTdGF0ZSBpcyBjYWxsZWQgZnJvbVxuICAgIC8vIGNvbXBvbmVudFdpbGxNb3VudC4gRWl0aGVyIGZpeCBpdCBvciBkaXNhbGxvdyBkb2luZyBzbyBjb21wbGV0ZWx5IGluXG4gICAgLy8gZmF2b3Igb2YgZ2V0SW5pdGlhbFN0YXRlLiBBbHRlcm5hdGl2ZWx5LCB3ZSBjYW4gZGlzYWxsb3dcbiAgICAvLyBjb21wb25lbnRXaWxsTW91bnQgZHVyaW5nIHNlcnZlci1zaWRlIHJlbmRlcmluZy5cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIGVucXVldWVDYWxsYmFja0ludGVybmFsOiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgY2FsbGJhY2spIHtcbiAgICAhKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZW5xdWV1ZUNhbGxiYWNrKC4uLik6IFlvdSBjYWxsZWQgYHNldFByb3BzYCwgYHJlcGxhY2VQcm9wc2AsICcgKyAnYHNldFN0YXRlYCwgYHJlcGxhY2VTdGF0ZWAsIG9yIGBmb3JjZVVwZGF0ZWAgd2l0aCBhIGNhbGxiYWNrIHRoYXQgJyArICdpc25cXCd0IGNhbGxhYmxlLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcykge1xuICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcyA9IFtjYWxsYmFja107XG4gICAgfVxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG5cbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSB0cnVlO1xuXG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSkge1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG5cbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IFtjb21wbGV0ZVN0YXRlXTtcbiAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gdHJ1ZTtcblxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlKSB7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuXG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHF1ZXVlID0gaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ1N0YXRlUXVldWUgfHwgKGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gW10pO1xuICAgIHF1ZXVlLnB1c2gocGFydGlhbFN0YXRlKTtcblxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHByb3BzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxQcm9wcyBTdWJzZXQgb2YgdGhlIG5leHQgcHJvcHMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFByb3BzOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxQcm9wcykge1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCAnc2V0UHJvcHMnKTtcbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlU2V0UHJvcHNJbnRlcm5hbChpbnRlcm5hbEluc3RhbmNlLCBwYXJ0aWFsUHJvcHMpO1xuICB9LFxuXG4gIGVucXVldWVTZXRQcm9wc0ludGVybmFsOiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgcGFydGlhbFByb3BzKSB7XG4gICAgdmFyIHRvcExldmVsV3JhcHBlciA9IGludGVybmFsSW5zdGFuY2UuX3RvcExldmVsV3JhcHBlcjtcbiAgICAhdG9wTGV2ZWxXcmFwcGVyID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3NldFByb3BzKC4uLik6IFlvdSBjYWxsZWQgYHNldFByb3BzYCBvbiBhICcgKyAnY29tcG9uZW50IHdpdGggYSBwYXJlbnQuIFRoaXMgaXMgYW4gYW50aS1wYXR0ZXJuIHNpbmNlIHByb3BzIHdpbGwgJyArICdnZXQgcmVhY3RpdmVseSB1cGRhdGVkIHdoZW4gcmVuZGVyZWQuIEluc3RlYWQsIGNoYW5nZSB0aGUgb3duZXJcXCdzICcgKyAnYHJlbmRlcmAgbWV0aG9kIHRvIHBhc3MgdGhlIGNvcnJlY3QgdmFsdWUgYXMgcHJvcHMgdG8gdGhlIGNvbXBvbmVudCAnICsgJ3doZXJlIGl0IGlzIGNyZWF0ZWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgLy8gTWVyZ2Ugd2l0aCB0aGUgcGVuZGluZyBlbGVtZW50IGlmIGl0IGV4aXN0cywgb3RoZXJ3aXNlIHdpdGggZXhpc3RpbmdcbiAgICAvLyBlbGVtZW50IHByb3BzLlxuICAgIHZhciB3cmFwRWxlbWVudCA9IHRvcExldmVsV3JhcHBlci5fcGVuZGluZ0VsZW1lbnQgfHwgdG9wTGV2ZWxXcmFwcGVyLl9jdXJyZW50RWxlbWVudDtcbiAgICB2YXIgZWxlbWVudCA9IHdyYXBFbGVtZW50LnByb3BzO1xuICAgIHZhciBwcm9wcyA9IGFzc2lnbih7fSwgZWxlbWVudC5wcm9wcywgcGFydGlhbFByb3BzKTtcbiAgICB0b3BMZXZlbFdyYXBwZXIuX3BlbmRpbmdFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZVByb3BzKHdyYXBFbGVtZW50LCBSZWFjdEVsZW1lbnQuY2xvbmVBbmRSZXBsYWNlUHJvcHMoZWxlbWVudCwgcHJvcHMpKTtcblxuICAgIGVucXVldWVVcGRhdGUodG9wTGV2ZWxXcmFwcGVyKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBwcm9wcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyBOZXcgcHJvcHMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VQcm9wczogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwcm9wcykge1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVByb3BzJyk7XG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZVJlcGxhY2VQcm9wc0ludGVybmFsKGludGVybmFsSW5zdGFuY2UsIHByb3BzKTtcbiAgfSxcblxuICBlbnF1ZXVlUmVwbGFjZVByb3BzSW50ZXJuYWw6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCBwcm9wcykge1xuICAgIHZhciB0b3BMZXZlbFdyYXBwZXIgPSBpbnRlcm5hbEluc3RhbmNlLl90b3BMZXZlbFdyYXBwZXI7XG4gICAgIXRvcExldmVsV3JhcHBlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdyZXBsYWNlUHJvcHMoLi4uKTogWW91IGNhbGxlZCBgcmVwbGFjZVByb3BzYCBvbiBhICcgKyAnY29tcG9uZW50IHdpdGggYSBwYXJlbnQuIFRoaXMgaXMgYW4gYW50aS1wYXR0ZXJuIHNpbmNlIHByb3BzIHdpbGwgJyArICdnZXQgcmVhY3RpdmVseSB1cGRhdGVkIHdoZW4gcmVuZGVyZWQuIEluc3RlYWQsIGNoYW5nZSB0aGUgb3duZXJcXCdzICcgKyAnYHJlbmRlcmAgbWV0aG9kIHRvIHBhc3MgdGhlIGNvcnJlY3QgdmFsdWUgYXMgcHJvcHMgdG8gdGhlIGNvbXBvbmVudCAnICsgJ3doZXJlIGl0IGlzIGNyZWF0ZWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgLy8gTWVyZ2Ugd2l0aCB0aGUgcGVuZGluZyBlbGVtZW50IGlmIGl0IGV4aXN0cywgb3RoZXJ3aXNlIHdpdGggZXhpc3RpbmdcbiAgICAvLyBlbGVtZW50IHByb3BzLlxuICAgIHZhciB3cmFwRWxlbWVudCA9IHRvcExldmVsV3JhcHBlci5fcGVuZGluZ0VsZW1lbnQgfHwgdG9wTGV2ZWxXcmFwcGVyLl9jdXJyZW50RWxlbWVudDtcbiAgICB2YXIgZWxlbWVudCA9IHdyYXBFbGVtZW50LnByb3BzO1xuICAgIHRvcExldmVsV3JhcHBlci5fcGVuZGluZ0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY2xvbmVBbmRSZXBsYWNlUHJvcHMod3JhcEVsZW1lbnQsIFJlYWN0RWxlbWVudC5jbG9uZUFuZFJlcGxhY2VQcm9wcyhlbGVtZW50LCBwcm9wcykpO1xuXG4gICAgZW5xdWV1ZVVwZGF0ZSh0b3BMZXZlbFdyYXBwZXIpO1xuICB9LFxuXG4gIGVucXVldWVFbGVtZW50SW50ZXJuYWw6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCBuZXdFbGVtZW50KSB7XG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0VsZW1lbnQgPSBuZXdFbGVtZW50O1xuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFVwZGF0ZVF1ZXVlO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RVcGRhdGVRdWV1ZS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFVwZGF0ZXNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDYWxsYmFja1F1ZXVlID0gcmVxdWlyZSgnLi9DYWxsYmFja1F1ZXVlJyk7XG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZSgnLi9SZWFjdFBlcmYnKTtcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9UcmFuc2FjdGlvbicpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBkaXJ0eUNvbXBvbmVudHMgPSBbXTtcbnZhciBhc2FwQ2FsbGJhY2tRdWV1ZSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKCk7XG52YXIgYXNhcEVucXVldWVkID0gZmFsc2U7XG5cbnZhciBiYXRjaGluZ1N0cmF0ZWd5ID0gbnVsbDtcblxuZnVuY3Rpb24gZW5zdXJlSW5qZWN0ZWQoKSB7XG4gICEoUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24gJiYgYmF0Y2hpbmdTdHJhdGVneSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IGluamVjdCBhIHJlY29uY2lsZSB0cmFuc2FjdGlvbiBjbGFzcyBhbmQgYmF0Y2hpbmcgJyArICdzdHJhdGVneScpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbn1cblxudmFyIE5FU1RFRF9VUERBVEVTID0ge1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggPSBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoO1xuICB9LFxuICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCAhPT0gZGlydHlDb21wb25lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gQWRkaXRpb25hbCB1cGRhdGVzIHdlcmUgZW5xdWV1ZWQgYnkgY29tcG9uZW50RGlkVXBkYXRlIGhhbmRsZXJzIG9yXG4gICAgICAvLyBzaW1pbGFyOyBiZWZvcmUgb3VyIG93biBVUERBVEVfUVVFVUVJTkcgd3JhcHBlciBjbG9zZXMsIHdlIHdhbnQgdG8gcnVuXG4gICAgICAvLyB0aGVzZSBuZXcgdXBkYXRlcyBzbyB0aGF0IGlmIEEncyBjb21wb25lbnREaWRVcGRhdGUgY2FsbHMgc2V0U3RhdGUgb25cbiAgICAgIC8vIEIsIEIgd2lsbCB1cGRhdGUgYmVmb3JlIHRoZSBjYWxsYmFjayBBJ3MgdXBkYXRlciBwcm92aWRlZCB3aGVuIGNhbGxpbmdcbiAgICAgIC8vIHNldFN0YXRlLlxuICAgICAgZGlydHlDb21wb25lbnRzLnNwbGljZSgwLCB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCk7XG4gICAgICBmbHVzaEJhdGNoZWRVcGRhdGVzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpcnR5Q29tcG9uZW50cy5sZW5ndGggPSAwO1xuICAgIH1cbiAgfVxufTtcblxudmFyIFVQREFURV9RVUVVRUlORyA9IHtcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY2FsbGJhY2tRdWV1ZS5yZXNldCgpO1xuICB9LFxuICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY2FsbGJhY2tRdWV1ZS5ub3RpZnlBbGwoKTtcbiAgfVxufTtcblxudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW05FU1RFRF9VUERBVEVTLCBVUERBVEVfUVVFVUVJTkddO1xuXG5mdW5jdGlvbiBSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uKCkge1xuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XG4gIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoID0gbnVsbDtcbiAgdGhpcy5jYWxsYmFja1F1ZXVlID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQoKTtcbiAgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbiA9IFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLmdldFBvb2xlZCggLyogZm9yY2VIVE1MICovZmFsc2UpO1xufVxuXG5hc3NpZ24oUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFRyYW5zYWN0aW9uLk1peGluLCB7XG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVFJBTlNBQ1RJT05fV1JBUFBFUlM7XG4gIH0sXG5cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoID0gbnVsbDtcbiAgICBDYWxsYmFja1F1ZXVlLnJlbGVhc2UodGhpcy5jYWxsYmFja1F1ZXVlKTtcbiAgICB0aGlzLmNhbGxiYWNrUXVldWUgPSBudWxsO1xuICAgIFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLnJlbGVhc2UodGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbik7XG4gICAgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbiA9IG51bGw7XG4gIH0sXG5cbiAgcGVyZm9ybTogZnVuY3Rpb24gKG1ldGhvZCwgc2NvcGUsIGEpIHtcbiAgICAvLyBFc3NlbnRpYWxseSBjYWxscyBgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbi5wZXJmb3JtKG1ldGhvZCwgc2NvcGUsIGEpYFxuICAgIC8vIHdpdGggdGhpcyB0cmFuc2FjdGlvbidzIHdyYXBwZXJzIGFyb3VuZCBpdC5cbiAgICByZXR1cm4gVHJhbnNhY3Rpb24uTWl4aW4ucGVyZm9ybS5jYWxsKHRoaXMsIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24ucGVyZm9ybSwgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbiwgbWV0aG9kLCBzY29wZSwgYSk7XG4gIH1cbn0pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbik7XG5cbmZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzKGNhbGxiYWNrLCBhLCBiLCBjLCBkLCBlKSB7XG4gIGVuc3VyZUluamVjdGVkKCk7XG4gIGJhdGNoaW5nU3RyYXRlZ3kuYmF0Y2hlZFVwZGF0ZXMoY2FsbGJhY2ssIGEsIGIsIGMsIGQsIGUpO1xufVxuXG4vKipcbiAqIEFycmF5IGNvbXBhcmF0b3IgZm9yIFJlYWN0Q29tcG9uZW50cyBieSBtb3VudCBvcmRlcmluZy5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjMSBmaXJzdCBjb21wb25lbnQgeW91J3JlIGNvbXBhcmluZ1xuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gYzIgc2Vjb25kIGNvbXBvbmVudCB5b3UncmUgY29tcGFyaW5nXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFJldHVybiB2YWx1ZSB1c2FibGUgYnkgQXJyYXkucHJvdG90eXBlLnNvcnQoKS5cbiAqL1xuZnVuY3Rpb24gbW91bnRPcmRlckNvbXBhcmF0b3IoYzEsIGMyKSB7XG4gIHJldHVybiBjMS5fbW91bnRPcmRlciAtIGMyLl9tb3VudE9yZGVyO1xufVxuXG5mdW5jdGlvbiBydW5CYXRjaGVkVXBkYXRlcyh0cmFuc2FjdGlvbikge1xuICB2YXIgbGVuID0gdHJhbnNhY3Rpb24uZGlydHlDb21wb25lbnRzTGVuZ3RoO1xuICAhKGxlbiA9PT0gZGlydHlDb21wb25lbnRzLmxlbmd0aCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgZmx1c2ggdHJhbnNhY3Rpb25cXCdzIHN0b3JlZCBkaXJ0eS1jb21wb25lbnRzIGxlbmd0aCAoJXMpIHRvICcgKyAnbWF0Y2ggZGlydHktY29tcG9uZW50cyBhcnJheSBsZW5ndGggKCVzKS4nLCBsZW4sIGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAvLyBTaW5jZSByZWNvbmNpbGluZyBhIGNvbXBvbmVudCBoaWdoZXIgaW4gdGhlIG93bmVyIGhpZXJhcmNoeSB1c3VhbGx5IChub3RcbiAgLy8gYWx3YXlzIC0tIHNlZSBzaG91bGRDb21wb25lbnRVcGRhdGUoKSkgd2lsbCByZWNvbmNpbGUgY2hpbGRyZW4sIHJlY29uY2lsZVxuICAvLyB0aGVtIGJlZm9yZSB0aGVpciBjaGlsZHJlbiBieSBzb3J0aW5nIHRoZSBhcnJheS5cbiAgZGlydHlDb21wb25lbnRzLnNvcnQobW91bnRPcmRlckNvbXBhcmF0b3IpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAvLyBJZiBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgYmVmb3JlIHBlbmRpbmcgY2hhbmdlcyBhcHBseSwgaXQgd2lsbCBzdGlsbFxuICAgIC8vIGJlIGhlcmUsIGJ1dCB3ZSBhc3N1bWUgdGhhdCBpdCBoYXMgY2xlYXJlZCBpdHMgX3BlbmRpbmdDYWxsYmFja3MgYW5kXG4gICAgLy8gdGhhdCBwZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkgaXMgYSBub29wLlxuICAgIHZhciBjb21wb25lbnQgPSBkaXJ0eUNvbXBvbmVudHNbaV07XG5cbiAgICAvLyBJZiBwZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkgaGFwcGVucyB0byBlbnF1ZXVlIGFueSBuZXcgdXBkYXRlcywgd2VcbiAgICAvLyBzaG91bGRuJ3QgZXhlY3V0ZSB0aGUgY2FsbGJhY2tzIHVudGlsIHRoZSBuZXh0IHJlbmRlciBoYXBwZW5zLCBzb1xuICAgIC8vIHN0YXNoIHRoZSBjYWxsYmFja3MgZmlyc3RcbiAgICB2YXIgY2FsbGJhY2tzID0gY29tcG9uZW50Ll9wZW5kaW5nQ2FsbGJhY2tzO1xuICAgIGNvbXBvbmVudC5fcGVuZGluZ0NhbGxiYWNrcyA9IG51bGw7XG5cbiAgICBSZWFjdFJlY29uY2lsZXIucGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5KGNvbXBvbmVudCwgdHJhbnNhY3Rpb24ucmVjb25jaWxlVHJhbnNhY3Rpb24pO1xuXG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjYWxsYmFja3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uY2FsbGJhY2tRdWV1ZS5lbnF1ZXVlKGNhbGxiYWNrc1tqXSwgY29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZmx1c2hCYXRjaGVkVXBkYXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbidzIHdyYXBwZXJzIHdpbGwgY2xlYXIgdGhlIGRpcnR5Q29tcG9uZW50c1xuICAvLyBhcnJheSBhbmQgcGVyZm9ybSBhbnkgdXBkYXRlcyBlbnF1ZXVlZCBieSBtb3VudC1yZWFkeSBoYW5kbGVycyAoaS5lLixcbiAgLy8gY29tcG9uZW50RGlkVXBkYXRlKSBidXQgd2UgbmVlZCB0byBjaGVjayBoZXJlIHRvbyBpbiBvcmRlciB0byBjYXRjaFxuICAvLyB1cGRhdGVzIGVucXVldWVkIGJ5IHNldFN0YXRlIGNhbGxiYWNrcyBhbmQgYXNhcCBjYWxscy5cbiAgd2hpbGUgKGRpcnR5Q29tcG9uZW50cy5sZW5ndGggfHwgYXNhcEVucXVldWVkKSB7XG4gICAgaWYgKGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgIHZhciB0cmFuc2FjdGlvbiA9IFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKCk7XG4gICAgICB0cmFuc2FjdGlvbi5wZXJmb3JtKHJ1bkJhdGNoZWRVcGRhdGVzLCBudWxsLCB0cmFuc2FjdGlvbik7XG4gICAgICBSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uLnJlbGVhc2UodHJhbnNhY3Rpb24pO1xuICAgIH1cblxuICAgIGlmIChhc2FwRW5xdWV1ZWQpIHtcbiAgICAgIGFzYXBFbnF1ZXVlZCA9IGZhbHNlO1xuICAgICAgdmFyIHF1ZXVlID0gYXNhcENhbGxiYWNrUXVldWU7XG4gICAgICBhc2FwQ2FsbGJhY2tRdWV1ZSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKCk7XG4gICAgICBxdWV1ZS5ub3RpZnlBbGwoKTtcbiAgICAgIENhbGxiYWNrUXVldWUucmVsZWFzZShxdWV1ZSk7XG4gICAgfVxuICB9XG59O1xuZmx1c2hCYXRjaGVkVXBkYXRlcyA9IFJlYWN0UGVyZi5tZWFzdXJlKCdSZWFjdFVwZGF0ZXMnLCAnZmx1c2hCYXRjaGVkVXBkYXRlcycsIGZsdXNoQmF0Y2hlZFVwZGF0ZXMpO1xuXG4vKipcbiAqIE1hcmsgYSBjb21wb25lbnQgYXMgbmVlZGluZyBhIHJlcmVuZGVyLCBhZGRpbmcgYW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gYVxuICogbGlzdCBvZiBmdW5jdGlvbnMgd2hpY2ggd2lsbCBiZSBleGVjdXRlZCBvbmNlIHRoZSByZXJlbmRlciBvY2N1cnMuXG4gKi9cbmZ1bmN0aW9uIGVucXVldWVVcGRhdGUoY29tcG9uZW50KSB7XG4gIGVuc3VyZUluamVjdGVkKCk7XG5cbiAgLy8gVmFyaW91cyBwYXJ0cyBvZiBvdXIgY29kZSAoc3VjaCBhcyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCdzXG4gIC8vIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQpIGFzc3VtZSB0aGF0IGNhbGxzIHRvIHJlbmRlciBhcmVuJ3QgbmVzdGVkO1xuICAvLyB2ZXJpZnkgdGhhdCB0aGF0J3MgdGhlIGNhc2UuIChUaGlzIGlzIGNhbGxlZCBieSBlYWNoIHRvcC1sZXZlbCB1cGRhdGVcbiAgLy8gZnVuY3Rpb24sIGxpa2Ugc2V0UHJvcHMsIHNldFN0YXRlLCBmb3JjZVVwZGF0ZSwgZXRjLjsgY3JlYXRpb24gYW5kXG4gIC8vIGRlc3RydWN0aW9uIG9mIHRvcC1sZXZlbCBjb21wb25lbnRzIGlzIGd1YXJkZWQgaW4gUmVhY3RNb3VudC4pXG5cbiAgaWYgKCFiYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgYmF0Y2hpbmdTdHJhdGVneS5iYXRjaGVkVXBkYXRlcyhlbnF1ZXVlVXBkYXRlLCBjb21wb25lbnQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGRpcnR5Q29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG59XG5cbi8qKlxuICogRW5xdWV1ZSBhIGNhbGxiYWNrIHRvIGJlIHJ1biBhdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGJhdGNoaW5nIGN5Y2xlLiBUaHJvd3NcbiAqIGlmIG5vIHVwZGF0ZXMgYXJlIGN1cnJlbnRseSBiZWluZyBwZXJmb3JtZWQuXG4gKi9cbmZ1bmN0aW9uIGFzYXAoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgIWJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzLmFzYXA6IENhblxcJ3QgZW5xdWV1ZSBhbiBhc2FwIGNhbGxiYWNrIGluIGEgY29udGV4dCB3aGVyZScgKyAndXBkYXRlcyBhcmUgbm90IGJlaW5nIGJhdGNoZWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICBhc2FwQ2FsbGJhY2tRdWV1ZS5lbnF1ZXVlKGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgYXNhcEVucXVldWVkID0gdHJ1ZTtcbn1cblxudmFyIFJlYWN0VXBkYXRlc0luamVjdGlvbiA9IHtcbiAgaW5qZWN0UmVjb25jaWxlVHJhbnNhY3Rpb246IGZ1bmN0aW9uIChSZWNvbmNpbGVUcmFuc2FjdGlvbikge1xuICAgICFSZWNvbmNpbGVUcmFuc2FjdGlvbiA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgcHJvdmlkZSBhIHJlY29uY2lsZSB0cmFuc2FjdGlvbiBjbGFzcycpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbiA9IFJlY29uY2lsZVRyYW5zYWN0aW9uO1xuICB9LFxuXG4gIGluamVjdEJhdGNoaW5nU3RyYXRlZ3k6IGZ1bmN0aW9uIChfYmF0Y2hpbmdTdHJhdGVneSkge1xuICAgICFfYmF0Y2hpbmdTdHJhdGVneSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgcHJvdmlkZSBhIGJhdGNoaW5nIHN0cmF0ZWd5JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICEodHlwZW9mIF9iYXRjaGluZ1N0cmF0ZWd5LmJhdGNoZWRVcGRhdGVzID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgcHJvdmlkZSBhIGJhdGNoZWRVcGRhdGVzKCkgZnVuY3Rpb24nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgISh0eXBlb2YgX2JhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMgPT09ICdib29sZWFuJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYW4gaXNCYXRjaGluZ1VwZGF0ZXMgYm9vbGVhbiBhdHRyaWJ1dGUnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgYmF0Y2hpbmdTdHJhdGVneSA9IF9iYXRjaGluZ1N0cmF0ZWd5O1xuICB9XG59O1xuXG52YXIgUmVhY3RVcGRhdGVzID0ge1xuICAvKipcbiAgICogUmVhY3QgcmVmZXJlbmNlcyBgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbmAgdXNpbmcgdGhpcyBwcm9wZXJ0eSBpbiBvcmRlclxuICAgKiB0byBhbGxvdyBkZXBlbmRlbmN5IGluamVjdGlvbi5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uOiBudWxsLFxuXG4gIGJhdGNoZWRVcGRhdGVzOiBiYXRjaGVkVXBkYXRlcyxcbiAgZW5xdWV1ZVVwZGF0ZTogZW5xdWV1ZVVwZGF0ZSxcbiAgZmx1c2hCYXRjaGVkVXBkYXRlczogZmx1c2hCYXRjaGVkVXBkYXRlcyxcbiAgaW5qZWN0aW9uOiBSZWFjdFVwZGF0ZXNJbmplY3Rpb24sXG4gIGFzYXA6IGFzYXBcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RVcGRhdGVzO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RVcGRhdGVzLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENhbGxiYWNrUXVldWVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgcHNldWRvLWV2ZW50IG1vZHVsZSB0byBoZWxwIGtlZXAgdHJhY2sgb2YgY29tcG9uZW50cyB3YWl0aW5nIHRvXG4gKiBiZSBub3RpZmllZCB3aGVuIHRoZWlyIERPTSByZXByZXNlbnRhdGlvbnMgYXJlIGF2YWlsYWJsZSBmb3IgdXNlLlxuICpcbiAqIFRoaXMgaW1wbGVtZW50cyBgUG9vbGVkQ2xhc3NgLCBzbyB5b3Ugc2hvdWxkIG5ldmVyIG5lZWQgdG8gaW5zdGFudGlhdGUgdGhpcy5cbiAqIEluc3RlYWQsIHVzZSBgQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQoKWAuXG4gKlxuICogQGNsYXNzIFJlYWN0TW91bnRSZWFkeVxuICogQGltcGxlbWVudHMgUG9vbGVkQ2xhc3NcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBDYWxsYmFja1F1ZXVlKCkge1xuICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICB0aGlzLl9jb250ZXh0cyA9IG51bGw7XG59XG5cbmFzc2lnbihDYWxsYmFja1F1ZXVlLnByb3RvdHlwZSwge1xuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiBgbm90aWZ5QWxsYCBpcyBpbnZva2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBJbnZva2VkIHdoZW4gYG5vdGlmeUFsbGAgaXMgaW52b2tlZC5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBjb250ZXh0IENvbnRleHQgdG8gY2FsbCBgY2FsbGJhY2tgIHdpdGguXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZTogZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IFtdO1xuICAgIHRoaXMuX2NvbnRleHRzID0gdGhpcy5fY29udGV4dHMgfHwgW107XG4gICAgdGhpcy5fY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIHRoaXMuX2NvbnRleHRzLnB1c2goY29udGV4dCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZXMgYWxsIGVucXVldWVkIGNhbGxiYWNrcyBhbmQgY2xlYXJzIHRoZSBxdWV1ZS4gVGhpcyBpcyBpbnZva2VkIGFmdGVyXG4gICAqIHRoZSBET00gcmVwcmVzZW50YXRpb24gb2YgYSBjb21wb25lbnQgaGFzIGJlZW4gY3JlYXRlZCBvciB1cGRhdGVkLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG5vdGlmeUFsbDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3M7XG4gICAgdmFyIGNvbnRleHRzID0gdGhpcy5fY29udGV4dHM7XG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgIShjYWxsYmFja3MubGVuZ3RoID09PSBjb250ZXh0cy5sZW5ndGgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ01pc21hdGNoZWQgbGlzdCBvZiBjb250ZXh0cyBpbiBjYWxsYmFjayBxdWV1ZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IG51bGw7XG4gICAgICB0aGlzLl9jb250ZXh0cyA9IG51bGw7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsYmFja3NbaV0uY2FsbChjb250ZXh0c1tpXSk7XG4gICAgICB9XG4gICAgICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICAgIGNvbnRleHRzLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIGludGVybmFsIHF1ZXVlLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLl9jb250ZXh0cyA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGBQb29sZWRDbGFzc2AgbG9va3MgZm9yIHRoaXMuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG5cbn0pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oQ2FsbGJhY2tRdWV1ZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FsbGJhY2tRdWV1ZTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL0NhbGxiYWNrUXVldWUuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUG9vbGVkQ2xhc3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBTdGF0aWMgcG9vbGVycy4gU2V2ZXJhbCBjdXN0b20gdmVyc2lvbnMgZm9yIGVhY2ggcG90ZW50aWFsIG51bWJlciBvZlxuICogYXJndW1lbnRzLiBBIGNvbXBsZXRlbHkgZ2VuZXJpYyBwb29sZXIgaXMgZWFzeSB0byBpbXBsZW1lbnQsIGJ1dCB3b3VsZFxuICogcmVxdWlyZSBhY2Nlc3NpbmcgdGhlIGBhcmd1bWVudHNgIG9iamVjdC4gSW4gZWFjaCBvZiB0aGVzZSwgYHRoaXNgIHJlZmVycyB0b1xuICogdGhlIENsYXNzIGl0c2VsZiwgbm90IGFuIGluc3RhbmNlLiBJZiBhbnkgb3RoZXJzIGFyZSBuZWVkZWQsIHNpbXBseSBhZGQgdGhlbVxuICogaGVyZSwgb3IgaW4gdGhlaXIgb3duIGZpbGVzLlxuICovXG52YXIgb25lQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoY29weUZpZWxkc0Zyb20pIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgY29weUZpZWxkc0Zyb20pO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGNvcHlGaWVsZHNGcm9tKTtcbiAgfVxufTtcblxudmFyIHR3b0FyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMikge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMik7XG4gIH1cbn07XG5cbnZhciB0aHJlZUFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMiwgYTMpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyLCBhMyk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyLCBhMyk7XG4gIH1cbn07XG5cbnZhciBmb3VyQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyLCBhMywgYTQpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMiwgYTMsIGE0KTtcbiAgfVxufTtcblxudmFyIGZpdmVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyLCBhMywgYTQsIGE1KTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIsIGEzLCBhNCwgYTUpO1xuICB9XG59O1xuXG52YXIgc3RhbmRhcmRSZWxlYXNlciA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICAhKGluc3RhbmNlIGluc3RhbmNlb2YgS2xhc3MpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RyeWluZyB0byByZWxlYXNlIGFuIGluc3RhbmNlIGludG8gYSBwb29sIG9mIGEgZGlmZmVyZW50IHR5cGUuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICBpbnN0YW5jZS5kZXN0cnVjdG9yKCk7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoIDwgS2xhc3MucG9vbFNpemUpIHtcbiAgICBLbGFzcy5pbnN0YW5jZVBvb2wucHVzaChpbnN0YW5jZSk7XG4gIH1cbn07XG5cbnZhciBERUZBVUxUX1BPT0xfU0laRSA9IDEwO1xudmFyIERFRkFVTFRfUE9PTEVSID0gb25lQXJndW1lbnRQb29sZXI7XG5cbi8qKlxuICogQXVnbWVudHMgYENvcHlDb25zdHJ1Y3RvcmAgdG8gYmUgYSBwb29sYWJsZSBjbGFzcywgYXVnbWVudGluZyBvbmx5IHRoZSBjbGFzc1xuICogaXRzZWxmIChzdGF0aWNhbGx5KSBub3QgYWRkaW5nIGFueSBwcm90b3R5cGljYWwgZmllbGRzLiBBbnkgQ29weUNvbnN0cnVjdG9yXG4gKiB5b3UgZ2l2ZSB0aGlzIG1heSBoYXZlIGEgYHBvb2xTaXplYCBwcm9wZXJ0eSwgYW5kIHdpbGwgbG9vayBmb3IgYVxuICogcHJvdG90eXBpY2FsIGBkZXN0cnVjdG9yYCBvbiBpbnN0YW5jZXMgKG9wdGlvbmFsKS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBDb3B5Q29uc3RydWN0b3IgQ29uc3RydWN0b3IgdGhhdCBjYW4gYmUgdXNlZCB0byByZXNldC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBvb2xlciBDdXN0b21pemFibGUgcG9vbGVyLlxuICovXG52YXIgYWRkUG9vbGluZ1RvID0gZnVuY3Rpb24gKENvcHlDb25zdHJ1Y3RvciwgcG9vbGVyKSB7XG4gIHZhciBOZXdLbGFzcyA9IENvcHlDb25zdHJ1Y3RvcjtcbiAgTmV3S2xhc3MuaW5zdGFuY2VQb29sID0gW107XG4gIE5ld0tsYXNzLmdldFBvb2xlZCA9IHBvb2xlciB8fCBERUZBVUxUX1BPT0xFUjtcbiAgaWYgKCFOZXdLbGFzcy5wb29sU2l6ZSkge1xuICAgIE5ld0tsYXNzLnBvb2xTaXplID0gREVGQVVMVF9QT09MX1NJWkU7XG4gIH1cbiAgTmV3S2xhc3MucmVsZWFzZSA9IHN0YW5kYXJkUmVsZWFzZXI7XG4gIHJldHVybiBOZXdLbGFzcztcbn07XG5cbnZhciBQb29sZWRDbGFzcyA9IHtcbiAgYWRkUG9vbGluZ1RvOiBhZGRQb29saW5nVG8sXG4gIG9uZUFyZ3VtZW50UG9vbGVyOiBvbmVBcmd1bWVudFBvb2xlcixcbiAgdHdvQXJndW1lbnRQb29sZXI6IHR3b0FyZ3VtZW50UG9vbGVyLFxuICB0aHJlZUFyZ3VtZW50UG9vbGVyOiB0aHJlZUFyZ3VtZW50UG9vbGVyLFxuICBmb3VyQXJndW1lbnRQb29sZXI6IGZvdXJBcmd1bWVudFBvb2xlcixcbiAgZml2ZUFyZ3VtZW50UG9vbGVyOiBmaXZlQXJndW1lbnRQb29sZXJcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9vbGVkQ2xhc3M7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9Qb29sZWRDbGFzcy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBUcmFuc2FjdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIGBUcmFuc2FjdGlvbmAgY3JlYXRlcyBhIGJsYWNrIGJveCB0aGF0IGlzIGFibGUgdG8gd3JhcCBhbnkgbWV0aG9kIHN1Y2ggdGhhdFxuICogY2VydGFpbiBpbnZhcmlhbnRzIGFyZSBtYWludGFpbmVkIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIG1ldGhvZCBpcyBpbnZva2VkXG4gKiAoRXZlbiBpZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIHdoaWxlIGludm9raW5nIHRoZSB3cmFwcGVkIG1ldGhvZCkuIFdob2V2ZXJcbiAqIGluc3RhbnRpYXRlcyBhIHRyYW5zYWN0aW9uIGNhbiBwcm92aWRlIGVuZm9yY2VycyBvZiB0aGUgaW52YXJpYW50cyBhdFxuICogY3JlYXRpb24gdGltZS4gVGhlIGBUcmFuc2FjdGlvbmAgY2xhc3MgaXRzZWxmIHdpbGwgc3VwcGx5IG9uZSBhZGRpdGlvbmFsXG4gKiBhdXRvbWF0aWMgaW52YXJpYW50IGZvciB5b3UgLSB0aGUgaW52YXJpYW50IHRoYXQgYW55IHRyYW5zYWN0aW9uIGluc3RhbmNlXG4gKiBzaG91bGQgbm90IGJlIHJ1biB3aGlsZSBpdCBpcyBhbHJlYWR5IGJlaW5nIHJ1bi4gWW91IHdvdWxkIHR5cGljYWxseSBjcmVhdGUgYVxuICogc2luZ2xlIGluc3RhbmNlIG9mIGEgYFRyYW5zYWN0aW9uYCBmb3IgcmV1c2UgbXVsdGlwbGUgdGltZXMsIHRoYXQgcG90ZW50aWFsbHlcbiAqIGlzIHVzZWQgdG8gd3JhcCBzZXZlcmFsIGRpZmZlcmVudCBtZXRob2RzLiBXcmFwcGVycyBhcmUgZXh0cmVtZWx5IHNpbXBsZSAtXG4gKiB0aGV5IG9ubHkgcmVxdWlyZSBpbXBsZW1lbnRpbmcgdHdvIG1ldGhvZHMuXG4gKlxuICogPHByZT5cbiAqICAgICAgICAgICAgICAgICAgICAgICB3cmFwcGVycyAoaW5qZWN0ZWQgYXQgY3JlYXRpb24gdGltZSlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArICAgICAgICArXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLXwtLS0tLS0tLS0tLS0tLStcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICB2ICAgICAgICB8ICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgICAgICstLS0tLS0tLS0tLS0tLS0rICAgfCAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICArLS18ICAgIHdyYXBwZXIxICAgfC0tLXwtLS0tKyAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgKy0tLS0tLS0tLS0tLS0tLSsgICB2ICAgIHwgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgICAgICAgKy0tLS0tLS0tLS0tLS0rICB8ICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICArLS0tLXwgICB3cmFwcGVyMiAgfC0tLS0tLS0tKyAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgfCAgICArLS0tLS0tLS0tLS0tLSsgIHwgICAgIHwgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgIHwgICAgICAgICAgICAgICAgICAgICB8ICAgICB8ICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB2ICAgICB2ICAgICAgICAgICAgICAgICAgICAgdiAgICAgdiAgIHwgd3JhcHBlclxuICogICAgICAgICAgICAgICAgICAgIHwgKy0tLSsgKy0tLSsgICArLS0tLS0tLS0tKyAgICstLS0rICstLS0rIHwgaW52YXJpYW50c1xuICogcGVyZm9ybShhbnlNZXRob2QpIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHwgbWFpbnRhaW5lZFxuICogKy0tLS0tLS0tLS0tLS0tLS0tPnwtfC0tLXwtfC0tLXwtLT58YW55TWV0aG9kfC0tLXwtLS18LXwtLS18LXwtLS0tLS0tLT5cbiAqICAgICAgICAgICAgICAgICAgICB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfFxuICogICAgICAgICAgICAgICAgICAgIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICstLS0rICstLS0rICAgKy0tLS0tLS0tLSsgICArLS0tKyArLS0tKyB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgaW5pdGlhbGl6ZSAgICAgICAgICAgICAgICAgICAgY2xvc2UgICAgfFxuICogICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAqIDwvcHJlPlxuICpcbiAqIFVzZSBjYXNlczpcbiAqIC0gUHJlc2VydmluZyB0aGUgaW5wdXQgc2VsZWN0aW9uIHJhbmdlcyBiZWZvcmUvYWZ0ZXIgcmVjb25jaWxpYXRpb24uXG4gKiAgIFJlc3RvcmluZyBzZWxlY3Rpb24gZXZlbiBpbiB0aGUgZXZlbnQgb2YgYW4gdW5leHBlY3RlZCBlcnJvci5cbiAqIC0gRGVhY3RpdmF0aW5nIGV2ZW50cyB3aGlsZSByZWFycmFuZ2luZyB0aGUgRE9NLCBwcmV2ZW50aW5nIGJsdXJzL2ZvY3VzZXMsXG4gKiAgIHdoaWxlIGd1YXJhbnRlZWluZyB0aGF0IGFmdGVyd2FyZHMsIHRoZSBldmVudCBzeXN0ZW0gaXMgcmVhY3RpdmF0ZWQuXG4gKiAtIEZsdXNoaW5nIGEgcXVldWUgb2YgY29sbGVjdGVkIERPTSBtdXRhdGlvbnMgdG8gdGhlIG1haW4gVUkgdGhyZWFkIGFmdGVyIGFcbiAqICAgcmVjb25jaWxpYXRpb24gdGFrZXMgcGxhY2UgaW4gYSB3b3JrZXIgdGhyZWFkLlxuICogLSBJbnZva2luZyBhbnkgY29sbGVjdGVkIGBjb21wb25lbnREaWRVcGRhdGVgIGNhbGxiYWNrcyBhZnRlciByZW5kZXJpbmcgbmV3XG4gKiAgIGNvbnRlbnQuXG4gKiAtIChGdXR1cmUgdXNlIGNhc2UpOiBXcmFwcGluZyBwYXJ0aWN1bGFyIGZsdXNoZXMgb2YgdGhlIGBSZWFjdFdvcmtlcmAgcXVldWVcbiAqICAgdG8gcHJlc2VydmUgdGhlIGBzY3JvbGxUb3BgIChhbiBhdXRvbWF0aWMgc2Nyb2xsIGF3YXJlIERPTSkuXG4gKiAtIChGdXR1cmUgdXNlIGNhc2UpOiBMYXlvdXQgY2FsY3VsYXRpb25zIGJlZm9yZSBhbmQgYWZ0ZXIgRE9NIHVwZGF0ZXMuXG4gKlxuICogVHJhbnNhY3Rpb25hbCBwbHVnaW4gQVBJOlxuICogLSBBIG1vZHVsZSB0aGF0IGhhcyBhbiBgaW5pdGlhbGl6ZWAgbWV0aG9kIHRoYXQgcmV0dXJucyBhbnkgcHJlY29tcHV0YXRpb24uXG4gKiAtIGFuZCBhIGBjbG9zZWAgbWV0aG9kIHRoYXQgYWNjZXB0cyB0aGUgcHJlY29tcHV0YXRpb24uIGBjbG9zZWAgaXMgaW52b2tlZFxuICogICB3aGVuIHRoZSB3cmFwcGVkIHByb2Nlc3MgaXMgY29tcGxldGVkLCBvciBoYXMgZmFpbGVkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8VHJhbnNhY3Rpb25hbFdyYXBwZXI+fSB0cmFuc2FjdGlvbldyYXBwZXIgV3JhcHBlciBtb2R1bGVzXG4gKiB0aGF0IGltcGxlbWVudCBgaW5pdGlhbGl6ZWAgYW5kIGBjbG9zZWAuXG4gKiBAcmV0dXJuIHtUcmFuc2FjdGlvbn0gU2luZ2xlIHRyYW5zYWN0aW9uIGZvciByZXVzZSBpbiB0aHJlYWQuXG4gKlxuICogQGNsYXNzIFRyYW5zYWN0aW9uXG4gKi9cbnZhciBNaXhpbiA9IHtcbiAgLyoqXG4gICAqIFNldHMgdXAgdGhpcyBpbnN0YW5jZSBzbyB0aGF0IGl0IGlzIHByZXBhcmVkIGZvciBjb2xsZWN0aW5nIG1ldHJpY3MuIERvZXNcbiAgICogc28gc3VjaCB0aGF0IHRoaXMgc2V0dXAgbWV0aG9kIG1heSBiZSB1c2VkIG9uIGFuIGluc3RhbmNlIHRoYXQgaXMgYWxyZWFkeVxuICAgKiBpbml0aWFsaXplZCwgaW4gYSB3YXkgdGhhdCBkb2VzIG5vdCBjb25zdW1lIGFkZGl0aW9uYWwgbWVtb3J5IHVwb24gcmV1c2UuXG4gICAqIFRoYXQgY2FuIGJlIHVzZWZ1bCBpZiB5b3UgZGVjaWRlIHRvIG1ha2UgeW91ciBzdWJjbGFzcyBvZiB0aGlzIG1peGluIGFcbiAgICogXCJQb29sZWRDbGFzc1wiLlxuICAgKi9cbiAgcmVpbml0aWFsaXplVHJhbnNhY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnMgPSB0aGlzLmdldFRyYW5zYWN0aW9uV3JhcHBlcnMoKTtcbiAgICBpZiAodGhpcy53cmFwcGVySW5pdERhdGEpIHtcbiAgICAgIHRoaXMud3JhcHBlckluaXREYXRhLmxlbmd0aCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud3JhcHBlckluaXREYXRhID0gW107XG4gICAgfVxuICAgIHRoaXMuX2lzSW5UcmFuc2FjdGlvbiA9IGZhbHNlO1xuICB9LFxuXG4gIF9pc0luVHJhbnNhY3Rpb246IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7QXJyYXk8VHJhbnNhY3Rpb25XcmFwcGVyPn0gQXJyYXkgb2YgdHJhbnNhY3Rpb24gd3JhcHBlcnMuXG4gICAqL1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBudWxsLFxuXG4gIGlzSW5UcmFuc2FjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2lzSW5UcmFuc2FjdGlvbjtcbiAgfSxcblxuICAvKipcbiAgICogRXhlY3V0ZXMgdGhlIGZ1bmN0aW9uIHdpdGhpbiBhIHNhZmV0eSB3aW5kb3cuIFVzZSB0aGlzIGZvciB0aGUgdG9wIGxldmVsXG4gICAqIG1ldGhvZHMgdGhhdCByZXN1bHQgaW4gbGFyZ2UgYW1vdW50cyBvZiBjb21wdXRhdGlvbi9tdXRhdGlvbnMgdGhhdCB3b3VsZFxuICAgKiBuZWVkIHRvIGJlIHNhZmV0eSBjaGVja2VkLiBUaGUgb3B0aW9uYWwgYXJndW1lbnRzIGhlbHBzIHByZXZlbnQgdGhlIG5lZWRcbiAgICogdG8gYmluZCBpbiBtYW55IGNhc2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXRob2QgTWVtYmVyIG9mIHNjb3BlIHRvIGNhbGwuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZSBTY29wZSB0byBpbnZva2UgZnJvbS5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gYSBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGIgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBjIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gZCBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGUgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBmIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICpcbiAgICogQHJldHVybiB7Kn0gUmV0dXJuIHZhbHVlIGZyb20gYG1ldGhvZGAuXG4gICAqL1xuICBwZXJmb3JtOiBmdW5jdGlvbiAobWV0aG9kLCBzY29wZSwgYSwgYiwgYywgZCwgZSwgZikge1xuICAgICEhdGhpcy5pc0luVHJhbnNhY3Rpb24oKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUcmFuc2FjdGlvbi5wZXJmb3JtKC4uLik6IENhbm5vdCBpbml0aWFsaXplIGEgdHJhbnNhY3Rpb24gd2hlbiB0aGVyZSAnICsgJ2lzIGFscmVhZHkgYW4gb3V0c3RhbmRpbmcgdHJhbnNhY3Rpb24uJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIHZhciBlcnJvclRocm93bjtcbiAgICB2YXIgcmV0O1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl9pc0luVHJhbnNhY3Rpb24gPSB0cnVlO1xuICAgICAgLy8gQ2F0Y2hpbmcgZXJyb3JzIG1ha2VzIGRlYnVnZ2luZyBtb3JlIGRpZmZpY3VsdCwgc28gd2Ugc3RhcnQgd2l0aFxuICAgICAgLy8gZXJyb3JUaHJvd24gc2V0IHRvIHRydWUgYmVmb3JlIHNldHRpbmcgaXQgdG8gZmFsc2UgYWZ0ZXIgY2FsbGluZ1xuICAgICAgLy8gY2xvc2UgLS0gaWYgaXQncyBzdGlsbCBzZXQgdG8gdHJ1ZSBpbiB0aGUgZmluYWxseSBibG9jaywgaXQgbWVhbnNcbiAgICAgIC8vIG9uZSBvZiB0aGVzZSBjYWxscyB0aHJldy5cbiAgICAgIGVycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZUFsbCgwKTtcbiAgICAgIHJldCA9IG1ldGhvZC5jYWxsKHNjb3BlLCBhLCBiLCBjLCBkLCBlLCBmKTtcbiAgICAgIGVycm9yVGhyb3duID0gZmFsc2U7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChlcnJvclRocm93bikge1xuICAgICAgICAgIC8vIElmIGBtZXRob2RgIHRocm93cywgcHJlZmVyIHRvIHNob3cgdGhhdCBzdGFjayB0cmFjZSBvdmVyIGFueSB0aHJvd25cbiAgICAgICAgICAvLyBieSBpbnZva2luZyBgY2xvc2VBbGxgLlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlQWxsKDApO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBTaW5jZSBgbWV0aG9kYCBkaWRuJ3QgdGhyb3csIHdlIGRvbid0IHdhbnQgdG8gc2lsZW5jZSB0aGUgZXhjZXB0aW9uXG4gICAgICAgICAgLy8gaGVyZS5cbiAgICAgICAgICB0aGlzLmNsb3NlQWxsKDApO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLl9pc0luVHJhbnNhY3Rpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICBpbml0aWFsaXplQWxsOiBmdW5jdGlvbiAoc3RhcnRJbmRleCkge1xuICAgIHZhciB0cmFuc2FjdGlvbldyYXBwZXJzID0gdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzO1xuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgdHJhbnNhY3Rpb25XcmFwcGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHdyYXBwZXIgPSB0cmFuc2FjdGlvbldyYXBwZXJzW2ldO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQ2F0Y2hpbmcgZXJyb3JzIG1ha2VzIGRlYnVnZ2luZyBtb3JlIGRpZmZpY3VsdCwgc28gd2Ugc3RhcnQgd2l0aCB0aGVcbiAgICAgICAgLy8gT0JTRVJWRURfRVJST1Igc3RhdGUgYmVmb3JlIG92ZXJ3cml0aW5nIGl0IHdpdGggdGhlIHJlYWwgcmV0dXJuIHZhbHVlXG4gICAgICAgIC8vIG9mIGluaXRpYWxpemUgLS0gaWYgaXQncyBzdGlsbCBzZXQgdG8gT0JTRVJWRURfRVJST1IgaW4gdGhlIGZpbmFsbHlcbiAgICAgICAgLy8gYmxvY2ssIGl0IG1lYW5zIHdyYXBwZXIuaW5pdGlhbGl6ZSB0aHJldy5cbiAgICAgICAgdGhpcy53cmFwcGVySW5pdERhdGFbaV0gPSBUcmFuc2FjdGlvbi5PQlNFUlZFRF9FUlJPUjtcbiAgICAgICAgdGhpcy53cmFwcGVySW5pdERhdGFbaV0gPSB3cmFwcGVyLmluaXRpYWxpemUgPyB3cmFwcGVyLmluaXRpYWxpemUuY2FsbCh0aGlzKSA6IG51bGw7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAodGhpcy53cmFwcGVySW5pdERhdGFbaV0gPT09IFRyYW5zYWN0aW9uLk9CU0VSVkVEX0VSUk9SKSB7XG4gICAgICAgICAgLy8gVGhlIGluaXRpYWxpemVyIGZvciB3cmFwcGVyIGkgdGhyZXcgYW4gZXJyb3I7IGluaXRpYWxpemUgdGhlXG4gICAgICAgICAgLy8gcmVtYWluaW5nIHdyYXBwZXJzIGJ1dCBzaWxlbmNlIGFueSBleGNlcHRpb25zIGZyb20gdGhlbSB0byBlbnN1cmVcbiAgICAgICAgICAvLyB0aGF0IHRoZSBmaXJzdCBlcnJvciBpcyB0aGUgb25lIHRvIGJ1YmJsZSB1cC5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplQWxsKGkgKyAxKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZXMgZWFjaCBvZiBgdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzLmNsb3NlW2ldYCBmdW5jdGlvbnMsIHBhc3NpbmcgaW50b1xuICAgKiB0aGVtIHRoZSByZXNwZWN0aXZlIHJldHVybiB2YWx1ZXMgb2YgYHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycy5pbml0W2ldYFxuICAgKiAoYGNsb3NlYHJzIHRoYXQgY29ycmVzcG9uZCB0byBpbml0aWFsaXplcnMgdGhhdCBmYWlsZWQgd2lsbCBub3QgYmVcbiAgICogaW52b2tlZCkuXG4gICAqL1xuICBjbG9zZUFsbDogZnVuY3Rpb24gKHN0YXJ0SW5kZXgpIHtcbiAgICAhdGhpcy5pc0luVHJhbnNhY3Rpb24oKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUcmFuc2FjdGlvbi5jbG9zZUFsbCgpOiBDYW5ub3QgY2xvc2UgdHJhbnNhY3Rpb24gd2hlbiBub25lIGFyZSBvcGVuLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgdHJhbnNhY3Rpb25XcmFwcGVycyA9IHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycztcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IHRyYW5zYWN0aW9uV3JhcHBlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3cmFwcGVyID0gdHJhbnNhY3Rpb25XcmFwcGVyc1tpXTtcbiAgICAgIHZhciBpbml0RGF0YSA9IHRoaXMud3JhcHBlckluaXREYXRhW2ldO1xuICAgICAgdmFyIGVycm9yVGhyb3duO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQ2F0Y2hpbmcgZXJyb3JzIG1ha2VzIGRlYnVnZ2luZyBtb3JlIGRpZmZpY3VsdCwgc28gd2Ugc3RhcnQgd2l0aFxuICAgICAgICAvLyBlcnJvclRocm93biBzZXQgdG8gdHJ1ZSBiZWZvcmUgc2V0dGluZyBpdCB0byBmYWxzZSBhZnRlciBjYWxsaW5nXG4gICAgICAgIC8vIGNsb3NlIC0tIGlmIGl0J3Mgc3RpbGwgc2V0IHRvIHRydWUgaW4gdGhlIGZpbmFsbHkgYmxvY2ssIGl0IG1lYW5zXG4gICAgICAgIC8vIHdyYXBwZXIuY2xvc2UgdGhyZXcuXG4gICAgICAgIGVycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgICAgaWYgKGluaXREYXRhICE9PSBUcmFuc2FjdGlvbi5PQlNFUlZFRF9FUlJPUiAmJiB3cmFwcGVyLmNsb3NlKSB7XG4gICAgICAgICAgd3JhcHBlci5jbG9zZS5jYWxsKHRoaXMsIGluaXREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlcnJvclRocm93biA9IGZhbHNlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgLy8gVGhlIGNsb3NlciBmb3Igd3JhcHBlciBpIHRocmV3IGFuIGVycm9yOyBjbG9zZSB0aGUgcmVtYWluaW5nXG4gICAgICAgICAgLy8gd3JhcHBlcnMgYnV0IHNpbGVuY2UgYW55IGV4Y2VwdGlvbnMgZnJvbSB0aGVtIHRvIGVuc3VyZSB0aGF0IHRoZVxuICAgICAgICAgIC8vIGZpcnN0IGVycm9yIGlzIHRoZSBvbmUgdG8gYnViYmxlIHVwLlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlQWxsKGkgKyAxKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMud3JhcHBlckluaXREYXRhLmxlbmd0aCA9IDA7XG4gIH1cbn07XG5cbnZhciBUcmFuc2FjdGlvbiA9IHtcblxuICBNaXhpbjogTWl4aW4sXG5cbiAgLyoqXG4gICAqIFRva2VuIHRvIGxvb2sgZm9yIHRvIGRldGVybWluZSBpZiBhbiBlcnJvciBvY2N1cnJlZC5cbiAgICovXG4gIE9CU0VSVkVEX0VSUk9SOiB7fVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zYWN0aW9uO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvVHJhbnNhY3Rpb24uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZW1wdHlPYmplY3RcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eU9iamVjdDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvZW1wdHlPYmplY3QuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY29udGFpbnNOb2RlXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzVGV4dE5vZGUgPSByZXF1aXJlKCcuL2lzVGV4dE5vZGUnKTtcblxuLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gRE9NIG5vZGUgY29udGFpbnMgb3IgaXMgYW5vdGhlciBET00gbm9kZS5cbiAqXG4gKiBAcGFyYW0gez9ET01Ob2RlfSBvdXRlck5vZGUgT3V0ZXIgRE9NIG5vZGUuXG4gKiBAcGFyYW0gez9ET01Ob2RlfSBpbm5lck5vZGUgSW5uZXIgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvdXRlck5vZGVgIGNvbnRhaW5zIG9yIGlzIGBpbm5lck5vZGVgLlxuICovXG5mdW5jdGlvbiBjb250YWluc05vZGUoX3gsIF94Mikge1xuICB2YXIgX2FnYWluID0gdHJ1ZTtcblxuICBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHtcbiAgICB2YXIgb3V0ZXJOb2RlID0gX3gsXG4gICAgICAgIGlubmVyTm9kZSA9IF94MjtcbiAgICBfYWdhaW4gPSBmYWxzZTtcblxuICAgIGlmICghb3V0ZXJOb2RlIHx8ICFpbm5lck5vZGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKG91dGVyTm9kZSA9PT0gaW5uZXJOb2RlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGlzVGV4dE5vZGUob3V0ZXJOb2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShpbm5lck5vZGUpKSB7XG4gICAgICBfeCA9IG91dGVyTm9kZTtcbiAgICAgIF94MiA9IGlubmVyTm9kZS5wYXJlbnROb2RlO1xuICAgICAgX2FnYWluID0gdHJ1ZTtcbiAgICAgIGNvbnRpbnVlIF9mdW5jdGlvbjtcbiAgICB9IGVsc2UgaWYgKG91dGVyTm9kZS5jb250YWlucykge1xuICAgICAgcmV0dXJuIG91dGVyTm9kZS5jb250YWlucyhpbm5lck5vZGUpO1xuICAgIH0gZWxzZSBpZiAob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKSB7XG4gICAgICByZXR1cm4gISEob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGlubmVyTm9kZSkgJiAxNik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250YWluc05vZGU7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL2NvbnRhaW5zTm9kZS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpc1RleHROb2RlXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzTm9kZSA9IHJlcXVpcmUoJy4vaXNOb2RlJyk7XG5cbi8qKlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgYSBET00gdGV4dCBub2RlLlxuICovXG5mdW5jdGlvbiBpc1RleHROb2RlKG9iamVjdCkge1xuICByZXR1cm4gaXNOb2RlKG9iamVjdCkgJiYgb2JqZWN0Lm5vZGVUeXBlID09IDM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUZXh0Tm9kZTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvaXNUZXh0Tm9kZS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpc05vZGVcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIG9iamVjdCBpcyBhIERPTSBub2RlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGlzTm9kZShvYmplY3QpIHtcbiAgcmV0dXJuICEhKG9iamVjdCAmJiAodHlwZW9mIE5vZGUgPT09ICdmdW5jdGlvbicgPyBvYmplY3QgaW5zdGFuY2VvZiBOb2RlIDogdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iamVjdC5ub2RlVHlwZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIG9iamVjdC5ub2RlTmFtZSA9PT0gJ3N0cmluZycpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc05vZGU7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL2lzTm9kZS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpO1xudmFyIFJlYWN0RW1wdHlDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RW1wdHlDb21wb25lbnQnKTtcbnZhciBSZWFjdE5hdGl2ZUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3ROYXRpdmVDb21wb25lbnQnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8vIFRvIGF2b2lkIGEgY3ljbGljIGRlcGVuZGVuY3ksIHdlIGNyZWF0ZSB0aGUgZmluYWwgY2xhc3MgaW4gdGhpcyBtb2R1bGVcbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudFdyYXBwZXIgPSBmdW5jdGlvbiAoKSB7fTtcbmFzc2lnbihSZWFjdENvbXBvc2l0ZUNvbXBvbmVudFdyYXBwZXIucHJvdG90eXBlLCBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5NaXhpbiwge1xuICBfaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDogaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudFxufSk7XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikge1xuICBpZiAob3duZXIpIHtcbiAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSB0eXBlIHJlZmVyZW5jZSBpcyBhIGtub3duIGludGVybmFsIHR5cGUuIEkuZS4gbm90IGEgdXNlclxuICogcHJvdmlkZWQgY29tcG9zaXRlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHlwZVxuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoaXMgaXMgYSB2YWxpZCBpbnRlcm5hbCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc0ludGVybmFsQ29tcG9uZW50VHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdHlwZS5wcm90b3R5cGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB0eXBlLnByb3RvdHlwZS5tb3VudENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdHlwZS5wcm90b3R5cGUucmVjZWl2ZUNvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBHaXZlbiBhIFJlYWN0Tm9kZSwgY3JlYXRlIGFuIGluc3RhbmNlIHRoYXQgd2lsbCBhY3R1YWxseSBiZSBtb3VudGVkLlxuICpcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtvYmplY3R9IEEgbmV3IGluc3RhbmNlIG9mIHRoZSBlbGVtZW50J3MgY29uc3RydWN0b3IuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbmZ1bmN0aW9uIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQobm9kZSkge1xuICB2YXIgaW5zdGFuY2U7XG5cbiAgaWYgKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gZmFsc2UpIHtcbiAgICBpbnN0YW5jZSA9IG5ldyBSZWFjdEVtcHR5Q29tcG9uZW50KGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBub2RlID09PSAnb2JqZWN0Jykge1xuICAgIHZhciBlbGVtZW50ID0gbm9kZTtcbiAgICAhKGVsZW1lbnQgJiYgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ3N0cmluZycpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFbGVtZW50IHR5cGUgaXMgaW52YWxpZDogZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiBjb21wb25lbnRzKSAnICsgJ29yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCBlbGVtZW50LnR5cGUgPT0gbnVsbCA/IGVsZW1lbnQudHlwZSA6IHR5cGVvZiBlbGVtZW50LnR5cGUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShlbGVtZW50Ll9vd25lcikpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBzdHJpbmcgdmFsdWVzXG4gICAgaWYgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpbnN0YW5jZSA9IFJlYWN0TmF0aXZlQ29tcG9uZW50LmNyZWF0ZUludGVybmFsQ29tcG9uZW50KGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAoaXNJbnRlcm5hbENvbXBvbmVudFR5cGUoZWxlbWVudC50eXBlKSkge1xuICAgICAgLy8gVGhpcyBpcyB0ZW1wb3JhcmlseSBhdmFpbGFibGUgZm9yIGN1c3RvbSBjb21wb25lbnRzIHRoYXQgYXJlIG5vdCBzdHJpbmdcbiAgICAgIC8vIHJlcHJlc2VudGF0aW9ucy4gSS5lLiBBUlQuIE9uY2UgdGhvc2UgYXJlIHVwZGF0ZWQgdG8gdXNlIHRoZSBzdHJpbmdcbiAgICAgIC8vIHJlcHJlc2VudGF0aW9uLCB3ZSBjYW4gZHJvcCB0aGlzIGNvZGUgcGF0aC5cbiAgICAgIGluc3RhbmNlID0gbmV3IGVsZW1lbnQudHlwZShlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdGFuY2UgPSBuZXcgUmVhY3RDb21wb3NpdGVDb21wb25lbnRXcmFwcGVyKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBub2RlID09PSAnc3RyaW5nJyB8fCB0eXBlb2Ygbm9kZSA9PT0gJ251bWJlcicpIHtcbiAgICBpbnN0YW5jZSA9IFJlYWN0TmF0aXZlQ29tcG9uZW50LmNyZWF0ZUluc3RhbmNlRm9yVGV4dChub2RlKTtcbiAgfSBlbHNlIHtcbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRW5jb3VudGVyZWQgaW52YWxpZCBSZWFjdCBub2RlIG9mIHR5cGUgJXMnLCB0eXBlb2Ygbm9kZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgaW5zdGFuY2UuY29uc3RydWN0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS5tb3VudENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UucmVjZWl2ZUNvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UudW5tb3VudENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJywgJ09ubHkgUmVhY3QgQ29tcG9uZW50cyBjYW4gYmUgbW91bnRlZC4nKSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIFNldHMgdXAgdGhlIGluc3RhbmNlLiBUaGlzIGNhbiBwcm9iYWJseSBqdXN0IG1vdmUgaW50byB0aGUgY29uc3RydWN0b3Igbm93LlxuICBpbnN0YW5jZS5jb25zdHJ1Y3Qobm9kZSk7XG5cbiAgLy8gVGhlc2UgdHdvIGZpZWxkcyBhcmUgdXNlZCBieSB0aGUgRE9NIGFuZCBBUlQgZGlmZmluZyBhbGdvcml0aG1zXG4gIC8vIHJlc3BlY3RpdmVseS4gSW5zdGVhZCBvZiB1c2luZyBleHBhbmRvcyBvbiBjb21wb25lbnRzLCB3ZSBzaG91bGQgYmVcbiAgLy8gc3RvcmluZyB0aGUgc3RhdGUgbmVlZGVkIGJ5IHRoZSBkaWZmaW5nIGFsZ29yaXRobXMgZWxzZXdoZXJlLlxuICBpbnN0YW5jZS5fbW91bnRJbmRleCA9IDA7XG4gIGluc3RhbmNlLl9tb3VudEltYWdlID0gbnVsbDtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGluc3RhbmNlLl9pc093bmVyTmVjZXNzYXJ5ID0gZmFsc2U7XG4gICAgaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gZmFsc2U7XG4gIH1cblxuICAvLyBJbnRlcm5hbCBpbnN0YW5jZXMgc2hvdWxkIGZ1bGx5IGNvbnN0cnVjdGVkIGF0IHRoaXMgcG9pbnQsIHNvIHRoZXkgc2hvdWxkXG4gIC8vIG5vdCBnZXQgYW55IG5ldyBmaWVsZHMgYWRkZWQgdG8gdGhlbSBhdCB0aGlzIHBvaW50LlxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChPYmplY3QucHJldmVudEV4dGVuc2lvbnMpIHtcbiAgICAgIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyhpbnN0YW5jZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9ucycpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcycpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVRdWV1ZScpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpIHtcbiAgdmFyIG93bmVyID0gY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXIgfHwgbnVsbDtcbiAgaWYgKG93bmVyKSB7XG4gICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gU3RhdGVsZXNzQ29tcG9uZW50KENvbXBvbmVudCkge31cblN0YXRlbGVzc0NvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgQ29tcG9uZW50ID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQodGhpcykuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gIHJldHVybiBDb21wb25lbnQodGhpcy5wcm9wcywgdGhpcy5jb250ZXh0LCB0aGlzLnVwZGF0ZXIpO1xufTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0gVGhlIExpZmUtQ3ljbGUgb2YgYSBDb21wb3NpdGUgQ29tcG9uZW50IC0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIC0gY29uc3RydWN0b3I6IEluaXRpYWxpemF0aW9uIG9mIHN0YXRlLiBUaGUgaW5zdGFuY2UgaXMgbm93IHJldGFpbmVkLlxuICogICAtIGNvbXBvbmVudFdpbGxNb3VudFxuICogICAtIHJlbmRlclxuICogICAtIFtjaGlsZHJlbidzIGNvbnN0cnVjdG9yc11cbiAqICAgICAtIFtjaGlsZHJlbidzIGNvbXBvbmVudFdpbGxNb3VudCBhbmQgcmVuZGVyXVxuICogICAgIC0gW2NoaWxkcmVuJ3MgY29tcG9uZW50RGlkTW91bnRdXG4gKiAgICAgLSBjb21wb25lbnREaWRNb3VudFxuICpcbiAqICAgICAgIFVwZGF0ZSBQaGFzZXM6XG4gKiAgICAgICAtIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgKG9ubHkgY2FsbGVkIGlmIHBhcmVudCB1cGRhdGVkKVxuICogICAgICAgLSBzaG91bGRDb21wb25lbnRVcGRhdGVcbiAqICAgICAgICAgLSBjb21wb25lbnRXaWxsVXBkYXRlXG4gKiAgICAgICAgICAgLSByZW5kZXJcbiAqICAgICAgICAgICAtIFtjaGlsZHJlbidzIGNvbnN0cnVjdG9ycyBvciByZWNlaXZlIHByb3BzIHBoYXNlc11cbiAqICAgICAgICAgLSBjb21wb25lbnREaWRVcGRhdGVcbiAqXG4gKiAgICAgLSBjb21wb25lbnRXaWxsVW5tb3VudFxuICogICAgIC0gW2NoaWxkcmVuJ3MgY29tcG9uZW50V2lsbFVubW91bnRdXG4gKiAgIC0gW2NoaWxkcmVuIGRlc3Ryb3llZF1cbiAqIC0gKGRlc3Ryb3llZCk6IFRoZSBpbnN0YW5jZSBpcyBub3cgYmxhbmssIHJlbGVhc2VkIGJ5IFJlYWN0IGFuZCByZWFkeSBmb3IgR0MuXG4gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4vKipcbiAqIEFuIGluY3JlbWVudGluZyBJRCBhc3NpZ25lZCB0byBlYWNoIGNvbXBvbmVudCB3aGVuIGl0IGlzIG1vdW50ZWQuIFRoaXMgaXNcbiAqIHVzZWQgdG8gZW5mb3JjZSB0aGUgb3JkZXIgaW4gd2hpY2ggYFJlYWN0VXBkYXRlc2AgdXBkYXRlcyBkaXJ0eSBjb21wb25lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBuZXh0TW91bnRJRCA9IDE7XG5cbi8qKlxuICogQGxlbmRzIHtSZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5wcm90b3R5cGV9XG4gKi9cbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudE1peGluID0ge1xuXG4gIC8qKlxuICAgKiBCYXNlIGNvbnN0cnVjdG9yIGZvciBhbGwgY29tcG9zaXRlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0OiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gbnVsbDtcbiAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG5cbiAgICAvLyBTZWUgUmVhY3RVcGRhdGVRdWV1ZVxuICAgIHRoaXMuX3BlbmRpbmdFbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSBudWxsO1xuXG4gICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5fbW91bnRPcmRlciA9IDA7XG4gICAgdGhpcy5fdG9wTGV2ZWxXcmFwcGVyID0gbnVsbDtcblxuICAgIC8vIFNlZSBSZWFjdFVwZGF0ZXMgYW5kIFJlYWN0VXBkYXRlUXVldWUuXG4gICAgdGhpcy5fcGVuZGluZ0NhbGxiYWNrcyA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBjb21wb25lbnQsIHJlbmRlcnMgbWFya3VwLCBhbmQgcmVnaXN0ZXJzIGV2ZW50IGxpc3RlbmVycy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJvb3RJRCBET00gSUQgb2YgdGhlIHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm4gez9zdHJpbmd9IFJlbmRlcmVkIG1hcmt1cCB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSBET00uXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAocm9vdElELCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuX21vdW50T3JkZXIgPSBuZXh0TW91bnRJRCsrO1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSByb290SUQ7XG5cbiAgICB2YXIgcHVibGljUHJvcHMgPSB0aGlzLl9wcm9jZXNzUHJvcHModGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHMpO1xuICAgIHZhciBwdWJsaWNDb250ZXh0ID0gdGhpcy5fcHJvY2Vzc0NvbnRleHQoY29udGV4dCk7XG5cbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIHB1YmxpYyBjbGFzc1xuICAgIHZhciBpbnN0O1xuICAgIHZhciByZW5kZXJlZEVsZW1lbnQ7XG5cbiAgICAvLyBUaGlzIGlzIGEgd2F5IHRvIGRldGVjdCBpZiBDb21wb25lbnQgaXMgYSBzdGF0ZWxlc3MgYXJyb3cgZnVuY3Rpb25cbiAgICAvLyBjb21wb25lbnQsIHdoaWNoIGlzIG5vdCBuZXdhYmxlLiBJdCBtaWdodCBub3QgYmUgMTAwJSByZWxpYWJsZSBidXQgaXNcbiAgICAvLyBzb21ldGhpbmcgd2UgY2FuIGRvIHVudGlsIHdlIHN0YXJ0IGRldGVjdGluZyB0aGF0IENvbXBvbmVudCBleHRlbmRzXG4gICAgLy8gUmVhY3QuQ29tcG9uZW50LiBXZSBhbHJlYWR5IGFzc3VtZSB0aGF0IHR5cGVvZiBDb21wb25lbnQgPT09ICdmdW5jdGlvbicuXG4gICAgdmFyIGNhbkluc3RhbnRpYXRlID0gKCdwcm90b3R5cGUnIGluIENvbXBvbmVudCk7XG5cbiAgICBpZiAoY2FuSW5zdGFudGlhdGUpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB0aGlzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGluc3QgPSBuZXcgQ29tcG9uZW50KHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCBSZWFjdFVwZGF0ZVF1ZXVlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zdCA9IG5ldyBDb21wb25lbnQocHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIFJlYWN0VXBkYXRlUXVldWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghY2FuSW5zdGFudGlhdGUgfHwgaW5zdCA9PT0gbnVsbCB8fCBpbnN0ID09PSBmYWxzZSB8fCBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoaW5zdCkpIHtcbiAgICAgIHJlbmRlcmVkRWxlbWVudCA9IGluc3Q7XG4gICAgICBpbnN0ID0gbmV3IFN0YXRlbGVzc0NvbXBvbmVudChDb21wb25lbnQpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgbGF0ZXIgaW4gX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCwgYnV0IGFkZCBhbiBlYXJseVxuICAgICAgLy8gd2FybmluZyBub3cgdG8gaGVscCBkZWJ1Z2dpbmdcbiAgICAgIGlmIChpbnN0LnJlbmRlciA9PSBudWxsKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogeW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBkZWZpbmUgYHJlbmRlcmAsIHJldHVybmVkICcgKyAnbnVsbC9mYWxzZSBmcm9tIGEgc3RhdGVsZXNzIGNvbXBvbmVudCwgb3IgdHJpZWQgdG8gcmVuZGVyIGFuICcgKyAnZWxlbWVudCB3aG9zZSB0eXBlIGlzIGEgZnVuY3Rpb24gdGhhdCBpc25cXCd0IGEgUmVhY3QgY29tcG9uZW50LicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSBzdXBwb3J0IEVTNiBpbmhlcml0aW5nIGZyb20gUmVhY3QuQ29tcG9uZW50LCB0aGUgbW9kdWxlIHBhdHRlcm4sXG4gICAgICAgIC8vIGFuZCBzdGF0ZWxlc3MgY29tcG9uZW50cywgYnV0IG5vdCBFUzYgY2xhc3NlcyB0aGF0IGRvbid0IGV4dGVuZFxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhDb21wb25lbnQucHJvdG90eXBlICYmIENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCB8fCAhY2FuSW5zdGFudGlhdGUgfHwgIShpbnN0IGluc3RhbmNlb2YgQ29tcG9uZW50KSwgJyVzKC4uLik6IFJlYWN0IGNvbXBvbmVudCBjbGFzc2VzIG11c3QgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZXNlIHNob3VsZCBiZSBzZXQgdXAgaW4gdGhlIGNvbnN0cnVjdG9yLCBidXQgYXMgYSBjb252ZW5pZW5jZSBmb3JcbiAgICAvLyBzaW1wbGVyIGNsYXNzIGFic3RyYWN0aW9ucywgd2Ugc2V0IHRoZW0gdXAgYWZ0ZXIgdGhlIGZhY3QuXG4gICAgaW5zdC5wcm9wcyA9IHB1YmxpY1Byb3BzO1xuICAgIGluc3QuY29udGV4dCA9IHB1YmxpY0NvbnRleHQ7XG4gICAgaW5zdC5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgaW5zdC51cGRhdGVyID0gUmVhY3RVcGRhdGVRdWV1ZTtcblxuICAgIHRoaXMuX2luc3RhbmNlID0gaW5zdDtcblxuICAgIC8vIFN0b3JlIGEgcmVmZXJlbmNlIGZyb20gdGhlIGluc3RhbmNlIGJhY2sgdG8gdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uXG4gICAgUmVhY3RJbnN0YW5jZU1hcC5zZXQoaW5zdCwgdGhpcyk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gU2luY2UgcGxhaW4gSlMgY2xhc3NlcyBhcmUgZGVmaW5lZCB3aXRob3V0IGFueSBzcGVjaWFsIGluaXRpYWxpemF0aW9uXG4gICAgICAvLyBsb2dpYywgd2UgY2FuIG5vdCBjYXRjaCBjb21tb24gZXJyb3JzIGVhcmx5LiBUaGVyZWZvcmUsIHdlIGhhdmUgdG9cbiAgICAgIC8vIGNhdGNoIHRoZW0gaGVyZSwgYXQgaW5pdGlhbGl6YXRpb24gdGltZSwgaW5zdGVhZC5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpbnN0LmdldEluaXRpYWxTdGF0ZSB8fCBpbnN0LmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCwgJ2dldEluaXRpYWxTdGF0ZSB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD8nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpbnN0LmdldERlZmF1bHRQcm9wcyB8fCBpbnN0LmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCwgJ2dldERlZmF1bHRQcm9wcyB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGRlZmF1bHRQcm9wcyBpbnN0ZWFkLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdhIGNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWluc3QucHJvcFR5cGVzLCAncHJvcFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgcHJvcFR5cGVzIGluc3RlYWQuJywgdGhpcy5nZXROYW1lKCkgfHwgJ2EgY29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaW5zdC5jb250ZXh0VHlwZXMsICdjb250ZXh0VHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhICcgKyAnc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZXMgaW5zdGVhZC4nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiBpbnN0LmNvbXBvbmVudFNob3VsZFVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICsgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICsgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIGluc3QuY29tcG9uZW50RGlkVW5tb3VudCAhPT0gJ2Z1bmN0aW9uJywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnREaWRVbm1vdW50KCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxVbm1vdW50KCk/JywgdGhpcy5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgaW5zdC5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzICE9PSAnZnVuY3Rpb24nLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCB0aGlzLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB2YXIgaW5pdGlhbFN0YXRlID0gaW5zdC5zdGF0ZTtcbiAgICBpZiAoaW5pdGlhbFN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGluc3Quc3RhdGUgPSBpbml0aWFsU3RhdGUgPSBudWxsO1xuICAgIH1cbiAgICAhKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGluaXRpYWxTdGF0ZSkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbCcsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XG5cbiAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsTW91bnQpIHtcbiAgICAgIGluc3QuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICAvLyBXaGVuIG1vdW50aW5nLCBjYWxscyB0byBgc2V0U3RhdGVgIGJ5IGBjb21wb25lbnRXaWxsTW91bnRgIHdpbGwgc2V0XG4gICAgICAvLyBgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWVgIHdpdGhvdXQgdHJpZ2dlcmluZyBhIHJlLXJlbmRlci5cbiAgICAgIGlmICh0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSkge1xuICAgICAgICBpbnN0LnN0YXRlID0gdGhpcy5fcHJvY2Vzc1BlbmRpbmdTdGF0ZShpbnN0LnByb3BzLCBpbnN0LmNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIG5vdCBhIHN0YXRlbGVzcyBjb21wb25lbnQsIHdlIG5vdyByZW5kZXJcbiAgICBpZiAocmVuZGVyZWRFbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlbmRlcmVkRWxlbWVudCA9IHRoaXMuX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCgpO1xuICAgIH1cblxuICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gdGhpcy5faW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChyZW5kZXJlZEVsZW1lbnQpO1xuXG4gICAgdmFyIG1hcmt1cCA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudCh0aGlzLl9yZW5kZXJlZENvbXBvbmVudCwgcm9vdElELCB0cmFuc2FjdGlvbiwgdGhpcy5fcHJvY2Vzc0NoaWxkQ29udGV4dChjb250ZXh0KSk7XG4gICAgaWYgKGluc3QuY29tcG9uZW50RGlkTW91bnQpIHtcbiAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoaW5zdC5jb21wb25lbnREaWRNb3VudCwgaW5zdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfSxcblxuICAvKipcbiAgICogUmVsZWFzZXMgYW55IHJlc291cmNlcyBhbGxvY2F0ZWQgYnkgYG1vdW50Q29tcG9uZW50YC5cbiAgICpcbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG5cbiAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsVW5tb3VudCkge1xuICAgICAgaW5zdC5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICAgIH1cblxuICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50KTtcbiAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IG51bGw7XG4gICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xuXG4gICAgLy8gUmVzZXQgcGVuZGluZyBmaWVsZHNcbiAgICAvLyBFdmVuIGlmIHRoaXMgY29tcG9uZW50IGlzIHNjaGVkdWxlZCBmb3IgYW5vdGhlciB1cGRhdGUgaW4gUmVhY3RVcGRhdGVzLFxuICAgIC8vIGl0IHdvdWxkIHN0aWxsIGJlIGlnbm9yZWQgYmVjYXVzZSB0aGVzZSBmaWVsZHMgYXJlIHJlc2V0LlxuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ0NhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ0VsZW1lbnQgPSBudWxsO1xuXG4gICAgLy8gVGhlc2UgZmllbGRzIGRvIG5vdCByZWFsbHkgbmVlZCB0byBiZSByZXNldCBzaW5jZSB0aGlzIG9iamVjdCBpcyBub1xuICAgIC8vIGxvbmdlciBhY2Nlc3NpYmxlLlxuICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSBudWxsO1xuICAgIHRoaXMuX3RvcExldmVsV3JhcHBlciA9IG51bGw7XG5cbiAgICAvLyBEZWxldGUgdGhlIHJlZmVyZW5jZSBmcm9tIHRoZSBpbnN0YW5jZSB0byB0aGlzIGludGVybmFsIHJlcHJlc2VudGF0aW9uXG4gICAgLy8gd2hpY2ggYWxsb3cgdGhlIGludGVybmFscyB0byBiZSBwcm9wZXJseSBjbGVhbmVkIHVwIGV2ZW4gaWYgdGhlIHVzZXJcbiAgICAvLyBsZWFrcyBhIHJlZmVyZW5jZSB0byB0aGUgcHVibGljIGluc3RhbmNlLlxuICAgIFJlYWN0SW5zdGFuY2VNYXAucmVtb3ZlKGluc3QpO1xuXG4gICAgLy8gU29tZSBleGlzdGluZyBjb21wb25lbnRzIHJlbHkgb24gaW5zdC5wcm9wcyBldmVuIGFmdGVyIHRoZXkndmUgYmVlblxuICAgIC8vIGRlc3Ryb3llZCAoaW4gZXZlbnQgaGFuZGxlcnMpLlxuICAgIC8vIFRPRE86IGluc3QucHJvcHMgPSBudWxsO1xuICAgIC8vIFRPRE86IGluc3Quc3RhdGUgPSBudWxsO1xuICAgIC8vIFRPRE86IGluc3QuY29udGV4dCA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbHRlcnMgdGhlIGNvbnRleHQgb2JqZWN0IHRvIG9ubHkgY29udGFpbiBrZXlzIHNwZWNpZmllZCBpblxuICAgKiBgY29udGV4dFR5cGVzYFxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21hc2tDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBtYXNrZWRDb250ZXh0ID0gbnVsbDtcbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICB2YXIgY29udGV4dFR5cGVzID0gQ29tcG9uZW50LmNvbnRleHRUeXBlcztcbiAgICBpZiAoIWNvbnRleHRUeXBlcykge1xuICAgICAgcmV0dXJuIGVtcHR5T2JqZWN0O1xuICAgIH1cbiAgICBtYXNrZWRDb250ZXh0ID0ge307XG4gICAgZm9yICh2YXIgY29udGV4dE5hbWUgaW4gY29udGV4dFR5cGVzKSB7XG4gICAgICBtYXNrZWRDb250ZXh0W2NvbnRleHROYW1lXSA9IGNvbnRleHRbY29udGV4dE5hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gbWFza2VkQ29udGV4dDtcbiAgfSxcblxuICAvKipcbiAgICogRmlsdGVycyB0aGUgY29udGV4dCBvYmplY3QgdG8gb25seSBjb250YWluIGtleXMgc3BlY2lmaWVkIGluXG4gICAqIGBjb250ZXh0VHlwZXNgLCBhbmQgYXNzZXJ0cyB0aGF0IHRoZXkgYXJlIHZhbGlkLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb2Nlc3NDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBtYXNrZWRDb250ZXh0ID0gdGhpcy5fbWFza0NvbnRleHQoY29udGV4dCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgICAgaWYgKENvbXBvbmVudC5jb250ZXh0VHlwZXMpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tQcm9wVHlwZXMoQ29tcG9uZW50LmNvbnRleHRUeXBlcywgbWFza2VkQ29udGV4dCwgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5jb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hc2tlZENvbnRleHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjdXJyZW50Q29udGV4dFxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJvY2Vzc0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKGN1cnJlbnRDb250ZXh0KSB7XG4gICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICB2YXIgY2hpbGRDb250ZXh0ID0gaW5zdC5nZXRDaGlsZENvbnRleHQgJiYgaW5zdC5nZXRDaGlsZENvbnRleHQoKTtcbiAgICBpZiAoY2hpbGRDb250ZXh0KSB7XG4gICAgICAhKHR5cGVvZiBDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMgPT09ICdvYmplY3QnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5nZXRDaGlsZENvbnRleHQoKTogY2hpbGRDb250ZXh0VHlwZXMgbXVzdCBiZSBkZWZpbmVkIGluIG9yZGVyIHRvICcgKyAndXNlIGdldENoaWxkQ29udGV4dCgpLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrUHJvcFR5cGVzKENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcywgY2hpbGRDb250ZXh0LCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLmNoaWxkQ29udGV4dCk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGNoaWxkQ29udGV4dCkge1xuICAgICAgICAhKG5hbWUgaW4gQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5nZXRDaGlsZENvbnRleHQoKToga2V5IFwiJXNcIiBpcyBub3QgZGVmaW5lZCBpbiBjaGlsZENvbnRleHRUeXBlcy4nLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnLCBuYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXNzaWduKHt9LCBjdXJyZW50Q29udGV4dCwgY2hpbGRDb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnRDb250ZXh0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBQcm9jZXNzZXMgcHJvcHMgYnkgc2V0dGluZyBkZWZhdWx0IHZhbHVlcyBmb3IgdW5zcGVjaWZpZWQgcHJvcHMgYW5kXG4gICAqIGFzc2VydGluZyB0aGF0IHRoZSBwcm9wcyBhcmUgdmFsaWQuIERvZXMgbm90IG11dGF0ZSBpdHMgYXJndW1lbnQ7IHJldHVybnNcbiAgICogYSBuZXcgcHJvcHMgb2JqZWN0IHdpdGggZGVmYXVsdHMgbWVyZ2VkIGluLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV3UHJvcHNcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb2Nlc3NQcm9wczogZnVuY3Rpb24gKG5ld1Byb3BzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgICAgaWYgKENvbXBvbmVudC5wcm9wVHlwZXMpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tQcm9wVHlwZXMoQ29tcG9uZW50LnByb3BUeXBlcywgbmV3UHJvcHMsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMucHJvcCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdQcm9wcztcbiAgfSxcblxuICAvKipcbiAgICogQXNzZXJ0IHRoYXQgdGhlIHByb3BzIGFyZSB2YWxpZFxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcFR5cGVzIE1hcCBvZiBwcm9wIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2hlY2tQcm9wVHlwZXM6IGZ1bmN0aW9uIChwcm9wVHlwZXMsIHByb3BzLCBsb2NhdGlvbikge1xuICAgIC8vIFRPRE86IFN0b3AgdmFsaWRhdGluZyBwcm9wIHR5cGVzIGhlcmUgYW5kIG9ubHkgdXNlIHRoZSBlbGVtZW50XG4gICAgLy8gdmFsaWRhdGlvbi5cbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IHRoaXMuZ2V0TmFtZSgpO1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BUeXBlcykge1xuICAgICAgaWYgKHByb3BUeXBlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICAhKHR5cGVvZiBwcm9wVHlwZXNbcHJvcE5hbWVdID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSAnICsgJ2Zyb20gUmVhY3QuUHJvcFR5cGVzLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCBwcm9wTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgICAgIGVycm9yID0gcHJvcFR5cGVzW3Byb3BOYW1lXShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgLy8gV2UgbWF5IHdhbnQgdG8gZXh0ZW5kIHRoaXMgbG9naWMgZm9yIHNpbWlsYXIgZXJyb3JzIGluXG4gICAgICAgICAgLy8gdG9wLWxldmVsIHJlbmRlciBjYWxscywgc28gSSdtIGFic3RyYWN0aW5nIGl0IGF3YXkgaW50b1xuICAgICAgICAgIC8vIGEgZnVuY3Rpb24gdG8gbWluaW1pemUgcmVmYWN0b3JpbmcgaW4gdGhlIGZ1dHVyZVxuICAgICAgICAgIHZhciBhZGRlbmR1bSA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSh0aGlzKTtcblxuICAgICAgICAgIGlmIChsb2NhdGlvbiA9PT0gUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5wcm9wKSB7XG4gICAgICAgICAgICAvLyBQcmVmYWNlIGdpdmVzIHVzIHNvbWV0aGluZyB0byBibGFja2xpc3QgaW4gd2FybmluZyBtb2R1bGVcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJXMlcycsIGVycm9yLm1lc3NhZ2UsIGFkZGVuZHVtKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgQ29udGV4dCBUeXBlczogJXMlcycsIGVycm9yLm1lc3NhZ2UsIGFkZGVuZHVtKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgbmV4dENvbnRleHQpIHtcbiAgICB2YXIgcHJldkVsZW1lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudDtcbiAgICB2YXIgcHJldkNvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xuXG4gICAgdGhpcy5fcGVuZGluZ0VsZW1lbnQgPSBudWxsO1xuXG4gICAgdGhpcy51cGRhdGVDb21wb25lbnQodHJhbnNhY3Rpb24sIHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCwgcHJldkNvbnRleHQsIG5leHRDb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogSWYgYW55IG9mIGBfcGVuZGluZ0VsZW1lbnRgLCBgX3BlbmRpbmdTdGF0ZVF1ZXVlYCwgb3IgYF9wZW5kaW5nRm9yY2VVcGRhdGVgXG4gICAqIGlzIHNldCwgdXBkYXRlIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwZXJmb3JtVXBkYXRlSWZOZWNlc3Nhcnk6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuICAgIGlmICh0aGlzLl9wZW5kaW5nRWxlbWVudCAhPSBudWxsKSB7XG4gICAgICBSZWFjdFJlY29uY2lsZXIucmVjZWl2ZUNvbXBvbmVudCh0aGlzLCB0aGlzLl9wZW5kaW5nRWxlbWVudCB8fCB0aGlzLl9jdXJyZW50RWxlbWVudCwgdHJhbnNhY3Rpb24sIHRoaXMuX2NvbnRleHQpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSAhPT0gbnVsbCB8fCB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUpIHtcbiAgICAgIHRoaXMudXBkYXRlQ29tcG9uZW50KHRyYW5zYWN0aW9uLCB0aGlzLl9jdXJyZW50RWxlbWVudCwgdGhpcy5fY3VycmVudEVsZW1lbnQsIHRoaXMuX2NvbnRleHQsIHRoaXMuX2NvbnRleHQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUGVyZm9ybSBhbiB1cGRhdGUgdG8gYSBtb3VudGVkIGNvbXBvbmVudC4gVGhlIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgYW5kXG4gICAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSBtZXRob2RzIGFyZSBjYWxsZWQsIHRoZW4gKGFzc3VtaW5nIHRoZSB1cGRhdGUgaXNuJ3RcbiAgICogc2tpcHBlZCkgdGhlIHJlbWFpbmluZyB1cGRhdGUgbGlmZWN5Y2xlIG1ldGhvZHMgYXJlIGNhbGxlZCBhbmQgdGhlIERPTVxuICAgKiByZXByZXNlbnRhdGlvbiBpcyB1cGRhdGVkLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGlzIGltcGxlbWVudHMgUmVhY3QncyByZW5kZXJpbmcgYW5kIHJlY29uY2lsaWF0aW9uIGFsZ29yaXRobS5cbiAgICogU29waGlzdGljYXRlZCBjbGllbnRzIG1heSB3aXNoIHRvIG92ZXJyaWRlIHRoaXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IHByZXZQYXJlbnRFbGVtZW50XG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0UGFyZW50RWxlbWVudFxuICAgKiBAaW50ZXJuYWxcbiAgICogQG92ZXJyaWRhYmxlXG4gICAqL1xuICB1cGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJldlBhcmVudEVsZW1lbnQsIG5leHRQYXJlbnRFbGVtZW50LCBwcmV2VW5tYXNrZWRDb250ZXh0LCBuZXh0VW5tYXNrZWRDb250ZXh0KSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcblxuICAgIHZhciBuZXh0Q29udGV4dCA9IHRoaXMuX2NvbnRleHQgPT09IG5leHRVbm1hc2tlZENvbnRleHQgPyBpbnN0LmNvbnRleHQgOiB0aGlzLl9wcm9jZXNzQ29udGV4dChuZXh0VW5tYXNrZWRDb250ZXh0KTtcbiAgICB2YXIgbmV4dFByb3BzO1xuXG4gICAgLy8gRGlzdGluZ3Vpc2ggYmV0d2VlbiBhIHByb3BzIHVwZGF0ZSB2ZXJzdXMgYSBzaW1wbGUgc3RhdGUgdXBkYXRlXG4gICAgaWYgKHByZXZQYXJlbnRFbGVtZW50ID09PSBuZXh0UGFyZW50RWxlbWVudCkge1xuICAgICAgLy8gU2tpcCBjaGVja2luZyBwcm9wIHR5cGVzIGFnYWluIC0tIHdlIGRvbid0IHJlYWQgaW5zdC5wcm9wcyB0byBhdm9pZFxuICAgICAgLy8gd2FybmluZyBmb3IgRE9NIGNvbXBvbmVudCBwcm9wcyBpbiB0aGlzIHVwZ3JhZGVcbiAgICAgIG5leHRQcm9wcyA9IG5leHRQYXJlbnRFbGVtZW50LnByb3BzO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0UHJvcHMgPSB0aGlzLl9wcm9jZXNzUHJvcHMobmV4dFBhcmVudEVsZW1lbnQucHJvcHMpO1xuICAgICAgLy8gQW4gdXBkYXRlIGhlcmUgd2lsbCBzY2hlZHVsZSBhbiB1cGRhdGUgYnV0IGltbWVkaWF0ZWx5IHNldFxuICAgICAgLy8gX3BlbmRpbmdTdGF0ZVF1ZXVlIHdoaWNoIHdpbGwgZW5zdXJlIHRoYXQgYW55IHN0YXRlIHVwZGF0ZXMgZ2V0c1xuICAgICAgLy8gaW1tZWRpYXRlbHkgcmVjb25jaWxlZCBpbnN0ZWFkIG9mIHdhaXRpbmcgZm9yIHRoZSBuZXh0IGJhdGNoLlxuXG4gICAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKSB7XG4gICAgICAgIGluc3QuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbmV4dFN0YXRlID0gdGhpcy5fcHJvY2Vzc1BlbmRpbmdTdGF0ZShuZXh0UHJvcHMsIG5leHRDb250ZXh0KTtcblxuICAgIHZhciBzaG91bGRVcGRhdGUgPSB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgfHwgIWluc3Quc2hvdWxkQ29tcG9uZW50VXBkYXRlIHx8IGluc3Quc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIHNob3VsZFVwZGF0ZSAhPT0gJ3VuZGVmaW5lZCcsICclcy5zaG91bGRDb21wb25lbnRVcGRhdGUoKTogUmV0dXJuZWQgdW5kZWZpbmVkIGluc3RlYWQgb2YgYSAnICsgJ2Jvb2xlYW4gdmFsdWUuIE1ha2Ugc3VyZSB0byByZXR1cm4gdHJ1ZSBvciBmYWxzZS4nLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcbiAgICAgIC8vIFdpbGwgc2V0IGB0aGlzLnByb3BzYCwgYHRoaXMuc3RhdGVgIGFuZCBgdGhpcy5jb250ZXh0YC5cbiAgICAgIHRoaXMuX3BlcmZvcm1Db21wb25lbnRVcGRhdGUobmV4dFBhcmVudEVsZW1lbnQsIG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCwgdHJhbnNhY3Rpb24sIG5leHRVbm1hc2tlZENvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBpdCdzIGRldGVybWluZWQgdGhhdCBhIGNvbXBvbmVudCBzaG91bGQgbm90IHVwZGF0ZSwgd2Ugc3RpbGwgd2FudFxuICAgICAgLy8gdG8gc2V0IHByb3BzIGFuZCBzdGF0ZSBidXQgd2Ugc2hvcnRjdXQgdGhlIHJlc3Qgb2YgdGhlIHVwZGF0ZS5cbiAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dFBhcmVudEVsZW1lbnQ7XG4gICAgICB0aGlzLl9jb250ZXh0ID0gbmV4dFVubWFza2VkQ29udGV4dDtcbiAgICAgIGluc3QucHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgICBpbnN0LnN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgaW5zdC5jb250ZXh0ID0gbmV4dENvbnRleHQ7XG4gICAgfVxuICB9LFxuXG4gIF9wcm9jZXNzUGVuZGluZ1N0YXRlOiBmdW5jdGlvbiAocHJvcHMsIGNvbnRleHQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgIHZhciBxdWV1ZSA9IHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlO1xuICAgIHZhciByZXBsYWNlID0gdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZTtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuXG4gICAgaWYgKCFxdWV1ZSkge1xuICAgICAgcmV0dXJuIGluc3Quc3RhdGU7XG4gICAgfVxuXG4gICAgaWYgKHJlcGxhY2UgJiYgcXVldWUubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gcXVldWVbMF07XG4gICAgfVxuXG4gICAgdmFyIG5leHRTdGF0ZSA9IGFzc2lnbih7fSwgcmVwbGFjZSA/IHF1ZXVlWzBdIDogaW5zdC5zdGF0ZSk7XG4gICAgZm9yICh2YXIgaSA9IHJlcGxhY2UgPyAxIDogMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcGFydGlhbCA9IHF1ZXVlW2ldO1xuICAgICAgYXNzaWduKG5leHRTdGF0ZSwgdHlwZW9mIHBhcnRpYWwgPT09ICdmdW5jdGlvbicgPyBwYXJ0aWFsLmNhbGwoaW5zdCwgbmV4dFN0YXRlLCBwcm9wcywgY29udGV4dCkgOiBwYXJ0aWFsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dFN0YXRlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNZXJnZXMgbmV3IHByb3BzIGFuZCBzdGF0ZSwgbm90aWZpZXMgZGVsZWdhdGUgbWV0aG9kcyBvZiB1cGRhdGUgYW5kXG4gICAqIHBlcmZvcm1zIHVwZGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IE5leHQgZWxlbWVudFxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzIE5leHQgcHVibGljIG9iamVjdCB0byBzZXQgYXMgcHJvcGVydGllcy5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGUgTmV4dCBvYmplY3QgdG8gc2V0IGFzIHN0YXRlLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0IE5leHQgcHVibGljIG9iamVjdCB0byBzZXQgYXMgY29udGV4dC5cbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gez9vYmplY3R9IHVubWFza2VkQ29udGV4dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3BlcmZvcm1Db21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgbmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0LCB0cmFuc2FjdGlvbiwgdW5tYXNrZWRDb250ZXh0KSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcblxuICAgIHZhciBoYXNDb21wb25lbnREaWRVcGRhdGUgPSBCb29sZWFuKGluc3QuY29tcG9uZW50RGlkVXBkYXRlKTtcbiAgICB2YXIgcHJldlByb3BzO1xuICAgIHZhciBwcmV2U3RhdGU7XG4gICAgdmFyIHByZXZDb250ZXh0O1xuICAgIGlmIChoYXNDb21wb25lbnREaWRVcGRhdGUpIHtcbiAgICAgIHByZXZQcm9wcyA9IGluc3QucHJvcHM7XG4gICAgICBwcmV2U3RhdGUgPSBpbnN0LnN0YXRlO1xuICAgICAgcHJldkNvbnRleHQgPSBpbnN0LmNvbnRleHQ7XG4gICAgfVxuXG4gICAgaWYgKGluc3QuY29tcG9uZW50V2lsbFVwZGF0ZSkge1xuICAgICAgaW5zdC5jb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgfVxuXG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBuZXh0RWxlbWVudDtcbiAgICB0aGlzLl9jb250ZXh0ID0gdW5tYXNrZWRDb250ZXh0O1xuICAgIGluc3QucHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgaW5zdC5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICBpbnN0LmNvbnRleHQgPSBuZXh0Q29udGV4dDtcblxuICAgIHRoaXMuX3VwZGF0ZVJlbmRlcmVkQ29tcG9uZW50KHRyYW5zYWN0aW9uLCB1bm1hc2tlZENvbnRleHQpO1xuXG4gICAgaWYgKGhhc0NvbXBvbmVudERpZFVwZGF0ZSkge1xuICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShpbnN0LmNvbXBvbmVudERpZFVwZGF0ZS5iaW5kKGluc3QsIHByZXZQcm9wcywgcHJldlN0YXRlLCBwcmV2Q29udGV4dCksIGluc3QpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2FsbCB0aGUgY29tcG9uZW50J3MgYHJlbmRlcmAgbWV0aG9kIGFuZCB1cGRhdGUgdGhlIERPTSBhY2NvcmRpbmdseS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF91cGRhdGVSZW5kZXJlZENvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIHByZXZDb21wb25lbnRJbnN0YW5jZSA9IHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50O1xuICAgIHZhciBwcmV2UmVuZGVyZWRFbGVtZW50ID0gcHJldkNvbXBvbmVudEluc3RhbmNlLl9jdXJyZW50RWxlbWVudDtcbiAgICB2YXIgbmV4dFJlbmRlcmVkRWxlbWVudCA9IHRoaXMuX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCgpO1xuICAgIGlmIChzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2UmVuZGVyZWRFbGVtZW50LCBuZXh0UmVuZGVyZWRFbGVtZW50KSkge1xuICAgICAgUmVhY3RSZWNvbmNpbGVyLnJlY2VpdmVDb21wb25lbnQocHJldkNvbXBvbmVudEluc3RhbmNlLCBuZXh0UmVuZGVyZWRFbGVtZW50LCB0cmFuc2FjdGlvbiwgdGhpcy5fcHJvY2Vzc0NoaWxkQ29udGV4dChjb250ZXh0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZXNlIHR3byBJRHMgYXJlIGFjdHVhbGx5IHRoZSBzYW1lISBCdXQgbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGF0LlxuICAgICAgdmFyIHRoaXNJRCA9IHRoaXMuX3Jvb3ROb2RlSUQ7XG4gICAgICB2YXIgcHJldkNvbXBvbmVudElEID0gcHJldkNvbXBvbmVudEluc3RhbmNlLl9yb290Tm9kZUlEO1xuICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocHJldkNvbXBvbmVudEluc3RhbmNlKTtcblxuICAgICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSB0aGlzLl9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5leHRSZW5kZXJlZEVsZW1lbnQpO1xuICAgICAgdmFyIG5leHRNYXJrdXAgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQodGhpcy5fcmVuZGVyZWRDb21wb25lbnQsIHRoaXNJRCwgdHJhbnNhY3Rpb24sIHRoaXMuX3Byb2Nlc3NDaGlsZENvbnRleHQoY29udGV4dCkpO1xuICAgICAgdGhpcy5fcmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRChwcmV2Q29tcG9uZW50SUQsIG5leHRNYXJrdXApO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3JlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQ6IGZ1bmN0aW9uIChwcmV2Q29tcG9uZW50SUQsIG5leHRNYXJrdXApIHtcbiAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnJlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQocHJldkNvbXBvbmVudElELCBuZXh0TWFya3VwKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudFdpdGhvdXRPd25lck9yQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG4gICAgdmFyIHJlbmRlcmVkQ29tcG9uZW50ID0gaW5zdC5yZW5kZXIoKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gV2UgYWxsb3cgYXV0by1tb2NrcyB0byBwcm9jZWVkIGFzIGlmIHRoZXkncmUgcmV0dXJuaW5nIG51bGwuXG4gICAgICBpZiAodHlwZW9mIHJlbmRlcmVkQ29tcG9uZW50ID09PSAndW5kZWZpbmVkJyAmJiBpbnN0LnJlbmRlci5faXNNb2NrRnVuY3Rpb24pIHtcbiAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBiYWQgcHJhY3RpY2UuIENvbnNpZGVyIHdhcm5pbmcgaGVyZSBhbmRcbiAgICAgICAgLy8gZGVwcmVjYXRpbmcgdGhpcyBjb252ZW5pZW5jZS5cbiAgICAgICAgcmVuZGVyZWRDb21wb25lbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZW5kZXJlZENvbXBvbmVudDtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVuZGVyZWRDb21wb25lbnQ7XG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHRoaXM7XG4gICAgdHJ5IHtcbiAgICAgIHJlbmRlcmVkQ29tcG9uZW50ID0gdGhpcy5fcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50V2l0aG91dE93bmVyT3JDb250ZXh0KCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgICAhKFxuICAgIC8vIFRPRE86IEFuIGBpc1ZhbGlkTm9kZWAgZnVuY3Rpb24gd291bGQgcHJvYmFibHkgYmUgbW9yZSBhcHByb3ByaWF0ZVxuICAgIHJlbmRlcmVkQ29tcG9uZW50ID09PSBudWxsIHx8IHJlbmRlcmVkQ29tcG9uZW50ID09PSBmYWxzZSB8fCBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQocmVuZGVyZWRDb21wb25lbnQpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5yZW5kZXIoKTogQSB2YWxpZCBSZWFjdENvbXBvbmVudCBtdXN0IGJlIHJldHVybmVkLiBZb3UgbWF5IGhhdmUgJyArICdyZXR1cm5lZCB1bmRlZmluZWQsIGFuIGFycmF5IG9yIHNvbWUgb3RoZXIgaW52YWxpZCBvYmplY3QuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiByZW5kZXJlZENvbXBvbmVudDtcbiAgfSxcblxuICAvKipcbiAgICogTGF6aWx5IGFsbG9jYXRlcyB0aGUgcmVmcyBvYmplY3QgYW5kIHN0b3JlcyBgY29tcG9uZW50YCBhcyBgcmVmYC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBSZWZlcmVuY2UgbmFtZS5cbiAgICogQHBhcmFtIHtjb21wb25lbnR9IGNvbXBvbmVudCBDb21wb25lbnQgdG8gc3RvcmUgYXMgYHJlZmAuXG4gICAqIEBmaW5hbFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXR0YWNoUmVmOiBmdW5jdGlvbiAocmVmLCBjb21wb25lbnQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICAhKGluc3QgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnU3RhdGVsZXNzIGZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGhhdmUgcmVmcy4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIHB1YmxpY0NvbXBvbmVudEluc3RhbmNlID0gY29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gY29tcG9uZW50ICYmIGNvbXBvbmVudC5nZXROYW1lID8gY29tcG9uZW50LmdldE5hbWUoKSA6ICdhIGNvbXBvbmVudCc7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwdWJsaWNDb21wb25lbnRJbnN0YW5jZSAhPSBudWxsLCAnU3RhdGVsZXNzIGZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGJlIGdpdmVuIHJlZnMgJyArICcoU2VlIHJlZiBcIiVzXCIgaW4gJXMgY3JlYXRlZCBieSAlcykuICcgKyAnQXR0ZW1wdHMgdG8gYWNjZXNzIHRoaXMgcmVmIHdpbGwgZmFpbC4nLCByZWYsIGNvbXBvbmVudE5hbWUsIHRoaXMuZ2V0TmFtZSgpKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmFyIHJlZnMgPSBpbnN0LnJlZnMgPT09IGVtcHR5T2JqZWN0ID8gaW5zdC5yZWZzID0ge30gOiBpbnN0LnJlZnM7XG4gICAgcmVmc1tyZWZdID0gcHVibGljQ29tcG9uZW50SW5zdGFuY2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERldGFjaGVzIGEgcmVmZXJlbmNlIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgTmFtZSB0byBkZXJlZmVyZW5jZS5cbiAgICogQGZpbmFsXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZXRhY2hSZWY6IGZ1bmN0aW9uIChyZWYpIHtcbiAgICB2YXIgcmVmcyA9IHRoaXMuZ2V0UHVibGljSW5zdGFuY2UoKS5yZWZzO1xuICAgIGRlbGV0ZSByZWZzW3JlZl07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBhIHRleHQgZGVzY3JpcHRpb24gb2YgdGhlIGNvbXBvbmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvIGlkZW50aWZ5IGl0XG4gICAqIGluIGVycm9yIG1lc3NhZ2VzLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBuYW1lIG9yIG51bGwuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0TmFtZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciB0eXBlID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICB2YXIgY29uc3RydWN0b3IgPSB0aGlzLl9pbnN0YW5jZSAmJiB0aGlzLl9pbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCBjb25zdHJ1Y3RvciAmJiBjb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgY29uc3RydWN0b3IgJiYgY29uc3RydWN0b3IubmFtZSB8fCBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHB1YmxpY2x5IGFjY2Vzc2libGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBjb21wb25lbnQgLSBpLmUuIHdoYXRcbiAgICogaXMgZXhwb3NlZCBieSByZWZzIGFuZCByZXR1cm5lZCBieSByZW5kZXIuIENhbiBiZSBudWxsIGZvciBzdGF0ZWxlc3NcbiAgICogY29tcG9uZW50cy5cbiAgICpcbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IHRoZSBwdWJsaWMgY29tcG9uZW50IGluc3RhbmNlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldFB1YmxpY0luc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICBpZiAoaW5zdCBpbnN0YW5jZW9mIFN0YXRlbGVzc0NvbXBvbmVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBpbnN0O1xuICB9LFxuXG4gIC8vIFN0dWJcbiAgX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQ6IG51bGxcblxufTtcblxuUmVhY3RQZXJmLm1lYXN1cmVNZXRob2RzKFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50TWl4aW4sICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcsIHtcbiAgbW91bnRDb21wb25lbnQ6ICdtb3VudENvbXBvbmVudCcsXG4gIHVwZGF0ZUNvbXBvbmVudDogJ3VwZGF0ZUNvbXBvbmVudCcsXG4gIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQ6ICdfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50J1xufSk7XG5cbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCA9IHtcblxuICBNaXhpbjogUmVhY3RDb21wb3NpdGVDb21wb25lbnRNaXhpblxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RDb21wb3NpdGVDb21wb25lbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgaW5qZWN0ZWQgPSBmYWxzZTtcblxudmFyIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQgPSB7XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsbHkgaW5qZWN0YWJsZSBlbnZpcm9ubWVudCBkZXBlbmRlbnQgY2xlYW51cCBob29rLiAoc2VydmVyIHZzLlxuICAgKiBicm93c2VyIGV0YykuIEV4YW1wbGU6IEEgYnJvd3NlciBzeXN0ZW0gY2FjaGVzIERPTSBub2RlcyBiYXNlZCBvbiBjb21wb25lbnRcbiAgICogSUQgYW5kIG11c3QgcmVtb3ZlIHRoYXQgY2FjaGUgZW50cnkgd2hlbiB0aGlzIGluc3RhbmNlIGlzIHVubW91bnRlZC5cbiAgICovXG4gIHVubW91bnRJREZyb21FbnZpcm9ubWVudDogbnVsbCxcblxuICAvKipcbiAgICogT3B0aW9uYWxseSBpbmplY3RhYmxlIGhvb2sgZm9yIHN3YXBwaW5nIG91dCBtb3VudCBpbWFnZXMgaW4gdGhlIG1pZGRsZSBvZlxuICAgKiB0aGUgdHJlZS5cbiAgICovXG4gIHJlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsbHkgaW5qZWN0YWJsZSBob29rIGZvciBwcm9jZXNzaW5nIGEgcXVldWUgb2YgY2hpbGQgdXBkYXRlcy4gV2lsbFxuICAgKiBsYXRlciBtb3ZlIGludG8gTXVsdGlDaGlsZENvbXBvbmVudHMuXG4gICAqL1xuICBwcm9jZXNzQ2hpbGRyZW5VcGRhdGVzOiBudWxsLFxuXG4gIGluamVjdGlvbjoge1xuICAgIGluamVjdEVudmlyb25tZW50OiBmdW5jdGlvbiAoZW52aXJvbm1lbnQpIHtcbiAgICAgICEhaW5qZWN0ZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQ6IGluamVjdEVudmlyb25tZW50KCkgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC51bm1vdW50SURGcm9tRW52aXJvbm1lbnQgPSBlbnZpcm9ubWVudC51bm1vdW50SURGcm9tRW52aXJvbm1lbnQ7XG4gICAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnJlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQgPSBlbnZpcm9ubWVudC5yZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEO1xuICAgICAgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5wcm9jZXNzQ2hpbGRyZW5VcGRhdGVzID0gZW52aXJvbm1lbnQucHJvY2Vzc0NoaWxkcmVuVXBkYXRlcztcbiAgICAgIGluamVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudEVudmlyb25tZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFByb3BUeXBlTG9jYXRpb25zXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5TWlycm9yID0gcmVxdWlyZSgnZmJqcy9saWIva2V5TWlycm9yJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25zID0ga2V5TWlycm9yKHtcbiAgcHJvcDogbnVsbCxcbiAgY29udGV4dDogbnVsbCxcbiAgY2hpbGRDb250ZXh0OiBudWxsXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25zO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0ge1xuICAgIHByb3A6ICdwcm9wJyxcbiAgICBjb250ZXh0OiAnY29udGV4dCcsXG4gICAgY2hpbGRDb250ZXh0OiAnY2hpbGQgY29udGV4dCdcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHaXZlbiBhIGBwcmV2RWxlbWVudGAgYW5kIGBuZXh0RWxlbWVudGAsIGRldGVybWluZXMgaWYgdGhlIGV4aXN0aW5nXG4gKiBpbnN0YW5jZSBzaG91bGQgYmUgdXBkYXRlZCBhcyBvcHBvc2VkIHRvIGJlaW5nIGRlc3Ryb3llZCBvciByZXBsYWNlZCBieSBhIG5ld1xuICogaW5zdGFuY2UuIEJvdGggYXJndW1lbnRzIGFyZSBlbGVtZW50cy4gVGhpcyBlbnN1cmVzIHRoYXQgdGhpcyBsb2dpYyBjYW5cbiAqIG9wZXJhdGUgb24gc3RhdGVsZXNzIHRyZWVzIHdpdGhvdXQgYW55IGJhY2tpbmcgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2RWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0RWxlbWVudFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXhpc3RpbmcgaW5zdGFuY2Ugc2hvdWxkIGJlIHVwZGF0ZWQuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCkge1xuICB2YXIgcHJldkVtcHR5ID0gcHJldkVsZW1lbnQgPT09IG51bGwgfHwgcHJldkVsZW1lbnQgPT09IGZhbHNlO1xuICB2YXIgbmV4dEVtcHR5ID0gbmV4dEVsZW1lbnQgPT09IG51bGwgfHwgbmV4dEVsZW1lbnQgPT09IGZhbHNlO1xuICBpZiAocHJldkVtcHR5IHx8IG5leHRFbXB0eSkge1xuICAgIHJldHVybiBwcmV2RW1wdHkgPT09IG5leHRFbXB0eTtcbiAgfVxuXG4gIHZhciBwcmV2VHlwZSA9IHR5cGVvZiBwcmV2RWxlbWVudDtcbiAgdmFyIG5leHRUeXBlID0gdHlwZW9mIG5leHRFbGVtZW50O1xuICBpZiAocHJldlR5cGUgPT09ICdzdHJpbmcnIHx8IHByZXZUeXBlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBuZXh0VHlwZSA9PT0gJ3N0cmluZycgfHwgbmV4dFR5cGUgPT09ICdudW1iZXInO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgcHJldkVsZW1lbnQudHlwZSA9PT0gbmV4dEVsZW1lbnQudHlwZSAmJiBwcmV2RWxlbWVudC5rZXkgPT09IG5leHRFbGVtZW50LmtleTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEVtcHR5Q29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50UmVnaXN0cnkgPSByZXF1aXJlKCcuL1JlYWN0RW1wdHlDb21wb25lbnRSZWdpc3RyeScpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcblxudmFyIHBsYWNlaG9sZGVyRWxlbWVudDtcblxudmFyIFJlYWN0RW1wdHlDb21wb25lbnRJbmplY3Rpb24gPSB7XG4gIGluamVjdEVtcHR5Q29tcG9uZW50OiBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgcGxhY2Vob2xkZXJFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJOdWxsQ29tcG9uZW50SUQoKSB7XG4gIFJlYWN0RW1wdHlDb21wb25lbnRSZWdpc3RyeS5yZWdpc3Rlck51bGxDb21wb25lbnRJRCh0aGlzLl9yb290Tm9kZUlEKTtcbn1cblxudmFyIFJlYWN0RW1wdHlDb21wb25lbnQgPSBmdW5jdGlvbiAoaW5zdGFudGlhdGUpIHtcbiAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBudWxsO1xuICB0aGlzLl9yb290Tm9kZUlEID0gbnVsbDtcbiAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSBpbnN0YW50aWF0ZShwbGFjZWhvbGRlckVsZW1lbnQpO1xufTtcbmFzc2lnbihSZWFjdEVtcHR5Q29tcG9uZW50LnByb3RvdHlwZSwge1xuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChlbGVtZW50KSB7fSxcbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChyb290SUQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShyZWdpc3Rlck51bGxDb21wb25lbnRJRCwgdGhpcyk7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IHJvb3RJRDtcbiAgICByZXR1cm4gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50LCByb290SUQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgfSxcbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKCkge30sXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChyb290SUQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQodGhpcy5fcmVuZGVyZWRDb21wb25lbnQpO1xuICAgIFJlYWN0RW1wdHlDb21wb25lbnRSZWdpc3RyeS5kZXJlZ2lzdGVyTnVsbENvbXBvbmVudElEKHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSBudWxsO1xuICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gbnVsbDtcbiAgfVxufSk7XG5cblJlYWN0RW1wdHlDb21wb25lbnQuaW5qZWN0aW9uID0gUmVhY3RFbXB0eUNvbXBvbmVudEluamVjdGlvbjtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVtcHR5Q29tcG9uZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RFbXB0eUNvbXBvbmVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE5hdGl2ZUNvbXBvbmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgYXV0b0dlbmVyYXRlV3JhcHBlckNsYXNzID0gbnVsbDtcbnZhciBnZW5lcmljQ29tcG9uZW50Q2xhc3MgPSBudWxsO1xuLy8gVGhpcyByZWdpc3RyeSBrZWVwcyB0cmFjayBvZiB3cmFwcGVyIGNsYXNzZXMgYXJvdW5kIG5hdGl2ZSB0YWdzLlxudmFyIHRhZ1RvQ29tcG9uZW50Q2xhc3MgPSB7fTtcbnZhciB0ZXh0Q29tcG9uZW50Q2xhc3MgPSBudWxsO1xuXG52YXIgUmVhY3ROYXRpdmVDb21wb25lbnRJbmplY3Rpb24gPSB7XG4gIC8vIFRoaXMgYWNjZXB0cyBhIGNsYXNzIHRoYXQgcmVjZWl2ZXMgdGhlIHRhZyBzdHJpbmcuIFRoaXMgaXMgYSBjYXRjaCBhbGxcbiAgLy8gdGhhdCBjYW4gcmVuZGVyIGFueSBraW5kIG9mIHRhZy5cbiAgaW5qZWN0R2VuZXJpY0NvbXBvbmVudENsYXNzOiBmdW5jdGlvbiAoY29tcG9uZW50Q2xhc3MpIHtcbiAgICBnZW5lcmljQ29tcG9uZW50Q2xhc3MgPSBjb21wb25lbnRDbGFzcztcbiAgfSxcbiAgLy8gVGhpcyBhY2NlcHRzIGEgdGV4dCBjb21wb25lbnQgY2xhc3MgdGhhdCB0YWtlcyB0aGUgdGV4dCBzdHJpbmcgdG8gYmVcbiAgLy8gcmVuZGVyZWQgYXMgcHJvcHMuXG4gIGluamVjdFRleHRDb21wb25lbnRDbGFzczogZnVuY3Rpb24gKGNvbXBvbmVudENsYXNzKSB7XG4gICAgdGV4dENvbXBvbmVudENsYXNzID0gY29tcG9uZW50Q2xhc3M7XG4gIH0sXG4gIC8vIFRoaXMgYWNjZXB0cyBhIGtleWVkIG9iamVjdCB3aXRoIGNsYXNzZXMgYXMgdmFsdWVzLiBFYWNoIGtleSByZXByZXNlbnRzIGFcbiAgLy8gdGFnLiBUaGF0IHBhcnRpY3VsYXIgdGFnIHdpbGwgdXNlIHRoaXMgY2xhc3MgaW5zdGVhZCBvZiB0aGUgZ2VuZXJpYyBvbmUuXG4gIGluamVjdENvbXBvbmVudENsYXNzZXM6IGZ1bmN0aW9uIChjb21wb25lbnRDbGFzc2VzKSB7XG4gICAgYXNzaWduKHRhZ1RvQ29tcG9uZW50Q2xhc3MsIGNvbXBvbmVudENsYXNzZXMpO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCBhIGNvbXBvc2l0ZSBjb21wb25lbnQgd3JhcHBlciBjbGFzcyBmb3IgYSBzcGVjaWZpYyB0YWcuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgVGhlIHRhZyBmb3Igd2hpY2ggdG8gZ2V0IHRoZSBjbGFzcy5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgUmVhY3QgY2xhc3MgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvbmVudENsYXNzRm9yRWxlbWVudChlbGVtZW50KSB7XG4gIGlmICh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQudHlwZTtcbiAgfVxuICB2YXIgdGFnID0gZWxlbWVudC50eXBlO1xuICB2YXIgY29tcG9uZW50Q2xhc3MgPSB0YWdUb0NvbXBvbmVudENsYXNzW3RhZ107XG4gIGlmIChjb21wb25lbnRDbGFzcyA9PSBudWxsKSB7XG4gICAgdGFnVG9Db21wb25lbnRDbGFzc1t0YWddID0gY29tcG9uZW50Q2xhc3MgPSBhdXRvR2VuZXJhdGVXcmFwcGVyQ2xhc3ModGFnKTtcbiAgfVxuICByZXR1cm4gY29tcG9uZW50Q2xhc3M7XG59XG5cbi8qKlxuICogR2V0IGEgbmF0aXZlIGludGVybmFsIGNvbXBvbmVudCBjbGFzcyBmb3IgYSBzcGVjaWZpYyB0YWcuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gY3JlYXRlLlxuICogQHJldHVybiB7ZnVuY3Rpb259IFRoZSBpbnRlcm5hbCBjbGFzcyBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW50ZXJuYWxDb21wb25lbnQoZWxlbWVudCkge1xuICAhZ2VuZXJpY0NvbXBvbmVudENsYXNzID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RoZXJlIGlzIG5vIHJlZ2lzdGVyZWQgY29tcG9uZW50IGZvciB0aGUgdGFnICVzJywgZWxlbWVudC50eXBlKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBuZXcgZ2VuZXJpY0NvbXBvbmVudENsYXNzKGVsZW1lbnQudHlwZSwgZWxlbWVudC5wcm9wcyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFjdFRleHR9IHRleHRcbiAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZUZvclRleHQodGV4dCkge1xuICByZXR1cm4gbmV3IHRleHRDb21wb25lbnRDbGFzcyh0ZXh0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVGV4dENvbXBvbmVudChjb21wb25lbnQpIHtcbiAgcmV0dXJuIGNvbXBvbmVudCBpbnN0YW5jZW9mIHRleHRDb21wb25lbnRDbGFzcztcbn1cblxudmFyIFJlYWN0TmF0aXZlQ29tcG9uZW50ID0ge1xuICBnZXRDb21wb25lbnRDbGFzc0ZvckVsZW1lbnQ6IGdldENvbXBvbmVudENsYXNzRm9yRWxlbWVudCxcbiAgY3JlYXRlSW50ZXJuYWxDb21wb25lbnQ6IGNyZWF0ZUludGVybmFsQ29tcG9uZW50LFxuICBjcmVhdGVJbnN0YW5jZUZvclRleHQ6IGNyZWF0ZUluc3RhbmNlRm9yVGV4dCxcbiAgaXNUZXh0Q29tcG9uZW50OiBpc1RleHRDb21wb25lbnQsXG4gIGluamVjdGlvbjogUmVhY3ROYXRpdmVDb21wb25lbnRJbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3ROYXRpdmVDb21wb25lbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdE5hdGl2ZUNvbXBvbmVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgdmFsaWRhdGVET01OZXN0aW5nXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgLy8gVGhpcyB2YWxpZGF0aW9uIGNvZGUgd2FzIHdyaXR0ZW4gYmFzZWQgb24gdGhlIEhUTUw1IHBhcnNpbmcgc3BlYzpcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgLy9cbiAgLy8gTm90ZTogdGhpcyBkb2VzIG5vdCBjYXRjaCBhbGwgaW52YWxpZCBuZXN0aW5nLCBub3IgZG9lcyBpdCB0cnkgdG8gKGFzIGl0J3NcbiAgLy8gbm90IGNsZWFyIHdoYXQgcHJhY3RpY2FsIGJlbmVmaXQgZG9pbmcgc28gcHJvdmlkZXMpOyBpbnN0ZWFkLCB3ZSB3YXJuIG9ubHlcbiAgLy8gZm9yIGNhc2VzIHdoZXJlIHRoZSBwYXJzZXIgd2lsbCBnaXZlIGEgcGFyc2UgdHJlZSBkaWZmZXJpbmcgZnJvbSB3aGF0IFJlYWN0XG4gIC8vIGludGVuZGVkLiBGb3IgZXhhbXBsZSwgPGI+PGRpdj48L2Rpdj48L2I+IGlzIGludmFsaWQgYnV0IHdlIGRvbid0IHdhcm5cbiAgLy8gYmVjYXVzZSBpdCBzdGlsbCBwYXJzZXMgY29ycmVjdGx5OyB3ZSBkbyB3YXJuIGZvciBvdGhlciBjYXNlcyBsaWtlIG5lc3RlZFxuICAvLyA8cD4gdGFncyB3aGVyZSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBpbXBsaWNpdGx5IGNsb3NlcyB0aGVcbiAgLy8gZmlyc3QsIGNhdXNpbmcgYSBjb25mdXNpbmcgbWVzcy5cblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNzcGVjaWFsXG4gIHZhciBzcGVjaWFsVGFncyA9IFsnYWRkcmVzcycsICdhcHBsZXQnLCAnYXJlYScsICdhcnRpY2xlJywgJ2FzaWRlJywgJ2Jhc2UnLCAnYmFzZWZvbnQnLCAnYmdzb3VuZCcsICdibG9ja3F1b3RlJywgJ2JvZHknLCAnYnInLCAnYnV0dG9uJywgJ2NhcHRpb24nLCAnY2VudGVyJywgJ2NvbCcsICdjb2xncm91cCcsICdkZCcsICdkZXRhaWxzJywgJ2RpcicsICdkaXYnLCAnZGwnLCAnZHQnLCAnZW1iZWQnLCAnZmllbGRzZXQnLCAnZmlnY2FwdGlvbicsICdmaWd1cmUnLCAnZm9vdGVyJywgJ2Zvcm0nLCAnZnJhbWUnLCAnZnJhbWVzZXQnLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGVhZCcsICdoZWFkZXInLCAnaGdyb3VwJywgJ2hyJywgJ2h0bWwnLCAnaWZyYW1lJywgJ2ltZycsICdpbnB1dCcsICdpc2luZGV4JywgJ2xpJywgJ2xpbmsnLCAnbGlzdGluZycsICdtYWluJywgJ21hcnF1ZWUnLCAnbWVudScsICdtZW51aXRlbScsICdtZXRhJywgJ25hdicsICdub2VtYmVkJywgJ25vZnJhbWVzJywgJ25vc2NyaXB0JywgJ29iamVjdCcsICdvbCcsICdwJywgJ3BhcmFtJywgJ3BsYWludGV4dCcsICdwcmUnLCAnc2NyaXB0JywgJ3NlY3Rpb24nLCAnc2VsZWN0JywgJ3NvdXJjZScsICdzdHlsZScsICdzdW1tYXJ5JywgJ3RhYmxlJywgJ3Rib2R5JywgJ3RkJywgJ3RlbXBsYXRlJywgJ3RleHRhcmVhJywgJ3Rmb290JywgJ3RoJywgJ3RoZWFkJywgJ3RpdGxlJywgJ3RyJywgJ3RyYWNrJywgJ3VsJywgJ3dicicsICd4bXAnXTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuICB2YXIgaW5TY29wZVRhZ3MgPSBbJ2FwcGxldCcsICdjYXB0aW9uJywgJ2h0bWwnLCAndGFibGUnLCAndGQnLCAndGgnLCAnbWFycXVlZScsICdvYmplY3QnLCAndGVtcGxhdGUnLFxuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2h0bWwtaW50ZWdyYXRpb24tcG9pbnRcbiAgLy8gVE9ETzogRGlzdGluZ3Vpc2ggYnkgbmFtZXNwYWNlIGhlcmUgLS0gZm9yIDx0aXRsZT4sIGluY2x1ZGluZyBpdCBoZXJlXG4gIC8vIGVycnMgb24gdGhlIHNpZGUgb2YgZmV3ZXIgd2FybmluZ3NcbiAgJ2ZvcmVpZ25PYmplY3QnLCAnZGVzYycsICd0aXRsZSddO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLWJ1dHRvbi1zY29wZVxuICB2YXIgYnV0dG9uU2NvcGVUYWdzID0gaW5TY29wZVRhZ3MuY29uY2F0KFsnYnV0dG9uJ10pO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2dlbmVyYXRlLWltcGxpZWQtZW5kLXRhZ3NcbiAgdmFyIGltcGxpZWRFbmRUYWdzID0gWydkZCcsICdkdCcsICdsaScsICdvcHRpb24nLCAnb3B0Z3JvdXAnLCAncCcsICdycCcsICdydCddO1xuXG4gIHZhciBlbXB0eUFuY2VzdG9ySW5mbyA9IHtcbiAgICBwYXJlbnRUYWc6IG51bGwsXG5cbiAgICBmb3JtVGFnOiBudWxsLFxuICAgIGFUYWdJblNjb3BlOiBudWxsLFxuICAgIGJ1dHRvblRhZ0luU2NvcGU6IG51bGwsXG4gICAgbm9iclRhZ0luU2NvcGU6IG51bGwsXG4gICAgcFRhZ0luQnV0dG9uU2NvcGU6IG51bGwsXG5cbiAgICBsaXN0SXRlbVRhZ0F1dG9jbG9zaW5nOiBudWxsLFxuICAgIGRsSXRlbVRhZ0F1dG9jbG9zaW5nOiBudWxsXG4gIH07XG5cbiAgdmFyIHVwZGF0ZWRBbmNlc3RvckluZm8gPSBmdW5jdGlvbiAob2xkSW5mbywgdGFnLCBpbnN0YW5jZSkge1xuICAgIHZhciBhbmNlc3RvckluZm8gPSBhc3NpZ24oe30sIG9sZEluZm8gfHwgZW1wdHlBbmNlc3RvckluZm8pO1xuICAgIHZhciBpbmZvID0geyB0YWc6IHRhZywgaW5zdGFuY2U6IGluc3RhbmNlIH07XG5cbiAgICBpZiAoaW5TY29wZVRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSkge1xuICAgICAgYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChidXR0b25TY29wZVRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSkge1xuICAgICAgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTZWUgcnVsZXMgZm9yICdsaScsICdkZCcsICdkdCcgc3RhcnQgdGFncyBpblxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcbiAgICBpZiAoc3BlY2lhbFRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSAmJiB0YWcgIT09ICdhZGRyZXNzJyAmJiB0YWcgIT09ICdkaXYnICYmIHRhZyAhPT0gJ3AnKSB7XG4gICAgICBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3NpbmcgPSBudWxsO1xuICAgIH1cblxuICAgIGFuY2VzdG9ySW5mby5wYXJlbnRUYWcgPSBpbmZvO1xuXG4gICAgaWYgKHRhZyA9PT0gJ2Zvcm0nKSB7XG4gICAgICBhbmNlc3RvckluZm8uZm9ybVRhZyA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdhJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2J1dHRvbicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ25vYnInKSB7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdsaScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2RkJyB8fCB0YWcgPT09ICdkdCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuY2VzdG9ySW5mbztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL1xuICB2YXIgaXNUYWdWYWxpZFdpdGhQYXJlbnQgPSBmdW5jdGlvbiAodGFnLCBwYXJlbnRUYWcpIHtcbiAgICAvLyBGaXJzdCwgbGV0J3MgY2hlY2sgaWYgd2UncmUgaW4gYW4gdW51c3VhbCBwYXJzaW5nIG1vZGUuLi5cbiAgICBzd2l0Y2ggKHBhcmVudFRhZykge1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluc2VsZWN0XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICdvcHRncm91cCcgfHwgdGFnID09PSAnI3RleHQnO1xuICAgICAgY2FzZSAnb3B0Z3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICcjdGV4dCc7XG4gICAgICAvLyBTdHJpY3RseSBzcGVha2luZywgc2VlaW5nIGFuIDxvcHRpb24+IGRvZXNuJ3QgbWVhbiB3ZSdyZSBpbiBhIDxzZWxlY3Q+XG4gICAgICAvLyBidXRcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICcjdGV4dCc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRkXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jYXB0aW9uXG4gICAgICAvLyBObyBzcGVjaWFsIGJlaGF2aW9yIHNpbmNlIHRoZXNlIHJ1bGVzIGZhbGwgYmFjayB0byBcImluIGJvZHlcIiBtb2RlIGZvclxuICAgICAgLy8gYWxsIGV4Y2VwdCBzcGVjaWFsIHRhYmxlIG5vZGVzIHdoaWNoIGNhdXNlIGJhZCBwYXJzaW5nIGJlaGF2aW9yIGFueXdheS5cblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludHJcbiAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RoJyB8fCB0YWcgPT09ICd0ZCcgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50Ym9keVxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAndHInIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY29sZ3JvdXBcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NvbCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50YWJsZVxuICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY2FwdGlvbicgfHwgdGFnID09PSAnY29sZ3JvdXAnIHx8IHRhZyA9PT0gJ3Rib2R5JyB8fCB0YWcgPT09ICd0Zm9vdCcgfHwgdGFnID09PSAndGhlYWQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluaGVhZFxuICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdiYXNlJyB8fCB0YWcgPT09ICdiYXNlZm9udCcgfHwgdGFnID09PSAnYmdzb3VuZCcgfHwgdGFnID09PSAnbGluaycgfHwgdGFnID09PSAnbWV0YScgfHwgdGFnID09PSAndGl0bGUnIHx8IHRhZyA9PT0gJ25vc2NyaXB0JyB8fCB0YWcgPT09ICdub2ZyYW1lcycgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZW1hbnRpY3MuaHRtbCN0aGUtaHRtbC1lbGVtZW50XG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2hlYWQnIHx8IHRhZyA9PT0gJ2JvZHknO1xuICAgIH1cblxuICAgIC8vIFByb2JhYmx5IGluIHRoZSBcImluIGJvZHlcIiBwYXJzaW5nIG1vZGUsIHNvIHdlIG91dGxhdyBvbmx5IHRhZyBjb21ib3NcbiAgICAvLyB3aGVyZSB0aGUgcGFyc2luZyBydWxlcyBjYXVzZSBpbXBsaWNpdCBvcGVucyBvciBjbG9zZXMgdG8gYmUgYWRkZWQuXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgIT09ICdoMScgJiYgcGFyZW50VGFnICE9PSAnaDInICYmIHBhcmVudFRhZyAhPT0gJ2gzJyAmJiBwYXJlbnRUYWcgIT09ICdoNCcgJiYgcGFyZW50VGFnICE9PSAnaDUnICYmIHBhcmVudFRhZyAhPT0gJ2g2JztcblxuICAgICAgY2FzZSAncnAnOlxuICAgICAgY2FzZSAncnQnOlxuICAgICAgICByZXR1cm4gaW1wbGllZEVuZFRhZ3MuaW5kZXhPZihwYXJlbnRUYWcpID09PSAtMTtcblxuICAgICAgY2FzZSAnY2FwdGlvbic6XG4gICAgICBjYXNlICdjb2wnOlxuICAgICAgY2FzZSAnY29sZ3JvdXAnOlxuICAgICAgY2FzZSAnZnJhbWUnOlxuICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0ZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICBjYXNlICd0aCc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIC8vIFRoZXNlIHRhZ3MgYXJlIG9ubHkgdmFsaWQgd2l0aCBhIGZldyBwYXJlbnRzIHRoYXQgaGF2ZSBzcGVjaWFsIGNoaWxkXG4gICAgICAgIC8vIHBhcnNpbmcgcnVsZXMgLS0gaWYgd2UncmUgZG93biBoZXJlLCB0aGVuIG5vbmUgb2YgdGhvc2UgbWF0Y2hlZCBhbmRcbiAgICAgICAgLy8gc28gd2UgYWxsb3cgaXQgb25seSBpZiB3ZSBkb24ndCBrbm93IHdoYXQgdGhlIHBhcmVudCBpcywgYXMgYWxsIG90aGVyXG4gICAgICAgIC8vIGNhc2VzIGFyZSBpbnZhbGlkLlxuICAgICAgICByZXR1cm4gcGFyZW50VGFnID09IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi9cbiAgdmFyIGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcgPSBmdW5jdGlvbiAodGFnLCBhbmNlc3RvckluZm8pIHtcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnYWRkcmVzcyc6XG4gICAgICBjYXNlICdhcnRpY2xlJzpcbiAgICAgIGNhc2UgJ2FzaWRlJzpcbiAgICAgIGNhc2UgJ2Jsb2NrcXVvdGUnOlxuICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgY2FzZSAnZGlhbG9nJzpcbiAgICAgIGNhc2UgJ2Rpcic6XG4gICAgICBjYXNlICdkaXYnOlxuICAgICAgY2FzZSAnZGwnOlxuICAgICAgY2FzZSAnZmllbGRzZXQnOlxuICAgICAgY2FzZSAnZmlnY2FwdGlvbic6XG4gICAgICBjYXNlICdmaWd1cmUnOlxuICAgICAgY2FzZSAnZm9vdGVyJzpcbiAgICAgIGNhc2UgJ2hlYWRlcic6XG4gICAgICBjYXNlICdoZ3JvdXAnOlxuICAgICAgY2FzZSAnbWFpbic6XG4gICAgICBjYXNlICdtZW51JzpcbiAgICAgIGNhc2UgJ25hdic6XG4gICAgICBjYXNlICdvbCc6XG4gICAgICBjYXNlICdwJzpcbiAgICAgIGNhc2UgJ3NlY3Rpb24nOlxuICAgICAgY2FzZSAnc3VtbWFyeSc6XG4gICAgICBjYXNlICd1bCc6XG5cbiAgICAgIGNhc2UgJ3ByZSc6XG4gICAgICBjYXNlICdsaXN0aW5nJzpcblxuICAgICAgY2FzZSAndGFibGUnOlxuXG4gICAgICBjYXNlICdocic6XG5cbiAgICAgIGNhc2UgJ3htcCc6XG5cbiAgICAgIGNhc2UgJ2gxJzpcbiAgICAgIGNhc2UgJ2gyJzpcbiAgICAgIGNhc2UgJ2gzJzpcbiAgICAgIGNhc2UgJ2g0JzpcbiAgICAgIGNhc2UgJ2g1JzpcbiAgICAgIGNhc2UgJ2g2JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnZm9ybSc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZm9ybVRhZyB8fCBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2xpJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nO1xuXG4gICAgICBjYXNlICdkZCc6XG4gICAgICBjYXNlICdkdCc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnYSc6XG4gICAgICAgIC8vIFNwZWMgc2F5cyBzb21ldGhpbmcgYWJvdXQgc3RvcmluZyBhIGxpc3Qgb2YgbWFya2VycywgYnV0IGl0IHNvdW5kc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIHRoaXMgY2hlY2suXG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGU7XG5cbiAgICAgIGNhc2UgJ25vYnInOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHaXZlbiBhIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50IGluc3RhbmNlLCByZXR1cm4gYSBsaXN0IG9mIGl0cyByZWN1cnNpdmVcbiAgICogb3duZXJzLCBzdGFydGluZyBhdCB0aGUgcm9vdCBhbmQgZW5kaW5nIHdpdGggdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIHZhciBmaW5kT3duZXJTdGFjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICAvKmVzbGludC1kaXNhYmxlIHNwYWNlLWFmdGVyLWtleXdvcmRzICovXG4gICAgZG8ge1xuICAgICAgLyplc2xpbnQtZW5hYmxlIHNwYWNlLWFmdGVyLWtleXdvcmRzICovXG4gICAgICBzdGFjay5wdXNoKGluc3RhbmNlKTtcbiAgICB9IHdoaWxlIChpbnN0YW5jZSA9IGluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXIpO1xuICAgIHN0YWNrLnJldmVyc2UoKTtcbiAgICByZXR1cm4gc3RhY2s7XG4gIH07XG5cbiAgdmFyIGRpZFdhcm4gPSB7fTtcblxuICB2YWxpZGF0ZURPTU5lc3RpbmcgPSBmdW5jdGlvbiAoY2hpbGRUYWcsIGNoaWxkSW5zdGFuY2UsIGFuY2VzdG9ySW5mbykge1xuICAgIGFuY2VzdG9ySW5mbyA9IGFuY2VzdG9ySW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbztcbiAgICB2YXIgcGFyZW50SW5mbyA9IGFuY2VzdG9ySW5mby5wYXJlbnRUYWc7XG4gICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XG5cbiAgICB2YXIgaW52YWxpZFBhcmVudCA9IGlzVGFnVmFsaWRXaXRoUGFyZW50KGNoaWxkVGFnLCBwYXJlbnRUYWcpID8gbnVsbCA6IHBhcmVudEluZm87XG4gICAgdmFyIGludmFsaWRBbmNlc3RvciA9IGludmFsaWRQYXJlbnQgPyBudWxsIDogZmluZEludmFsaWRBbmNlc3RvckZvclRhZyhjaGlsZFRhZywgYW5jZXN0b3JJbmZvKTtcbiAgICB2YXIgcHJvYmxlbWF0aWMgPSBpbnZhbGlkUGFyZW50IHx8IGludmFsaWRBbmNlc3RvcjtcblxuICAgIGlmIChwcm9ibGVtYXRpYykge1xuICAgICAgdmFyIGFuY2VzdG9yVGFnID0gcHJvYmxlbWF0aWMudGFnO1xuICAgICAgdmFyIGFuY2VzdG9ySW5zdGFuY2UgPSBwcm9ibGVtYXRpYy5pbnN0YW5jZTtcblxuICAgICAgdmFyIGNoaWxkT3duZXIgPSBjaGlsZEluc3RhbmNlICYmIGNoaWxkSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBhbmNlc3Rvck93bmVyID0gYW5jZXN0b3JJbnN0YW5jZSAmJiBhbmNlc3Rvckluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XG5cbiAgICAgIHZhciBjaGlsZE93bmVycyA9IGZpbmRPd25lclN0YWNrKGNoaWxkT3duZXIpO1xuICAgICAgdmFyIGFuY2VzdG9yT3duZXJzID0gZmluZE93bmVyU3RhY2soYW5jZXN0b3JPd25lcik7XG5cbiAgICAgIHZhciBtaW5TdGFja0xlbiA9IE1hdGgubWluKGNoaWxkT3duZXJzLmxlbmd0aCwgYW5jZXN0b3JPd25lcnMubGVuZ3RoKTtcbiAgICAgIHZhciBpO1xuXG4gICAgICB2YXIgZGVlcGVzdENvbW1vbiA9IC0xO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG1pblN0YWNrTGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGNoaWxkT3duZXJzW2ldID09PSBhbmNlc3Rvck93bmVyc1tpXSkge1xuICAgICAgICAgIGRlZXBlc3RDb21tb24gPSBpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBVTktOT1dOID0gJyh1bmtub3duKSc7XG4gICAgICB2YXIgY2hpbGRPd25lck5hbWVzID0gY2hpbGRPd25lcnMuc2xpY2UoZGVlcGVzdENvbW1vbiArIDEpLm1hcChmdW5jdGlvbiAoaW5zdCkge1xuICAgICAgICByZXR1cm4gaW5zdC5nZXROYW1lKCkgfHwgVU5LTk9XTjtcbiAgICAgIH0pO1xuICAgICAgdmFyIGFuY2VzdG9yT3duZXJOYW1lcyA9IGFuY2VzdG9yT3duZXJzLnNsaWNlKGRlZXBlc3RDb21tb24gKyAxKS5tYXAoZnVuY3Rpb24gKGluc3QpIHtcbiAgICAgICAgcmV0dXJuIGluc3QuZ2V0TmFtZSgpIHx8IFVOS05PV047XG4gICAgICB9KTtcbiAgICAgIHZhciBvd25lckluZm8gPSBbXS5jb25jYXQoXG4gICAgICAvLyBJZiB0aGUgcGFyZW50IGFuZCBjaGlsZCBpbnN0YW5jZXMgaGF2ZSBhIGNvbW1vbiBvd25lciBhbmNlc3Rvciwgc3RhcnRcbiAgICAgIC8vIHdpdGggdGhhdCAtLSBvdGhlcndpc2Ugd2UganVzdCBzdGFydCB3aXRoIHRoZSBwYXJlbnQncyBvd25lcnMuXG4gICAgICBkZWVwZXN0Q29tbW9uICE9PSAtMSA/IGNoaWxkT3duZXJzW2RlZXBlc3RDb21tb25dLmdldE5hbWUoKSB8fCBVTktOT1dOIDogW10sIGFuY2VzdG9yT3duZXJOYW1lcywgYW5jZXN0b3JUYWcsXG4gICAgICAvLyBJZiB3ZSdyZSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgKG5vbi1wYXJlbnQpIGFuY2VzdHJ5LCBhZGQgJy4uLidcbiAgICAgIGludmFsaWRBbmNlc3RvciA/IFsnLi4uJ10gOiBbXSwgY2hpbGRPd25lck5hbWVzLCBjaGlsZFRhZykuam9pbignID4gJyk7XG5cbiAgICAgIHZhciB3YXJuS2V5ID0gISFpbnZhbGlkUGFyZW50ICsgJ3wnICsgY2hpbGRUYWcgKyAnfCcgKyBhbmNlc3RvclRhZyArICd8JyArIG93bmVySW5mbztcbiAgICAgIGlmIChkaWRXYXJuW3dhcm5LZXldKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRpZFdhcm5bd2FybktleV0gPSB0cnVlO1xuXG4gICAgICBpZiAoaW52YWxpZFBhcmVudCkge1xuICAgICAgICB2YXIgaW5mbyA9ICcnO1xuICAgICAgICBpZiAoYW5jZXN0b3JUYWcgPT09ICd0YWJsZScgJiYgY2hpbGRUYWcgPT09ICd0cicpIHtcbiAgICAgICAgICBpbmZvICs9ICcgQWRkIGEgPHRib2R5PiB0byB5b3VyIGNvZGUgdG8gbWF0Y2ggdGhlIERPTSB0cmVlIGdlbmVyYXRlZCBieSAnICsgJ3RoZSBicm93c2VyLic7XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogPCVzPiBjYW5ub3QgYXBwZWFyIGFzIGEgY2hpbGQgb2YgPCVzPi4gJyArICdTZWUgJXMuJXMnLCBjaGlsZFRhZywgYW5jZXN0b3JUYWcsIG93bmVySW5mbywgaW5mbykgOiB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ3ZhbGlkYXRlRE9NTmVzdGluZyguLi4pOiA8JXM+IGNhbm5vdCBhcHBlYXIgYXMgYSBkZXNjZW5kYW50IG9mICcgKyAnPCVzPi4gU2VlICVzLicsIGNoaWxkVGFnLCBhbmNlc3RvclRhZywgb3duZXJJbmZvKSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFsaWRhdGVET01OZXN0aW5nLmFuY2VzdG9ySW5mb0NvbnRleHRLZXkgPSAnX192YWxpZGF0ZURPTU5lc3RpbmdfYW5jZXN0b3JJbmZvJCcgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcblxuICB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm87XG5cbiAgLy8gRm9yIHRlc3RpbmdcbiAgdmFsaWRhdGVET01OZXN0aW5nLmlzVGFnVmFsaWRJbkNvbnRleHQgPSBmdW5jdGlvbiAodGFnLCBhbmNlc3RvckluZm8pIHtcbiAgICBhbmNlc3RvckluZm8gPSBhbmNlc3RvckluZm8gfHwgZW1wdHlBbmNlc3RvckluZm87XG4gICAgdmFyIHBhcmVudEluZm8gPSBhbmNlc3RvckluZm8ucGFyZW50VGFnO1xuICAgIHZhciBwYXJlbnRUYWcgPSBwYXJlbnRJbmZvICYmIHBhcmVudEluZm8udGFnO1xuICAgIHJldHVybiBpc1RhZ1ZhbGlkV2l0aFBhcmVudCh0YWcsIHBhcmVudFRhZykgJiYgIWZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcodGFnLCBhbmNlc3RvckluZm8pO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHZhbGlkYXRlRE9NTmVzdGluZztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL3ZhbGlkYXRlRE9NTmVzdGluZy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERlZmF1bHRJbmplY3Rpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luID0gcmVxdWlyZSgnLi9CZWZvcmVJbnB1dEV2ZW50UGx1Z2luJyk7XG52YXIgQ2hhbmdlRXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL0NoYW5nZUV2ZW50UGx1Z2luJyk7XG52YXIgQ2xpZW50UmVhY3RSb290SW5kZXggPSByZXF1aXJlKCcuL0NsaWVudFJlYWN0Um9vdEluZGV4Jyk7XG52YXIgRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIgPSByZXF1aXJlKCcuL0RlZmF1bHRFdmVudFBsdWdpbk9yZGVyJyk7XG52YXIgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luID0gcmVxdWlyZSgnLi9FbnRlckxlYXZlRXZlbnRQbHVnaW4nKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgSFRNTERPTVByb3BlcnR5Q29uZmlnID0gcmVxdWlyZSgnLi9IVE1MRE9NUHJvcGVydHlDb25maWcnKTtcbnZhciBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbiA9IHJlcXVpcmUoJy4vUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4nKTtcbnZhciBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5ID0gcmVxdWlyZSgnLi9SZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5Jyk7XG52YXIgUmVhY3RET01Db21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50Jyk7XG52YXIgUmVhY3RET01UZXh0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdERPTVRleHRDb21wb25lbnQnKTtcbnZhciBSZWFjdEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCcuL1JlYWN0RXZlbnRMaXN0ZW5lcicpO1xudmFyIFJlYWN0SW5qZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluamVjdGlvbicpO1xudmFyIFJlYWN0SW5zdGFuY2VIYW5kbGVzID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlSGFuZGxlcycpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcbnZhciBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uJyk7XG52YXIgU2VsZWN0RXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL1NlbGVjdEV2ZW50UGx1Z2luJyk7XG52YXIgU2VydmVyUmVhY3RSb290SW5kZXggPSByZXF1aXJlKCcuL1NlcnZlclJlYWN0Um9vdEluZGV4Jyk7XG52YXIgU2ltcGxlRXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL1NpbXBsZUV2ZW50UGx1Z2luJyk7XG52YXIgU1ZHRE9NUHJvcGVydHlDb25maWcgPSByZXF1aXJlKCcuL1NWR0RPTVByb3BlcnR5Q29uZmlnJyk7XG5cbnZhciBhbHJlYWR5SW5qZWN0ZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gaW5qZWN0KCkge1xuICBpZiAoYWxyZWFkeUluamVjdGVkKSB7XG4gICAgLy8gVE9ETzogVGhpcyBpcyBjdXJyZW50bHkgdHJ1ZSBiZWNhdXNlIHRoZXNlIGluamVjdGlvbnMgYXJlIHNoYXJlZCBiZXR3ZWVuXG4gICAgLy8gdGhlIGNsaWVudCBhbmQgdGhlIHNlcnZlciBwYWNrYWdlLiBUaGV5IHNob3VsZCBiZSBidWlsdCBpbmRlcGVuZGVudGx5XG4gICAgLy8gYW5kIG5vdCBzaGFyZSBhbnkgaW5qZWN0aW9uIHN0YXRlLiBUaGVuIHRoaXMgcHJvYmxlbSB3aWxsIGJlIHNvbHZlZC5cbiAgICByZXR1cm47XG4gIH1cbiAgYWxyZWFkeUluamVjdGVkID0gdHJ1ZTtcblxuICBSZWFjdEluamVjdGlvbi5FdmVudEVtaXR0ZXIuaW5qZWN0UmVhY3RFdmVudExpc3RlbmVyKFJlYWN0RXZlbnRMaXN0ZW5lcik7XG5cbiAgLyoqXG4gICAqIEluamVjdCBtb2R1bGVzIGZvciByZXNvbHZpbmcgRE9NIGhpZXJhcmNoeSBhbmQgcGx1Z2luIG9yZGVyaW5nLlxuICAgKi9cbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5IdWIuaW5qZWN0RXZlbnRQbHVnaW5PcmRlcihEZWZhdWx0RXZlbnRQbHVnaW5PcmRlcik7XG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50UGx1Z2luSHViLmluamVjdEluc3RhbmNlSGFuZGxlKFJlYWN0SW5zdGFuY2VIYW5kbGVzKTtcbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5IdWIuaW5qZWN0TW91bnQoUmVhY3RNb3VudCk7XG5cbiAgLyoqXG4gICAqIFNvbWUgaW1wb3J0YW50IGV2ZW50IHBsdWdpbnMgaW5jbHVkZWQgYnkgZGVmYXVsdCAod2l0aG91dCBoYXZpbmcgdG8gcmVxdWlyZVxuICAgKiB0aGVtKS5cbiAgICovXG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50UGx1Z2luSHViLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZSh7XG4gICAgU2ltcGxlRXZlbnRQbHVnaW46IFNpbXBsZUV2ZW50UGx1Z2luLFxuICAgIEVudGVyTGVhdmVFdmVudFBsdWdpbjogRW50ZXJMZWF2ZUV2ZW50UGx1Z2luLFxuICAgIENoYW5nZUV2ZW50UGx1Z2luOiBDaGFuZ2VFdmVudFBsdWdpbixcbiAgICBTZWxlY3RFdmVudFBsdWdpbjogU2VsZWN0RXZlbnRQbHVnaW4sXG4gICAgQmVmb3JlSW5wdXRFdmVudFBsdWdpbjogQmVmb3JlSW5wdXRFdmVudFBsdWdpblxuICB9KTtcblxuICBSZWFjdEluamVjdGlvbi5OYXRpdmVDb21wb25lbnQuaW5qZWN0R2VuZXJpY0NvbXBvbmVudENsYXNzKFJlYWN0RE9NQ29tcG9uZW50KTtcblxuICBSZWFjdEluamVjdGlvbi5OYXRpdmVDb21wb25lbnQuaW5qZWN0VGV4dENvbXBvbmVudENsYXNzKFJlYWN0RE9NVGV4dENvbXBvbmVudCk7XG5cbiAgUmVhY3RJbmplY3Rpb24uQ2xhc3MuaW5qZWN0TWl4aW4oUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4pO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkRPTVByb3BlcnR5LmluamVjdERPTVByb3BlcnR5Q29uZmlnKEhUTUxET01Qcm9wZXJ0eUNvbmZpZyk7XG4gIFJlYWN0SW5qZWN0aW9uLkRPTVByb3BlcnR5LmluamVjdERPTVByb3BlcnR5Q29uZmlnKFNWR0RPTVByb3BlcnR5Q29uZmlnKTtcblxuICBSZWFjdEluamVjdGlvbi5FbXB0eUNvbXBvbmVudC5pbmplY3RFbXB0eUNvbXBvbmVudCgnbm9zY3JpcHQnKTtcblxuICBSZWFjdEluamVjdGlvbi5VcGRhdGVzLmluamVjdFJlY29uY2lsZVRyYW5zYWN0aW9uKFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24pO1xuICBSZWFjdEluamVjdGlvbi5VcGRhdGVzLmluamVjdEJhdGNoaW5nU3RyYXRlZ3koUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneSk7XG5cbiAgUmVhY3RJbmplY3Rpb24uUm9vdEluZGV4LmluamVjdENyZWF0ZVJlYWN0Um9vdEluZGV4KEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IENsaWVudFJlYWN0Um9vdEluZGV4LmNyZWF0ZVJlYWN0Um9vdEluZGV4IDogU2VydmVyUmVhY3RSb290SW5kZXguY3JlYXRlUmVhY3RSb290SW5kZXgpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkNvbXBvbmVudC5pbmplY3RFbnZpcm9ubWVudChSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgdXJsID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmIHdpbmRvdy5sb2NhdGlvbi5ocmVmIHx8ICcnO1xuICAgIGlmICgvWz8mXXJlYWN0X3BlcmZcXGIvLnRlc3QodXJsKSkge1xuICAgICAgdmFyIFJlYWN0RGVmYXVsdFBlcmYgPSByZXF1aXJlKCcuL1JlYWN0RGVmYXVsdFBlcmYnKTtcbiAgICAgIFJlYWN0RGVmYXVsdFBlcmYuc3RhcnQoKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGluamVjdDogaW5qZWN0XG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3REZWZhdWx0SW5qZWN0aW9uLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1IEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQmVmb3JlSW5wdXRFdmVudFBsdWdpblxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZSA9IHJlcXVpcmUoJy4vRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlJyk7XG52YXIgU3ludGhldGljQ29tcG9zaXRpb25FdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljQ29tcG9zaXRpb25FdmVudCcpO1xudmFyIFN5bnRoZXRpY0lucHV0RXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0lucHV0RXZlbnQnKTtcblxudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcblxudmFyIEVORF9LRVlDT0RFUyA9IFs5LCAxMywgMjcsIDMyXTsgLy8gVGFiLCBSZXR1cm4sIEVzYywgU3BhY2VcbnZhciBTVEFSVF9LRVlDT0RFID0gMjI5O1xuXG52YXIgY2FuVXNlQ29tcG9zaXRpb25FdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnQ29tcG9zaXRpb25FdmVudCcgaW4gd2luZG93O1xuXG52YXIgZG9jdW1lbnRNb2RlID0gbnVsbDtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpIHtcbiAgZG9jdW1lbnRNb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xufVxuXG4vLyBXZWJraXQgb2ZmZXJzIGEgdmVyeSB1c2VmdWwgYHRleHRJbnB1dGAgZXZlbnQgdGhhdCBjYW4gYmUgdXNlZCB0b1xuLy8gZGlyZWN0bHkgcmVwcmVzZW50IGBiZWZvcmVJbnB1dGAuIFRoZSBJRSBgdGV4dGlucHV0YCBldmVudCBpcyBub3QgYXNcbi8vIHVzZWZ1bCwgc28gd2UgZG9uJ3QgdXNlIGl0LlxudmFyIGNhblVzZVRleHRJbnB1dEV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdUZXh0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlICYmICFpc1ByZXN0bygpO1xuXG4vLyBJbiBJRTkrLCB3ZSBoYXZlIGFjY2VzcyB0byBjb21wb3NpdGlvbiBldmVudHMsIGJ1dCB0aGUgZGF0YSBzdXBwbGllZFxuLy8gYnkgdGhlIG5hdGl2ZSBjb21wb3NpdGlvbmVuZCBldmVudCBtYXkgYmUgaW5jb3JyZWN0LiBKYXBhbmVzZSBpZGVvZ3JhcGhpY1xuLy8gc3BhY2VzLCBmb3IgaW5zdGFuY2UgKFxcdTMwMDApIGFyZSBub3QgcmVjb3JkZWQgY29ycmVjdGx5LlxudmFyIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICghY2FuVXNlQ29tcG9zaXRpb25FdmVudCB8fCBkb2N1bWVudE1vZGUgJiYgZG9jdW1lbnRNb2RlID4gOCAmJiBkb2N1bWVudE1vZGUgPD0gMTEpO1xuXG4vKipcbiAqIE9wZXJhIDw9IDEyIGluY2x1ZGVzIFRleHRFdmVudCBpbiB3aW5kb3csIGJ1dCBkb2VzIG5vdCBmaXJlXG4gKiB0ZXh0IGlucHV0IGV2ZW50cy4gUmVseSBvbiBrZXlwcmVzcyBpbnN0ZWFkLlxuICovXG5mdW5jdGlvbiBpc1ByZXN0bygpIHtcbiAgdmFyIG9wZXJhID0gd2luZG93Lm9wZXJhO1xuICByZXR1cm4gdHlwZW9mIG9wZXJhID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb3BlcmEudmVyc2lvbiA9PT0gJ2Z1bmN0aW9uJyAmJiBwYXJzZUludChvcGVyYS52ZXJzaW9uKCksIDEwKSA8PSAxMjtcbn1cblxudmFyIFNQQUNFQkFSX0NPREUgPSAzMjtcbnZhciBTUEFDRUJBUl9DSEFSID0gU3RyaW5nLmZyb21DaGFyQ29kZShTUEFDRUJBUl9DT0RFKTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG4vLyBFdmVudHMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgbmFtZXMuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgYmVmb3JlSW5wdXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkJlZm9yZUlucHV0OiBudWxsIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25CZWZvcmVJbnB1dENhcHR1cmU6IG51bGwgfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25FbmQsIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3MsIHRvcExldmVsVHlwZXMudG9wVGV4dElucHV0LCB0b3BMZXZlbFR5cGVzLnRvcFBhc3RlXVxuICB9LFxuICBjb21wb3NpdGlvbkVuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ29tcG9zaXRpb25FbmQ6IG51bGwgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNvbXBvc2l0aW9uRW5kQ2FwdHVyZTogbnVsbCB9KVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BCbHVyLCB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uRW5kLCB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24sIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3MsIHRvcExldmVsVHlwZXMudG9wS2V5VXAsIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duXVxuICB9LFxuICBjb21wb3NpdGlvblN0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Db21wb3NpdGlvblN0YXJ0OiBudWxsIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Db21wb3NpdGlvblN0YXJ0Q2FwdHVyZTogbnVsbCB9KVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BCbHVyLCB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uU3RhcnQsIHRvcExldmVsVHlwZXMudG9wS2V5RG93biwgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzcywgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcCwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd25dXG4gIH0sXG4gIGNvbXBvc2l0aW9uVXBkYXRlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Db21wb3NpdGlvblVwZGF0ZTogbnVsbCB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ29tcG9zaXRpb25VcGRhdGVDYXB0dXJlOiBudWxsIH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcEJsdXIsIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25VcGRhdGUsIHRvcExldmVsVHlwZXMudG9wS2V5RG93biwgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzcywgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcCwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd25dXG4gIH1cbn07XG5cbi8vIFRyYWNrIHdoZXRoZXIgd2UndmUgZXZlciBoYW5kbGVkIGEga2V5cHJlc3Mgb24gdGhlIHNwYWNlIGtleS5cbnZhciBoYXNTcGFjZUtleXByZXNzID0gZmFsc2U7XG5cbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgYSBuYXRpdmUga2V5cHJlc3MgZXZlbnQgaXMgYXNzdW1lZCB0byBiZSBhIGNvbW1hbmQuXG4gKiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgRmlyZWZveCBmaXJlcyBga2V5cHJlc3NgIGV2ZW50cyBmb3Iga2V5IGNvbW1hbmRzXG4gKiAoY3V0LCBjb3B5LCBzZWxlY3QtYWxsLCBldGMuKSBldmVuIHRob3VnaCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiAobmF0aXZlRXZlbnQuY3RybEtleSB8fCBuYXRpdmVFdmVudC5hbHRLZXkgfHwgbmF0aXZlRXZlbnQubWV0YUtleSkgJiZcbiAgLy8gY3RybEtleSAmJiBhbHRLZXkgaXMgZXF1aXZhbGVudCB0byBBbHRHciwgYW5kIGlzIG5vdCBhIGNvbW1hbmQuXG4gICEobmF0aXZlRXZlbnQuY3RybEtleSAmJiBuYXRpdmVFdmVudC5hbHRLZXkpO1xufVxuXG4vKipcbiAqIFRyYW5zbGF0ZSBuYXRpdmUgdG9wIGxldmVsIGV2ZW50cyBpbnRvIGV2ZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUodG9wTGV2ZWxUeXBlKSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uU3RhcnQ6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0O1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZDpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvblVwZGF0ZTpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uVXBkYXRlO1xuICB9XG59XG5cbi8qKlxuICogRG9lcyBvdXIgZmFsbGJhY2sgYmVzdC1ndWVzcyBtb2RlbCB0aGluayB0aGlzIGV2ZW50IHNpZ25pZmllcyB0aGF0XG4gKiBjb21wb3NpdGlvbiBoYXMgYmVndW4/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wS2V5RG93biAmJiBuYXRpdmVFdmVudC5rZXlDb2RlID09PSBTVEFSVF9LRVlDT0RFO1xufVxuXG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIG1vZGUgdGhpbmsgdGhhdCB0aGlzIGV2ZW50IGlzIHRoZSBlbmQgb2YgY29tcG9zaXRpb24/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcDpcbiAgICAgIC8vIENvbW1hbmQga2V5cyBpbnNlcnQgb3IgY2xlYXIgSU1FIGlucHV0LlxuICAgICAgcmV0dXJuIEVORF9LRVlDT0RFUy5pbmRleE9mKG5hdGl2ZUV2ZW50LmtleUNvZGUpICE9PSAtMTtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5RG93bjpcbiAgICAgIC8vIEV4cGVjdCBJTUUga2V5Q29kZSBvbiBlYWNoIGtleWRvd24uIElmIHdlIGdldCBhbnkgb3RoZXJcbiAgICAgIC8vIGNvZGUgd2UgbXVzdCBoYXZlIGV4aXRlZCBlYXJsaWVyLlxuICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmtleUNvZGUgIT09IFNUQVJUX0tFWUNPREU7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzOlxuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd246XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEJsdXI6XG4gICAgICAvLyBFdmVudHMgYXJlIG5vdCBwb3NzaWJsZSB3aXRob3V0IGNhbmNlbGxpbmcgSU1FLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEdvb2dsZSBJbnB1dCBUb29scyBwcm92aWRlcyBjb21wb3NpdGlvbiBkYXRhIHZpYSBhIEN1c3RvbUV2ZW50LFxuICogd2l0aCB0aGUgYGRhdGFgIHByb3BlcnR5IHBvcHVsYXRlZCBpbiB0aGUgYGRldGFpbGAgb2JqZWN0LiBJZiB0aGlzXG4gKiBpcyBhdmFpbGFibGUgb24gdGhlIGV2ZW50IG9iamVjdCwgdXNlIGl0LiBJZiBub3QsIHRoaXMgaXMgYSBwbGFpblxuICogY29tcG9zaXRpb24gZXZlbnQgYW5kIHdlIGhhdmUgbm90aGluZyBzcGVjaWFsIHRvIGV4dHJhY3QuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBkZXRhaWwgPSBuYXRpdmVFdmVudC5kZXRhaWw7XG4gIGlmICh0eXBlb2YgZGV0YWlsID09PSAnb2JqZWN0JyAmJiAnZGF0YScgaW4gZGV0YWlsKSB7XG4gICAgcmV0dXJuIGRldGFpbC5kYXRhO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBUcmFjayB0aGUgY3VycmVudCBJTUUgY29tcG9zaXRpb24gZmFsbGJhY2sgb2JqZWN0LCBpZiBhbnkuXG52YXIgY3VycmVudENvbXBvc2l0aW9uID0gbnVsbDtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LlxuICovXG5mdW5jdGlvbiBleHRyYWN0Q29tcG9zaXRpb25FdmVudCh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGV2ZW50VHlwZTtcbiAgdmFyIGZhbGxiYWNrRGF0YTtcblxuICBpZiAoY2FuVXNlQ29tcG9zaXRpb25FdmVudCkge1xuICAgIGV2ZW50VHlwZSA9IGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKHRvcExldmVsVHlwZSk7XG4gIH0gZWxzZSBpZiAoIWN1cnJlbnRDb21wb3NpdGlvbikge1xuICAgIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICBldmVudFR5cGUgPSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kO1xuICB9XG5cbiAgaWYgKCFldmVudFR5cGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSkge1xuICAgIC8vIFRoZSBjdXJyZW50IGNvbXBvc2l0aW9uIGlzIHN0b3JlZCBzdGF0aWNhbGx5IGFuZCBtdXN0IG5vdCBiZVxuICAgIC8vIG92ZXJ3cml0dGVuIHdoaWxlIGNvbXBvc2l0aW9uIGNvbnRpbnVlcy5cbiAgICBpZiAoIWN1cnJlbnRDb21wb3NpdGlvbiAmJiBldmVudFR5cGUgPT09IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydCkge1xuICAgICAgY3VycmVudENvbXBvc2l0aW9uID0gRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLmdldFBvb2xlZCh0b3BMZXZlbFRhcmdldCk7XG4gICAgfSBlbHNlIGlmIChldmVudFR5cGUgPT09IGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQpIHtcbiAgICAgIGlmIChjdXJyZW50Q29tcG9zaXRpb24pIHtcbiAgICAgICAgZmFsbGJhY2tEYXRhID0gY3VycmVudENvbXBvc2l0aW9uLmdldERhdGEoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LmdldFBvb2xlZChldmVudFR5cGUsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgaWYgKGZhbGxiYWNrRGF0YSkge1xuICAgIC8vIEluamVjdCBkYXRhIGdlbmVyYXRlZCBmcm9tIGZhbGxiYWNrIHBhdGggaW50byB0aGUgc3ludGhldGljIGV2ZW50LlxuICAgIC8vIFRoaXMgbWF0Y2hlcyB0aGUgcHJvcGVydHkgb2YgbmF0aXZlIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UuXG4gICAgZXZlbnQuZGF0YSA9IGZhbGxiYWNrRGF0YTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VzdG9tRGF0YSA9IGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGlmIChjdXN0b21EYXRhICE9PSBudWxsKSB7XG4gICAgICBldmVudC5kYXRhID0gY3VzdG9tRGF0YTtcbiAgICB9XG4gIH1cblxuICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIHN0cmluZyBjb3JyZXNwb25kaW5nIHRvIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uRW5kOlxuICAgICAgcmV0dXJuIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzczpcbiAgICAgIC8qKlxuICAgICAgICogSWYgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50cyBhcmUgYXZhaWxhYmxlLCBvdXIgZ29hbCBpcyB0byBtYWtlXG4gICAgICAgKiB1c2Ugb2YgdGhlbS4gSG93ZXZlciwgdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2U6IHRoZSBzcGFjZWJhciBrZXkuXG4gICAgICAgKiBJbiBXZWJraXQsIHByZXZlbnRpbmcgZGVmYXVsdCBvbiBhIHNwYWNlYmFyIGB0ZXh0SW5wdXRgIGV2ZW50XG4gICAgICAgKiBjYW5jZWxzIGNoYXJhY3RlciBpbnNlcnRpb24sIGJ1dCBpdCAqYWxzbyogY2F1c2VzIHRoZSBicm93c2VyXG4gICAgICAgKiB0byBmYWxsIGJhY2sgdG8gaXRzIGRlZmF1bHQgc3BhY2ViYXIgYmVoYXZpb3Igb2Ygc2Nyb2xsaW5nIHRoZVxuICAgICAgICogcGFnZS5cbiAgICAgICAqXG4gICAgICAgKiBUcmFja2luZyBhdDpcbiAgICAgICAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNTUxMDNcbiAgICAgICAqXG4gICAgICAgKiBUbyBhdm9pZCB0aGlzIGlzc3VlLCB1c2UgdGhlIGtleXByZXNzIGV2ZW50IGFzIGlmIG5vIGB0ZXh0SW5wdXRgXG4gICAgICAgKiBldmVudCBpcyBhdmFpbGFibGUuXG4gICAgICAgKi9cbiAgICAgIHZhciB3aGljaCA9IG5hdGl2ZUV2ZW50LndoaWNoO1xuICAgICAgaWYgKHdoaWNoICE9PSBTUEFDRUJBUl9DT0RFKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBoYXNTcGFjZUtleXByZXNzID0gdHJ1ZTtcbiAgICAgIHJldHVybiBTUEFDRUJBUl9DSEFSO1xuXG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRleHRJbnB1dDpcbiAgICAgIC8vIFJlY29yZCB0aGUgY2hhcmFjdGVycyB0byBiZSBhZGRlZCB0byB0aGUgRE9NLlxuICAgICAgdmFyIGNoYXJzID0gbmF0aXZlRXZlbnQuZGF0YTtcblxuICAgICAgLy8gSWYgaXQncyBhIHNwYWNlYmFyIGNoYXJhY3RlciwgYXNzdW1lIHRoYXQgd2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWRcbiAgICAgIC8vIGl0IGF0IHRoZSBrZXlwcmVzcyBsZXZlbCBhbmQgYmFpbCBpbW1lZGlhdGVseS4gQW5kcm9pZCBDaHJvbWVcbiAgICAgIC8vIGRvZXNuJ3QgZ2l2ZSB1cyBrZXljb2Rlcywgc28gd2UgbmVlZCB0byBibGFja2xpc3QgaXQuXG4gICAgICBpZiAoY2hhcnMgPT09IFNQQUNFQkFSX0NIQVIgJiYgaGFzU3BhY2VLZXlwcmVzcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYXJzO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEZvciBvdGhlciBuYXRpdmUgZXZlbnQgdHlwZXMsIGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEZvciBicm93c2VycyB0aGF0IGRvIG5vdCBwcm92aWRlIHRoZSBgdGV4dElucHV0YCBldmVudCwgZXh0cmFjdCB0aGVcbiAqIGFwcHJvcHJpYXRlIHN0cmluZyB0byB1c2UgZm9yIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIGZhbGxiYWNrIHN0cmluZyBmb3IgdGhpcyBgYmVmb3JlSW5wdXRgIGV2ZW50LlxuICovXG5mdW5jdGlvbiBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGNvbXBvc2luZyAoSU1FKSBhbmQgdXNpbmcgYSBmYWxsYmFjayB0byBkbyBzbyxcbiAgLy8gdHJ5IHRvIGV4dHJhY3QgdGhlIGNvbXBvc2VkIGNoYXJhY3RlcnMgZnJvbSB0aGUgZmFsbGJhY2sgb2JqZWN0LlxuICBpZiAoY3VycmVudENvbXBvc2l0aW9uKSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZCB8fCBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIHZhciBjaGFycyA9IGN1cnJlbnRDb21wb3NpdGlvbi5nZXREYXRhKCk7XG4gICAgICBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUucmVsZWFzZShjdXJyZW50Q29tcG9zaXRpb24pO1xuICAgICAgY3VycmVudENvbXBvc2l0aW9uID0gbnVsbDtcbiAgICAgIHJldHVybiBjaGFycztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BQYXN0ZTpcbiAgICAgIC8vIElmIGEgcGFzdGUgZXZlbnQgb2NjdXJzIGFmdGVyIGEga2V5cHJlc3MsIHRocm93IG91dCB0aGUgaW5wdXRcbiAgICAgIC8vIGNoYXJzLiBQYXN0ZSBldmVudHMgc2hvdWxkIG5vdCBsZWFkIHRvIEJlZm9yZUlucHV0IGV2ZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzczpcbiAgICAgIC8qKlxuICAgICAgICogQXMgb2YgdjI3LCBGaXJlZm94IG1heSBmaXJlIGtleXByZXNzIGV2ZW50cyBldmVuIHdoZW4gbm8gY2hhcmFjdGVyXG4gICAgICAgKiB3aWxsIGJlIGluc2VydGVkLiBBIGZldyBwb3NzaWJpbGl0aWVzOlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyBgMGAuIEFycm93IGtleXMsIEVzYyBrZXksIGV0Yy5cbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgdGhlIHByZXNzZWQga2V5IGNvZGUsIGJ1dCBubyBjaGFyIGlzIGF2YWlsYWJsZS5cbiAgICAgICAqICAgRXg6ICdBbHRHciArIGRgIGluIFBvbGlzaC4gVGhlcmUgaXMgbm8gbW9kaWZpZWQgY2hhcmFjdGVyIGZvclxuICAgICAgICogICB0aGlzIGtleSBjb21iaW5hdGlvbiBhbmQgbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkIGludG8gdGhlXG4gICAgICAgKiAgIGRvY3VtZW50LCBidXQgRkYgZmlyZXMgdGhlIGtleXByZXNzIGZvciBjaGFyIGNvZGUgYDEwMGAgYW55d2F5LlxuICAgICAgICogICBObyBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgYSBjb21tYW5kIGNvbWJpbmF0aW9uIGlzXG4gICAgICAgKiAgIGJlaW5nIHVzZWQuIEV4OiBgQ21kK0NgLiBObyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQsIGFuZCBub1xuICAgICAgICogICBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgKi9cbiAgICAgIGlmIChuYXRpdmVFdmVudC53aGljaCAmJiAhaXNLZXlwcmVzc0NvbW1hbmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG5hdGl2ZUV2ZW50LndoaWNoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZDpcbiAgICAgIHJldHVybiB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSA/IG51bGwgOiBuYXRpdmVFdmVudC5kYXRhO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgYSBTeW50aGV0aWNJbnB1dEV2ZW50IGZvciBgYmVmb3JlSW5wdXRgLCBiYXNlZCBvbiBlaXRoZXIgbmF0aXZlXG4gKiBgdGV4dElucHV0YCBvciBmYWxsYmFjayBiZWhhdmlvci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNJbnB1dEV2ZW50LlxuICovXG5mdW5jdGlvbiBleHRyYWN0QmVmb3JlSW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGNoYXJzO1xuXG4gIGlmIChjYW5Vc2VUZXh0SW5wdXRFdmVudCkge1xuICAgIGNoYXJzID0gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBjaGFycyA9IGdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcbiAgfVxuXG4gIC8vIElmIG5vIGNoYXJhY3RlcnMgYXJlIGJlaW5nIGluc2VydGVkLCBubyBCZWZvcmVJbnB1dCBldmVudCBzaG91bGRcbiAgLy8gYmUgZmlyZWQuXG4gIGlmICghY2hhcnMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0lucHV0RXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuYmVmb3JlSW5wdXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgZXZlbnQuZGF0YSA9IGNoYXJzO1xuICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGBvbkJlZm9yZUlucHV0YCBldmVudCB0byBtYXRjaFxuICogaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDUvI2V2ZW50cy1pbnB1dGV2ZW50cy5cbiAqXG4gKiBUaGlzIGV2ZW50IHBsdWdpbiBpcyBiYXNlZCBvbiB0aGUgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50XG4gKiBhdmFpbGFibGUgaW4gQ2hyb21lLCBTYWZhcmksIE9wZXJhLCBhbmQgSUUuIFRoaXMgZXZlbnQgZmlyZXMgYWZ0ZXJcbiAqIGBvbktleVByZXNzYCBhbmQgYG9uQ29tcG9zaXRpb25FbmRgLCBidXQgYmVmb3JlIGBvbklucHV0YC5cbiAqXG4gKiBgYmVmb3JlSW5wdXRgIGlzIHNwZWMnZCBidXQgbm90IGltcGxlbWVudGVkIGluIGFueSBicm93c2VycywgYW5kXG4gKiB0aGUgYGlucHV0YCBldmVudCBkb2VzIG5vdCBwcm92aWRlIGFueSB1c2VmdWwgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBoYXNcbiAqIGFjdHVhbGx5IGJlZW4gYWRkZWQsIGNvbnRyYXJ5IHRvIHRoZSBzcGVjLiBUaHVzLCBgdGV4dElucHV0YCBpcyB0aGUgYmVzdFxuICogYXZhaWxhYmxlIGV2ZW50IHRvIGlkZW50aWZ5IHRoZSBjaGFyYWN0ZXJzIHRoYXQgaGF2ZSBhY3R1YWxseSBiZWVuIGluc2VydGVkXG4gKiBpbnRvIHRoZSB0YXJnZXQgbm9kZS5cbiAqXG4gKiBUaGlzIHBsdWdpbiBpcyBhbHNvIHJlc3BvbnNpYmxlIGZvciBlbWl0dGluZyBgY29tcG9zaXRpb25gIGV2ZW50cywgdGh1c1xuICogYWxsb3dpbmcgdXMgdG8gc2hhcmUgY29tcG9zaXRpb24gZmFsbGJhY2sgY29kZSBmb3IgYm90aCBgYmVmb3JlSW5wdXRgIGFuZFxuICogYGNvbXBvc2l0aW9uYCBldmVudCB0eXBlcy5cbiAqL1xudmFyIEJlZm9yZUlucHV0RXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmV4dHJhY3RFdmVudHN9XG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgcmV0dXJuIFtleHRyYWN0Q29tcG9zaXRpb25FdmVudCh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpLCBleHRyYWN0QmVmb3JlSW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpXTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvQmVmb3JlSW5wdXRFdmVudFBsdWdpbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudFByb3BhZ2F0b3JzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luSHViJyk7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgYWNjdW11bGF0ZUludG8gPSByZXF1aXJlKCcuL2FjY3VtdWxhdGVJbnRvJyk7XG52YXIgZm9yRWFjaEFjY3VtdWxhdGVkID0gcmVxdWlyZSgnLi9mb3JFYWNoQWNjdW11bGF0ZWQnKTtcblxudmFyIFByb3BhZ2F0aW9uUGhhc2VzID0gRXZlbnRDb25zdGFudHMuUHJvcGFnYXRpb25QaGFzZXM7XG52YXIgZ2V0TGlzdGVuZXIgPSBFdmVudFBsdWdpbkh1Yi5nZXRMaXN0ZW5lcjtcblxuLyoqXG4gKiBTb21lIGV2ZW50IHR5cGVzIGhhdmUgYSBub3Rpb24gb2YgZGlmZmVyZW50IHJlZ2lzdHJhdGlvbiBuYW1lcyBmb3IgZGlmZmVyZW50XG4gKiBcInBoYXNlc1wiIG9mIHByb3BhZ2F0aW9uLiBUaGlzIGZpbmRzIGxpc3RlbmVycyBieSBhIGdpdmVuIHBoYXNlLlxuICovXG5mdW5jdGlvbiBsaXN0ZW5lckF0UGhhc2UoaWQsIGV2ZW50LCBwcm9wYWdhdGlvblBoYXNlKSB7XG4gIHZhciByZWdpc3RyYXRpb25OYW1lID0gZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcHJvcGFnYXRpb25QaGFzZV07XG4gIHJldHVybiBnZXRMaXN0ZW5lcihpZCwgcmVnaXN0cmF0aW9uTmFtZSk7XG59XG5cbi8qKlxuICogVGFncyBhIGBTeW50aGV0aWNFdmVudGAgd2l0aCBkaXNwYXRjaGVkIGxpc3RlbmVycy4gQ3JlYXRpbmcgdGhpcyBmdW5jdGlvblxuICogaGVyZSwgYWxsb3dzIHVzIHRvIG5vdCBoYXZlIHRvIGJpbmQgb3IgY3JlYXRlIGZ1bmN0aW9ucyBmb3IgZWFjaCBldmVudC5cbiAqIE11dGF0aW5nIHRoZSBldmVudCdzIG1lbWJlcnMgYWxsb3dzIHVzIHRvIG5vdCBoYXZlIHRvIGNyZWF0ZSBhIHdyYXBwaW5nXG4gKiBcImRpc3BhdGNoXCIgb2JqZWN0IHRoYXQgcGFpcnMgdGhlIGV2ZW50IHdpdGggdGhlIGxpc3RlbmVyLlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzKGRvbUlELCB1cHdhcmRzLCBldmVudCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGRvbUlELCAnRGlzcGF0Y2hpbmcgaWQgbXVzdCBub3QgYmUgbnVsbCcpIDogdW5kZWZpbmVkO1xuICB9XG4gIHZhciBwaGFzZSA9IHVwd2FyZHMgPyBQcm9wYWdhdGlvblBoYXNlcy5idWJibGVkIDogUHJvcGFnYXRpb25QaGFzZXMuY2FwdHVyZWQ7XG4gIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyQXRQaGFzZShkb21JRCwgZXZlbnQsIHBoYXNlKTtcbiAgaWYgKGxpc3RlbmVyKSB7XG4gICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgZXZlbnQuX2Rpc3BhdGNoSURzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoSURzLCBkb21JRCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb2xsZWN0IGRpc3BhdGNoZXMgKG11c3QgYmUgZW50aXJlbHkgY29sbGVjdGVkIGJlZm9yZSBkaXNwYXRjaGluZyAtIHNlZSB1bml0XG4gKiB0ZXN0cykuIExhemlseSBhbGxvY2F0ZSB0aGUgYXJyYXkgdG8gY29uc2VydmUgbWVtb3J5LiAgV2UgbXVzdCBsb29wIHRocm91Z2hcbiAqIGVhY2ggZXZlbnQgYW5kIHBlcmZvcm0gdGhlIHRyYXZlcnNhbCBmb3IgZWFjaCBvbmUuIFdlIGNhbm5vdCBwZXJmb3JtIGFcbiAqIHNpbmdsZSB0cmF2ZXJzYWwgZm9yIHRoZSBlbnRpcmUgY29sbGVjdGlvbiBvZiBldmVudHMgYmVjYXVzZSBlYWNoIGV2ZW50IG1heVxuICogaGF2ZSBhIGRpZmZlcmVudCB0YXJnZXQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgRXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmdldEluc3RhbmNlSGFuZGxlKCkudHJhdmVyc2VUd29QaGFzZShldmVudC5kaXNwYXRjaE1hcmtlciwgYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcywgZXZlbnQpO1xuICB9XG59XG5cbi8qKlxuICogU2FtZSBhcyBgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZWAsIGJ1dCBza2lwcyBvdmVyIHRoZSB0YXJnZXRJRC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZVNraXBUYXJnZXQoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgRXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmdldEluc3RhbmNlSGFuZGxlKCkudHJhdmVyc2VUd29QaGFzZVNraXBUYXJnZXQoZXZlbnQuZGlzcGF0Y2hNYXJrZXIsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGVzIHdpdGhvdXQgcmVnYXJkIHRvIGRpcmVjdGlvbiwgZG9lcyBub3QgbG9vayBmb3IgcGhhc2VkXG4gKiByZWdpc3RyYXRpb24gbmFtZXMuIFNhbWUgYXMgYGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlYCBidXQgd2l0aG91dFxuICogcmVxdWlyaW5nIHRoYXQgdGhlIGBkaXNwYXRjaE1hcmtlcmAgYmUgdGhlIHNhbWUgYXMgdGhlIGRpc3BhdGNoZWQgSUQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXNwYXRjaGVzKGlkLCBpZ25vcmVkRGlyZWN0aW9uLCBldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHZhciByZWdpc3RyYXRpb25OYW1lID0gZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZTtcbiAgICB2YXIgbGlzdGVuZXIgPSBnZXRMaXN0ZW5lcihpZCwgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICAgIGV2ZW50Ll9kaXNwYXRjaElEcyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaElEcywgaWQpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGVzIGRpc3BhdGNoZXMgb24gYW4gYFN5bnRoZXRpY0V2ZW50YCwgYnV0IG9ubHkgZm9yIHRoZVxuICogYGRpc3BhdGNoTWFya2VyYC5cbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgYWNjdW11bGF0ZURpc3BhdGNoZXMoZXZlbnQuZGlzcGF0Y2hNYXJrZXIsIG51bGwsIGV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbUlELCB0b0lEKSB7XG4gIEV2ZW50UGx1Z2luSHViLmluamVjdGlvbi5nZXRJbnN0YW5jZUhhbmRsZSgpLnRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tSUQsIHRvSUQsIGFjY3VtdWxhdGVEaXNwYXRjaGVzLCBsZWF2ZSwgZW50ZXIpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyhldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUpO1xufVxuXG4vKipcbiAqIEEgc21hbGwgc2V0IG9mIHByb3BhZ2F0aW9uIHBhdHRlcm5zLCBlYWNoIG9mIHdoaWNoIHdpbGwgYWNjZXB0IGEgc21hbGwgYW1vdW50XG4gKiBvZiBpbmZvcm1hdGlvbiwgYW5kIGdlbmVyYXRlIGEgc2V0IG9mIFwiZGlzcGF0Y2ggcmVhZHkgZXZlbnQgb2JqZWN0c1wiIC0gd2hpY2hcbiAqIGFyZSBzZXRzIG9mIGV2ZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGFubm90YXRlZCB3aXRoIGEgc2V0IG9mIGRpc3BhdGNoZWRcbiAqIGxpc3RlbmVyIGZ1bmN0aW9ucy9pZHMuIFRoZSBBUEkgaXMgZGVzaWduZWQgdGhpcyB3YXkgdG8gZGlzY291cmFnZSB0aGVzZVxuICogcHJvcGFnYXRpb24gc3RyYXRlZ2llcyBmcm9tIGFjdHVhbGx5IGV4ZWN1dGluZyB0aGUgZGlzcGF0Y2hlcywgc2luY2Ugd2VcbiAqIGFsd2F5cyB3YW50IHRvIGNvbGxlY3QgdGhlIGVudGlyZSBzZXQgb2YgZGlzcGF0Y2hlcyBiZWZvcmUgZXhlY3V0aW5nIGV2ZW50IGFcbiAqIHNpbmdsZSBvbmUuXG4gKlxuICogQGNvbnN0cnVjdG9yIEV2ZW50UHJvcGFnYXRvcnNcbiAqL1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSB7XG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMsXG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0OiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldCxcbiAgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXM6IGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzLFxuICBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFByb3BhZ2F0b3JzO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvRXZlbnRQcm9wYWdhdG9ycy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGVcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBnZXRUZXh0Q29udGVudEFjY2Vzc29yID0gcmVxdWlyZSgnLi9nZXRUZXh0Q29udGVudEFjY2Vzc29yJyk7XG5cbi8qKlxuICogVGhpcyBoZWxwZXIgY2xhc3Mgc3RvcmVzIGluZm9ybWF0aW9uIGFib3V0IHRleHQgY29udGVudCBvZiBhIHRhcmdldCBub2RlLFxuICogYWxsb3dpbmcgY29tcGFyaXNvbiBvZiBjb250ZW50IGJlZm9yZSBhbmQgYWZ0ZXIgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBJZGVudGlmeSB0aGUgbm9kZSB3aGVyZSBzZWxlY3Rpb24gY3VycmVudGx5IGJlZ2lucywgdGhlbiBvYnNlcnZlXG4gKiBib3RoIGl0cyB0ZXh0IGNvbnRlbnQgYW5kIGl0cyBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBET00uIFNpbmNlIHRoZVxuICogYnJvd3NlciBtYXkgbmF0aXZlbHkgcmVwbGFjZSB0aGUgdGFyZ2V0IG5vZGUgZHVyaW5nIGNvbXBvc2l0aW9uLCB3ZSBjYW5cbiAqIHVzZSBpdHMgcG9zaXRpb24gdG8gZmluZCBpdHMgcmVwbGFjZW1lbnQuXG4gKlxuICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gcm9vdFxuICovXG5mdW5jdGlvbiBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUocm9vdCkge1xuICB0aGlzLl9yb290ID0gcm9vdDtcbiAgdGhpcy5fc3RhcnRUZXh0ID0gdGhpcy5nZXRUZXh0KCk7XG4gIHRoaXMuX2ZhbGxiYWNrVGV4dCA9IG51bGw7XG59XG5cbmFzc2lnbihGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUucHJvdG90eXBlLCB7XG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICB0aGlzLl9zdGFydFRleHQgPSBudWxsO1xuICAgIHRoaXMuX2ZhbGxiYWNrVGV4dCA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBjdXJyZW50IHRleHQgb2YgaW5wdXQuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldFRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoJ3ZhbHVlJyBpbiB0aGlzLl9yb290KSB7XG4gICAgICByZXR1cm4gdGhpcy5fcm9vdC52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3Jvb3RbZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpXTtcbiAgfSxcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHRoZSBkaWZmZXJpbmcgc3Vic3RyaW5nIGJldHdlZW4gdGhlIGluaXRpYWxseSBzdG9yZWRcbiAgICogdGV4dCBjb250ZW50IGFuZCB0aGUgY3VycmVudCBjb250ZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXREYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2ZhbGxiYWNrVGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZhbGxiYWNrVGV4dDtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnQ7XG4gICAgdmFyIHN0YXJ0VmFsdWUgPSB0aGlzLl9zdGFydFRleHQ7XG4gICAgdmFyIHN0YXJ0TGVuZ3RoID0gc3RhcnRWYWx1ZS5sZW5ndGg7XG4gICAgdmFyIGVuZDtcbiAgICB2YXIgZW5kVmFsdWUgPSB0aGlzLmdldFRleHQoKTtcbiAgICB2YXIgZW5kTGVuZ3RoID0gZW5kVmFsdWUubGVuZ3RoO1xuXG4gICAgZm9yIChzdGFydCA9IDA7IHN0YXJ0IDwgc3RhcnRMZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChzdGFydFZhbHVlW3N0YXJ0XSAhPT0gZW5kVmFsdWVbc3RhcnRdKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBtaW5FbmQgPSBzdGFydExlbmd0aCAtIHN0YXJ0O1xuICAgIGZvciAoZW5kID0gMTsgZW5kIDw9IG1pbkVuZDsgZW5kKyspIHtcbiAgICAgIGlmIChzdGFydFZhbHVlW3N0YXJ0TGVuZ3RoIC0gZW5kXSAhPT0gZW5kVmFsdWVbZW5kTGVuZ3RoIC0gZW5kXSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2xpY2VUYWlsID0gZW5kID4gMSA/IDEgLSBlbmQgOiB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZmFsbGJhY2tUZXh0ID0gZW5kVmFsdWUuc2xpY2Uoc3RhcnQsIHNsaWNlVGFpbCk7XG4gICAgcmV0dXJuIHRoaXMuX2ZhbGxiYWNrVGV4dDtcbiAgfVxufSk7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL0ZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRUZXh0Q29udGVudEFjY2Vzc29yXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgY29udGVudEtleSA9IG51bGw7XG5cbi8qKlxuICogR2V0cyB0aGUga2V5IHVzZWQgdG8gYWNjZXNzIHRleHQgY29udGVudCBvbiBhIERPTSBub2RlLlxuICpcbiAqIEByZXR1cm4gez9zdHJpbmd9IEtleSB1c2VkIHRvIGFjY2VzcyB0ZXh0IGNvbnRlbnQuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpIHtcbiAgaWYgKCFjb250ZW50S2V5ICYmIEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAgIC8vIFByZWZlciB0ZXh0Q29udGVudCB0byBpbm5lclRleHQgYmVjYXVzZSBtYW55IGJyb3dzZXJzIHN1cHBvcnQgYm90aCBidXRcbiAgICAvLyBTVkcgPHRleHQ+IGVsZW1lbnRzIGRvbid0IHN1cHBvcnQgaW5uZXJUZXh0IGV2ZW4gd2hlbiA8ZGl2PiBkb2VzLlxuICAgIGNvbnRlbnRLZXkgPSAndGV4dENvbnRlbnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA/ICd0ZXh0Q29udGVudCcgOiAnaW5uZXJUZXh0JztcbiAgfVxuICByZXR1cm4gY29udGVudEtleTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRUZXh0Q29udGVudEFjY2Vzc29yO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvZ2V0VGV4dENvbnRlbnRBY2Nlc3Nvci5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtY29tcG9zaXRpb25ldmVudHNcbiAqL1xudmFyIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGE6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LCBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEV2ZW50SW50ZXJmYWNlID0ge1xuICB0eXBlOiBudWxsLFxuICB0YXJnZXQ6IG51bGwsXG4gIC8vIGN1cnJlbnRUYXJnZXQgaXMgc2V0IHdoZW4gZGlzcGF0Y2hpbmc7IG5vIHVzZSBpbiBjb3B5aW5nIGl0IGhlcmVcbiAgY3VycmVudFRhcmdldDogZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwsXG4gIGV2ZW50UGhhc2U6IG51bGwsXG4gIGJ1YmJsZXM6IG51bGwsXG4gIGNhbmNlbGFibGU6IG51bGwsXG4gIHRpbWVTdGFtcDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuICB9LFxuICBkZWZhdWx0UHJldmVudGVkOiBudWxsLFxuICBpc1RydXN0ZWQ6IG51bGxcbn07XG5cbi8qKlxuICogU3ludGhldGljIGV2ZW50cyBhcmUgZGlzcGF0Y2hlZCBieSBldmVudCBwbHVnaW5zLCB0eXBpY2FsbHkgaW4gcmVzcG9uc2UgdG8gYVxuICogdG9wLWxldmVsIGV2ZW50IGRlbGVnYXRpb24gaGFuZGxlci5cbiAqXG4gKiBUaGVzZSBzeXN0ZW1zIHNob3VsZCBnZW5lcmFsbHkgdXNlIHBvb2xpbmcgdG8gcmVkdWNlIHRoZSBmcmVxdWVuY3kgb2YgZ2FyYmFnZVxuICogY29sbGVjdGlvbi4gVGhlIHN5c3RlbSBzaG91bGQgY2hlY2sgYGlzUGVyc2lzdGVudGAgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlXG4gKiBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgaW50byB0aGUgcG9vbCBhZnRlciBiZWluZyBkaXNwYXRjaGVkLiBVc2VycyB0aGF0XG4gKiBuZWVkIGEgcGVyc2lzdGVkIGV2ZW50IHNob3VsZCBpbnZva2UgYHBlcnNpc3RgLlxuICpcbiAqIFN5bnRoZXRpYyBldmVudHMgKGFuZCBzdWJjbGFzc2VzKSBpbXBsZW1lbnQgdGhlIERPTSBMZXZlbCAzIEV2ZW50cyBBUEkgYnlcbiAqIG5vcm1hbGl6aW5nIGJyb3dzZXIgcXVpcmtzLiBTdWJjbGFzc2VzIGRvIG5vdCBuZWNlc3NhcmlseSBoYXZlIHRvIGltcGxlbWVudCBhXG4gKiBET00gaW50ZXJmYWNlOyBjdXN0b20gYXBwbGljYXRpb24tc3BlY2lmaWMgZXZlbnRzIGNhbiBhbHNvIHN1YmNsYXNzIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB0aGlzLmRpc3BhdGNoQ29uZmlnID0gZGlzcGF0Y2hDb25maWc7XG4gIHRoaXMuZGlzcGF0Y2hNYXJrZXIgPSBkaXNwYXRjaE1hcmtlcjtcbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuXG4gIHZhciBJbnRlcmZhY2UgPSB0aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtcbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgaWYgKCFJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6ZSA9IEludGVyZmFjZVtwcm9wTmFtZV07XG4gICAgaWYgKG5vcm1hbGl6ZSkge1xuICAgICAgdGhpc1twcm9wTmFtZV0gPSBub3JtYWxpemUobmF0aXZlRXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvcE5hbWUgPT09ICd0YXJnZXQnKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gbmF0aXZlRXZlbnRUYXJnZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW3Byb3BOYW1lXSA9IG5hdGl2ZUV2ZW50W3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZGVmYXVsdFByZXZlbnRlZCA9IG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgIT0gbnVsbCA/IG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgOiBuYXRpdmVFdmVudC5yZXR1cm5WYWx1ZSA9PT0gZmFsc2U7XG4gIGlmIChkZWZhdWx0UHJldmVudGVkKSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZTtcbiAgfVxuICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlO1xufVxuXG5hc3NpZ24oU3ludGhldGljRXZlbnQucHJvdG90eXBlLCB7XG5cbiAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGV2ZW50LCAnVGhpcyBzeW50aGV0aWMgZXZlbnQgaXMgcmV1c2VkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBJZiB5b3VcXCdyZSAnICsgJ3NlZWluZyB0aGlzLCB5b3VcXCdyZSBjYWxsaW5nIGBwcmV2ZW50RGVmYXVsdGAgb24gYSAnICsgJ3JlbGVhc2VkL251bGxpZmllZCBzeW50aGV0aWMgZXZlbnQuIFRoaXMgaXMgYSBuby1vcC4gU2VlICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1ldmVudC1wb29saW5nIGZvciBtb3JlIGluZm9ybWF0aW9uLicpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGV2ZW50LCAnVGhpcyBzeW50aGV0aWMgZXZlbnQgaXMgcmV1c2VkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBJZiB5b3VcXCdyZSAnICsgJ3NlZWluZyB0aGlzLCB5b3VcXCdyZSBjYWxsaW5nIGBzdG9wUHJvcGFnYXRpb25gIG9uIGEgJyArICdyZWxlYXNlZC9udWxsaWZpZWQgc3ludGhldGljIGV2ZW50LiBUaGlzIGlzIGEgbm8tb3AuIFNlZSAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZXZlbnQtcG9vbGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKCFldmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdlIHJlbGVhc2UgYWxsIGRpc3BhdGNoZWQgYFN5bnRoZXRpY0V2ZW50YHMgYWZ0ZXIgZWFjaCBldmVudCBsb29wLCBhZGRpbmdcbiAgICogdGhlbSBiYWNrIGludG8gdGhlIHBvb2wuIFRoaXMgYWxsb3dzIGEgd2F5IHRvIGhvbGQgb250byBhIHJlZmVyZW5jZSB0aGF0XG4gICAqIHdvbid0IGJlIGFkZGVkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICovXG4gIHBlcnNpc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlzUGVyc2lzdGVudCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoaXMgc2hvdWxkIG5vdCBiZSByZWxlYXNlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNQZXJzaXN0ZW50OiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UsXG5cbiAgLyoqXG4gICAqIGBQb29sZWRDbGFzc2AgbG9va3MgZm9yIGBkZXN0cnVjdG9yYCBvbiBlYWNoIGluc3RhbmNlIGl0IHJlbGVhc2VzLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBJbnRlcmZhY2UgPSB0aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBJbnRlcmZhY2UpIHtcbiAgICAgIHRoaXNbcHJvcE5hbWVdID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5kaXNwYXRjaENvbmZpZyA9IG51bGw7XG4gICAgdGhpcy5kaXNwYXRjaE1hcmtlciA9IG51bGw7XG4gICAgdGhpcy5uYXRpdmVFdmVudCA9IG51bGw7XG4gIH1cblxufSk7XG5cblN5bnRoZXRpY0V2ZW50LkludGVyZmFjZSA9IEV2ZW50SW50ZXJmYWNlO1xuXG4vKipcbiAqIEhlbHBlciB0byByZWR1Y2UgYm9pbGVycGxhdGUgd2hlbiBjcmVhdGluZyBzdWJjbGFzc2VzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENsYXNzXG4gKiBAcGFyYW0gez9vYmplY3R9IEludGVyZmFjZVxuICovXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MgPSBmdW5jdGlvbiAoQ2xhc3MsIEludGVyZmFjZSkge1xuICB2YXIgU3VwZXIgPSB0aGlzO1xuXG4gIHZhciBwcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gIGFzc2lnbihwcm90b3R5cGUsIENsYXNzLnByb3RvdHlwZSk7XG4gIENsYXNzLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2xhc3M7XG5cbiAgQ2xhc3MuSW50ZXJmYWNlID0gYXNzaWduKHt9LCBTdXBlci5JbnRlcmZhY2UsIEludGVyZmFjZSk7XG4gIENsYXNzLmF1Z21lbnRDbGFzcyA9IFN1cGVyLmF1Z21lbnRDbGFzcztcblxuICBQb29sZWRDbGFzcy5hZGRQb29saW5nVG8oQ2xhc3MsIFBvb2xlZENsYXNzLmZvdXJBcmd1bWVudFBvb2xlcik7XG59O1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oU3ludGhldGljRXZlbnQsIFBvb2xlZENsYXNzLmZvdXJBcmd1bWVudFBvb2xlcik7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljRXZlbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNFdmVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNJbnB1dEV2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDVcbiAqICAgICAgLyNldmVudHMtaW5wdXRldmVudHNcbiAqL1xudmFyIElucHV0RXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGE6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0lucHV0RXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNJbnB1dEV2ZW50LCBJbnB1dEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNJbnB1dEV2ZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvU3ludGhldGljSW5wdXRFdmVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBrZXlPZlxuICovXG5cbi8qKlxuICogQWxsb3dzIGV4dHJhY3Rpb24gb2YgYSBtaW5pZmllZCBrZXkuIExldCdzIHRoZSBidWlsZCBzeXN0ZW0gbWluaWZ5IGtleXNcbiAqIHdpdGhvdXQgbG9zaW5nIHRoZSBhYmlsaXR5IHRvIGR5bmFtaWNhbGx5IHVzZSBrZXkgc3RyaW5ncyBhcyB2YWx1ZXNcbiAqIHRoZW1zZWx2ZXMuIFBhc3MgaW4gYW4gb2JqZWN0IHdpdGggYSBzaW5nbGUga2V5L3ZhbCBwYWlyIGFuZCBpdCB3aWxsIHJldHVyblxuICogeW91IHRoZSBzdHJpbmcga2V5IG9mIHRoYXQgc2luZ2xlIHJlY29yZC4gU3VwcG9zZSB5b3Ugd2FudCB0byBncmFiIHRoZVxuICogdmFsdWUgZm9yIGEga2V5ICdjbGFzc05hbWUnIGluc2lkZSBvZiBhbiBvYmplY3QuIEtleS92YWwgbWluaWZpY2F0aW9uIG1heVxuICogaGF2ZSBhbGlhc2VkIHRoYXQga2V5IHRvIGJlICd4YTEyJy4ga2V5T2Yoe2NsYXNzTmFtZTogbnVsbH0pIHdpbGwgcmV0dXJuXG4gKiAneGExMicgaW4gdGhhdCBjYXNlLiBSZXNvbHZlIGtleXMgeW91IHdhbnQgdG8gdXNlIG9uY2UgYXQgc3RhcnR1cCB0aW1lLCB0aGVuXG4gKiByZXVzZSB0aG9zZSByZXNvbHV0aW9ucy5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBrZXlPZiA9IGZ1bmN0aW9uIChvbmVLZXlPYmopIHtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gb25lS2V5T2JqKSB7XG4gICAgaWYgKCFvbmVLZXlPYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtleU9mO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9rZXlPZi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBDaGFuZ2VFdmVudFBsdWdpblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpbkh1YicpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxudmFyIGdldEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9nZXRFdmVudFRhcmdldCcpO1xudmFyIGlzRXZlbnRTdXBwb3J0ZWQgPSByZXF1aXJlKCcuL2lzRXZlbnRTdXBwb3J0ZWQnKTtcbnZhciBpc1RleHRJbnB1dEVsZW1lbnQgPSByZXF1aXJlKCcuL2lzVGV4dElucHV0RWxlbWVudCcpO1xudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgY2hhbmdlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25DaGFuZ2U6IG51bGwgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNoYW5nZUNhcHR1cmU6IG51bGwgfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wQmx1ciwgdG9wTGV2ZWxUeXBlcy50b3BDaGFuZ2UsIHRvcExldmVsVHlwZXMudG9wQ2xpY2ssIHRvcExldmVsVHlwZXMudG9wRm9jdXMsIHRvcExldmVsVHlwZXMudG9wSW5wdXQsIHRvcExldmVsVHlwZXMudG9wS2V5RG93biwgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcCwgdG9wTGV2ZWxUeXBlcy50b3BTZWxlY3Rpb25DaGFuZ2VdXG4gIH1cbn07XG5cbi8qKlxuICogRm9yIElFIHNoaW1zXG4gKi9cbnZhciBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SUQgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudFZhbHVlUHJvcCA9IG51bGw7XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBjaGFuZ2VgIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVzZUNoYW5nZUV2ZW50KGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBub2RlTmFtZSA9PT0gJ3NlbGVjdCcgfHwgbm9kZU5hbWUgPT09ICdpbnB1dCcgJiYgZWxlbS50eXBlID09PSAnZmlsZSc7XG59XG5cbnZhciBkb2VzQ2hhbmdlRXZlbnRCdWJibGUgPSBmYWxzZTtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgLy8gU2VlIGBoYW5kbGVDaGFuZ2VgIGNvbW1lbnQgYmVsb3dcbiAgZG9lc0NoYW5nZUV2ZW50QnViYmxlID0gaXNFdmVudFN1cHBvcnRlZCgnY2hhbmdlJykgJiYgKCEoJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA+IDgpO1xufVxuXG5mdW5jdGlvbiBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLmNoYW5nZSwgYWN0aXZlRWxlbWVudElELCBuYXRpdmVFdmVudCwgZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpKTtcbiAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcblxuICAvLyBJZiBjaGFuZ2UgYW5kIHByb3BlcnR5Y2hhbmdlIGJ1YmJsZWQsIHdlJ2QganVzdCBiaW5kIHRvIGl0IGxpa2UgYWxsIHRoZVxuICAvLyBvdGhlciBldmVudHMgYW5kIGhhdmUgaXQgZ28gdGhyb3VnaCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuIFNpbmNlIGl0XG4gIC8vIGRvZXNuJ3QsIHdlIG1hbnVhbGx5IGxpc3RlbiBmb3IgdGhlIGV2ZW50cyBhbmQgc28gd2UgaGF2ZSB0byBlbnF1ZXVlIGFuZFxuICAvLyBwcm9jZXNzIHRoZSBhYnN0cmFjdCBldmVudCBtYW51YWxseS5cbiAgLy9cbiAgLy8gQmF0Y2hpbmcgaXMgbmVjZXNzYXJ5IGhlcmUgaW4gb3JkZXIgdG8gZW5zdXJlIHRoYXQgYWxsIGV2ZW50IGhhbmRsZXJzIHJ1blxuICAvLyBiZWZvcmUgdGhlIG5leHQgcmVyZW5kZXIgKGluY2x1ZGluZyBldmVudCBoYW5kbGVycyBhdHRhY2hlZCB0byBhbmNlc3RvclxuICAvLyBlbGVtZW50cyBpbnN0ZWFkIG9mIGRpcmVjdGx5IG9uIHRoZSBpbnB1dCkuIFdpdGhvdXQgdGhpcywgY29udHJvbGxlZFxuICAvLyBjb21wb25lbnRzIGRvbid0IHdvcmsgcHJvcGVybHkgaW4gY29uanVuY3Rpb24gd2l0aCBldmVudCBidWJibGluZyBiZWNhdXNlXG4gIC8vIHRoZSBjb21wb25lbnQgaXMgcmVyZW5kZXJlZCBhbmQgdGhlIHZhbHVlIHJldmVydGVkIGJlZm9yZSBhbGwgdGhlIGV2ZW50XG4gIC8vIGhhbmRsZXJzIGNhbiBydW4uIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcwOC5cbiAgUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzKHJ1bkV2ZW50SW5CYXRjaCwgZXZlbnQpO1xufVxuXG5mdW5jdGlvbiBydW5FdmVudEluQmF0Y2goZXZlbnQpIHtcbiAgRXZlbnRQbHVnaW5IdWIuZW5xdWV1ZUV2ZW50cyhldmVudCk7XG4gIEV2ZW50UGx1Z2luSHViLnByb2Nlc3NFdmVudFF1ZXVlKGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KHRhcmdldCwgdGFyZ2V0SUQpIHtcbiAgYWN0aXZlRWxlbWVudCA9IHRhcmdldDtcbiAgYWN0aXZlRWxlbWVudElEID0gdGFyZ2V0SUQ7XG4gIGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQoJ29uY2hhbmdlJywgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudCk7XG59XG5cbmZ1bmN0aW9uIHN0b3BXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KCkge1xuICBpZiAoIWFjdGl2ZUVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYWN0aXZlRWxlbWVudC5kZXRhY2hFdmVudCgnb25jaGFuZ2UnLCBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KTtcbiAgYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRJRCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldElERm9yQ2hhbmdlRXZlbnQodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcENoYW5nZSkge1xuICAgIHJldHVybiB0b3BMZXZlbFRhcmdldElEO1xuICB9XG59XG5mdW5jdGlvbiBoYW5kbGVFdmVudHNGb3JDaGFuZ2VFdmVudElFOCh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElEKSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wRm9jdXMpIHtcbiAgICAvLyBzdG9wV2F0Y2hpbmcoKSBzaG91bGQgYmUgYSBub29wIGhlcmUgYnV0IHdlIGNhbGwgaXQganVzdCBpbiBjYXNlIHdlXG4gICAgLy8gbWlzc2VkIGEgYmx1ciBldmVudCBzb21laG93LlxuICAgIHN0b3BXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KCk7XG4gICAgc3RhcnRXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElEKTtcbiAgfSBlbHNlIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wQmx1cikge1xuICAgIHN0b3BXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGlucHV0YCBldmVudFxuICovXG52YXIgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gZmFsc2U7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIElFOSBjbGFpbXMgdG8gc3VwcG9ydCB0aGUgaW5wdXQgZXZlbnQgYnV0IGZhaWxzIHRvIHRyaWdnZXIgaXQgd2hlblxuICAvLyBkZWxldGluZyB0ZXh0LCBzbyB3ZSBpZ25vcmUgaXRzIGlucHV0IGV2ZW50c1xuICBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBpc0V2ZW50U3VwcG9ydGVkKCdpbnB1dCcpICYmICghKCdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50KSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiA5KTtcbn1cblxuLyoqXG4gKiAoRm9yIG9sZCBJRS4pIFJlcGxhY2VtZW50IGdldHRlci9zZXR0ZXIgZm9yIHRoZSBgdmFsdWVgIHByb3BlcnR5IHRoYXQgZ2V0c1xuICogc2V0IG9uIHRoZSBhY3RpdmUgZWxlbWVudC5cbiAqL1xudmFyIG5ld1ZhbHVlUHJvcCA9IHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AuZ2V0LmNhbGwodGhpcyk7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgIC8vIENhc3QgdG8gYSBzdHJpbmcgc28gd2UgY2FuIGRvIGVxdWFsaXR5IGNoZWNrcy5cbiAgICBhY3RpdmVFbGVtZW50VmFsdWUgPSAnJyArIHZhbDtcbiAgICBhY3RpdmVFbGVtZW50VmFsdWVQcm9wLnNldC5jYWxsKHRoaXMsIHZhbCk7XG4gIH1cbn07XG5cbi8qKlxuICogKEZvciBvbGQgSUUuKSBTdGFydHMgdHJhY2tpbmcgcHJvcGVydHljaGFuZ2UgZXZlbnRzIG9uIHRoZSBwYXNzZWQtaW4gZWxlbWVudFxuICogYW5kIG92ZXJyaWRlIHRoZSB2YWx1ZSBwcm9wZXJ0eSBzbyB0aGF0IHdlIGNhbiBkaXN0aW5ndWlzaCB1c2VyIGV2ZW50cyBmcm9tXG4gKiB2YWx1ZSBjaGFuZ2VzIGluIEpTLlxuICovXG5mdW5jdGlvbiBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodGFyZ2V0LCB0YXJnZXRJRCkge1xuICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0O1xuICBhY3RpdmVFbGVtZW50SUQgPSB0YXJnZXRJRDtcbiAgYWN0aXZlRWxlbWVudFZhbHVlID0gdGFyZ2V0LnZhbHVlO1xuICBhY3RpdmVFbGVtZW50VmFsdWVQcm9wID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQuY29uc3RydWN0b3IucHJvdG90eXBlLCAndmFsdWUnKTtcblxuICAvLyBOb3QgZ3VhcmRlZCBpbiBhIGNhbkRlZmluZVByb3BlcnR5IGNoZWNrOiBJRTggc3VwcG9ydHMgZGVmaW5lUHJvcGVydHkgb25seVxuICAvLyBvbiBET00gZWxlbWVudHNcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFjdGl2ZUVsZW1lbnQsICd2YWx1ZScsIG5ld1ZhbHVlUHJvcCk7XG4gIGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7XG59XG5cbi8qKlxuICogKEZvciBvbGQgSUUuKSBSZW1vdmVzIHRoZSBldmVudCBsaXN0ZW5lcnMgZnJvbSB0aGUgY3VycmVudGx5LXRyYWNrZWQgZWxlbWVudCxcbiAqIGlmIGFueSBleGlzdHMuXG4gKi9cbmZ1bmN0aW9uIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCkge1xuICBpZiAoIWFjdGl2ZUVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBkZWxldGUgcmVzdG9yZXMgdGhlIG9yaWdpbmFsIHByb3BlcnR5IGRlZmluaXRpb25cbiAgZGVsZXRlIGFjdGl2ZUVsZW1lbnQudmFsdWU7XG4gIGFjdGl2ZUVsZW1lbnQuZGV0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7XG5cbiAgYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRJRCA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AgPSBudWxsO1xufVxuXG4vKipcbiAqIChGb3Igb2xkIElFLikgSGFuZGxlcyBhIHByb3BlcnR5Y2hhbmdlIGV2ZW50LCBzZW5kaW5nIGEgYGNoYW5nZWAgZXZlbnQgaWZcbiAqIHRoZSB2YWx1ZSBvZiB0aGUgYWN0aXZlIGVsZW1lbnQgaGFzIGNoYW5nZWQuXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVByb3BlcnR5Q2hhbmdlKG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChuYXRpdmVFdmVudC5wcm9wZXJ0eU5hbWUgIT09ICd2YWx1ZScpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHZhbHVlID0gbmF0aXZlRXZlbnQuc3JjRWxlbWVudC52YWx1ZTtcbiAgaWYgKHZhbHVlID09PSBhY3RpdmVFbGVtZW50VmFsdWUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYWN0aXZlRWxlbWVudFZhbHVlID0gdmFsdWU7XG5cbiAgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCk7XG59XG5cbi8qKlxuICogSWYgYSBgY2hhbmdlYCBldmVudCBzaG91bGQgYmUgZmlyZWQsIHJldHVybnMgdGhlIHRhcmdldCdzIElELlxuICovXG5mdW5jdGlvbiBnZXRUYXJnZXRJREZvcklucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcElucHV0KSB7XG4gICAgLy8gSW4gbW9kZXJuIGJyb3dzZXJzIChpLmUuLCBub3QgSUU4IG9yIElFOSksIHRoZSBpbnB1dCBldmVudCBpcyBleGFjdGx5XG4gICAgLy8gd2hhdCB3ZSB3YW50IHNvIGZhbGwgdGhyb3VnaCBoZXJlIGFuZCB0cmlnZ2VyIGFuIGFic3RyYWN0IGV2ZW50XG4gICAgcmV0dXJuIHRvcExldmVsVGFyZ2V0SUQ7XG4gIH1cbn1cblxuLy8gRm9yIElFOCBhbmQgSUU5LlxuZnVuY3Rpb24gaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudElFKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BGb2N1cykge1xuICAgIC8vIEluIElFOCwgd2UgY2FuIGNhcHR1cmUgYWxtb3N0IGFsbCAudmFsdWUgY2hhbmdlcyBieSBhZGRpbmcgYVxuICAgIC8vIHByb3BlcnR5Y2hhbmdlIGhhbmRsZXIgYW5kIGxvb2tpbmcgZm9yIGV2ZW50cyB3aXRoIHByb3BlcnR5TmFtZVxuICAgIC8vIGVxdWFsIHRvICd2YWx1ZSdcbiAgICAvLyBJbiBJRTksIHByb3BlcnR5Y2hhbmdlIGZpcmVzIGZvciBtb3N0IGlucHV0IGV2ZW50cyBidXQgaXMgYnVnZ3kgYW5kXG4gICAgLy8gZG9lc24ndCBmaXJlIHdoZW4gdGV4dCBpcyBkZWxldGVkLCBidXQgY29udmVuaWVudGx5LCBzZWxlY3Rpb25jaGFuZ2VcbiAgICAvLyBhcHBlYXJzIHRvIGZpcmUgaW4gYWxsIG9mIHRoZSByZW1haW5pbmcgY2FzZXMgc28gd2UgY2F0Y2ggdGhvc2UgYW5kXG4gICAgLy8gZm9yd2FyZCB0aGUgZXZlbnQgaWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkXG4gICAgLy8gSW4gZWl0aGVyIGNhc2UsIHdlIGRvbid0IHdhbnQgdG8gY2FsbCB0aGUgZXZlbnQgaGFuZGxlciBpZiB0aGUgdmFsdWVcbiAgICAvLyBpcyBjaGFuZ2VkIGZyb20gSlMgc28gd2UgcmVkZWZpbmUgYSBzZXR0ZXIgZm9yIGAudmFsdWVgIHRoYXQgdXBkYXRlc1xuICAgIC8vIG91ciBhY3RpdmVFbGVtZW50VmFsdWUgdmFyaWFibGUsIGFsbG93aW5nIHVzIHRvIGlnbm9yZSB0aG9zZSBjaGFuZ2VzXG4gICAgLy9cbiAgICAvLyBzdG9wV2F0Y2hpbmcoKSBzaG91bGQgYmUgYSBub29wIGhlcmUgYnV0IHdlIGNhbGwgaXQganVzdCBpbiBjYXNlIHdlXG4gICAgLy8gbWlzc2VkIGEgYmx1ciBldmVudCBzb21laG93LlxuICAgIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCk7XG4gICAgc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElEKTtcbiAgfSBlbHNlIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wQmx1cikge1xuICAgIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCk7XG4gIH1cbn1cblxuLy8gRm9yIElFOCBhbmQgSUU5LlxuZnVuY3Rpb24gZ2V0VGFyZ2V0SURGb3JJbnB1dEV2ZW50SUUodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcFNlbGVjdGlvbkNoYW5nZSB8fCB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wS2V5VXAgfHwgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24pIHtcbiAgICAvLyBPbiB0aGUgc2VsZWN0aW9uY2hhbmdlIGV2ZW50LCB0aGUgdGFyZ2V0IGlzIGp1c3QgZG9jdW1lbnQgd2hpY2ggaXNuJ3RcbiAgICAvLyBoZWxwZnVsIGZvciB1cyBzbyBqdXN0IGNoZWNrIGFjdGl2ZUVsZW1lbnQgaW5zdGVhZC5cbiAgICAvL1xuICAgIC8vIDk5JSBvZiB0aGUgdGltZSwga2V5ZG93biBhbmQga2V5dXAgYXJlbid0IG5lY2Vzc2FyeS4gSUU4IGZhaWxzIHRvIGZpcmVcbiAgICAvLyBwcm9wZXJ0eWNoYW5nZSBvbiB0aGUgZmlyc3QgaW5wdXQgZXZlbnQgYWZ0ZXIgc2V0dGluZyBgdmFsdWVgIGZyb20gYVxuICAgIC8vIHNjcmlwdCBhbmQgZmlyZXMgb25seSBrZXlkb3duLCBrZXlwcmVzcywga2V5dXAuIENhdGNoaW5nIGtleXVwIHVzdWFsbHlcbiAgICAvLyBnZXRzIGl0IGFuZCBjYXRjaGluZyBrZXlkb3duIGxldHMgdXMgZmlyZSBhbiBldmVudCBmb3IgdGhlIGZpcnN0XG4gICAgLy8ga2V5c3Ryb2tlIGlmIHVzZXIgZG9lcyBhIGtleSByZXBlYXQgKGl0J2xsIGJlIGEgbGl0dGxlIGRlbGF5ZWQ6IHJpZ2h0XG4gICAgLy8gYmVmb3JlIHRoZSBzZWNvbmQga2V5c3Ryb2tlKS4gT3RoZXIgaW5wdXQgbWV0aG9kcyAoZS5nLiwgcGFzdGUpIHNlZW0gdG9cbiAgICAvLyBmaXJlIHNlbGVjdGlvbmNoYW5nZSBub3JtYWxseS5cbiAgICBpZiAoYWN0aXZlRWxlbWVudCAmJiBhY3RpdmVFbGVtZW50LnZhbHVlICE9PSBhY3RpdmVFbGVtZW50VmFsdWUpIHtcbiAgICAgIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IGFjdGl2ZUVsZW1lbnQudmFsdWU7XG4gICAgICByZXR1cm4gYWN0aXZlRWxlbWVudElEO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2xpY2tgIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVzZUNsaWNrRXZlbnQoZWxlbSkge1xuICAvLyBVc2UgdGhlIGBjbGlja2AgZXZlbnQgdG8gZGV0ZWN0IGNoYW5nZXMgdG8gY2hlY2tib3ggYW5kIHJhZGlvIGlucHV0cy5cbiAgLy8gVGhpcyBhcHByb2FjaCB3b3JrcyBhY3Jvc3MgYWxsIGJyb3dzZXJzLCB3aGVyZWFzIGBjaGFuZ2VgIGRvZXMgbm90IGZpcmVcbiAgLy8gdW50aWwgYGJsdXJgIGluIElFOC5cbiAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnICYmIChlbGVtLnR5cGUgPT09ICdjaGVja2JveCcgfHwgZWxlbS50eXBlID09PSAncmFkaW8nKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SURGb3JDbGlja0V2ZW50KHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BDbGljaykge1xuICAgIHJldHVybiB0b3BMZXZlbFRhcmdldElEO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25DaGFuZ2VgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBjaGFuZ2UgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy4gVGhpcyBldmVudCBmaXJlcyBhdCBhIHRpbWUgd2hlbiBpdCdzIHBvc3NpYmxlIHRvXG4gKiBjaGFuZ2UgdGhlIGVsZW1lbnQncyB2YWx1ZSB3aXRob3V0IHNlZWluZyBhIGZsaWNrZXIuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gc2VsZWN0XG4gKi9cbnZhciBDaGFuZ2VFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRvcExldmVsVGFyZ2V0IFRoZSBsaXN0ZW5pbmcgY29tcG9uZW50IHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVGFyZ2V0SUQgSUQgb2YgYHRvcExldmVsVGFyZ2V0YC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuZXh0cmFjdEV2ZW50c31cbiAgICovXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcblxuICAgIHZhciBnZXRUYXJnZXRJREZ1bmMsIGhhbmRsZUV2ZW50RnVuYztcbiAgICBpZiAoc2hvdWxkVXNlQ2hhbmdlRXZlbnQodG9wTGV2ZWxUYXJnZXQpKSB7XG4gICAgICBpZiAoZG9lc0NoYW5nZUV2ZW50QnViYmxlKSB7XG4gICAgICAgIGdldFRhcmdldElERnVuYyA9IGdldFRhcmdldElERm9yQ2hhbmdlRXZlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVFdmVudEZ1bmMgPSBoYW5kbGVFdmVudHNGb3JDaGFuZ2VFdmVudElFODtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0b3BMZXZlbFRhcmdldCkpIHtcbiAgICAgIGlmIChpc0lucHV0RXZlbnRTdXBwb3J0ZWQpIHtcbiAgICAgICAgZ2V0VGFyZ2V0SURGdW5jID0gZ2V0VGFyZ2V0SURGb3JJbnB1dEV2ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0VGFyZ2V0SURGdW5jID0gZ2V0VGFyZ2V0SURGb3JJbnB1dEV2ZW50SUU7XG4gICAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRJRTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNob3VsZFVzZUNsaWNrRXZlbnQodG9wTGV2ZWxUYXJnZXQpKSB7XG4gICAgICBnZXRUYXJnZXRJREZ1bmMgPSBnZXRUYXJnZXRJREZvckNsaWNrRXZlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGdldFRhcmdldElERnVuYykge1xuICAgICAgdmFyIHRhcmdldElEID0gZ2V0VGFyZ2V0SURGdW5jKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpO1xuICAgICAgaWYgKHRhcmdldElEKSB7XG4gICAgICAgIHZhciBldmVudCA9IFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLmNoYW5nZSwgdGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICAgIGV2ZW50LnR5cGUgPSAnY2hhbmdlJztcbiAgICAgICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYW5kbGVFdmVudEZ1bmMpIHtcbiAgICAgIGhhbmRsZUV2ZW50RnVuYyh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElEKTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDaGFuZ2VFdmVudFBsdWdpbjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL0NoYW5nZUV2ZW50UGx1Z2luLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEV2ZW50VGFyZ2V0XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHZXRzIHRoZSB0YXJnZXQgbm9kZSBmcm9tIGEgbmF0aXZlIGJyb3dzZXIgZXZlbnQgYnkgYWNjb3VudGluZyBmb3JcbiAqIGluY29uc2lzdGVuY2llcyBpbiBicm93c2VyIERPTSBBUElzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge0RPTUV2ZW50VGFyZ2V0fSBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IG5hdGl2ZUV2ZW50LnRhcmdldCB8fCBuYXRpdmVFdmVudC5zcmNFbGVtZW50IHx8IHdpbmRvdztcbiAgLy8gU2FmYXJpIG1heSBmaXJlIGV2ZW50cyBvbiB0ZXh0IG5vZGVzIChOb2RlLlRFWFRfTk9ERSBpcyAzKS5cbiAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2pzL2V2ZW50c19wcm9wZXJ0aWVzLmh0bWxcbiAgcmV0dXJuIHRhcmdldC5ub2RlVHlwZSA9PT0gMyA/IHRhcmdldC5wYXJlbnROb2RlIDogdGFyZ2V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEV2ZW50VGFyZ2V0O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvZ2V0RXZlbnRUYXJnZXQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaXNUZXh0SW5wdXRFbGVtZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBzZWUgaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWlucHV0LWVsZW1lbnQuaHRtbCNpbnB1dC10eXBlLWF0dHItc3VtbWFyeVxuICovXG52YXIgc3VwcG9ydGVkSW5wdXRUeXBlcyA9IHtcbiAgJ2NvbG9yJzogdHJ1ZSxcbiAgJ2RhdGUnOiB0cnVlLFxuICAnZGF0ZXRpbWUnOiB0cnVlLFxuICAnZGF0ZXRpbWUtbG9jYWwnOiB0cnVlLFxuICAnZW1haWwnOiB0cnVlLFxuICAnbW9udGgnOiB0cnVlLFxuICAnbnVtYmVyJzogdHJ1ZSxcbiAgJ3Bhc3N3b3JkJzogdHJ1ZSxcbiAgJ3JhbmdlJzogdHJ1ZSxcbiAgJ3NlYXJjaCc6IHRydWUsXG4gICd0ZWwnOiB0cnVlLFxuICAndGV4dCc6IHRydWUsXG4gICd0aW1lJzogdHJ1ZSxcbiAgJ3VybCc6IHRydWUsXG4gICd3ZWVrJzogdHJ1ZVxufTtcblxuZnVuY3Rpb24gaXNUZXh0SW5wdXRFbGVtZW50KGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIChub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBzdXBwb3J0ZWRJbnB1dFR5cGVzW2VsZW0udHlwZV0gfHwgbm9kZU5hbWUgPT09ICd0ZXh0YXJlYScpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVGV4dElucHV0RWxlbWVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL2lzVGV4dElucHV0RWxlbWVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBDbGllbnRSZWFjdFJvb3RJbmRleFxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBuZXh0UmVhY3RSb290SW5kZXggPSAwO1xuXG52YXIgQ2xpZW50UmVhY3RSb290SW5kZXggPSB7XG4gIGNyZWF0ZVJlYWN0Um9vdEluZGV4OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5leHRSZWFjdFJvb3RJbmRleCsrO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENsaWVudFJlYWN0Um9vdEluZGV4O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvQ2xpZW50UmVhY3RSb290SW5kZXguanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG5cbi8qKlxuICogTW9kdWxlIHRoYXQgaXMgaW5qZWN0YWJsZSBpbnRvIGBFdmVudFBsdWdpbkh1YmAsIHRoYXQgc3BlY2lmaWVzIGFcbiAqIGRldGVybWluaXN0aWMgb3JkZXJpbmcgb2YgYEV2ZW50UGx1Z2luYHMuIEEgY29udmVuaWVudCB3YXkgdG8gcmVhc29uIGFib3V0XG4gKiBwbHVnaW5zLCB3aXRob3V0IGhhdmluZyB0byBwYWNrYWdlIGV2ZXJ5IG9uZSBvZiB0aGVtLiBUaGlzIGlzIGJldHRlciB0aGFuXG4gKiBoYXZpbmcgcGx1Z2lucyBiZSBvcmRlcmVkIGluIHRoZSBzYW1lIG9yZGVyIHRoYXQgdGhleSBhcmUgaW5qZWN0ZWQgYmVjYXVzZVxuICogdGhhdCBvcmRlcmluZyB3b3VsZCBiZSBpbmZsdWVuY2VkIGJ5IHRoZSBwYWNrYWdpbmcgb3JkZXIuXG4gKiBgUmVzcG9uZGVyRXZlbnRQbHVnaW5gIG11c3Qgb2NjdXIgYmVmb3JlIGBTaW1wbGVFdmVudFBsdWdpbmAgc28gdGhhdFxuICogcHJldmVudGluZyBkZWZhdWx0IG9uIGV2ZW50cyBpcyBjb252ZW5pZW50IGluIGBTaW1wbGVFdmVudFBsdWdpbmAgaGFuZGxlcnMuXG4gKi9cbnZhciBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlciA9IFtrZXlPZih7IFJlc3BvbmRlckV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IFNpbXBsZUV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IFRhcEV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IEVudGVyTGVhdmVFdmVudFBsdWdpbjogbnVsbCB9KSwga2V5T2YoeyBDaGFuZ2VFdmVudFBsdWdpbjogbnVsbCB9KSwga2V5T2YoeyBTZWxlY3RFdmVudFBsdWdpbjogbnVsbCB9KSwga2V5T2YoeyBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luOiBudWxsIH0pXTtcblxubW9kdWxlLmV4cG9ydHMgPSBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlcjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL0RlZmF1bHRFdmVudFBsdWdpbk9yZGVyLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEVudGVyTGVhdmVFdmVudFBsdWdpblxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgU3ludGhldGljTW91c2VFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljTW91c2VFdmVudCcpO1xuXG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xudmFyIGdldEZpcnN0UmVhY3RET00gPSBSZWFjdE1vdW50LmdldEZpcnN0UmVhY3RET007XG5cbnZhciBldmVudFR5cGVzID0ge1xuICBtb3VzZUVudGVyOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZToga2V5T2YoeyBvbk1vdXNlRW50ZXI6IG51bGwgfSksXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dCwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU92ZXJdXG4gIH0sXG4gIG1vdXNlTGVhdmU6IHtcbiAgICByZWdpc3RyYXRpb25OYW1lOiBrZXlPZih7IG9uTW91c2VMZWF2ZTogbnVsbCB9KSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3V0LCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3Zlcl1cbiAgfVxufTtcblxudmFyIGV4dHJhY3RlZEV2ZW50cyA9IFtudWxsLCBudWxsXTtcblxudmFyIEVudGVyTGVhdmVFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIC8qKlxuICAgKiBGb3IgYWxtb3N0IGV2ZXJ5IGludGVyYWN0aW9uIHdlIGNhcmUgYWJvdXQsIHRoZXJlIHdpbGwgYmUgYm90aCBhIHRvcC1sZXZlbFxuICAgKiBgbW91c2VvdmVyYCBhbmQgYG1vdXNlb3V0YCBldmVudCB0aGF0IG9jY3Vycy4gT25seSB1c2UgYG1vdXNlb3V0YCBzbyB0aGF0XG4gICAqIHdlIGRvIG5vdCBleHRyYWN0IGR1cGxpY2F0ZSBldmVudHMuIEhvd2V2ZXIsIG1vdmluZyB0aGUgbW91c2UgaW50byB0aGVcbiAgICogYnJvd3NlciBmcm9tIG91dHNpZGUgd2lsbCBub3QgZmlyZSBhIGBtb3VzZW91dGAgZXZlbnQuIEluIHRoaXMgY2FzZSwgd2UgdXNlXG4gICAqIHRoZSBgbW91c2VvdmVyYCB0b3AtbGV2ZWwgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5leHRyYWN0RXZlbnRzfVxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyICYmIChuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LmZyb21FbGVtZW50KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0b3BMZXZlbFR5cGUgIT09IHRvcExldmVsVHlwZXMudG9wTW91c2VPdXQgJiYgdG9wTGV2ZWxUeXBlICE9PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3Zlcikge1xuICAgICAgLy8gTXVzdCBub3QgYmUgYSBtb3VzZSBpbiBvciBtb3VzZSBvdXQgLSBpZ25vcmluZy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB3aW47XG4gICAgaWYgKHRvcExldmVsVGFyZ2V0LndpbmRvdyA9PT0gdG9wTGV2ZWxUYXJnZXQpIHtcbiAgICAgIC8vIGB0b3BMZXZlbFRhcmdldGAgaXMgcHJvYmFibHkgYSB3aW5kb3cgb2JqZWN0LlxuICAgICAgd2luID0gdG9wTGV2ZWxUYXJnZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2h5IGBvd25lckRvY3VtZW50YCBpcyBzb21ldGltZXMgdW5kZWZpbmVkIGluIElFOC5cbiAgICAgIHZhciBkb2MgPSB0b3BMZXZlbFRhcmdldC5vd25lckRvY3VtZW50O1xuICAgICAgaWYgKGRvYykge1xuICAgICAgICB3aW4gPSBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbiA9IHdpbmRvdztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZnJvbTtcbiAgICB2YXIgdG87XG4gICAgdmFyIGZyb21JRCA9ICcnO1xuICAgIHZhciB0b0lEID0gJyc7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dCkge1xuICAgICAgZnJvbSA9IHRvcExldmVsVGFyZ2V0O1xuICAgICAgZnJvbUlEID0gdG9wTGV2ZWxUYXJnZXRJRDtcbiAgICAgIHRvID0gZ2V0Rmlyc3RSZWFjdERPTShuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnRvRWxlbWVudCk7XG4gICAgICBpZiAodG8pIHtcbiAgICAgICAgdG9JRCA9IFJlYWN0TW91bnQuZ2V0SUQodG8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG8gPSB3aW47XG4gICAgICB9XG4gICAgICB0byA9IHRvIHx8IHdpbjtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJvbSA9IHdpbjtcbiAgICAgIHRvID0gdG9wTGV2ZWxUYXJnZXQ7XG4gICAgICB0b0lEID0gdG9wTGV2ZWxUYXJnZXRJRDtcbiAgICB9XG5cbiAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgIC8vIE5vdGhpbmcgcGVydGFpbnMgdG8gb3VyIG1hbmFnZWQgY29tcG9uZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBsZWF2ZSA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMubW91c2VMZWF2ZSwgZnJvbUlELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGxlYXZlLnR5cGUgPSAnbW91c2VsZWF2ZSc7XG4gICAgbGVhdmUudGFyZ2V0ID0gZnJvbTtcbiAgICBsZWF2ZS5yZWxhdGVkVGFyZ2V0ID0gdG87XG5cbiAgICB2YXIgZW50ZXIgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLm1vdXNlRW50ZXIsIHRvSUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgZW50ZXIudHlwZSA9ICdtb3VzZWVudGVyJztcbiAgICBlbnRlci50YXJnZXQgPSB0bztcbiAgICBlbnRlci5yZWxhdGVkVGFyZ2V0ID0gZnJvbTtcblxuICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbUlELCB0b0lEKTtcblxuICAgIGV4dHJhY3RlZEV2ZW50c1swXSA9IGxlYXZlO1xuICAgIGV4dHJhY3RlZEV2ZW50c1sxXSA9IGVudGVyO1xuXG4gICAgcmV0dXJuIGV4dHJhY3RlZEV2ZW50cztcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVudGVyTGVhdmVFdmVudFBsdWdpbjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL0VudGVyTGVhdmVFdmVudFBsdWdpbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNNb3VzZUV2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcbnZhciBWaWV3cG9ydE1ldHJpY3MgPSByZXF1aXJlKCcuL1ZpZXdwb3J0TWV0cmljcycpO1xuXG52YXIgZ2V0RXZlbnRNb2RpZmllclN0YXRlID0gcmVxdWlyZSgnLi9nZXRFdmVudE1vZGlmaWVyU3RhdGUnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIE1vdXNlRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgTW91c2VFdmVudEludGVyZmFjZSA9IHtcbiAgc2NyZWVuWDogbnVsbCxcbiAgc2NyZWVuWTogbnVsbCxcbiAgY2xpZW50WDogbnVsbCxcbiAgY2xpZW50WTogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlLFxuICBidXR0b246IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIFdlYmtpdCwgRmlyZWZveCwgSUU5K1xuICAgIC8vIHdoaWNoOiAgMSAyIDNcbiAgICAvLyBidXR0b246IDAgMSAyIChzdGFuZGFyZClcbiAgICB2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuICAgIGlmICgnd2hpY2gnIGluIGV2ZW50KSB7XG4gICAgICByZXR1cm4gYnV0dG9uO1xuICAgIH1cbiAgICAvLyBJRTw5XG4gICAgLy8gd2hpY2g6ICB1bmRlZmluZWRcbiAgICAvLyBidXR0b246IDAgMCAwXG4gICAgLy8gYnV0dG9uOiAxIDQgMiAob25tb3VzZXVwKVxuICAgIHJldHVybiBidXR0b24gPT09IDIgPyAyIDogYnV0dG9uID09PSA0ID8gMSA6IDA7XG4gIH0sXG4gIGJ1dHRvbnM6IG51bGwsXG4gIHJlbGF0ZWRUYXJnZXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBldmVudC5yZWxhdGVkVGFyZ2V0IHx8IChldmVudC5mcm9tRWxlbWVudCA9PT0gZXZlbnQuc3JjRWxlbWVudCA/IGV2ZW50LnRvRWxlbWVudCA6IGV2ZW50LmZyb21FbGVtZW50KTtcbiAgfSxcbiAgLy8gXCJQcm9wcmlldGFyeVwiIEludGVyZmFjZS5cbiAgcGFnZVg6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAncGFnZVgnIGluIGV2ZW50ID8gZXZlbnQucGFnZVggOiBldmVudC5jbGllbnRYICsgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxMZWZ0O1xuICB9LFxuICBwYWdlWTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdwYWdlWScgaW4gZXZlbnQgPyBldmVudC5wYWdlWSA6IGV2ZW50LmNsaWVudFkgKyBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbFRvcDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljTW91c2VFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNNb3VzZUV2ZW50LCBNb3VzZUV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvU3ludGhldGljTW91c2VFdmVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNVSUV2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG52YXIgZ2V0RXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL2dldEV2ZW50VGFyZ2V0Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBVSUV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFVJRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHZpZXc6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC52aWV3KSB7XG4gICAgICByZXR1cm4gZXZlbnQudmlldztcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZXZlbnQpO1xuICAgIGlmICh0YXJnZXQgIT0gbnVsbCAmJiB0YXJnZXQud2luZG93ID09PSB0YXJnZXQpIHtcbiAgICAgIC8vIHRhcmdldCBpcyBhIHdpbmRvdyBvYmplY3RcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgdmFyIGRvYyA9IHRhcmdldC5vd25lckRvY3VtZW50O1xuICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2h5IGBvd25lckRvY3VtZW50YCBpcyBzb21ldGltZXMgdW5kZWZpbmVkIGluIElFOC5cbiAgICBpZiAoZG9jKSB7XG4gICAgICByZXR1cm4gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgfVxuICB9LFxuICBkZXRhaWw6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBldmVudC5kZXRhaWwgfHwgMDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1VJRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNVSUV2ZW50LCBVSUV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNVSUV2ZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvU3ludGhldGljVUlFdmVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRFdmVudE1vZGlmaWVyU3RhdGVcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFRyYW5zbGF0aW9uIGZyb20gbW9kaWZpZXIga2V5IHRvIHRoZSBhc3NvY2lhdGVkIHByb3BlcnR5IGluIHRoZSBldmVudC5cbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNrZXlzLU1vZGlmaWVyc1xuICovXG5cbnZhciBtb2RpZmllcktleVRvUHJvcCA9IHtcbiAgJ0FsdCc6ICdhbHRLZXknLFxuICAnQ29udHJvbCc6ICdjdHJsS2V5JyxcbiAgJ01ldGEnOiAnbWV0YUtleScsXG4gICdTaGlmdCc6ICdzaGlmdEtleSdcbn07XG5cbi8vIElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgZ2V0TW9kaWZpZXJTdGF0ZSBzbyB3ZSBzaW1wbHkgbWFwIGl0IHRvIHRoZSBvbmx5XG4vLyBtb2RpZmllciBrZXlzIGV4cG9zZWQgYnkgdGhlIGV2ZW50IGl0c2VsZiwgZG9lcyBub3Qgc3VwcG9ydCBMb2NrLWtleXMuXG4vLyBDdXJyZW50bHksIGFsbCBtYWpvciBicm93c2VycyBleGNlcHQgQ2hyb21lIHNlZW1zIHRvIHN1cHBvcnQgTG9jay1rZXlzLlxuZnVuY3Rpb24gbW9kaWZpZXJTdGF0ZUdldHRlcihrZXlBcmcpIHtcbiAgdmFyIHN5bnRoZXRpY0V2ZW50ID0gdGhpcztcbiAgdmFyIG5hdGl2ZUV2ZW50ID0gc3ludGhldGljRXZlbnQubmF0aXZlRXZlbnQ7XG4gIGlmIChuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUoa2V5QXJnKTtcbiAgfVxuICB2YXIga2V5UHJvcCA9IG1vZGlmaWVyS2V5VG9Qcm9wW2tleUFyZ107XG4gIHJldHVybiBrZXlQcm9wID8gISFuYXRpdmVFdmVudFtrZXlQcm9wXSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRFdmVudE1vZGlmaWVyU3RhdGUobmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIG1vZGlmaWVyU3RhdGVHZXR0ZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRNb2RpZmllclN0YXRlO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvZ2V0RXZlbnRNb2RpZmllclN0YXRlLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEhUTUxET01Qcm9wZXJ0eUNvbmZpZ1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIE1VU1RfVVNFX0FUVFJJQlVURSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5NVVNUX1VTRV9BVFRSSUJVVEU7XG52YXIgTVVTVF9VU0VfUFJPUEVSVFkgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uTVVTVF9VU0VfUFJPUEVSVFk7XG52YXIgSEFTX0JPT0xFQU5fVkFMVUUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX0JPT0xFQU5fVkFMVUU7XG52YXIgSEFTX1NJREVfRUZGRUNUUyA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfU0lERV9FRkZFQ1RTO1xudmFyIEhBU19OVU1FUklDX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19OVU1FUklDX1ZBTFVFO1xudmFyIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFO1xudmFyIEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRTtcblxudmFyIGhhc1NWRztcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgdmFyIGltcGxlbWVudGF0aW9uID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb247XG4gIGhhc1NWRyA9IGltcGxlbWVudGF0aW9uICYmIGltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUgJiYgaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgnaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNCYXNpY1N0cnVjdHVyZScsICcxLjEnKTtcbn1cblxudmFyIEhUTUxET01Qcm9wZXJ0eUNvbmZpZyA9IHtcbiAgaXNDdXN0b21BdHRyaWJ1dGU6IFJlZ0V4cC5wcm90b3R5cGUudGVzdC5iaW5kKC9eKGRhdGF8YXJpYSktW2Etel9dW2EtelxcZF8uXFwtXSokLyksXG4gIFByb3BlcnRpZXM6IHtcbiAgICAvKipcbiAgICAgKiBTdGFuZGFyZCBQcm9wZXJ0aWVzXG4gICAgICovXG4gICAgYWNjZXB0OiBudWxsLFxuICAgIGFjY2VwdENoYXJzZXQ6IG51bGwsXG4gICAgYWNjZXNzS2V5OiBudWxsLFxuICAgIGFjdGlvbjogbnVsbCxcbiAgICBhbGxvd0Z1bGxTY3JlZW46IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGFsbG93VHJhbnNwYXJlbmN5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgYWx0OiBudWxsLFxuICAgIGFzeW5jOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBhdXRvQ29tcGxldGU6IG51bGwsXG4gICAgLy8gYXV0b0ZvY3VzIGlzIHBvbHlmaWxsZWQvbm9ybWFsaXplZCBieSBBdXRvRm9jdXNVdGlsc1xuICAgIC8vIGF1dG9Gb2N1czogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgYXV0b1BsYXk6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNhcHR1cmU6IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNlbGxQYWRkaW5nOiBudWxsLFxuICAgIGNlbGxTcGFjaW5nOiBudWxsLFxuICAgIGNoYXJTZXQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBjaGFsbGVuZ2U6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBjaGVja2VkOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNsYXNzSUQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICAvLyBUbyBzZXQgY2xhc3NOYW1lIG9uIFNWRyBlbGVtZW50cywgaXQncyBuZWNlc3NhcnkgdG8gdXNlIC5zZXRBdHRyaWJ1dGU7XG4gICAgLy8gdGhpcyB3b3JrcyBvbiBIVE1MIGVsZW1lbnRzIHRvbyBpbiBhbGwgYnJvd3NlcnMgZXhjZXB0IElFOC4gQ29udmVuaWVudGx5LFxuICAgIC8vIElFOCBkb2Vzbid0IHN1cHBvcnQgU1ZHIGFuZCBzbyB3ZSBjYW4gc2ltcGx5IHVzZSB0aGUgYXR0cmlidXRlIGluXG4gICAgLy8gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IFNWRyBhbmQgdGhlIHByb3BlcnR5IGluIGJyb3dzZXJzIHRoYXQgZG9uJ3QsXG4gICAgLy8gcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIEhUTUwgb3IgU1ZHLlxuICAgIGNsYXNzTmFtZTogaGFzU1ZHID8gTVVTVF9VU0VfQVRUUklCVVRFIDogTVVTVF9VU0VfUFJPUEVSVFksXG4gICAgY29sczogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgY29sU3BhbjogbnVsbCxcbiAgICBjb250ZW50OiBudWxsLFxuICAgIGNvbnRlbnRFZGl0YWJsZTogbnVsbCxcbiAgICBjb250ZXh0TWVudTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGNvbnRyb2xzOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNvb3JkczogbnVsbCxcbiAgICBjcm9zc09yaWdpbjogbnVsbCxcbiAgICBkYXRhOiBudWxsLCAvLyBGb3IgYDxvYmplY3QgLz5gIGFjdHMgYXMgYHNyY2AuXG4gICAgZGF0ZVRpbWU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICAnZGVmYXVsdCc6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGRlZmVyOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkaXI6IG51bGwsXG4gICAgZGlzYWJsZWQ6IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGRvd25sb2FkOiBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFLFxuICAgIGRyYWdnYWJsZTogbnVsbCxcbiAgICBlbmNUeXBlOiBudWxsLFxuICAgIGZvcm06IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmb3JtQWN0aW9uOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZm9ybUVuY1R5cGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmb3JtTWV0aG9kOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZm9ybU5vVmFsaWRhdGU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGZvcm1UYXJnZXQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmcmFtZUJvcmRlcjogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGhlYWRlcnM6IG51bGwsXG4gICAgaGVpZ2h0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgaGlkZGVuOiBNVVNUX1VTRV9BVFRSSUJVVEUgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBoaWdoOiBudWxsLFxuICAgIGhyZWY6IG51bGwsXG4gICAgaHJlZkxhbmc6IG51bGwsXG4gICAgaHRtbEZvcjogbnVsbCxcbiAgICBodHRwRXF1aXY6IG51bGwsXG4gICAgaWNvbjogbnVsbCxcbiAgICBpZDogTVVTVF9VU0VfUFJPUEVSVFksXG4gICAgaW5wdXRNb2RlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgaW50ZWdyaXR5OiBudWxsLFxuICAgIGlzOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAga2V5UGFyYW1zOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAga2V5VHlwZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGtpbmQ6IG51bGwsXG4gICAgbGFiZWw6IG51bGwsXG4gICAgbGFuZzogbnVsbCxcbiAgICBsaXN0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgbG9vcDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBsb3c6IG51bGwsXG4gICAgbWFuaWZlc3Q6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtYXJnaW5IZWlnaHQ6IG51bGwsXG4gICAgbWFyZ2luV2lkdGg6IG51bGwsXG4gICAgbWF4OiBudWxsLFxuICAgIG1heExlbmd0aDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG1lZGlhOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgbWVkaWFHcm91cDogbnVsbCxcbiAgICBtZXRob2Q6IG51bGwsXG4gICAgbWluOiBudWxsLFxuICAgIG1pbkxlbmd0aDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG11bHRpcGxlOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG11dGVkOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG5hbWU6IG51bGwsXG4gICAgbm9uY2U6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBub1ZhbGlkYXRlOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBvcGVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBvcHRpbXVtOiBudWxsLFxuICAgIHBhdHRlcm46IG51bGwsXG4gICAgcGxhY2Vob2xkZXI6IG51bGwsXG4gICAgcG9zdGVyOiBudWxsLFxuICAgIHByZWxvYWQ6IG51bGwsXG4gICAgcmFkaW9Hcm91cDogbnVsbCxcbiAgICByZWFkT25seTogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByZWw6IG51bGwsXG4gICAgcmVxdWlyZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJldmVyc2VkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByb2xlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcm93czogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgcm93U3BhbjogbnVsbCxcbiAgICBzYW5kYm94OiBudWxsLFxuICAgIHNjb3BlOiBudWxsLFxuICAgIHNjb3BlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2Nyb2xsaW5nOiBudWxsLFxuICAgIHNlYW1sZXNzOiBNVVNUX1VTRV9BVFRSSUJVVEUgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBzZWxlY3RlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBzaGFwZTogbnVsbCxcbiAgICBzaXplOiBNVVNUX1VTRV9BVFRSSUJVVEUgfCBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICBzaXplczogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHNwYW46IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHNwZWxsQ2hlY2s6IG51bGwsXG4gICAgc3JjOiBudWxsLFxuICAgIHNyY0RvYzogTVVTVF9VU0VfUFJPUEVSVFksXG4gICAgc3JjTGFuZzogbnVsbCxcbiAgICBzcmNTZXQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzdGFydDogSEFTX05VTUVSSUNfVkFMVUUsXG4gICAgc3RlcDogbnVsbCxcbiAgICBzdHlsZTogbnVsbCxcbiAgICBzdW1tYXJ5OiBudWxsLFxuICAgIHRhYkluZGV4OiBudWxsLFxuICAgIHRhcmdldDogbnVsbCxcbiAgICB0aXRsZTogbnVsbCxcbiAgICB0eXBlOiBudWxsLFxuICAgIHVzZU1hcDogbnVsbCxcbiAgICB2YWx1ZTogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfU0lERV9FRkZFQ1RTLFxuICAgIHdpZHRoOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgd21vZGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB3cmFwOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogUkRGYSBQcm9wZXJ0aWVzXG4gICAgICovXG4gICAgYWJvdXQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBkYXRhdHlwZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGlubGlzdDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHByZWZpeDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIC8vIHByb3BlcnR5IGlzIGFsc28gc3VwcG9ydGVkIGZvciBPcGVuR3JhcGggaW4gbWV0YSB0YWdzLlxuICAgIHByb3BlcnR5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcmVzb3VyY2U6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICAndHlwZW9mJzogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHZvY2FiOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG5cbiAgICAvKipcbiAgICAgKiBOb24tc3RhbmRhcmQgUHJvcGVydGllc1xuICAgICAqL1xuICAgIC8vIGF1dG9DYXBpdGFsaXplIGFuZCBhdXRvQ29ycmVjdCBhcmUgc3VwcG9ydGVkIGluIE1vYmlsZSBTYWZhcmkgZm9yXG4gICAgLy8ga2V5Ym9hcmQgaGludHMuXG4gICAgYXV0b0NhcGl0YWxpemU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBhdXRvQ29ycmVjdDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIC8vIGF1dG9TYXZlIGFsbG93cyBXZWJLaXQvQmxpbmsgdG8gcGVyc2lzdCB2YWx1ZXMgb2YgaW5wdXQgZmllbGRzIG9uIHBhZ2UgcmVsb2Fkc1xuICAgIGF1dG9TYXZlOiBudWxsLFxuICAgIC8vIGNvbG9yIGlzIGZvciBTYWZhcmkgbWFzay1pY29uIGxpbmtcbiAgICBjb2xvcjogbnVsbCxcbiAgICAvLyBpdGVtUHJvcCwgaXRlbVNjb3BlLCBpdGVtVHlwZSBhcmUgZm9yXG4gICAgLy8gTWljcm9kYXRhIHN1cHBvcnQuIFNlZSBodHRwOi8vc2NoZW1hLm9yZy9kb2NzL2dzLmh0bWxcbiAgICBpdGVtUHJvcDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGl0ZW1TY29wZTogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgaXRlbVR5cGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICAvLyBpdGVtSUQgYW5kIGl0ZW1SZWYgYXJlIGZvciBNaWNyb2RhdGEgc3VwcG9ydCBhcyB3ZWxsIGJ1dFxuICAgIC8vIG9ubHkgc3BlY2lmaWVkIGluIHRoZSB0aGUgV0hBVFdHIHNwZWMgZG9jdW1lbnQuIFNlZVxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL21pY3JvZGF0YS5odG1sI21pY3JvZGF0YS1kb20tYXBpXG4gICAgaXRlbUlEOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgaXRlbVJlZjogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIC8vIHJlc3VsdHMgc2hvdyBsb29raW5nIGdsYXNzIGljb24gYW5kIHJlY2VudCBzZWFyY2hlcyBvbiBpbnB1dFxuICAgIC8vIHNlYXJjaCBmaWVsZHMgaW4gV2ViS2l0L0JsaW5rXG4gICAgcmVzdWx0czogbnVsbCxcbiAgICAvLyBJRS1vbmx5IGF0dHJpYnV0ZSB0aGF0IHNwZWNpZmllcyBzZWN1cml0eSByZXN0cmljdGlvbnMgb24gYW4gaWZyYW1lXG4gICAgLy8gYXMgYW4gYWx0ZXJuYXRpdmUgdG8gdGhlIHNhbmRib3ggYXR0cmlidXRlIG9uIElFPDEwXG4gICAgc2VjdXJpdHk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICAvLyBJRS1vbmx5IGF0dHJpYnV0ZSB0aGF0IGNvbnRyb2xzIGZvY3VzIGJlaGF2aW9yXG4gICAgdW5zZWxlY3RhYmxlOiBNVVNUX1VTRV9BVFRSSUJVVEVcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXM6IHtcbiAgICBhY2NlcHRDaGFyc2V0OiAnYWNjZXB0LWNoYXJzZXQnLFxuICAgIGNsYXNzTmFtZTogJ2NsYXNzJyxcbiAgICBodG1sRm9yOiAnZm9yJyxcbiAgICBodHRwRXF1aXY6ICdodHRwLWVxdWl2J1xuICB9LFxuICBET01Qcm9wZXJ0eU5hbWVzOiB7XG4gICAgYXV0b0NvbXBsZXRlOiAnYXV0b2NvbXBsZXRlJyxcbiAgICBhdXRvRm9jdXM6ICdhdXRvZm9jdXMnLFxuICAgIGF1dG9QbGF5OiAnYXV0b3BsYXknLFxuICAgIGF1dG9TYXZlOiAnYXV0b3NhdmUnLFxuICAgIC8vIGBlbmNvZGluZ2AgaXMgZXF1aXZhbGVudCB0byBgZW5jdHlwZWAsIElFOCBsYWNrcyBhbiBgZW5jdHlwZWAgc2V0dGVyLlxuICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2Zvcm1zLmh0bWwjZG9tLWZzLWVuY29kaW5nXG4gICAgZW5jVHlwZTogJ2VuY29kaW5nJyxcbiAgICBocmVmTGFuZzogJ2hyZWZsYW5nJyxcbiAgICByYWRpb0dyb3VwOiAncmFkaW9ncm91cCcsXG4gICAgc3BlbGxDaGVjazogJ3NwZWxsY2hlY2snLFxuICAgIHNyY0RvYzogJ3NyY2RvYycsXG4gICAgc3JjU2V0OiAnc3Jjc2V0J1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhUTUxET01Qcm9wZXJ0eUNvbmZpZztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL0hUTUxET01Qcm9wZXJ0eUNvbmZpZy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0SW5zdGFuY2VNYXAgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VNYXAnKTtcblxudmFyIGZpbmRET01Ob2RlID0gcmVxdWlyZSgnLi9maW5kRE9NTm9kZScpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBkaWRXYXJuS2V5ID0gJ19nZXRET01Ob2RlRGlkV2Fybic7XG5cbnZhciBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbiA9IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIERPTSBub2RlIHJlbmRlcmVkIGJ5IHRoaXMgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtET01FbGVtZW50fSBUaGUgcm9vdCBub2RlIG9mIHRoaXMgY29tcG9uZW50LlxuICAgKiBAZmluYWxcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZ2V0RE9NTm9kZTogZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHRoaXMuY29uc3RydWN0b3JbZGlkV2FybktleV0sICclcy5nZXRET01Ob2RlKC4uLikgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSAnICsgJ1JlYWN0RE9NLmZpbmRET01Ob2RlKGluc3RhbmNlKSBpbnN0ZWFkLicsIFJlYWN0SW5zdGFuY2VNYXAuZ2V0KHRoaXMpLmdldE5hbWUoKSB8fCB0aGlzLnRhZ05hbWUgfHwgJ1Vua25vd24nKSA6IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNvbnN0cnVjdG9yW2RpZFdhcm5LZXldID0gdHJ1ZTtcbiAgICByZXR1cm4gZmluZERPTU5vZGUodGhpcyk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW47XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBmaW5kRE9NTm9kZVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBET00gbm9kZSByZW5kZXJlZCBieSB0aGlzIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudHxET01FbGVtZW50fSBjb21wb25lbnRPckVsZW1lbnRcbiAqIEByZXR1cm4gez9ET01FbGVtZW50fSBUaGUgcm9vdCBub2RlIG9mIHRoaXMgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gZmluZERPTU5vZGUoY29tcG9uZW50T3JFbGVtZW50KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICBpZiAob3duZXIgIT09IG51bGwpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKG93bmVyLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciwgJyVzIGlzIGFjY2Vzc2luZyBnZXRET01Ob2RlIG9yIGZpbmRET01Ob2RlIGluc2lkZSBpdHMgcmVuZGVyKCkuICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBvd25lci5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgICBvd25lci5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoY29tcG9uZW50T3JFbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoY29tcG9uZW50T3JFbGVtZW50Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudE9yRWxlbWVudDtcbiAgfVxuICBpZiAoUmVhY3RJbnN0YW5jZU1hcC5oYXMoY29tcG9uZW50T3JFbGVtZW50KSkge1xuICAgIHJldHVybiBSZWFjdE1vdW50LmdldE5vZGVGcm9tSW5zdGFuY2UoY29tcG9uZW50T3JFbGVtZW50KTtcbiAgfVxuICAhKGNvbXBvbmVudE9yRWxlbWVudC5yZW5kZXIgPT0gbnVsbCB8fCB0eXBlb2YgY29tcG9uZW50T3JFbGVtZW50LnJlbmRlciAhPT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZmluZERPTU5vZGUgd2FzIGNhbGxlZCBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgYXBwZWFycyB0byBiZSBuZWl0aGVyIFJlYWN0Q29tcG9uZW50IG5vciBET01Ob2RlIChrZXlzOiAlcyknLCBPYmplY3Qua2V5cyhjb21wb25lbnRPckVsZW1lbnQpKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZERPTU5vZGU7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9maW5kRE9NTm9kZS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNhY3Rpb24nKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG5cbnZhciBSRVNFVF9CQVRDSEVEX1VQREFURVMgPSB7XG4gIGluaXRpYWxpemU6IGVtcHR5RnVuY3Rpb24sXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA9IGZhbHNlO1xuICB9XG59O1xuXG52YXIgRkxVU0hfQkFUQ0hFRF9VUERBVEVTID0ge1xuICBpbml0aWFsaXplOiBlbXB0eUZ1bmN0aW9uLFxuICBjbG9zZTogUmVhY3RVcGRhdGVzLmZsdXNoQmF0Y2hlZFVwZGF0ZXMuYmluZChSZWFjdFVwZGF0ZXMpXG59O1xuXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbRkxVU0hfQkFUQ0hFRF9VUERBVEVTLCBSRVNFVF9CQVRDSEVEX1VQREFURVNdO1xuXG5mdW5jdGlvbiBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5VHJhbnNhY3Rpb24oKSB7XG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcbn1cblxuYXNzaWduKFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFRyYW5zYWN0aW9uLk1peGluLCB7XG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVFJBTlNBQ1RJT05fV1JBUFBFUlM7XG4gIH1cbn0pO1xuXG52YXIgdHJhbnNhY3Rpb24gPSBuZXcgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVRyYW5zYWN0aW9uKCk7XG5cbnZhciBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5ID0ge1xuICBpc0JhdGNoaW5nVXBkYXRlczogZmFsc2UsXG5cbiAgLyoqXG4gICAqIENhbGwgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGluIGEgY29udGV4dCB3aXRoaW4gd2hpY2ggY2FsbHMgdG8gYHNldFN0YXRlYFxuICAgKiBhbmQgZnJpZW5kcyBhcmUgYmF0Y2hlZCBzdWNoIHRoYXQgY29tcG9uZW50cyBhcmVuJ3QgdXBkYXRlZCB1bm5lY2Vzc2FyaWx5LlxuICAgKi9cbiAgYmF0Y2hlZFVwZGF0ZXM6IGZ1bmN0aW9uIChjYWxsYmFjaywgYSwgYiwgYywgZCwgZSkge1xuICAgIHZhciBhbHJlYWR5QmF0Y2hpbmdVcGRhdGVzID0gUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcztcblxuICAgIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMgPSB0cnVlO1xuXG4gICAgLy8gVGhlIGNvZGUgaXMgd3JpdHRlbiB0aGlzIHdheSB0byBhdm9pZCBleHRyYSBhbGxvY2F0aW9uc1xuICAgIGlmIChhbHJlYWR5QmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgICBjYWxsYmFjayhhLCBiLCBjLCBkLCBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNhY3Rpb24ucGVyZm9ybShjYWxsYmFjaywgbnVsbCwgYSwgYiwgYywgZCwgZSk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3k7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NQ29tcG9uZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbi8qIGdsb2JhbCBoYXNPd25Qcm9wZXJ0eTp0cnVlICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEF1dG9Gb2N1c1V0aWxzID0gcmVxdWlyZSgnLi9BdXRvRm9jdXNVdGlscycpO1xudmFyIENTU1Byb3BlcnR5T3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vQ1NTUHJvcGVydHlPcGVyYXRpb25zJyk7XG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgRE9NUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnMnKTtcbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlcicpO1xudmFyIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0RE9NQnV0dG9uID0gcmVxdWlyZSgnLi9SZWFjdERPTUJ1dHRvbicpO1xudmFyIFJlYWN0RE9NSW5wdXQgPSByZXF1aXJlKCcuL1JlYWN0RE9NSW5wdXQnKTtcbnZhciBSZWFjdERPTU9wdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RET01PcHRpb24nKTtcbnZhciBSZWFjdERPTVNlbGVjdCA9IHJlcXVpcmUoJy4vUmVhY3RET01TZWxlY3QnKTtcbnZhciBSZWFjdERPTVRleHRhcmVhID0gcmVxdWlyZSgnLi9SZWFjdERPTVRleHRhcmVhJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xudmFyIFJlYWN0TXVsdGlDaGlsZCA9IHJlcXVpcmUoJy4vUmVhY3RNdWx0aUNoaWxkJyk7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZSgnLi9SZWFjdFBlcmYnKTtcbnZhciBSZWFjdFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZVF1ZXVlJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vY2FuRGVmaW5lUHJvcGVydHknKTtcbnZhciBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIgPSByZXF1aXJlKCcuL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlcicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIGlzRXZlbnRTdXBwb3J0ZWQgPSByZXF1aXJlKCcuL2lzRXZlbnRTdXBwb3J0ZWQnKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG52YXIgc2V0SW5uZXJIVE1MID0gcmVxdWlyZSgnLi9zZXRJbm5lckhUTUwnKTtcbnZhciBzZXRUZXh0Q29udGVudCA9IHJlcXVpcmUoJy4vc2V0VGV4dENvbnRlbnQnKTtcbnZhciBzaGFsbG93RXF1YWwgPSByZXF1aXJlKCdmYmpzL2xpYi9zaGFsbG93RXF1YWwnKTtcbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSByZXF1aXJlKCcuL3ZhbGlkYXRlRE9NTmVzdGluZycpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBkZWxldGVMaXN0ZW5lciA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5kZWxldGVMaXN0ZW5lcjtcbnZhciBsaXN0ZW5UbyA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5saXN0ZW5UbztcbnZhciByZWdpc3RyYXRpb25OYW1lTW9kdWxlcyA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5yZWdpc3RyYXRpb25OYW1lTW9kdWxlcztcblxuLy8gRm9yIHF1aWNrbHkgbWF0Y2hpbmcgY2hpbGRyZW4gdHlwZSwgdG8gdGVzdCBpZiBjYW4gYmUgdHJlYXRlZCBhcyBjb250ZW50LlxudmFyIENPTlRFTlRfVFlQRVMgPSB7ICdzdHJpbmcnOiB0cnVlLCAnbnVtYmVyJzogdHJ1ZSB9O1xuXG52YXIgQ0hJTERSRU4gPSBrZXlPZih7IGNoaWxkcmVuOiBudWxsIH0pO1xudmFyIFNUWUxFID0ga2V5T2YoeyBzdHlsZTogbnVsbCB9KTtcbnZhciBIVE1MID0ga2V5T2YoeyBfX2h0bWw6IG51bGwgfSk7XG5cbnZhciBFTEVNRU5UX05PREVfVFlQRSA9IDE7XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShpbnRlcm5hbEluc3RhbmNlKSB7XG4gIGlmIChpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgdmFyIG93bmVyID0gaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyIHx8IG51bGw7XG4gICAgaWYgKG93bmVyKSB7XG4gICAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAnIFRoaXMgRE9NIG5vZGUgd2FzIHJlbmRlcmVkIGJ5IGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxudmFyIGxlZ2FjeVByb3BzRGVzY3JpcHRvcjtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGxlZ2FjeVByb3BzRGVzY3JpcHRvciA9IHtcbiAgICBwcm9wczoge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuX3JlYWN0SW50ZXJuYWxDb21wb25lbnQ7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3RET01Db21wb25lbnQ6IERvIG5vdCBhY2Nlc3MgLnByb3BzIG9mIGEgRE9NIG5vZGU7IGluc3RlYWQsICcgKyAncmVjcmVhdGUgdGhlIHByb3BzIGFzIGByZW5kZXJgIGRpZCBvcmlnaW5hbGx5IG9yIHJlYWQgdGhlIERPTSAnICsgJ3Byb3BlcnRpZXMvYXR0cmlidXRlcyBkaXJlY3RseSBmcm9tIHRoaXMgbm9kZSAoZS5nLiwgJyArICd0aGlzLnJlZnMuYm94LmNsYXNzTmFtZSkuJXMnLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oY29tcG9uZW50KSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gbGVnYWN5R2V0RE9NTm9kZSgpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5fcmVhY3RJbnRlcm5hbENvbXBvbmVudDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1JlYWN0RE9NQ29tcG9uZW50OiBEbyBub3QgYWNjZXNzIC5nZXRET01Ob2RlKCkgb2YgYSBET00gbm9kZTsgJyArICdpbnN0ZWFkLCB1c2UgdGhlIG5vZGUgZGlyZWN0bHkuJXMnLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oY29tcG9uZW50KSkgOiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGxlZ2FjeUlzTW91bnRlZCgpIHtcbiAgdmFyIGNvbXBvbmVudCA9IHRoaXMuX3JlYWN0SW50ZXJuYWxDb21wb25lbnQ7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdERPTUNvbXBvbmVudDogRG8gbm90IGFjY2VzcyAuaXNNb3VudGVkKCkgb2YgYSBET00gbm9kZS4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpKSA6IHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gISFjb21wb25lbnQ7XG59XG5cbmZ1bmN0aW9uIGxlZ2FjeVNldFN0YXRlRXRjKCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBjb21wb25lbnQgPSB0aGlzLl9yZWFjdEludGVybmFsQ29tcG9uZW50O1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3RET01Db21wb25lbnQ6IERvIG5vdCBhY2Nlc3MgLnNldFN0YXRlKCksIC5yZXBsYWNlU3RhdGUoKSwgb3IgJyArICcuZm9yY2VVcGRhdGUoKSBvZiBhIERPTSBub2RlLiBUaGlzIGlzIGEgbm8tb3AuJXMnLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oY29tcG9uZW50KSkgOiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGVnYWN5U2V0UHJvcHMocGFydGlhbFByb3BzLCBjYWxsYmFjaykge1xuICB2YXIgY29tcG9uZW50ID0gdGhpcy5fcmVhY3RJbnRlcm5hbENvbXBvbmVudDtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1JlYWN0RE9NQ29tcG9uZW50OiBEbyBub3QgYWNjZXNzIC5zZXRQcm9wcygpIG9mIGEgRE9NIG5vZGUuICcgKyAnSW5zdGVhZCwgY2FsbCBSZWFjdERPTS5yZW5kZXIgYWdhaW4gYXQgdGhlIHRvcCBsZXZlbC4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoIWNvbXBvbmVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVTZXRQcm9wc0ludGVybmFsKGNvbXBvbmVudCwgcGFydGlhbFByb3BzKTtcbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlQ2FsbGJhY2tJbnRlcm5hbChjb21wb25lbnQsIGNhbGxiYWNrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsZWdhY3lSZXBsYWNlUHJvcHMocGFydGlhbFByb3BzLCBjYWxsYmFjaykge1xuICB2YXIgY29tcG9uZW50ID0gdGhpcy5fcmVhY3RJbnRlcm5hbENvbXBvbmVudDtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1JlYWN0RE9NQ29tcG9uZW50OiBEbyBub3QgYWNjZXNzIC5yZXBsYWNlUHJvcHMoKSBvZiBhIERPTSBub2RlLiAnICsgJ0luc3RlYWQsIGNhbGwgUmVhY3RET00ucmVuZGVyIGFnYWluIGF0IHRoZSB0b3AgbGV2ZWwuJXMnLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oY29tcG9uZW50KSkgOiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKCFjb21wb25lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlUmVwbGFjZVByb3BzSW50ZXJuYWwoY29tcG9uZW50LCBwYXJ0aWFsUHJvcHMpO1xuICBpZiAoY2FsbGJhY2spIHtcbiAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVDYWxsYmFja0ludGVybmFsKGNvbXBvbmVudCwgY2FsbGJhY2spO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZyaWVuZGx5U3RyaW5naWZ5KG9iaikge1xuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICByZXR1cm4gJ1snICsgb2JqLm1hcChmcmllbmRseVN0cmluZ2lmeSkuam9pbignLCAnKSArICddJztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBhaXJzID0gW107XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgdmFyIGtleUVzY2FwZWQgPSAvXlthLXokX11bXFx3JF9dKiQvaS50ZXN0KGtleSkgPyBrZXkgOiBKU09OLnN0cmluZ2lmeShrZXkpO1xuICAgICAgICAgIHBhaXJzLnB1c2goa2V5RXNjYXBlZCArICc6ICcgKyBmcmllbmRseVN0cmluZ2lmeShvYmpba2V5XSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gJ3snICsgcGFpcnMuam9pbignLCAnKSArICd9JztcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuICdbZnVuY3Rpb24gb2JqZWN0XSc7XG4gIH1cbiAgLy8gRGlmZmVycyBmcm9tIEpTT04uc3RyaW5naWZ5IGluIHRoYXQgdW5kZWZpbmVkIGJlY2F1c2VzIHVuZGVmaW5lZCBhbmQgdGhhdFxuICAvLyBpbmYgYW5kIG5hbiBkb24ndCBiZWNvbWUgbnVsbFxuICByZXR1cm4gU3RyaW5nKG9iaik7XG59XG5cbnZhciBzdHlsZU11dGF0aW9uV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBjaGVja0FuZFdhcm5Gb3JNdXRhdGVkU3R5bGUoc3R5bGUxLCBzdHlsZTIsIGNvbXBvbmVudCkge1xuICBpZiAoc3R5bGUxID09IG51bGwgfHwgc3R5bGUyID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHNoYWxsb3dFcXVhbChzdHlsZTEsIHN0eWxlMikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudC5fdGFnO1xuICB2YXIgb3duZXIgPSBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgdmFyIG93bmVyTmFtZTtcbiAgaWYgKG93bmVyKSB7XG4gICAgb3duZXJOYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICB9XG5cbiAgdmFyIGhhc2ggPSBvd25lck5hbWUgKyAnfCcgKyBjb21wb25lbnROYW1lO1xuXG4gIGlmIChzdHlsZU11dGF0aW9uV2FybmluZy5oYXNPd25Qcm9wZXJ0eShoYXNoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN0eWxlTXV0YXRpb25XYXJuaW5nW2hhc2hdID0gdHJ1ZTtcblxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2Alc2Agd2FzIHBhc3NlZCBhIHN0eWxlIG9iamVjdCB0aGF0IGhhcyBwcmV2aW91c2x5IGJlZW4gbXV0YXRlZC4gJyArICdNdXRhdGluZyBgc3R5bGVgIGlzIGRlcHJlY2F0ZWQuIENvbnNpZGVyIGNsb25pbmcgaXQgYmVmb3JlaGFuZC4gQ2hlY2sgJyArICd0aGUgYHJlbmRlcmAgJXMuIFByZXZpb3VzIHN0eWxlOiAlcy4gTXV0YXRlZCBzdHlsZTogJXMuJywgY29tcG9uZW50TmFtZSwgb3duZXIgPyAnb2YgYCcgKyBvd25lck5hbWUgKyAnYCcgOiAndXNpbmcgPCcgKyBjb21wb25lbnROYW1lICsgJz4nLCBmcmllbmRseVN0cmluZ2lmeShzdHlsZTEpLCBmcmllbmRseVN0cmluZ2lmeShzdHlsZTIpKSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IHByb3BzXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFZhbGlkUHJvcHMoY29tcG9uZW50LCBwcm9wcykge1xuICBpZiAoIXByb3BzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIE5vdGUgdGhlIHVzZSBvZiBgPT1gIHdoaWNoIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWQuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKHZvaWRFbGVtZW50VGFnc1tjb21wb25lbnQuX3RhZ10pIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHByb3BzLmNoaWxkcmVuID09IG51bGwgJiYgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCwgJyVzIGlzIGEgdm9pZCBlbGVtZW50IHRhZyBhbmQgbXVzdCBub3QgaGF2ZSBgY2hpbGRyZW5gIG9yICcgKyAndXNlIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuJXMnLCBjb21wb25lbnQuX3RhZywgY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXIgPyAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICcgKyBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lci5nZXROYW1lKCkgKyAnLicgOiAnJykgOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIGlmIChwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPSBudWxsKSB7XG4gICAgIShwcm9wcy5jaGlsZHJlbiA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW4gb25seSBzZXQgb25lIG9mIGBjaGlsZHJlbmAgb3IgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgISh0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT09ICdvYmplY3QnICYmIEhUTUwgaW4gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2Bwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAgbXVzdCBiZSBpbiB0aGUgZm9ybSBge19faHRtbDogLi4ufWAuICcgKyAnUGxlYXNlIHZpc2l0IGh0dHBzOi8vZmIubWUvcmVhY3QtaW52YXJpYW50LWRhbmdlcm91c2x5LXNldC1pbm5lci1odG1sICcgKyAnZm9yIG1vcmUgaW5mb3JtYXRpb24uJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHJvcHMuaW5uZXJIVE1MID09IG51bGwsICdEaXJlY3RseSBzZXR0aW5nIHByb3BlcnR5IGBpbm5lckhUTUxgIGlzIG5vdCBwZXJtaXR0ZWQuICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIGxvb2t1cCBkb2N1bWVudGF0aW9uIG9uIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJykgOiB1bmRlZmluZWQ7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIXByb3BzLmNvbnRlbnRFZGl0YWJsZSB8fCBwcm9wcy5jaGlsZHJlbiA9PSBudWxsLCAnQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSAnICsgJ1JlYWN0LiBJdCBpcyBub3cgeW91ciByZXNwb25zaWJpbGl0eSB0byBndWFyYW50ZWUgdGhhdCBub25lIG9mICcgKyAndGhvc2Ugbm9kZXMgYXJlIHVuZXhwZWN0ZWRseSBtb2RpZmllZCBvciBkdXBsaWNhdGVkLiBUaGlzIGlzICcgKyAncHJvYmFibHkgbm90IGludGVudGlvbmFsLicpIDogdW5kZWZpbmVkO1xuICB9XG4gICEocHJvcHMuc3R5bGUgPT0gbnVsbCB8fCB0eXBlb2YgcHJvcHMuc3R5bGUgPT09ICdvYmplY3QnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGUgYHN0eWxlYCBwcm9wIGV4cGVjdHMgYSBtYXBwaW5nIGZyb20gc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMsICcgKyAnbm90IGEgc3RyaW5nLiBGb3IgZXhhbXBsZSwgc3R5bGU9e3ttYXJnaW5SaWdodDogc3BhY2luZyArIFxcJ2VtXFwnfX0gd2hlbiAnICsgJ3VzaW5nIEpTWC4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGVucXVldWVQdXRMaXN0ZW5lcihpZCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIsIHRyYW5zYWN0aW9uKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gSUU4IGhhcyBubyBBUEkgZm9yIGV2ZW50IGNhcHR1cmluZyBhbmQgdGhlIGBvblNjcm9sbGAgZXZlbnQgZG9lc24ndFxuICAgIC8vIGJ1YmJsZS5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhyZWdpc3RyYXRpb25OYW1lICE9PSAnb25TY3JvbGwnIHx8IGlzRXZlbnRTdXBwb3J0ZWQoJ3Njcm9sbCcsIHRydWUpLCAnVGhpcyBicm93c2VyIGRvZXNuXFwndCBzdXBwb3J0IHRoZSBgb25TY3JvbGxgIGV2ZW50JykgOiB1bmRlZmluZWQ7XG4gIH1cbiAgdmFyIGNvbnRhaW5lciA9IFJlYWN0TW91bnQuZmluZFJlYWN0Q29udGFpbmVyRm9ySUQoaWQpO1xuICBpZiAoY29udGFpbmVyKSB7XG4gICAgdmFyIGRvYyA9IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUgPyBjb250YWluZXIub3duZXJEb2N1bWVudCA6IGNvbnRhaW5lcjtcbiAgICBsaXN0ZW5UbyhyZWdpc3RyYXRpb25OYW1lLCBkb2MpO1xuICB9XG4gIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUocHV0TGlzdGVuZXIsIHtcbiAgICBpZDogaWQsXG4gICAgcmVnaXN0cmF0aW9uTmFtZTogcmVnaXN0cmF0aW9uTmFtZSxcbiAgICBsaXN0ZW5lcjogbGlzdGVuZXJcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHB1dExpc3RlbmVyKCkge1xuICB2YXIgbGlzdGVuZXJUb1B1dCA9IHRoaXM7XG4gIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5wdXRMaXN0ZW5lcihsaXN0ZW5lclRvUHV0LmlkLCBsaXN0ZW5lclRvUHV0LnJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyVG9QdXQubGlzdGVuZXIpO1xufVxuXG4vLyBUaGVyZSBhcmUgc28gbWFueSBtZWRpYSBldmVudHMsIGl0IG1ha2VzIHNlbnNlIHRvIGp1c3Rcbi8vIG1haW50YWluIGEgbGlzdCByYXRoZXIgdGhhbiBjcmVhdGUgYSBgdHJhcEJ1YmJsZWRFdmVudGAgZm9yIGVhY2hcbnZhciBtZWRpYUV2ZW50cyA9IHtcbiAgdG9wQWJvcnQ6ICdhYm9ydCcsXG4gIHRvcENhblBsYXk6ICdjYW5wbGF5JyxcbiAgdG9wQ2FuUGxheVRocm91Z2g6ICdjYW5wbGF5dGhyb3VnaCcsXG4gIHRvcER1cmF0aW9uQ2hhbmdlOiAnZHVyYXRpb25jaGFuZ2UnLFxuICB0b3BFbXB0aWVkOiAnZW1wdGllZCcsXG4gIHRvcEVuY3J5cHRlZDogJ2VuY3J5cHRlZCcsXG4gIHRvcEVuZGVkOiAnZW5kZWQnLFxuICB0b3BFcnJvcjogJ2Vycm9yJyxcbiAgdG9wTG9hZGVkRGF0YTogJ2xvYWRlZGRhdGEnLFxuICB0b3BMb2FkZWRNZXRhZGF0YTogJ2xvYWRlZG1ldGFkYXRhJyxcbiAgdG9wTG9hZFN0YXJ0OiAnbG9hZHN0YXJ0JyxcbiAgdG9wUGF1c2U6ICdwYXVzZScsXG4gIHRvcFBsYXk6ICdwbGF5JyxcbiAgdG9wUGxheWluZzogJ3BsYXlpbmcnLFxuICB0b3BQcm9ncmVzczogJ3Byb2dyZXNzJyxcbiAgdG9wUmF0ZUNoYW5nZTogJ3JhdGVjaGFuZ2UnLFxuICB0b3BTZWVrZWQ6ICdzZWVrZWQnLFxuICB0b3BTZWVraW5nOiAnc2Vla2luZycsXG4gIHRvcFN0YWxsZWQ6ICdzdGFsbGVkJyxcbiAgdG9wU3VzcGVuZDogJ3N1c3BlbmQnLFxuICB0b3BUaW1lVXBkYXRlOiAndGltZXVwZGF0ZScsXG4gIHRvcFZvbHVtZUNoYW5nZTogJ3ZvbHVtZWNoYW5nZScsXG4gIHRvcFdhaXRpbmc6ICd3YWl0aW5nJ1xufTtcblxuZnVuY3Rpb24gdHJhcEJ1YmJsZWRFdmVudHNMb2NhbCgpIHtcbiAgdmFyIGluc3QgPSB0aGlzO1xuICAvLyBJZiBhIGNvbXBvbmVudCByZW5kZXJzIHRvIG51bGwgb3IgaWYgYW5vdGhlciBjb21wb25lbnQgZmF0YWxzIGFuZCBjYXVzZXNcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSB0cmVlIHRvIGJlIGNvcnJ1cHRlZCwgYG5vZGVgIGhlcmUgY2FuIGJlIG51bGwuXG4gICFpbnN0Ll9yb290Tm9kZUlEID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ011c3QgYmUgbW91bnRlZCB0byB0cmFwIGV2ZW50cycpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgdmFyIG5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUoaW5zdC5fcm9vdE5vZGVJRCk7XG4gICFub2RlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RyYXBCdWJibGVkRXZlbnQoLi4uKTogUmVxdWlyZXMgbm9kZSB0byBiZSByZW5kZXJlZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgc3dpdGNoIChpbnN0Ll90YWcpIHtcbiAgICBjYXNlICdpZnJhbWUnOlxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcExvYWQsICdsb2FkJywgbm9kZSldO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndmlkZW8nOlxuICAgIGNhc2UgJ2F1ZGlvJzpcblxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtdO1xuICAgICAgLy8gY3JlYXRlIGxpc3RlbmVyIGZvciBlYWNoIG1lZGlhIGV2ZW50XG4gICAgICBmb3IgKHZhciBldmVudCBpbiBtZWRpYUV2ZW50cykge1xuICAgICAgICBpZiAobWVkaWFFdmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XG4gICAgICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycy5wdXNoKFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXNbZXZlbnRdLCBtZWRpYUV2ZW50c1tldmVudF0sIG5vZGUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbWcnOlxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcEVycm9yLCAnZXJyb3InLCBub2RlKSwgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcy50b3BMb2FkLCAnbG9hZCcsIG5vZGUpXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcFJlc2V0LCAncmVzZXQnLCBub2RlKSwgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcy50b3BTdWJtaXQsICdzdWJtaXQnLCBub2RlKV07XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBtb3VudFJlYWR5SW5wdXRXcmFwcGVyKCkge1xuICBSZWFjdERPTUlucHV0Lm1vdW50UmVhZHlXcmFwcGVyKHRoaXMpO1xufVxuXG5mdW5jdGlvbiBwb3N0VXBkYXRlU2VsZWN0V3JhcHBlcigpIHtcbiAgUmVhY3RET01TZWxlY3QucG9zdFVwZGF0ZVdyYXBwZXIodGhpcyk7XG59XG5cbi8vIEZvciBIVE1MLCBjZXJ0YWluIHRhZ3Mgc2hvdWxkIG9taXQgdGhlaXIgY2xvc2UgdGFnLiBXZSBrZWVwIGEgd2hpdGVsaXN0IGZvclxuLy8gdGhvc2Ugc3BlY2lhbCBjYXNlZCB0YWdzLlxuXG52YXIgb21pdHRlZENsb3NlVGFncyA9IHtcbiAgJ2FyZWEnOiB0cnVlLFxuICAnYmFzZSc6IHRydWUsXG4gICdicic6IHRydWUsXG4gICdjb2wnOiB0cnVlLFxuICAnZW1iZWQnOiB0cnVlLFxuICAnaHInOiB0cnVlLFxuICAnaW1nJzogdHJ1ZSxcbiAgJ2lucHV0JzogdHJ1ZSxcbiAgJ2tleWdlbic6IHRydWUsXG4gICdsaW5rJzogdHJ1ZSxcbiAgJ21ldGEnOiB0cnVlLFxuICAncGFyYW0nOiB0cnVlLFxuICAnc291cmNlJzogdHJ1ZSxcbiAgJ3RyYWNrJzogdHJ1ZSxcbiAgJ3dicic6IHRydWVcbn07XG5cbi8vIE5PVEU6IG1lbnVpdGVtJ3MgY2xvc2UgdGFnIHNob3VsZCBiZSBvbWl0dGVkLCBidXQgdGhhdCBjYXVzZXMgcHJvYmxlbXMuXG52YXIgbmV3bGluZUVhdGluZ1RhZ3MgPSB7XG4gICdsaXN0aW5nJzogdHJ1ZSxcbiAgJ3ByZSc6IHRydWUsXG4gICd0ZXh0YXJlYSc6IHRydWVcbn07XG5cbi8vIEZvciBIVE1MLCBjZXJ0YWluIHRhZ3MgY2Fubm90IGhhdmUgY2hpbGRyZW4uIFRoaXMgaGFzIHRoZSBzYW1lIHB1cnBvc2UgYXNcbi8vIGBvbWl0dGVkQ2xvc2VUYWdzYCBleGNlcHQgdGhhdCBgbWVudWl0ZW1gIHNob3VsZCBzdGlsbCBoYXZlIGl0cyBjbG9zaW5nIHRhZy5cblxudmFyIHZvaWRFbGVtZW50VGFncyA9IGFzc2lnbih7XG4gICdtZW51aXRlbSc6IHRydWVcbn0sIG9taXR0ZWRDbG9zZVRhZ3MpO1xuXG4vLyBXZSBhY2NlcHQgYW55IHRhZyB0byBiZSByZW5kZXJlZCBidXQgc2luY2UgdGhpcyBnZXRzIGluamVjdGVkIGludG8gYXJiaXRyYXJ5XG4vLyBIVE1MLCB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB0aGF0IGl0J3MgYSBzYWZlIHRhZy5cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1JFQy14bWwvI05ULU5hbWVcblxudmFyIFZBTElEX1RBR19SRUdFWCA9IC9eW2EtekEtWl1bYS16QS1aOl9cXC5cXC1cXGRdKiQvOyAvLyBTaW1wbGlmaWVkIHN1YnNldFxudmFyIHZhbGlkYXRlZFRhZ0NhY2hlID0ge307XG52YXIgaGFzT3duUHJvcGVydHkgPSAoe30pLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZURhbmdlcm91c1RhZyh0YWcpIHtcbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbGlkYXRlZFRhZ0NhY2hlLCB0YWcpKSB7XG4gICAgIVZBTElEX1RBR19SRUdFWC50ZXN0KHRhZykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCB0YWc6ICVzJywgdGFnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgdmFsaWRhdGVkVGFnQ2FjaGVbdGFnXSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0NoaWxkQ29udGV4dERldihjb250ZXh0LCBpbnN0KSB7XG4gIC8vIFBhc3MgZG93biBvdXIgdGFnIG5hbWUgdG8gY2hpbGQgY29tcG9uZW50cyBmb3IgdmFsaWRhdGlvbiBwdXJwb3Nlc1xuICBjb250ZXh0ID0gYXNzaWduKHt9LCBjb250ZXh0KTtcbiAgdmFyIGluZm8gPSBjb250ZXh0W3ZhbGlkYXRlRE9NTmVzdGluZy5hbmNlc3RvckluZm9Db250ZXh0S2V5XTtcbiAgY29udGV4dFt2YWxpZGF0ZURPTU5lc3RpbmcuYW5jZXN0b3JJbmZvQ29udGV4dEtleV0gPSB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyhpbmZvLCBpbnN0Ll90YWcsIGluc3QpO1xuICByZXR1cm4gY29udGV4dDtcbn1cblxuZnVuY3Rpb24gaXNDdXN0b21Db21wb25lbnQodGFnTmFtZSwgcHJvcHMpIHtcbiAgcmV0dXJuIHRhZ05hbWUuaW5kZXhPZignLScpID49IDAgfHwgcHJvcHMuaXMgIT0gbnVsbDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFJlYWN0IGNsYXNzIHRoYXQgaXMgaWRlbXBvdGVudCBhbmQgY2FwYWJsZSBvZiBjb250YWluaW5nIG90aGVyXG4gKiBSZWFjdCBjb21wb25lbnRzLiBJdCBhY2NlcHRzIGV2ZW50IGxpc3RlbmVycyBhbmQgRE9NIHByb3BlcnRpZXMgdGhhdCBhcmVcbiAqIHZhbGlkIGFjY29yZGluZyB0byBgRE9NUHJvcGVydHlgLlxuICpcbiAqICAtIEV2ZW50IGxpc3RlbmVyczogYG9uQ2xpY2tgLCBgb25Nb3VzZURvd25gLCBldGMuXG4gKiAgLSBET00gcHJvcGVydGllczogYGNsYXNzTmFtZWAsIGBuYW1lYCwgYHRpdGxlYCwgZXRjLlxuICpcbiAqIFRoZSBgc3R5bGVgIHByb3BlcnR5IGZ1bmN0aW9ucyBkaWZmZXJlbnRseSBmcm9tIHRoZSBET00gQVBJLiBJdCBhY2NlcHRzIGFuXG4gKiBvYmplY3QgbWFwcGluZyBvZiBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcy5cbiAqXG4gKiBAY29uc3RydWN0b3IgUmVhY3RET01Db21wb25lbnRcbiAqIEBleHRlbmRzIFJlYWN0TXVsdGlDaGlsZFxuICovXG5mdW5jdGlvbiBSZWFjdERPTUNvbXBvbmVudCh0YWcpIHtcbiAgdmFsaWRhdGVEYW5nZXJvdXNUYWcodGFnKTtcbiAgdGhpcy5fdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gIHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW4gPSBudWxsO1xuICB0aGlzLl9wcmV2aW91c1N0eWxlID0gbnVsbDtcbiAgdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBudWxsO1xuICB0aGlzLl9yb290Tm9kZUlEID0gbnVsbDtcbiAgdGhpcy5fd3JhcHBlclN0YXRlID0gbnVsbDtcbiAgdGhpcy5fdG9wTGV2ZWxXcmFwcGVyID0gbnVsbDtcbiAgdGhpcy5fbm9kZVdpdGhMZWdhY3lQcm9wZXJ0aWVzID0gbnVsbDtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB0aGlzLl91bnByb2Nlc3NlZENvbnRleHREZXYgPSBudWxsO1xuICAgIHRoaXMuX3Byb2Nlc3NlZENvbnRleHREZXYgPSBudWxsO1xuICB9XG59XG5cblJlYWN0RE9NQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ1JlYWN0RE9NQ29tcG9uZW50JztcblxuUmVhY3RET01Db21wb25lbnQuTWl4aW4gPSB7XG5cbiAgY29uc3RydWN0OiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gZWxlbWVudDtcbiAgfSxcblxuICAvKipcbiAgICogR2VuZXJhdGVzIHJvb3QgdGFnIG1hcmt1cCB0aGVuIHJlY3Vyc2VzLiBUaGlzIG1ldGhvZCBoYXMgc2lkZSBlZmZlY3RzIGFuZFxuICAgKiBpcyBub3QgaWRlbXBvdGVudC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb290SUQgVGhlIHJvb3QgRE9NIElEIGZvciB0aGlzIG5vZGUuXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjb21wdXRlZCBtYXJrdXAuXG4gICAqL1xuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gcm9vdElEO1xuXG4gICAgdmFyIHByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xuICAgICAgY2FzZSAnaWZyYW1lJzpcbiAgICAgIGNhc2UgJ2ltZyc6XG4gICAgICBjYXNlICdmb3JtJzpcbiAgICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgICAgdGhpcy5fd3JhcHBlclN0YXRlID0ge1xuICAgICAgICAgIGxpc3RlbmVyczogbnVsbFxuICAgICAgICB9O1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHRyYXBCdWJibGVkRXZlbnRzTG9jYWwsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgICAgIHByb3BzID0gUmVhY3RET01CdXR0b24uZ2V0TmF0aXZlUHJvcHModGhpcywgcHJvcHMsIGNvbnRleHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgUmVhY3RET01JbnB1dC5tb3VudFdyYXBwZXIodGhpcywgcHJvcHMsIGNvbnRleHQpO1xuICAgICAgICBwcm9wcyA9IFJlYWN0RE9NSW5wdXQuZ2V0TmF0aXZlUHJvcHModGhpcywgcHJvcHMsIGNvbnRleHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIFJlYWN0RE9NT3B0aW9uLm1vdW50V3JhcHBlcih0aGlzLCBwcm9wcywgY29udGV4dCk7XG4gICAgICAgIHByb3BzID0gUmVhY3RET01PcHRpb24uZ2V0TmF0aXZlUHJvcHModGhpcywgcHJvcHMsIGNvbnRleHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIFJlYWN0RE9NU2VsZWN0Lm1vdW50V3JhcHBlcih0aGlzLCBwcm9wcywgY29udGV4dCk7XG4gICAgICAgIHByb3BzID0gUmVhY3RET01TZWxlY3QuZ2V0TmF0aXZlUHJvcHModGhpcywgcHJvcHMsIGNvbnRleHQpO1xuICAgICAgICBjb250ZXh0ID0gUmVhY3RET01TZWxlY3QucHJvY2Vzc0NoaWxkQ29udGV4dCh0aGlzLCBwcm9wcywgY29udGV4dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICBSZWFjdERPTVRleHRhcmVhLm1vdW50V3JhcHBlcih0aGlzLCBwcm9wcywgY29udGV4dCk7XG4gICAgICAgIHByb3BzID0gUmVhY3RET01UZXh0YXJlYS5nZXROYXRpdmVQcm9wcyh0aGlzLCBwcm9wcywgY29udGV4dCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGFzc2VydFZhbGlkUHJvcHModGhpcywgcHJvcHMpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoY29udGV4dFt2YWxpZGF0ZURPTU5lc3RpbmcuYW5jZXN0b3JJbmZvQ29udGV4dEtleV0pIHtcbiAgICAgICAgdmFsaWRhdGVET01OZXN0aW5nKHRoaXMuX3RhZywgdGhpcywgY29udGV4dFt2YWxpZGF0ZURPTU5lc3RpbmcuYW5jZXN0b3JJbmZvQ29udGV4dEtleV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB0aGlzLl91bnByb2Nlc3NlZENvbnRleHREZXYgPSBjb250ZXh0O1xuICAgICAgdGhpcy5fcHJvY2Vzc2VkQ29udGV4dERldiA9IHByb2Nlc3NDaGlsZENvbnRleHREZXYoY29udGV4dCwgdGhpcyk7XG4gICAgICBjb250ZXh0ID0gdGhpcy5fcHJvY2Vzc2VkQ29udGV4dERldjtcbiAgICB9XG5cbiAgICB2YXIgbW91bnRJbWFnZTtcbiAgICBpZiAodHJhbnNhY3Rpb24udXNlQ3JlYXRlRWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyRG9jdW1lbnQgPSBjb250ZXh0W1JlYWN0TW91bnQub3duZXJEb2N1bWVudENvbnRleHRLZXldO1xuICAgICAgdmFyIGVsID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGUpO1xuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldEF0dHJpYnV0ZUZvcklEKGVsLCB0aGlzLl9yb290Tm9kZUlEKTtcbiAgICAgIC8vIFBvcHVsYXRlIG5vZGUgY2FjaGVcbiAgICAgIFJlYWN0TW91bnQuZ2V0SUQoZWwpO1xuICAgICAgdGhpcy5fdXBkYXRlRE9NUHJvcGVydGllcyh7fSwgcHJvcHMsIHRyYW5zYWN0aW9uLCBlbCk7XG4gICAgICB0aGlzLl9jcmVhdGVJbml0aWFsQ2hpbGRyZW4odHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0LCBlbCk7XG4gICAgICBtb3VudEltYWdlID0gZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0YWdPcGVuID0gdGhpcy5fY3JlYXRlT3BlblRhZ01hcmt1cEFuZFB1dExpc3RlbmVycyh0cmFuc2FjdGlvbiwgcHJvcHMpO1xuICAgICAgdmFyIHRhZ0NvbnRlbnQgPSB0aGlzLl9jcmVhdGVDb250ZW50TWFya3VwKHRyYW5zYWN0aW9uLCBwcm9wcywgY29udGV4dCk7XG4gICAgICBpZiAoIXRhZ0NvbnRlbnQgJiYgb21pdHRlZENsb3NlVGFnc1t0aGlzLl90YWddKSB7XG4gICAgICAgIG1vdW50SW1hZ2UgPSB0YWdPcGVuICsgJy8+JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vdW50SW1hZ2UgPSB0YWdPcGVuICsgJz4nICsgdGFnQ29udGVudCArICc8LycgKyB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlICsgJz4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XG4gICAgICBjYXNlICdpbnB1dCc6XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUobW91bnRSZWFkeUlucHV0V3JhcHBlciwgdGhpcyk7XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgICAgaWYgKHByb3BzLmF1dG9Gb2N1cykge1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoQXV0b0ZvY3VzVXRpbHMuZm9jdXNET01Db21wb25lbnQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBtb3VudEltYWdlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgdGhlIG9wZW4gdGFnIGFuZCBhbGwgYXR0cmlidXRlcy5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaGFzIHNpZGUgZWZmZWN0cyBiZWNhdXNlIGV2ZW50cyBnZXQgcmVnaXN0ZXJlZC5cbiAgICpcbiAgICogSXRlcmF0aW5nIG92ZXIgb2JqZWN0IHByb3BlcnRpZXMgaXMgZmFzdGVyIHRoYW4gaXRlcmF0aW5nIG92ZXIgYXJyYXlzLlxuICAgKiBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL29iai12cy1hcnItaXRlcmF0aW9uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgb2Ygb3BlbmluZyB0YWcuXG4gICAqL1xuICBfY3JlYXRlT3BlblRhZ01hcmt1cEFuZFB1dExpc3RlbmVyczogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcm9wcykge1xuICAgIHZhciByZXQgPSAnPCcgKyB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuXG4gICAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBpZiAocHJvcFZhbHVlKSB7XG4gICAgICAgICAgZW5xdWV1ZVB1dExpc3RlbmVyKHRoaXMuX3Jvb3ROb2RlSUQsIHByb3BLZXksIHByb3BWYWx1ZSwgdHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgICBpZiAocHJvcFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAvLyBTZWUgYF91cGRhdGVET01Qcm9wZXJ0aWVzYC4gc3R5bGUgYmxvY2tcbiAgICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNTdHlsZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb3BWYWx1ZSA9IHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gYXNzaWduKHt9LCBwcm9wcy5zdHlsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByb3BWYWx1ZSA9IENTU1Byb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JTdHlsZXMocHJvcFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWFya3VwID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX3RhZyAhPSBudWxsICYmIGlzQ3VzdG9tQ29tcG9uZW50KHRoaXMuX3RhZywgcHJvcHMpKSB7XG4gICAgICAgICAgaWYgKHByb3BLZXkgIT09IENISUxEUkVOKSB7XG4gICAgICAgICAgICBtYXJrdXAgPSBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9yQ3VzdG9tQXR0cmlidXRlKHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hcmt1cCA9IERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JQcm9wZXJ0eShwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrdXApIHtcbiAgICAgICAgICByZXQgKz0gJyAnICsgbWFya3VwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRm9yIHN0YXRpYyBwYWdlcywgbm8gbmVlZCB0byBwdXQgUmVhY3QgSUQgYW5kIGNoZWNrc3VtLiBTYXZlcyBsb3RzIG9mXG4gICAgLy8gYnl0ZXMuXG4gICAgaWYgKHRyYW5zYWN0aW9uLnJlbmRlclRvU3RhdGljTWFya3VwKSB7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIHZhciBtYXJrdXBGb3JJRCA9IERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JJRCh0aGlzLl9yb290Tm9kZUlEKTtcbiAgICByZXR1cm4gcmV0ICsgJyAnICsgbWFya3VwRm9ySUQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciB0aGUgY29udGVudCBiZXR3ZWVuIHRoZSB0YWdzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4ge3N0cmluZ30gQ29udGVudCBtYXJrdXAuXG4gICAqL1xuICBfY3JlYXRlQ29udGVudE1hcmt1cDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcm9wcywgY29udGV4dCkge1xuICAgIHZhciByZXQgPSAnJztcblxuICAgIC8vIEludGVudGlvbmFsIHVzZSBvZiAhPSB0byBhdm9pZCBjYXRjaGluZyB6ZXJvL2ZhbHNlLlxuICAgIHZhciBpbm5lckhUTUwgPSBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcbiAgICBpZiAoaW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICAgIGlmIChpbm5lckhUTUwuX19odG1sICE9IG51bGwpIHtcbiAgICAgICAgcmV0ID0gaW5uZXJIVE1MLl9faHRtbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNvbnRlbnRUb1VzZSA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIHByb3BzLmNoaWxkcmVuXSA/IHByb3BzLmNoaWxkcmVuIDogbnVsbDtcbiAgICAgIHZhciBjaGlsZHJlblRvVXNlID0gY29udGVudFRvVXNlICE9IG51bGwgPyBudWxsIDogcHJvcHMuY2hpbGRyZW47XG4gICAgICBpZiAoY29udGVudFRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVmFsaWRhdGUgdGhhdCB0ZXh0IGlzIGFsbG93ZWQgYXMgYSBjaGlsZCBvZiB0aGlzIG5vZGVcbiAgICAgICAgcmV0ID0gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKGNvbnRlbnRUb1VzZSk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkcmVuVG9Vc2UgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbW91bnRJbWFnZXMgPSB0aGlzLm1vdW50Q2hpbGRyZW4oY2hpbGRyZW5Ub1VzZSwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICByZXQgPSBtb3VudEltYWdlcy5qb2luKCcnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5ld2xpbmVFYXRpbmdUYWdzW3RoaXMuX3RhZ10gJiYgcmV0LmNoYXJBdCgwKSA9PT0gJ1xcbicpIHtcbiAgICAgIC8vIHRleHQvaHRtbCBpZ25vcmVzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gdGhlc2UgdGFncyBpZiBpdCdzIGEgbmV3bGluZVxuICAgICAgLy8gUHJlZmVyIHRvIGJyZWFrIGFwcGxpY2F0aW9uL3htbCBvdmVyIHRleHQvaHRtbCAoZm9yIG5vdykgYnkgYWRkaW5nXG4gICAgICAvLyBhIG5ld2xpbmUgc3BlY2lmaWNhbGx5IHRvIGdldCBlYXRlbiBieSB0aGUgcGFyc2VyLiAoQWx0ZXJuYXRlbHkgZm9yXG4gICAgICAvLyB0ZXh0YXJlYXMsIHJlcGxhY2luZyBcIl5cXG5cIiB3aXRoIFwiXFxyXFxuXCIgZG9lc24ndCBnZXQgZWF0ZW4sIGFuZCB0aGUgZmlyc3RcbiAgICAgIC8vIFxcciBpcyBub3JtYWxpemVkIG91dCBieSBIVE1MVGV4dEFyZWFFbGVtZW50I3ZhbHVlLilcbiAgICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWwtcG9seWdsb3QvI25ld2xpbmVzLWluLXRleHRhcmVhLWFuZC1wcmU+XG4gICAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNlbGVtZW50LXJlc3RyaWN0aW9ucz5cbiAgICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI25ld2xpbmVzPlxuICAgICAgLy8gU2VlOiBQYXJzaW5nIG9mIFwidGV4dGFyZWFcIiBcImxpc3RpbmdcIiBhbmQgXCJwcmVcIiBlbGVtZW50c1xuICAgICAgLy8gIGZyb20gPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHk+XG4gICAgICByZXR1cm4gJ1xcbicgKyByZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LFxuXG4gIF9jcmVhdGVJbml0aWFsQ2hpbGRyZW46IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJvcHMsIGNvbnRleHQsIGVsKSB7XG4gICAgLy8gSW50ZW50aW9uYWwgdXNlIG9mICE9IHRvIGF2b2lkIGNhdGNoaW5nIHplcm8vZmFsc2UuXG4gICAgdmFyIGlubmVySFRNTCA9IHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MO1xuICAgIGlmIChpbm5lckhUTUwgIT0gbnVsbCkge1xuICAgICAgaWYgKGlubmVySFRNTC5fX2h0bWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRJbm5lckhUTUwoZWwsIGlubmVySFRNTC5fX2h0bWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29udGVudFRvVXNlID0gQ09OVEVOVF9UWVBFU1t0eXBlb2YgcHJvcHMuY2hpbGRyZW5dID8gcHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuICAgICAgdmFyIGNoaWxkcmVuVG9Vc2UgPSBjb250ZW50VG9Vc2UgIT0gbnVsbCA/IG51bGwgOiBwcm9wcy5jaGlsZHJlbjtcbiAgICAgIGlmIChjb250ZW50VG9Vc2UgIT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBWYWxpZGF0ZSB0aGF0IHRleHQgaXMgYWxsb3dlZCBhcyBhIGNoaWxkIG9mIHRoaXMgbm9kZVxuICAgICAgICBzZXRUZXh0Q29udGVudChlbCwgY29udGVudFRvVXNlKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGRyZW5Ub1VzZSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBtb3VudEltYWdlcyA9IHRoaXMubW91bnRDaGlsZHJlbihjaGlsZHJlblRvVXNlLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbW91bnRJbWFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBlbC5hcHBlbmRDaGlsZChtb3VudEltYWdlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlY2VpdmVzIGEgbmV4dCBlbGVtZW50IGFuZCB1cGRhdGVzIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnRcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqL1xuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAobmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIHByZXZFbGVtZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQ7XG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBuZXh0RWxlbWVudDtcbiAgICB0aGlzLnVwZGF0ZUNvbXBvbmVudCh0cmFuc2FjdGlvbiwgcHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBjb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyBhIG5hdGl2ZSBET00gY29tcG9uZW50IGFmdGVyIGl0IGhhcyBhbHJlYWR5IGJlZW4gYWxsb2NhdGVkIGFuZFxuICAgKiBhdHRhY2hlZCB0byB0aGUgRE9NLiBSZWNvbmNpbGVzIHRoZSByb290IERPTSBub2RlLCB0aGVuIHJlY3Vyc2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBwcmV2RWxlbWVudFxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnRcbiAgICogQGludGVybmFsXG4gICAqIEBvdmVycmlkYWJsZVxuICAgKi9cbiAgdXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCwgY29udGV4dCkge1xuICAgIHZhciBsYXN0UHJvcHMgPSBwcmV2RWxlbWVudC5wcm9wcztcbiAgICB2YXIgbmV4dFByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgbGFzdFByb3BzID0gUmVhY3RET01CdXR0b24uZ2V0TmF0aXZlUHJvcHModGhpcywgbGFzdFByb3BzKTtcbiAgICAgICAgbmV4dFByb3BzID0gUmVhY3RET01CdXR0b24uZ2V0TmF0aXZlUHJvcHModGhpcywgbmV4dFByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpbnB1dCc6XG4gICAgICAgIFJlYWN0RE9NSW5wdXQudXBkYXRlV3JhcHBlcih0aGlzKTtcbiAgICAgICAgbGFzdFByb3BzID0gUmVhY3RET01JbnB1dC5nZXROYXRpdmVQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTUlucHV0LmdldE5hdGl2ZVByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgbGFzdFByb3BzID0gUmVhY3RET01PcHRpb24uZ2V0TmF0aXZlUHJvcHModGhpcywgbGFzdFByb3BzKTtcbiAgICAgICAgbmV4dFByb3BzID0gUmVhY3RET01PcHRpb24uZ2V0TmF0aXZlUHJvcHModGhpcywgbmV4dFByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTVNlbGVjdC5nZXROYXRpdmVQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTVNlbGVjdC5nZXROYXRpdmVQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgICAgUmVhY3RET01UZXh0YXJlYS51cGRhdGVXcmFwcGVyKHRoaXMpO1xuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTVRleHRhcmVhLmdldE5hdGl2ZVByb3BzKHRoaXMsIGxhc3RQcm9wcyk7XG4gICAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NVGV4dGFyZWEuZ2V0TmF0aXZlUHJvcHModGhpcywgbmV4dFByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIElmIHRoZSBjb250ZXh0IGlzIHJlZmVyZW5jZS1lcXVhbCB0byB0aGUgb2xkIG9uZSwgcGFzcyBkb3duIHRoZSBzYW1lXG4gICAgICAvLyBwcm9jZXNzZWQgb2JqZWN0IHNvIHRoZSB1cGRhdGUgYmFpbG91dCBpbiBSZWFjdFJlY29uY2lsZXIgYmVoYXZlc1xuICAgICAgLy8gY29ycmVjdGx5IChhbmQgaWRlbnRpY2FsbHkgaW4gZGV2IGFuZCBwcm9kKS4gU2VlICM1MDA1LlxuICAgICAgaWYgKHRoaXMuX3VucHJvY2Vzc2VkQ29udGV4dERldiAhPT0gY29udGV4dCkge1xuICAgICAgICB0aGlzLl91bnByb2Nlc3NlZENvbnRleHREZXYgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLl9wcm9jZXNzZWRDb250ZXh0RGV2ID0gcHJvY2Vzc0NoaWxkQ29udGV4dERldihjb250ZXh0LCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQgPSB0aGlzLl9wcm9jZXNzZWRDb250ZXh0RGV2O1xuICAgIH1cblxuICAgIGFzc2VydFZhbGlkUHJvcHModGhpcywgbmV4dFByb3BzKTtcbiAgICB0aGlzLl91cGRhdGVET01Qcm9wZXJ0aWVzKGxhc3RQcm9wcywgbmV4dFByb3BzLCB0cmFuc2FjdGlvbiwgbnVsbCk7XG4gICAgdGhpcy5fdXBkYXRlRE9NQ2hpbGRyZW4obGFzdFByb3BzLCBuZXh0UHJvcHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcblxuICAgIGlmICghY2FuRGVmaW5lUHJvcGVydHkgJiYgdGhpcy5fbm9kZVdpdGhMZWdhY3lQcm9wZXJ0aWVzKSB7XG4gICAgICB0aGlzLl9ub2RlV2l0aExlZ2FjeVByb3BlcnRpZXMucHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3RhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIC8vIDxzZWxlY3Q+IHZhbHVlIHVwZGF0ZSBuZWVkcyB0byBvY2N1ciBhZnRlciA8b3B0aW9uPiBjaGlsZHJlblxuICAgICAgLy8gcmVjb25jaWxpYXRpb25cbiAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUocG9zdFVwZGF0ZVNlbGVjdFdyYXBwZXIsIHRoaXMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVjb25jaWxlcyB0aGUgcHJvcGVydGllcyBieSBkZXRlY3RpbmcgZGlmZmVyZW5jZXMgaW4gcHJvcGVydHkgdmFsdWVzIGFuZFxuICAgKiB1cGRhdGluZyB0aGUgRE9NIGFzIG5lY2Vzc2FyeS4gVGhpcyBmdW5jdGlvbiBpcyBwcm9iYWJseSB0aGUgc2luZ2xlIG1vc3RcbiAgICogY3JpdGljYWwgcGF0aCBmb3IgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uLlxuICAgKlxuICAgKiBUT0RPOiBCZW5jaG1hcmsgd2hldGhlciBjaGVja2luZyBmb3IgY2hhbmdlZCB2YWx1ZXMgaW4gbWVtb3J5IGFjdHVhbGx5XG4gICAqICAgICAgIGltcHJvdmVzIHBlcmZvcm1hbmNlIChlc3BlY2lhbGx5IHN0YXRpY2FsbHkgcG9zaXRpb25lZCBlbGVtZW50cykuXG4gICAqIFRPRE86IEJlbmNobWFyayB0aGUgZWZmZWN0cyBvZiBwdXR0aW5nIHRoaXMgYXQgdGhlIHRvcCBzaW5jZSA5OSUgb2YgcHJvcHNcbiAgICogICAgICAgZG8gbm90IGNoYW5nZSBmb3IgYSBnaXZlbiByZWNvbmNpbGlhdGlvbi5cbiAgICogVE9ETzogQmVuY2htYXJrIGFyZWFzIHRoYXQgY2FuIGJlIGltcHJvdmVkIHdpdGggY2FjaGluZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtvYmplY3R9IGxhc3RQcm9wc1xuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZVxuICAgKi9cbiAgX3VwZGF0ZURPTVByb3BlcnRpZXM6IGZ1bmN0aW9uIChsYXN0UHJvcHMsIG5leHRQcm9wcywgdHJhbnNhY3Rpb24sIG5vZGUpIHtcbiAgICB2YXIgcHJvcEtleTtcbiAgICB2YXIgc3R5bGVOYW1lO1xuICAgIHZhciBzdHlsZVVwZGF0ZXM7XG4gICAgZm9yIChwcm9wS2V5IGluIGxhc3RQcm9wcykge1xuICAgICAgaWYgKG5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCAhbGFzdFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICAgIHZhciBsYXN0U3R5bGUgPSB0aGlzLl9wcmV2aW91c1N0eWxlQ29weTtcbiAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbGFzdFN0eWxlKSB7XG4gICAgICAgICAgaWYgKGxhc3RTdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBzdHlsZVVwZGF0ZXMgfHwge307XG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGlmIChsYXN0UHJvcHNbcHJvcEtleV0pIHtcbiAgICAgICAgICAvLyBPbmx5IGNhbGwgZGVsZXRlTGlzdGVuZXIgaWYgdGhlcmUgd2FzIGEgbGlzdGVuZXIgcHJldmlvdXNseSBvclxuICAgICAgICAgIC8vIGVsc2Ugd2lsbERlbGV0ZUxpc3RlbmVyIGdldHMgY2FsbGVkIHdoZW4gdGhlcmUgd2Fzbid0IGFjdHVhbGx5IGFcbiAgICAgICAgICAvLyBsaXN0ZW5lciAoZS5nLiwgb25DbGljaz17bnVsbH0pXG4gICAgICAgICAgZGVsZXRlTGlzdGVuZXIodGhpcy5fcm9vdE5vZGVJRCwgcHJvcEtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkucHJvcGVydGllc1twcm9wS2V5XSB8fCBET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShwcm9wS2V5KSkge1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICBub2RlID0gUmVhY3RNb3VudC5nZXROb2RlKHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgICAgICB9XG4gICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5kZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIHByb3BLZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHByb3BLZXkgaW4gbmV4dFByb3BzKSB7XG4gICAgICB2YXIgbmV4dFByb3AgPSBuZXh0UHJvcHNbcHJvcEtleV07XG4gICAgICB2YXIgbGFzdFByb3AgPSBwcm9wS2V5ID09PSBTVFlMRSA/IHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5IDogbGFzdFByb3BzW3Byb3BLZXldO1xuICAgICAgaWYgKCFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbmV4dFByb3AgPT09IGxhc3RQcm9wKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBjaGVja0FuZFdhcm5Gb3JNdXRhdGVkU3R5bGUodGhpcy5fcHJldmlvdXNTdHlsZUNvcHksIHRoaXMuX3ByZXZpb3VzU3R5bGUsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNTdHlsZSA9IG5leHRQcm9wO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXh0UHJvcCA9IHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gYXNzaWduKHt9LCBuZXh0UHJvcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0UHJvcCkge1xuICAgICAgICAgIC8vIFVuc2V0IHN0eWxlcyBvbiBgbGFzdFByb3BgIGJ1dCBub3Qgb24gYG5leHRQcm9wYC5cbiAgICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBsYXN0UHJvcCkge1xuICAgICAgICAgICAgaWYgKGxhc3RQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiYgKCFuZXh0UHJvcCB8fCAhbmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkpIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0gc3R5bGVVcGRhdGVzIHx8IHt9O1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBVcGRhdGUgc3R5bGVzIHRoYXQgY2hhbmdlZCBzaW5jZSBgbGFzdFByb3BgLlxuICAgICAgICAgIGZvciAoc3R5bGVOYW1lIGluIG5leHRQcm9wKSB7XG4gICAgICAgICAgICBpZiAobmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiBsYXN0UHJvcFtzdHlsZU5hbWVdICE9PSBuZXh0UHJvcFtzdHlsZU5hbWVdKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHN0eWxlVXBkYXRlcyB8fCB7fTtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSBuZXh0UHJvcFtzdHlsZU5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cbiAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBuZXh0UHJvcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICBlbnF1ZXVlUHV0TGlzdGVuZXIodGhpcy5fcm9vdE5vZGVJRCwgcHJvcEtleSwgbmV4dFByb3AsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0UHJvcCkge1xuICAgICAgICAgIGRlbGV0ZUxpc3RlbmVyKHRoaXMuX3Jvb3ROb2RlSUQsIHByb3BLZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzQ3VzdG9tQ29tcG9uZW50KHRoaXMuX3RhZywgbmV4dFByb3BzKSkge1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICBub2RlID0gUmVhY3RNb3VudC5nZXROb2RlKHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgICAgIG5leHRQcm9wID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JBdHRyaWJ1dGUobm9kZSwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW3Byb3BLZXldIHx8IERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKHByb3BLZXkpKSB7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgIG5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUodGhpcy5fcm9vdE5vZGVJRCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UncmUgdXBkYXRpbmcgdG8gbnVsbCBvciB1bmRlZmluZWQsIHdlIHNob3VsZCByZW1vdmUgdGhlIHByb3BlcnR5XG4gICAgICAgIC8vIGZyb20gdGhlIERPTSBub2RlIGluc3RlYWQgb2YgaW5hZHZlcnRhbnRseSBzZXR0aW5nIHRvIGEgc3RyaW5nLiBUaGlzXG4gICAgICAgIC8vIGJyaW5ncyB1cyBpbiBsaW5lIHdpdGggdGhlIHNhbWUgYmVoYXZpb3Igd2UgaGF2ZSBvbiBpbml0aWFsIHJlbmRlci5cbiAgICAgICAgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLmRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgcHJvcEtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0eWxlVXBkYXRlcykge1xuICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgIG5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUodGhpcy5fcm9vdE5vZGVJRCk7XG4gICAgICB9XG4gICAgICBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JTdHlsZXMobm9kZSwgc3R5bGVVcGRhdGVzKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlY29uY2lsZXMgdGhlIGNoaWxkcmVuIHdpdGggdGhlIHZhcmlvdXMgcHJvcGVydGllcyB0aGF0IGFmZmVjdCB0aGVcbiAgICogY2hpbGRyZW4gY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGxhc3RQcm9wc1xuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICovXG4gIF91cGRhdGVET01DaGlsZHJlbjogZnVuY3Rpb24gKGxhc3RQcm9wcywgbmV4dFByb3BzLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBsYXN0Q29udGVudCA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIGxhc3RQcm9wcy5jaGlsZHJlbl0gPyBsYXN0UHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuICAgIHZhciBuZXh0Q29udGVudCA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIG5leHRQcm9wcy5jaGlsZHJlbl0gPyBuZXh0UHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuXG4gICAgdmFyIGxhc3RIdG1sID0gbGFzdFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICYmIGxhc3RQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWw7XG4gICAgdmFyIG5leHRIdG1sID0gbmV4dFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICYmIG5leHRQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWw7XG5cbiAgICAvLyBOb3RlIHRoZSB1c2Ugb2YgYCE9YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuICAgIHZhciBsYXN0Q2hpbGRyZW4gPSBsYXN0Q29udGVudCAhPSBudWxsID8gbnVsbCA6IGxhc3RQcm9wcy5jaGlsZHJlbjtcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dENvbnRlbnQgIT0gbnVsbCA/IG51bGwgOiBuZXh0UHJvcHMuY2hpbGRyZW47XG5cbiAgICAvLyBJZiB3ZSdyZSBzd2l0Y2hpbmcgZnJvbSBjaGlsZHJlbiB0byBjb250ZW50L2h0bWwgb3IgdmljZSB2ZXJzYSwgcmVtb3ZlXG4gICAgLy8gdGhlIG9sZCBjb250ZW50XG4gICAgdmFyIGxhc3RIYXNDb250ZW50T3JIdG1sID0gbGFzdENvbnRlbnQgIT0gbnVsbCB8fCBsYXN0SHRtbCAhPSBudWxsO1xuICAgIHZhciBuZXh0SGFzQ29udGVudE9ySHRtbCA9IG5leHRDb250ZW50ICE9IG51bGwgfHwgbmV4dEh0bWwgIT0gbnVsbDtcbiAgICBpZiAobGFzdENoaWxkcmVuICE9IG51bGwgJiYgbmV4dENoaWxkcmVuID09IG51bGwpIHtcbiAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4obnVsbCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAobGFzdEhhc0NvbnRlbnRPckh0bWwgJiYgIW5leHRIYXNDb250ZW50T3JIdG1sKSB7XG4gICAgICB0aGlzLnVwZGF0ZVRleHRDb250ZW50KCcnKTtcbiAgICB9XG5cbiAgICBpZiAobmV4dENvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgaWYgKGxhc3RDb250ZW50ICE9PSBuZXh0Q29udGVudCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVRleHRDb250ZW50KCcnICsgbmV4dENvbnRlbnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dEh0bWwgIT0gbnVsbCkge1xuICAgICAgaWYgKGxhc3RIdG1sICE9PSBuZXh0SHRtbCkge1xuICAgICAgICB0aGlzLnVwZGF0ZU1hcmt1cCgnJyArIG5leHRIdG1sKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRDaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICB0aGlzLnVwZGF0ZUNoaWxkcmVuKG5leHRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVzdHJveXMgYWxsIGV2ZW50IHJlZ2lzdHJhdGlvbnMgZm9yIHRoaXMgaW5zdGFuY2UuIERvZXMgbm90IHJlbW92ZSBmcm9tXG4gICAqIHRoZSBET00uIFRoYXQgbXVzdCBiZSBkb25lIGJ5IHRoZSBwYXJlbnQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XG4gICAgICBjYXNlICdpZnJhbWUnOlxuICAgICAgY2FzZSAnaW1nJzpcbiAgICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgY2FzZSAndmlkZW8nOlxuICAgICAgY2FzZSAnYXVkaW8nOlxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fd3JhcHBlclN0YXRlLmxpc3RlbmVycztcbiAgICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnNbaV0ucmVtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICBSZWFjdERPTUlucHV0LnVubW91bnRXcmFwcGVyKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICBjYXNlICdib2R5JzpcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBvbmVudHMgbGlrZSA8aHRtbD4gPGhlYWQ+IGFuZCA8Ym9keT4gY2FuJ3QgYmUgcmVtb3ZlZCBvciBhZGRlZFxuICAgICAgICAgKiBlYXNpbHkgaW4gYSBjcm9zcy1icm93c2VyIHdheSwgaG93ZXZlciBpdCdzIHZhbHVhYmxlIHRvIGJlIGFibGUgdG9cbiAgICAgICAgICogdGFrZSBhZHZhbnRhZ2Ugb2YgUmVhY3QncyByZWNvbmNpbGlhdGlvbiBmb3Igc3R5bGluZyBhbmQgPHRpdGxlPlxuICAgICAgICAgKiBtYW5hZ2VtZW50LiBTbyB3ZSBqdXN0IGRvY3VtZW50IGl0IGFuZCB0aHJvdyBpbiBkYW5nZXJvdXMgY2FzZXMuXG4gICAgICAgICAqL1xuICAgICAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnPCVzPiB0cmllZCB0byB1bm1vdW50LiBCZWNhdXNlIG9mIGNyb3NzLWJyb3dzZXIgcXVpcmtzIGl0IGlzICcgKyAnaW1wb3NzaWJsZSB0byB1bm1vdW50IHNvbWUgdG9wLWxldmVsIGNvbXBvbmVudHMgKGVnIDxodG1sPiwgJyArICc8aGVhZD4sIGFuZCA8Ym9keT4pIHJlbGlhYmx5IGFuZCBlZmZpY2llbnRseS4gVG8gZml4IHRoaXMsIGhhdmUgYSAnICsgJ3NpbmdsZSB0b3AtbGV2ZWwgY29tcG9uZW50IHRoYXQgbmV2ZXIgdW5tb3VudHMgcmVuZGVyIHRoZXNlICcgKyAnZWxlbWVudHMuJywgdGhpcy5fdGFnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMudW5tb3VudENoaWxkcmVuKCk7XG4gICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmRlbGV0ZUFsbExpc3RlbmVycyh0aGlzLl9yb290Tm9kZUlEKTtcbiAgICBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudC51bm1vdW50SURGcm9tRW52aXJvbm1lbnQodGhpcy5fcm9vdE5vZGVJRCk7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IG51bGw7XG4gICAgdGhpcy5fd3JhcHBlclN0YXRlID0gbnVsbDtcbiAgICBpZiAodGhpcy5fbm9kZVdpdGhMZWdhY3lQcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuX25vZGVXaXRoTGVnYWN5UHJvcGVydGllcztcbiAgICAgIG5vZGUuX3JlYWN0SW50ZXJuYWxDb21wb25lbnQgPSBudWxsO1xuICAgICAgdGhpcy5fbm9kZVdpdGhMZWdhY3lQcm9wZXJ0aWVzID0gbnVsbDtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0UHVibGljSW5zdGFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX25vZGVXaXRoTGVnYWN5UHJvcGVydGllcykge1xuICAgICAgdmFyIG5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUodGhpcy5fcm9vdE5vZGVJRCk7XG5cbiAgICAgIG5vZGUuX3JlYWN0SW50ZXJuYWxDb21wb25lbnQgPSB0aGlzO1xuICAgICAgbm9kZS5nZXRET01Ob2RlID0gbGVnYWN5R2V0RE9NTm9kZTtcbiAgICAgIG5vZGUuaXNNb3VudGVkID0gbGVnYWN5SXNNb3VudGVkO1xuICAgICAgbm9kZS5zZXRTdGF0ZSA9IGxlZ2FjeVNldFN0YXRlRXRjO1xuICAgICAgbm9kZS5yZXBsYWNlU3RhdGUgPSBsZWdhY3lTZXRTdGF0ZUV0YztcbiAgICAgIG5vZGUuZm9yY2VVcGRhdGUgPSBsZWdhY3lTZXRTdGF0ZUV0YztcbiAgICAgIG5vZGUuc2V0UHJvcHMgPSBsZWdhY3lTZXRQcm9wcztcbiAgICAgIG5vZGUucmVwbGFjZVByb3BzID0gbGVnYWN5UmVwbGFjZVByb3BzO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhub2RlLCBsZWdhY3lQcm9wc0Rlc2NyaXB0b3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHVwZGF0ZUNvbXBvbmVudCB3aWxsIHVwZGF0ZSB0aGlzIHByb3BlcnR5IG9uIHN1YnNlcXVlbnQgcmVuZGVyc1xuICAgICAgICAgIG5vZGUucHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdXBkYXRlQ29tcG9uZW50IHdpbGwgdXBkYXRlIHRoaXMgcHJvcGVydHkgb24gc3Vic2VxdWVudCByZW5kZXJzXG4gICAgICAgIG5vZGUucHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgICAgIH1cblxuICAgICAgdGhpcy5fbm9kZVdpdGhMZWdhY3lQcm9wZXJ0aWVzID0gbm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX25vZGVXaXRoTGVnYWN5UHJvcGVydGllcztcbiAgfVxuXG59O1xuXG5SZWFjdFBlcmYubWVhc3VyZU1ldGhvZHMoUmVhY3RET01Db21wb25lbnQsICdSZWFjdERPTUNvbXBvbmVudCcsIHtcbiAgbW91bnRDb21wb25lbnQ6ICdtb3VudENvbXBvbmVudCcsXG4gIHVwZGF0ZUNvbXBvbmVudDogJ3VwZGF0ZUNvbXBvbmVudCdcbn0pO1xuXG5hc3NpZ24oUmVhY3RET01Db21wb25lbnQucHJvdG90eXBlLCBSZWFjdERPTUNvbXBvbmVudC5NaXhpbiwgUmVhY3RNdWx0aUNoaWxkLk1peGluKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUNvbXBvbmVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NQ29tcG9uZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEF1dG9Gb2N1c1V0aWxzXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcblxudmFyIGZpbmRET01Ob2RlID0gcmVxdWlyZSgnLi9maW5kRE9NTm9kZScpO1xudmFyIGZvY3VzTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2ZvY3VzTm9kZScpO1xuXG52YXIgTWl4aW4gPSB7XG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICBmb2N1c05vZGUoZmluZERPTU5vZGUodGhpcykpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIEF1dG9Gb2N1c1V0aWxzID0ge1xuICBNaXhpbjogTWl4aW4sXG5cbiAgZm9jdXNET01Db21wb25lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICBmb2N1c05vZGUoUmVhY3RNb3VudC5nZXROb2RlKHRoaXMuX3Jvb3ROb2RlSUQpKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBdXRvRm9jdXNVdGlscztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL0F1dG9Gb2N1c1V0aWxzLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGZvY3VzTm9kZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgaW5wdXQvdGV4dGFyZWEgdG8gZm9jdXNcbiAqL1xuZnVuY3Rpb24gZm9jdXNOb2RlKG5vZGUpIHtcbiAgLy8gSUU4IGNhbiB0aHJvdyBcIkNhbid0IG1vdmUgZm9jdXMgdG8gdGhlIGNvbnRyb2wgYmVjYXVzZSBpdCBpcyBpbnZpc2libGUsXG4gIC8vIG5vdCBlbmFibGVkLCBvciBvZiBhIHR5cGUgdGhhdCBkb2VzIG5vdCBhY2NlcHQgdGhlIGZvY3VzLlwiIGZvciBhbGwga2luZHMgb2ZcbiAgLy8gcmVhc29ucyB0aGF0IGFyZSB0b28gZXhwZW5zaXZlIGFuZCBmcmFnaWxlIHRvIHRlc3QuXG4gIHRyeSB7XG4gICAgbm9kZS5mb2N1cygpO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvY3VzTm9kZTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvZm9jdXNOb2RlLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENTU1Byb3BlcnR5T3BlcmF0aW9uc1xuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDU1NQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vQ1NTUHJvcGVydHknKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZSgnLi9SZWFjdFBlcmYnKTtcblxudmFyIGNhbWVsaXplU3R5bGVOYW1lID0gcmVxdWlyZSgnZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUnKTtcbnZhciBkYW5nZXJvdXNTdHlsZVZhbHVlID0gcmVxdWlyZSgnLi9kYW5nZXJvdXNTdHlsZVZhbHVlJyk7XG52YXIgaHlwaGVuYXRlU3R5bGVOYW1lID0gcmVxdWlyZSgnZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lJyk7XG52YXIgbWVtb2l6ZVN0cmluZ09ubHkgPSByZXF1aXJlKCdmYmpzL2xpYi9tZW1vaXplU3RyaW5nT25seScpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBwcm9jZXNzU3R5bGVOYW1lID0gbWVtb2l6ZVN0cmluZ09ubHkoZnVuY3Rpb24gKHN0eWxlTmFtZSkge1xuICByZXR1cm4gaHlwaGVuYXRlU3R5bGVOYW1lKHN0eWxlTmFtZSk7XG59KTtcblxudmFyIGhhc1Nob3J0aGFuZFByb3BlcnR5QnVnID0gZmFsc2U7XG52YXIgc3R5bGVGbG9hdEFjY2Vzc29yID0gJ2Nzc0Zsb2F0JztcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgdmFyIHRlbXBTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuICB0cnkge1xuICAgIC8vIElFOCB0aHJvd3MgXCJJbnZhbGlkIGFyZ3VtZW50LlwiIGlmIHJlc2V0dGluZyBzaG9ydGhhbmQgc3R5bGUgcHJvcGVydGllcy5cbiAgICB0ZW1wU3R5bGUuZm9udCA9ICcnO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaGFzU2hvcnRoYW5kUHJvcGVydHlCdWcgPSB0cnVlO1xuICB9XG4gIC8vIElFOCBvbmx5IHN1cHBvcnRzIGFjY2Vzc2luZyBjc3NGbG9hdCAoc3RhbmRhcmQpIGFzIHN0eWxlRmxvYXRcbiAgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5jc3NGbG9hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3R5bGVGbG9hdEFjY2Vzc29yID0gJ3N0eWxlRmxvYXQnO1xuICB9XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vICdtc1RyYW5zZm9ybScgaXMgY29ycmVjdCwgYnV0IHRoZSBvdGhlciBwcmVmaXhlcyBzaG91bGQgYmUgY2FwaXRhbGl6ZWRcbiAgdmFyIGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybiA9IC9eKD86d2Via2l0fG1venxvKVtBLVpdLztcblxuICAvLyBzdHlsZSB2YWx1ZXMgc2hvdWxkbid0IGNvbnRhaW4gYSBzZW1pY29sb25cbiAgdmFyIGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiA9IC87XFxzKiQvO1xuXG4gIHZhciB3YXJuZWRTdHlsZU5hbWVzID0ge307XG4gIHZhciB3YXJuZWRTdHlsZVZhbHVlcyA9IHt9O1xuXG4gIHZhciB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5zdXBwb3J0ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8nLCBuYW1lLCBjYW1lbGl6ZVN0eWxlTmFtZShuYW1lKSkgOiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgdmFyIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5zdXBwb3J0ZWQgdmVuZG9yLXByZWZpeGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JywgbmFtZSwgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSkpIDogdW5kZWZpbmVkO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVWYWx1ZXMuaGFzT3duUHJvcGVydHkodmFsdWUpICYmIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSA9IHRydWU7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdTdHlsZSBwcm9wZXJ0eSB2YWx1ZXMgc2hvdWxkblxcJ3QgY29udGFpbiBhIHNlbWljb2xvbi4gJyArICdUcnkgXCIlczogJXNcIiBpbnN0ZWFkLicsIG5hbWUsIHZhbHVlLnJlcGxhY2UoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLCAnJykpIDogdW5kZWZpbmVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqL1xuICB2YXIgd2FyblZhbGlkU3R5bGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAobmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUobmFtZSk7XG4gICAgfSBlbHNlIGlmIChiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4udGVzdChuYW1lKSkge1xuICAgICAgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24obmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBPcGVyYXRpb25zIGZvciBkZWFsaW5nIHdpdGggQ1NTIHByb3BlcnRpZXMuXG4gKi9cbnZhciBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMgPSB7XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgYSBtYXBwaW5nIG9mIHN0eWxlIHByb3BlcnRpZXMgZm9yIHVzZSBhcyBpbmxpbmUgc3R5bGVzOlxuICAgKlxuICAgKiAgID4gY3JlYXRlTWFya3VwRm9yU3R5bGVzKHt3aWR0aDogJzIwMHB4JywgaGVpZ2h0OiAwfSlcbiAgICogICBcIndpZHRoOjIwMHB4O2hlaWdodDowO1wiXG4gICAqXG4gICAqIFVuZGVmaW5lZCB2YWx1ZXMgYXJlIGlnbm9yZWQgc28gdGhhdCBkZWNsYXJhdGl2ZSBwcm9ncmFtbWluZyBpcyBlYXNpZXIuXG4gICAqIFRoZSByZXN1bHQgc2hvdWxkIGJlIEhUTUwtZXNjYXBlZCBiZWZvcmUgaW5zZXJ0aW9uIGludG8gdGhlIERPTS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHN0eWxlc1xuICAgKiBAcmV0dXJuIHs/c3RyaW5nfVxuICAgKi9cbiAgY3JlYXRlTWFya3VwRm9yU3R5bGVzOiBmdW5jdGlvbiAoc3R5bGVzKSB7XG4gICAgdmFyIHNlcmlhbGl6ZWQgPSAnJztcbiAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBzdHlsZXNbc3R5bGVOYW1lXTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm5WYWxpZFN0eWxlKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGVWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHNlcmlhbGl6ZWQgKz0gcHJvY2Vzc1N0eWxlTmFtZShzdHlsZU5hbWUpICsgJzonO1xuICAgICAgICBzZXJpYWxpemVkICs9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlKSArICc7JztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQgfHwgbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgZm9yIG11bHRpcGxlIHN0eWxlcyBvbiBhIG5vZGUuICBJZiBhIHZhbHVlIGlzIHNwZWNpZmllZCBhc1xuICAgKiAnJyAoZW1wdHkgc3RyaW5nKSwgdGhlIGNvcnJlc3BvbmRpbmcgc3R5bGUgcHJvcGVydHkgd2lsbCBiZSB1bnNldC5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcbiAgICovXG4gIHNldFZhbHVlRm9yU3R5bGVzOiBmdW5jdGlvbiAobm9kZSwgc3R5bGVzKSB7XG4gICAgdmFyIHN0eWxlID0gbm9kZS5zdHlsZTtcbiAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FyblZhbGlkU3R5bGUoc3R5bGVOYW1lLCBzdHlsZXNbc3R5bGVOYW1lXSk7XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGVWYWx1ZSA9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZXNbc3R5bGVOYW1lXSk7XG4gICAgICBpZiAoc3R5bGVOYW1lID09PSAnZmxvYXQnKSB7XG4gICAgICAgIHN0eWxlTmFtZSA9IHN0eWxlRmxvYXRBY2Nlc3NvcjtcbiAgICAgIH1cbiAgICAgIGlmIChzdHlsZVZhbHVlKSB7XG4gICAgICAgIHN0eWxlW3N0eWxlTmFtZV0gPSBzdHlsZVZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGV4cGFuc2lvbiA9IGhhc1Nob3J0aGFuZFByb3BlcnR5QnVnICYmIENTU1Byb3BlcnR5LnNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9uc1tzdHlsZU5hbWVdO1xuICAgICAgICBpZiAoZXhwYW5zaW9uKSB7XG4gICAgICAgICAgLy8gU2hvcnRoYW5kIHByb3BlcnR5IHRoYXQgSUU4IHdvbid0IGxpa2UgdW5zZXR0aW5nLCBzbyB1bnNldCBlYWNoXG4gICAgICAgICAgLy8gY29tcG9uZW50IHRvIHBsYWNhdGUgaXRcbiAgICAgICAgICBmb3IgKHZhciBpbmRpdmlkdWFsU3R5bGVOYW1lIGluIGV4cGFuc2lvbikge1xuICAgICAgICAgICAgc3R5bGVbaW5kaXZpZHVhbFN0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3R5bGVbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cblJlYWN0UGVyZi5tZWFzdXJlTWV0aG9kcyhDU1NQcm9wZXJ0eU9wZXJhdGlvbnMsICdDU1NQcm9wZXJ0eU9wZXJhdGlvbnMnLCB7XG4gIHNldFZhbHVlRm9yU3R5bGVzOiAnc2V0VmFsdWVGb3JTdHlsZXMnXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDU1NQcm9wZXJ0eU9wZXJhdGlvbnM7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9DU1NQcm9wZXJ0eU9wZXJhdGlvbnMuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ1NTUHJvcGVydHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ1NTIHByb3BlcnRpZXMgd2hpY2ggYWNjZXB0IG51bWJlcnMgYnV0IGFyZSBub3QgaW4gdW5pdHMgb2YgXCJweFwiLlxuICovXG52YXIgaXNVbml0bGVzc051bWJlciA9IHtcbiAgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6IHRydWUsXG4gIGJveEZsZXg6IHRydWUsXG4gIGJveEZsZXhHcm91cDogdHJ1ZSxcbiAgYm94T3JkaW5hbEdyb3VwOiB0cnVlLFxuICBjb2x1bW5Db3VudDogdHJ1ZSxcbiAgZmxleDogdHJ1ZSxcbiAgZmxleEdyb3c6IHRydWUsXG4gIGZsZXhQb3NpdGl2ZTogdHJ1ZSxcbiAgZmxleFNocmluazogdHJ1ZSxcbiAgZmxleE5lZ2F0aXZlOiB0cnVlLFxuICBmbGV4T3JkZXI6IHRydWUsXG4gIGZvbnRXZWlnaHQ6IHRydWUsXG4gIGxpbmVDbGFtcDogdHJ1ZSxcbiAgbGluZUhlaWdodDogdHJ1ZSxcbiAgb3BhY2l0eTogdHJ1ZSxcbiAgb3JkZXI6IHRydWUsXG4gIG9ycGhhbnM6IHRydWUsXG4gIHRhYlNpemU6IHRydWUsXG4gIHdpZG93czogdHJ1ZSxcbiAgekluZGV4OiB0cnVlLFxuICB6b29tOiB0cnVlLFxuXG4gIC8vIFNWRy1yZWxhdGVkIHByb3BlcnRpZXNcbiAgZmlsbE9wYWNpdHk6IHRydWUsXG4gIHN0b3BPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VEYXNob2Zmc2V0OiB0cnVlLFxuICBzdHJva2VPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VXaWR0aDogdHJ1ZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IHZlbmRvci1zcGVjaWZpYyBwcmVmaXgsIGVnOiBXZWJraXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgc3R5bGUgbmFtZSwgZWc6IHRyYW5zaXRpb25EdXJhdGlvblxuICogQHJldHVybiB7c3RyaW5nfSBzdHlsZSBuYW1lIHByZWZpeGVkIHdpdGggYHByZWZpeGAsIHByb3Blcmx5IGNhbWVsQ2FzZWQsIGVnOlxuICogV2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHByZWZpeEtleShwcmVmaXgsIGtleSkge1xuICByZXR1cm4gcHJlZml4ICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnN1YnN0cmluZygxKTtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHN0eWxlIG5hbWVzIHRoYXQgbWF5IGNvbWUgcGFzc2VkIGluIHByZWZpeGVkIGJ5IGFkZGluZyBwZXJtdXRhdGlvbnNcbiAqIG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xudmFyIHByZWZpeGVzID0gWydXZWJraXQnLCAnbXMnLCAnTW96JywgJ08nXTtcblxuLy8gVXNpbmcgT2JqZWN0LmtleXMgaGVyZSwgb3IgZWxzZSB0aGUgdmFuaWxsYSBmb3ItaW4gbG9vcCBtYWtlcyBJRTggZ28gaW50byBhblxuLy8gaW5maW5pdGUgbG9vcCwgYmVjYXVzZSBpdCBpdGVyYXRlcyBvdmVyIHRoZSBuZXdseSBhZGRlZCBwcm9wcyB0b28uXG5PYmplY3Qua2V5cyhpc1VuaXRsZXNzTnVtYmVyKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gIHByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgIGlzVW5pdGxlc3NOdW1iZXJbcHJlZml4S2V5KHByZWZpeCwgcHJvcCldID0gaXNVbml0bGVzc051bWJlcltwcm9wXTtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBNb3N0IHN0eWxlIHByb3BlcnRpZXMgY2FuIGJlIHVuc2V0IGJ5IGRvaW5nIC5zdHlsZVtwcm9wXSA9ICcnIGJ1dCBJRThcbiAqIGRvZXNuJ3QgbGlrZSBkb2luZyB0aGF0IHdpdGggc2hvcnRoYW5kIHByb3BlcnRpZXMgc28gZm9yIHRoZSBwcm9wZXJ0aWVzIHRoYXRcbiAqIElFOCBicmVha3Mgb24sIHdoaWNoIGFyZSBsaXN0ZWQgaGVyZSwgd2UgaW5zdGVhZCB1bnNldCBlYWNoIG9mIHRoZVxuICogaW5kaXZpZHVhbCBwcm9wZXJ0aWVzLiBTZWUgaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzODUuXG4gKiBUaGUgNC12YWx1ZSAnY2xvY2snIHByb3BlcnRpZXMgbGlrZSBtYXJnaW4sIHBhZGRpbmcsIGJvcmRlci13aWR0aCBzZWVtIHRvXG4gKiBiZWhhdmUgd2l0aG91dCBhbnkgcHJvYmxlbXMuIEN1cmlvdXNseSwgbGlzdC1zdHlsZSB3b3JrcyB0b28gd2l0aG91dCBhbnlcbiAqIHNwZWNpYWwgcHJvZGRpbmcuXG4gKi9cbnZhciBzaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnMgPSB7XG4gIGJhY2tncm91bmQ6IHtcbiAgICBiYWNrZ3JvdW5kQXR0YWNobWVudDogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IHRydWUsXG4gICAgYmFja2dyb3VuZEltYWdlOiB0cnVlLFxuICAgIGJhY2tncm91bmRQb3NpdGlvblg6IHRydWUsXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWTogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kUmVwZWF0OiB0cnVlXG4gIH0sXG4gIGJhY2tncm91bmRQb3NpdGlvbjoge1xuICAgIGJhY2tncm91bmRQb3NpdGlvblg6IHRydWUsXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWTogdHJ1ZVxuICB9LFxuICBib3JkZXI6IHtcbiAgICBib3JkZXJXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJDb2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJCb3R0b206IHtcbiAgICBib3JkZXJCb3R0b21XaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJCb3R0b21TdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJCb3R0b21Db2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJMZWZ0OiB7XG4gICAgYm9yZGVyTGVmdFdpZHRoOiB0cnVlLFxuICAgIGJvcmRlckxlZnRTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJMZWZ0Q29sb3I6IHRydWVcbiAgfSxcbiAgYm9yZGVyUmlnaHQ6IHtcbiAgICBib3JkZXJSaWdodFdpZHRoOiB0cnVlLFxuICAgIGJvcmRlclJpZ2h0U3R5bGU6IHRydWUsXG4gICAgYm9yZGVyUmlnaHRDb2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJUb3A6IHtcbiAgICBib3JkZXJUb3BXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJUb3BTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJUb3BDb2xvcjogdHJ1ZVxuICB9LFxuICBmb250OiB7XG4gICAgZm9udFN0eWxlOiB0cnVlLFxuICAgIGZvbnRWYXJpYW50OiB0cnVlLFxuICAgIGZvbnRXZWlnaHQ6IHRydWUsXG4gICAgZm9udFNpemU6IHRydWUsXG4gICAgbGluZUhlaWdodDogdHJ1ZSxcbiAgICBmb250RmFtaWx5OiB0cnVlXG4gIH0sXG4gIG91dGxpbmU6IHtcbiAgICBvdXRsaW5lV2lkdGg6IHRydWUsXG4gICAgb3V0bGluZVN0eWxlOiB0cnVlLFxuICAgIG91dGxpbmVDb2xvcjogdHJ1ZVxuICB9XG59O1xuXG52YXIgQ1NTUHJvcGVydHkgPSB7XG4gIGlzVW5pdGxlc3NOdW1iZXI6IGlzVW5pdGxlc3NOdW1iZXIsXG4gIHNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9uczogc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENTU1Byb3BlcnR5O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvQ1NTUHJvcGVydHkuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY2FtZWxpemVTdHlsZU5hbWVcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FtZWxpemUgPSByZXF1aXJlKCcuL2NhbWVsaXplJyk7XG5cbnZhciBtc1BhdHRlcm4gPSAvXi1tcy0vO1xuXG4vKipcbiAqIENhbWVsY2FzZXMgYSBoeXBoZW5hdGVkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJ2JhY2tncm91bmQtY29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZENvbG9yXCJcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnLW1vei10cmFuc2l0aW9uJylcbiAqICAgPCBcIk1velRyYW5zaXRpb25cIlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCctbXMtdHJhbnNpdGlvbicpXG4gKiAgIDwgXCJtc1RyYW5zaXRpb25cIlxuICpcbiAqIEFzIEFuZGkgU21pdGggc3VnZ2VzdHNcbiAqIChodHRwOi8vd3d3LmFuZGlzbWl0aC5jb20vYmxvZy8yMDEyLzAyL21vZGVybml6ci1wcmVmaXhlZC8pLCBhbiBgLW1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNhbWVsaXplU3R5bGVOYW1lKHN0cmluZykge1xuICByZXR1cm4gY2FtZWxpemUoc3RyaW5nLnJlcGxhY2UobXNQYXR0ZXJuLCAnbXMtJykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbWVsaXplU3R5bGVOYW1lO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9jYW1lbGl6ZVN0eWxlTmFtZS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBjYW1lbGl6ZVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF9oeXBoZW5QYXR0ZXJuID0gLy0oLikvZztcblxuLyoqXG4gKiBDYW1lbGNhc2VzIGEgaHlwaGVuYXRlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBjYW1lbGl6ZSgnYmFja2dyb3VuZC1jb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kQ29sb3JcIlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY2FtZWxpemUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShfaHlwaGVuUGF0dGVybiwgZnVuY3Rpb24gKF8sIGNoYXJhY3Rlcikge1xuICAgIHJldHVybiBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FtZWxpemU7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL2NhbWVsaXplLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGRhbmdlcm91c1N0eWxlVmFsdWVcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ1NTUHJvcGVydHkgPSByZXF1aXJlKCcuL0NTU1Byb3BlcnR5Jyk7XG5cbnZhciBpc1VuaXRsZXNzTnVtYmVyID0gQ1NTUHJvcGVydHkuaXNVbml0bGVzc051bWJlcjtcblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgaW50byB0aGUgcHJvcGVyIGNzcyB3cml0YWJsZSB2YWx1ZS4gVGhlIHN0eWxlIG5hbWUgYG5hbWVgXG4gKiBzaG91bGQgYmUgbG9naWNhbCAobm8gaHlwaGVucyksIGFzIHNwZWNpZmllZFxuICogaW4gYENTU1Byb3BlcnR5LmlzVW5pdGxlc3NOdW1iZXJgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIENTUyBwcm9wZXJ0eSBuYW1lIHN1Y2ggYXMgYHRvcE1hcmdpbmAuXG4gKiBAcGFyYW0geyp9IHZhbHVlIENTUyBwcm9wZXJ0eSB2YWx1ZSBzdWNoIGFzIGAxMHB4YC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBzdHlsZSB2YWx1ZSB3aXRoIGRpbWVuc2lvbnMgYXBwbGllZC5cbiAqL1xuZnVuY3Rpb24gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShuYW1lLCB2YWx1ZSkge1xuICAvLyBOb3RlIHRoYXQgd2UndmUgcmVtb3ZlZCBlc2NhcGVUZXh0Rm9yQnJvd3NlcigpIGNhbGxzIGhlcmUgc2luY2UgdGhlXG4gIC8vIHdob2xlIHN0cmluZyB3aWxsIGJlIGVzY2FwZWQgd2hlbiB0aGUgYXR0cmlidXRlIGlzIGluamVjdGVkIGludG9cbiAgLy8gdGhlIG1hcmt1cC4gSWYgeW91IHByb3ZpZGUgdW5zYWZlIHVzZXIgZGF0YSBoZXJlIHRoZXkgY2FuIGluamVjdFxuICAvLyBhcmJpdHJhcnkgQ1NTIHdoaWNoIG1heSBiZSBwcm9ibGVtYXRpYyAoSSBjb3VsZG4ndCByZXBybyB0aGlzKTpcbiAgLy8gaHR0cHM6Ly93d3cub3dhc3Aub3JnL2luZGV4LnBocC9YU1NfRmlsdGVyX0V2YXNpb25fQ2hlYXRfU2hlZXRcbiAgLy8gaHR0cDovL3d3dy50aGVzcGFubmVyLmNvLnVrLzIwMDcvMTEvMjYvdWx0aW1hdGUteHNzLWNzcy1pbmplY3Rpb24vXG4gIC8vIFRoaXMgaXMgbm90IGFuIFhTUyBob2xlIGJ1dCBpbnN0ZWFkIGEgcG90ZW50aWFsIENTUyBpbmplY3Rpb24gaXNzdWVcbiAgLy8gd2hpY2ggaGFzIGxlYWQgdG8gYSBncmVhdGVyIGRpc2N1c3Npb24gYWJvdXQgaG93IHdlJ3JlIGdvaW5nIHRvXG4gIC8vIHRydXN0IFVSTHMgbW92aW5nIGZvcndhcmQuIFNlZSAjMjExNTkwMVxuXG4gIHZhciBpc0VtcHR5ID0gdmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fCB2YWx1ZSA9PT0gJyc7XG4gIGlmIChpc0VtcHR5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgdmFyIGlzTm9uTnVtZXJpYyA9IGlzTmFOKHZhbHVlKTtcbiAgaWYgKGlzTm9uTnVtZXJpYyB8fCB2YWx1ZSA9PT0gMCB8fCBpc1VuaXRsZXNzTnVtYmVyLmhhc093blByb3BlcnR5KG5hbWUpICYmIGlzVW5pdGxlc3NOdW1iZXJbbmFtZV0pIHtcbiAgICByZXR1cm4gJycgKyB2YWx1ZTsgLy8gY2FzdCB0byBzdHJpbmdcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlICsgJ3B4Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkYW5nZXJvdXNTdHlsZVZhbHVlO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvZGFuZ2Vyb3VzU3R5bGVWYWx1ZS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBoeXBoZW5hdGVTdHlsZU5hbWVcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaHlwaGVuYXRlID0gcmVxdWlyZSgnLi9oeXBoZW5hdGUnKTtcblxudmFyIG1zUGF0dGVybiA9IC9ebXMtLztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnTW96VHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbW96LXRyYW5zaXRpb25cIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnbXNUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tcy10cmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBNb2Rlcm5penIgc3VnZ2VzdHMgKGh0dHA6Ly9tb2Rlcm5penIuY29tL2RvY3MvI3ByZWZpeGVkKSwgYW4gYG1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBgLW1zLWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUoc3RyaW5nKSB7XG4gIHJldHVybiBoeXBoZW5hdGUoc3RyaW5nKS5yZXBsYWNlKG1zUGF0dGVybiwgJy1tcy0nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGVTdHlsZU5hbWU7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBoeXBoZW5hdGVcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3VwcGVyY2FzZVBhdHRlcm4gPSAvKFtBLVpdKS9nO1xuXG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIHN0cmluZywgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICpcbiAqIEZvciBDU1Mgc3R5bGUgbmFtZXMsIHVzZSBgaHlwaGVuYXRlU3R5bGVOYW1lYCBpbnN0ZWFkIHdoaWNoIHdvcmtzIHByb3Blcmx5XG4gKiB3aXRoIGFsbCB2ZW5kb3IgcHJlZml4ZXMsIGluY2x1ZGluZyBgbXNgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaHlwaGVuYXRlKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoX3VwcGVyY2FzZVBhdHRlcm4sICctJDEnKS50b0xvd2VyQ2FzZSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGhlbmF0ZTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvaHlwaGVuYXRlLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIG1lbW9pemVTdHJpbmdPbmx5XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNZW1vaXplcyB0aGUgcmV0dXJuIHZhbHVlIG9mIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIG9uZSBzdHJpbmcgYXJndW1lbnQuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBtZW1vaXplU3RyaW5nT25seShjYWxsYmFjaykge1xuICB2YXIgY2FjaGUgPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICBpZiAoIWNhY2hlLmhhc093blByb3BlcnR5KHN0cmluZykpIHtcbiAgICAgIGNhY2hlW3N0cmluZ10gPSBjYWxsYmFjay5jYWxsKHRoaXMsIHN0cmluZyk7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZVtzdHJpbmddO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemVTdHJpbmdPbmx5O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9tZW1vaXplU3RyaW5nT25seS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUJ1dHRvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG1vdXNlTGlzdGVuZXJOYW1lcyA9IHtcbiAgb25DbGljazogdHJ1ZSxcbiAgb25Eb3VibGVDbGljazogdHJ1ZSxcbiAgb25Nb3VzZURvd246IHRydWUsXG4gIG9uTW91c2VNb3ZlOiB0cnVlLFxuICBvbk1vdXNlVXA6IHRydWUsXG5cbiAgb25DbGlja0NhcHR1cmU6IHRydWUsXG4gIG9uRG91YmxlQ2xpY2tDYXB0dXJlOiB0cnVlLFxuICBvbk1vdXNlRG93bkNhcHR1cmU6IHRydWUsXG4gIG9uTW91c2VNb3ZlQ2FwdHVyZTogdHJ1ZSxcbiAgb25Nb3VzZVVwQ2FwdHVyZTogdHJ1ZVxufTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPGJ1dHRvbj4gbmF0aXZlIGNvbXBvbmVudCB0aGF0IGRvZXMgbm90IHJlY2VpdmUgbW91c2UgZXZlbnRzXG4gKiB3aGVuIGBkaXNhYmxlZGAgaXMgc2V0LlxuICovXG52YXIgUmVhY3RET01CdXR0b24gPSB7XG4gIGdldE5hdGl2ZVByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMsIGNvbnRleHQpIHtcbiAgICBpZiAoIXByb3BzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm4gcHJvcHM7XG4gICAgfVxuXG4gICAgLy8gQ29weSB0aGUgcHJvcHMsIGV4Y2VwdCB0aGUgbW91c2UgbGlzdGVuZXJzXG4gICAgdmFyIG5hdGl2ZVByb3BzID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhbW91c2VMaXN0ZW5lck5hbWVzW2tleV0pIHtcbiAgICAgICAgbmF0aXZlUHJvcHNba2V5XSA9IHByb3BzW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hdGl2ZVByb3BzO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQnV0dG9uO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01CdXR0b24uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01JbnB1dFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NSURPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9SZWFjdERPTUlET3BlcmF0aW9ucycpO1xudmFyIExpbmtlZFZhbHVlVXRpbHMgPSByZXF1aXJlKCcuL0xpbmtlZFZhbHVlVXRpbHMnKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgaW5zdGFuY2VzQnlSZWFjdElEID0ge307XG5cbmZ1bmN0aW9uIGZvcmNlVXBkYXRlSWZNb3VudGVkKCkge1xuICBpZiAodGhpcy5fcm9vdE5vZGVJRCkge1xuICAgIC8vIERPTSBjb21wb25lbnQgaXMgc3RpbGwgbW91bnRlZDsgdXBkYXRlXG4gICAgUmVhY3RET01JbnB1dC51cGRhdGVXcmFwcGVyKHRoaXMpO1xuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhbiA8aW5wdXQ+IG5hdGl2ZSBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyB0aGVzZSBvcHRpb25hbFxuICogcHJvcHM6IGBjaGVja2VkYCwgYHZhbHVlYCwgYGRlZmF1bHRDaGVja2VkYCwgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICpcbiAqIElmIGBjaGVja2VkYCBvciBgdmFsdWVgIGFyZSBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zXG4gKiB0aGF0IGFmZmVjdCB0aGUgY2hlY2tlZCBzdGF0ZSBvciB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiB0aGV5IGFyZSBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgbm90XG4gKiB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBwcm9wcyBtdXN0IGNoYW5nZSBpbiBvcmRlciBmb3JcbiAqIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCBhcyB1bmNoZWNrZWQgKG9yIGBkZWZhdWx0Q2hlY2tlZGApXG4gKiB3aXRoIGFuIGVtcHR5IHZhbHVlIChvciBgZGVmYXVsdFZhbHVlYCkuXG4gKlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEyL1dELWh0bWw1LTIwMTIxMDI1L3RoZS1pbnB1dC1lbGVtZW50Lmh0bWxcbiAqL1xudmFyIFJlYWN0RE9NSW5wdXQgPSB7XG4gIGdldE5hdGl2ZVByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMsIGNvbnRleHQpIHtcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICB2YXIgY2hlY2tlZCA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0Q2hlY2tlZChwcm9wcyk7XG5cbiAgICB2YXIgbmF0aXZlUHJvcHMgPSBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICBkZWZhdWx0Q2hlY2tlZDogdW5kZWZpbmVkLFxuICAgICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgICB2YWx1ZTogdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSxcbiAgICAgIGNoZWNrZWQ6IGNoZWNrZWQgIT0gbnVsbCA/IGNoZWNrZWQgOiBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWQsXG4gICAgICBvbkNoYW5nZTogaW5zdC5fd3JhcHBlclN0YXRlLm9uQ2hhbmdlXG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmF0aXZlUHJvcHM7XG4gIH0sXG5cbiAgbW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgTGlua2VkVmFsdWVVdGlscy5jaGVja1Byb3BUeXBlcygnaW5wdXQnLCBwcm9wcywgaW5zdC5fY3VycmVudEVsZW1lbnQuX293bmVyKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgIGluc3QuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICAgIGluaXRpYWxDaGVja2VkOiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCB8fCBmYWxzZSxcbiAgICAgIGluaXRpYWxWYWx1ZTogZGVmYXVsdFZhbHVlICE9IG51bGwgPyBkZWZhdWx0VmFsdWUgOiBudWxsLFxuICAgICAgb25DaGFuZ2U6IF9oYW5kbGVDaGFuZ2UuYmluZChpbnN0KVxuICAgIH07XG4gIH0sXG5cbiAgbW91bnRSZWFkeVdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgLy8gQ2FuJ3QgYmUgaW4gbW91bnRXcmFwcGVyIG9yIGVsc2Ugc2VydmVyIHJlbmRlcmluZyBsZWFrcy5cbiAgICBpbnN0YW5jZXNCeVJlYWN0SURbaW5zdC5fcm9vdE5vZGVJRF0gPSBpbnN0O1xuICB9LFxuXG4gIHVubW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIGRlbGV0ZSBpbnN0YW5jZXNCeVJlYWN0SURbaW5zdC5fcm9vdE5vZGVJRF07XG4gIH0sXG5cbiAgdXBkYXRlV3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIC8vIFRPRE86IFNob3VsZG4ndCB0aGlzIGJlIGdldENoZWNrZWQocHJvcHMpP1xuICAgIHZhciBjaGVja2VkID0gcHJvcHMuY2hlY2tlZDtcbiAgICBpZiAoY2hlY2tlZCAhPSBudWxsKSB7XG4gICAgICBSZWFjdERPTUlET3BlcmF0aW9ucy51cGRhdGVQcm9wZXJ0eUJ5SUQoaW5zdC5fcm9vdE5vZGVJRCwgJ2NoZWNrZWQnLCBjaGVja2VkIHx8IGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcbiAgICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cbiAgICAgIFJlYWN0RE9NSURPcGVyYXRpb25zLnVwZGF0ZVByb3BlcnR5QnlJRChpbnN0Ll9yb290Tm9kZUlELCAndmFsdWUnLCAnJyArIHZhbHVlKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9oYW5kbGVDaGFuZ2UoZXZlbnQpIHtcbiAgdmFyIHByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgdmFyIHJldHVyblZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5leGVjdXRlT25DaGFuZ2UocHJvcHMsIGV2ZW50KTtcblxuICAvLyBIZXJlIHdlIHVzZSBhc2FwIHRvIHdhaXQgdW50aWwgYWxsIHVwZGF0ZXMgaGF2ZSBwcm9wYWdhdGVkLCB3aGljaFxuICAvLyBpcyBpbXBvcnRhbnQgd2hlbiB1c2luZyBjb250cm9sbGVkIGNvbXBvbmVudHMgd2l0aGluIGxheWVyczpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNjk4XG4gIFJlYWN0VXBkYXRlcy5hc2FwKGZvcmNlVXBkYXRlSWZNb3VudGVkLCB0aGlzKTtcblxuICB2YXIgbmFtZSA9IHByb3BzLm5hbWU7XG4gIGlmIChwcm9wcy50eXBlID09PSAncmFkaW8nICYmIG5hbWUgIT0gbnVsbCkge1xuICAgIHZhciByb290Tm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZSh0aGlzLl9yb290Tm9kZUlEKTtcbiAgICB2YXIgcXVlcnlSb290ID0gcm9vdE5vZGU7XG5cbiAgICB3aGlsZSAocXVlcnlSb290LnBhcmVudE5vZGUpIHtcbiAgICAgIHF1ZXJ5Um9vdCA9IHF1ZXJ5Um9vdC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIC8vIElmIGByb290Tm9kZS5mb3JtYCB3YXMgbm9uLW51bGwsIHRoZW4gd2UgY291bGQgdHJ5IGBmb3JtLmVsZW1lbnRzYCxcbiAgICAvLyBidXQgdGhhdCBzb21ldGltZXMgYmVoYXZlcyBzdHJhbmdlbHkgaW4gSUU4LiBXZSBjb3VsZCBhbHNvIHRyeSB1c2luZ1xuICAgIC8vIGBmb3JtLmdldEVsZW1lbnRzQnlOYW1lYCwgYnV0IHRoYXQgd2lsbCBvbmx5IHJldHVybiBkaXJlY3QgY2hpbGRyZW5cbiAgICAvLyBhbmQgd29uJ3QgaW5jbHVkZSBpbnB1dHMgdGhhdCB1c2UgdGhlIEhUTUw1IGBmb3JtPWAgYXR0cmlidXRlLiBTaW5jZVxuICAgIC8vIHRoZSBpbnB1dCBtaWdodCBub3QgZXZlbiBiZSBpbiBhIGZvcm0sIGxldCdzIGp1c3QgdXNlIHRoZSBnbG9iYWxcbiAgICAvLyBgcXVlcnlTZWxlY3RvckFsbGAgdG8gZW5zdXJlIHdlIGRvbid0IG1pc3MgYW55dGhpbmcuXG4gICAgdmFyIGdyb3VwID0gcXVlcnlSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W25hbWU9JyArIEpTT04uc3RyaW5naWZ5KCcnICsgbmFtZSkgKyAnXVt0eXBlPVwicmFkaW9cIl0nKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvdGhlck5vZGUgPSBncm91cFtpXTtcbiAgICAgIGlmIChvdGhlck5vZGUgPT09IHJvb3ROb2RlIHx8IG90aGVyTm9kZS5mb3JtICE9PSByb290Tm9kZS5mb3JtKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGlmIHJhZGlvIGJ1dHRvbnMgcmVuZGVyZWQgYnkgZGlmZmVyZW50IGNvcGllcyBvZiBSZWFjdFxuICAgICAgLy8gYW5kIHRoZSBzYW1lIG5hbWUgYXJlIHJlbmRlcmVkIGludG8gdGhlIHNhbWUgZm9ybSAoc2FtZSBhcyAjMTkzOSkuXG4gICAgICAvLyBUaGF0J3MgcHJvYmFibHkgb2theTsgd2UgZG9uJ3Qgc3VwcG9ydCBpdCBqdXN0IGFzIHdlIGRvbid0IHN1cHBvcnRcbiAgICAgIC8vIG1peGluZyBSZWFjdCB3aXRoIG5vbi1SZWFjdC5cbiAgICAgIHZhciBvdGhlcklEID0gUmVhY3RNb3VudC5nZXRJRChvdGhlck5vZGUpO1xuICAgICAgIW90aGVySUQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET01JbnB1dDogTWl4aW5nIFJlYWN0IGFuZCBub24tUmVhY3QgcmFkaW8gaW5wdXRzIHdpdGggdGhlICcgKyAnc2FtZSBgbmFtZWAgaXMgbm90IHN1cHBvcnRlZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgb3RoZXJJbnN0YW5jZSA9IGluc3RhbmNlc0J5UmVhY3RJRFtvdGhlcklEXTtcbiAgICAgICFvdGhlckluc3RhbmNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0RE9NSW5wdXQ6IFVua25vd24gcmFkaW8gYnV0dG9uIElEICVzLicsIG90aGVySUQpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBjb250cm9sbGVkIHJhZGlvIGJ1dHRvbiBncm91cCwgZm9yY2luZyB0aGUgaW5wdXQgdGhhdFxuICAgICAgLy8gd2FzIHByZXZpb3VzbHkgY2hlY2tlZCB0byB1cGRhdGUgd2lsbCBjYXVzZSBpdCB0byBiZSBjb21lIHJlLWNoZWNrZWRcbiAgICAgIC8vIGFzIGFwcHJvcHJpYXRlLlxuICAgICAgUmVhY3RVcGRhdGVzLmFzYXAoZm9yY2VVcGRhdGVJZk1vdW50ZWQsIG90aGVySW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUlucHV0O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01JbnB1dC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBMaW5rZWRWYWx1ZVV0aWxzXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlcycpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbnMnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBoYXNSZWFkT25seVZhbHVlID0ge1xuICAnYnV0dG9uJzogdHJ1ZSxcbiAgJ2NoZWNrYm94JzogdHJ1ZSxcbiAgJ2ltYWdlJzogdHJ1ZSxcbiAgJ2hpZGRlbic6IHRydWUsXG4gICdyYWRpbyc6IHRydWUsXG4gICdyZXNldCc6IHRydWUsXG4gICdzdWJtaXQnOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBfYXNzZXJ0U2luZ2xlTGluayhpbnB1dFByb3BzKSB7XG4gICEoaW5wdXRQcm9wcy5jaGVja2VkTGluayA9PSBudWxsIHx8IGlucHV0UHJvcHMudmFsdWVMaW5rID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBwcm92aWRlIGEgY2hlY2tlZExpbmsgYW5kIGEgdmFsdWVMaW5rLiBJZiB5b3Ugd2FudCB0byB1c2UgJyArICdjaGVja2VkTGluaywgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byB1c2UgdmFsdWVMaW5rIGFuZCB2aWNlIHZlcnNhLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIF9hc3NlcnRWYWx1ZUxpbmsoaW5wdXRQcm9wcykge1xuICBfYXNzZXJ0U2luZ2xlTGluayhpbnB1dFByb3BzKTtcbiAgIShpbnB1dFByb3BzLnZhbHVlID09IG51bGwgJiYgaW5wdXRQcm9wcy5vbkNoYW5nZSA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcHJvdmlkZSBhIHZhbHVlTGluayBhbmQgYSB2YWx1ZSBvciBvbkNoYW5nZSBldmVudC4gSWYgeW91IHdhbnQgJyArICd0byB1c2UgdmFsdWUgb3Igb25DaGFuZ2UsIHlvdSBwcm9iYWJseSBkb25cXCd0IHdhbnQgdG8gdXNlIHZhbHVlTGluay4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRDaGVja2VkTGluayhpbnB1dFByb3BzKSB7XG4gIF9hc3NlcnRTaW5nbGVMaW5rKGlucHV0UHJvcHMpO1xuICAhKGlucHV0UHJvcHMuY2hlY2tlZCA9PSBudWxsICYmIGlucHV0UHJvcHMub25DaGFuZ2UgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHByb3ZpZGUgYSBjaGVja2VkTGluayBhbmQgYSBjaGVja2VkIHByb3BlcnR5IG9yIG9uQ2hhbmdlIGV2ZW50LiAnICsgJ0lmIHlvdSB3YW50IHRvIHVzZSBjaGVja2VkIG9yIG9uQ2hhbmdlLCB5b3UgcHJvYmFibHkgZG9uXFwndCB3YW50IHRvICcgKyAndXNlIGNoZWNrZWRMaW5rJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xufVxuXG52YXIgcHJvcFR5cGVzID0ge1xuICB2YWx1ZTogZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgIGlmICghcHJvcHNbcHJvcE5hbWVdIHx8IGhhc1JlYWRPbmx5VmFsdWVbcHJvcHMudHlwZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICB9LFxuICBjaGVja2VkOiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgaWYgKCFwcm9wc1twcm9wTmFtZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgY2hlY2tlZGAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0Q2hlY2tlZGAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgfSxcbiAgb25DaGFuZ2U6IFJlYWN0UHJvcFR5cGVzLmZ1bmNcbn07XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikge1xuICBpZiAob3duZXIpIHtcbiAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFByb3ZpZGUgYSBsaW5rZWQgYHZhbHVlYCBhdHRyaWJ1dGUgZm9yIGNvbnRyb2xsZWQgZm9ybXMuIFlvdSBzaG91bGQgbm90IHVzZVxuICogdGhpcyBvdXRzaWRlIG9mIHRoZSBSZWFjdERPTSBjb250cm9sbGVkIGZvcm0gY29tcG9uZW50cy5cbiAqL1xudmFyIExpbmtlZFZhbHVlVXRpbHMgPSB7XG4gIGNoZWNrUHJvcFR5cGVzOiBmdW5jdGlvbiAodGFnTmFtZSwgcHJvcHMsIG93bmVyKSB7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcFR5cGVzKSB7XG4gICAgICBpZiAocHJvcFR5cGVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IgPSBwcm9wVHlwZXNbcHJvcE5hbWVdKHByb3BzLCBwcm9wTmFtZSwgdGFnTmFtZSwgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5wcm9wKTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgIHZhciBhZGRlbmR1bSA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcik7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkIGZvcm0gcHJvcFR5cGU6ICVzJXMnLCBlcnJvci5tZXNzYWdlLCBhZGRlbmR1bSkgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5wdXRQcm9wcyBQcm9wcyBmb3IgZm9ybSBjb21wb25lbnRcbiAgICogQHJldHVybiB7Kn0gY3VycmVudCB2YWx1ZSBvZiB0aGUgaW5wdXQgZWl0aGVyIGZyb20gdmFsdWUgcHJvcCBvciBsaW5rLlxuICAgKi9cbiAgZ2V0VmFsdWU6IGZ1bmN0aW9uIChpbnB1dFByb3BzKSB7XG4gICAgaWYgKGlucHV0UHJvcHMudmFsdWVMaW5rKSB7XG4gICAgICBfYXNzZXJ0VmFsdWVMaW5rKGlucHV0UHJvcHMpO1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMudmFsdWVMaW5rLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXRQcm9wcy52YWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGlucHV0UHJvcHMgUHJvcHMgZm9yIGZvcm0gY29tcG9uZW50XG4gICAqIEByZXR1cm4geyp9IGN1cnJlbnQgY2hlY2tlZCBzdGF0dXMgb2YgdGhlIGlucHV0IGVpdGhlciBmcm9tIGNoZWNrZWQgcHJvcFxuICAgKiAgICAgICAgICAgICBvciBsaW5rLlxuICAgKi9cbiAgZ2V0Q2hlY2tlZDogZnVuY3Rpb24gKGlucHV0UHJvcHMpIHtcbiAgICBpZiAoaW5wdXRQcm9wcy5jaGVja2VkTGluaykge1xuICAgICAgX2Fzc2VydENoZWNrZWRMaW5rKGlucHV0UHJvcHMpO1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMuY2hlY2tlZExpbmsudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dFByb3BzLmNoZWNrZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnB1dFByb3BzIFByb3BzIGZvciBmb3JtIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBjaGFuZ2UgZXZlbnQgdG8gaGFuZGxlXG4gICAqL1xuICBleGVjdXRlT25DaGFuZ2U6IGZ1bmN0aW9uIChpbnB1dFByb3BzLCBldmVudCkge1xuICAgIGlmIChpbnB1dFByb3BzLnZhbHVlTGluaykge1xuICAgICAgX2Fzc2VydFZhbHVlTGluayhpbnB1dFByb3BzKTtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLnZhbHVlTGluay5yZXF1ZXN0Q2hhbmdlKGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChpbnB1dFByb3BzLmNoZWNrZWRMaW5rKSB7XG4gICAgICBfYXNzZXJ0Q2hlY2tlZExpbmsoaW5wdXRQcm9wcyk7XG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy5jaGVja2VkTGluay5yZXF1ZXN0Q2hhbmdlKGV2ZW50LnRhcmdldC5jaGVja2VkKTtcbiAgICB9IGVsc2UgaWYgKGlucHV0UHJvcHMub25DaGFuZ2UpIHtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLm9uQ2hhbmdlLmNhbGwodW5kZWZpbmVkLCBldmVudCk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmtlZFZhbHVlVXRpbHM7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9MaW5rZWRWYWx1ZVV0aWxzLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UHJvcFR5cGVzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMnKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgZ2V0SXRlcmF0b3JGbiA9IHJlcXVpcmUoJy4vZ2V0SXRlcmF0b3JGbicpO1xuXG4vKipcbiAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICpcbiAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgICBwcm9wVHlwZXM6IHtcbiAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gKlxuICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICpcbiAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICogICAgIH0sXG4gKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAqICAgfSk7XG4gKlxuICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICpcbiAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gKlxuICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICpcbiAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgcHJvcFR5cGVzOiB7XG4gKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gKiAgICAgICAgICApO1xuICogICAgICAgIH1cbiAqICAgICAgfVxuICogICAgfSxcbiAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICogIH0pO1xuICpcbiAqIEBpbnRlcm5hbFxuICovXG5cbnZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbnZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcblxuICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG4gIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcbiAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdSZXF1aXJlZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHdhcyBub3Qgc3BlY2lmaWVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcbiAgICB9XG4gIH1cblxuICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG5cbiAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyhudWxsKSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJyk7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgaWYgKCFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGlmICghKHByb3BzW3Byb3BOYW1lXSBpbnN0YW5jZW9mIGV4cGVjdGVkQ2xhc3MpKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgIHZhciBhY3R1YWxDbGFzc05hbWUgPSBnZXRDbGFzc05hbWUocHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgYWN0dWFsQ2xhc3NOYW1lICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdpbnN0YW5jZSBvZiBgJyArIGV4cGVjdGVkQ2xhc3NOYW1lICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIoZXhwZWN0ZWRWYWx1ZXMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gZXhwZWN0ZWRWYWx1ZXNbaV0pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMpO1xuICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB2YWx1ZSBgJyArIHByb3BWYWx1ZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBvbmUgb2YgJyArIHZhbHVlc1N0cmluZyArICcuJykpO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlPZlR5cGVDaGVja2VycykpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAoY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5KTtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcbiAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihwcm9wVmFsdWUpO1xuICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKHByb3BWYWx1ZSk7XG4gICAgICAgIHZhciBzdGVwO1xuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAoIWlzTm9kZShzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZW50cnlbMV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxuZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICByZXR1cm4gJ2FycmF5JztcbiAgfVxuICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuICAgIHJldHVybiAnb2JqZWN0JztcbiAgfVxuICByZXR1cm4gcHJvcFR5cGU7XG59XG5cbi8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbi8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuZnVuY3Rpb24gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKSB7XG4gIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gIGlmIChwcm9wVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuICdkYXRlJztcbiAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHJvcFR5cGU7XG59XG5cbi8vIFJldHVybnMgY2xhc3MgbmFtZSBvZiB0aGUgb2JqZWN0LCBpZiBhbnkuXG5mdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgIHJldHVybiAnPDxhbm9ueW1vdXM+Pic7XG4gIH1cbiAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZXMuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0SXRlcmF0b3JGblxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbCBTeW1ib2wgKi9cbnZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4vKipcbiAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAqXG4gKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAqXG4gKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gKiAgICAgICAuLi5cbiAqICAgICB9XG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEl0ZXJhdG9yRm47XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9nZXRJdGVyYXRvckZuLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NT3B0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDaGlsZHJlbiA9IHJlcXVpcmUoJy4vUmVhY3RDaGlsZHJlbicpO1xudmFyIFJlYWN0RE9NU2VsZWN0ID0gcmVxdWlyZSgnLi9SZWFjdERPTVNlbGVjdCcpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIHZhbHVlQ29udGV4dEtleSA9IFJlYWN0RE9NU2VsZWN0LnZhbHVlQ29udGV4dEtleTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxvcHRpb24+IG5hdGl2ZSBjb21wb25lbnQgdGhhdCB3YXJucyB3aGVuIGBzZWxlY3RlZGAgaXMgc2V0LlxuICovXG52YXIgUmVhY3RET01PcHRpb24gPSB7XG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzLCBjb250ZXh0KSB7XG4gICAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGBzZWxlY3RlZGAgaW4gPG9wdGlvbj4uXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHByb3BzLnNlbGVjdGVkID09IG51bGwsICdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgb24gPHNlbGVjdD4gaW5zdGVhZCBvZiAnICsgJ3NldHRpbmcgYHNlbGVjdGVkYCBvbiA8b3B0aW9uPi4nKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBMb29rIHVwIHdoZXRoZXIgdGhpcyBvcHRpb24gaXMgJ3NlbGVjdGVkJyB2aWEgY29udGV4dFxuICAgIHZhciBzZWxlY3RWYWx1ZSA9IGNvbnRleHRbdmFsdWVDb250ZXh0S2V5XTtcblxuICAgIC8vIElmIGNvbnRleHQga2V5IGlzIG51bGwgKGUuZy4sIG5vIHNwZWNpZmllZCB2YWx1ZSBvciBhZnRlciBpbml0aWFsIG1vdW50KVxuICAgIC8vIG9yIG1pc3NpbmcgKGUuZy4sIGZvciA8ZGF0YWxpc3Q+KSwgd2UgZG9uJ3QgY2hhbmdlIHByb3BzLnNlbGVjdGVkXG4gICAgdmFyIHNlbGVjdGVkID0gbnVsbDtcbiAgICBpZiAoc2VsZWN0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNlbGVjdFZhbHVlKSkge1xuICAgICAgICAvLyBtdWx0aXBsZVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCcnICsgc2VsZWN0VmFsdWVbaV0gPT09ICcnICsgcHJvcHMudmFsdWUpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0ZWQgPSAnJyArIHNlbGVjdFZhbHVlID09PSAnJyArIHByb3BzLnZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGluc3QuX3dyYXBwZXJTdGF0ZSA9IHsgc2VsZWN0ZWQ6IHNlbGVjdGVkIH07XG4gIH0sXG5cbiAgZ2V0TmF0aXZlUHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcywgY29udGV4dCkge1xuICAgIHZhciBuYXRpdmVQcm9wcyA9IGFzc2lnbih7IHNlbGVjdGVkOiB1bmRlZmluZWQsIGNoaWxkcmVuOiB1bmRlZmluZWQgfSwgcHJvcHMpO1xuXG4gICAgLy8gUmVhZCBzdGF0ZSBvbmx5IGZyb20gaW5pdGlhbCBtb3VudCBiZWNhdXNlIDxzZWxlY3Q+IHVwZGF0ZXMgdmFsdWVcbiAgICAvLyBtYW51YWxseTsgd2UgbmVlZCB0aGUgaW5pdGlhbCBzdGF0ZSBvbmx5IGZvciBzZXJ2ZXIgcmVuZGVyaW5nXG4gICAgaWYgKGluc3QuX3dyYXBwZXJTdGF0ZS5zZWxlY3RlZCAhPSBudWxsKSB7XG4gICAgICBuYXRpdmVQcm9wcy5zZWxlY3RlZCA9IGluc3QuX3dyYXBwZXJTdGF0ZS5zZWxlY3RlZDtcbiAgICB9XG5cbiAgICB2YXIgY29udGVudCA9ICcnO1xuXG4gICAgLy8gRmxhdHRlbiBjaGlsZHJlbiBhbmQgd2FybiBpZiB0aGV5IGFyZW4ndCBzdHJpbmdzIG9yIG51bWJlcnM7XG4gICAgLy8gaW52YWxpZCB0eXBlcyBhcmUgaWdub3JlZC5cbiAgICBSZWFjdENoaWxkcmVuLmZvckVhY2gocHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb250ZW50ICs9IGNoaWxkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdPbmx5IHN0cmluZ3MgYW5kIG51bWJlcnMgYXJlIHN1cHBvcnRlZCBhcyA8b3B0aW9uPiBjaGlsZHJlbi4nKSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChjb250ZW50KSB7XG4gICAgICBuYXRpdmVQcm9wcy5jaGlsZHJlbiA9IGNvbnRlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hdGl2ZVByb3BzO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01PcHRpb247XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTU9wdGlvbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENoaWxkcmVuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgdHJhdmVyc2VBbGxDaGlsZHJlbiA9IHJlcXVpcmUoJy4vdHJhdmVyc2VBbGxDaGlsZHJlbicpO1xuXG52YXIgdHdvQXJndW1lbnRQb29sZXIgPSBQb29sZWRDbGFzcy50d29Bcmd1bWVudFBvb2xlcjtcbnZhciBmb3VyQXJndW1lbnRQb29sZXIgPSBQb29sZWRDbGFzcy5mb3VyQXJndW1lbnRQb29sZXI7XG5cbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8oPyFcXC8pL2c7XG5mdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuICByZXR1cm4gKCcnICsgdGV4dCkucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgJy8vJyk7XG59XG5cbi8qKlxuICogUG9vbGVkQ2xhc3MgcmVwcmVzZW50aW5nIHRoZSBib29ra2VlcGluZyBhc3NvY2lhdGVkIHdpdGggcGVyZm9ybWluZyBhIGNoaWxkXG4gKiB0cmF2ZXJzYWwuIEFsbG93cyBhdm9pZGluZyBiaW5kaW5nIGNhbGxiYWNrcy5cbiAqXG4gKiBAY29uc3RydWN0b3IgRm9yRWFjaEJvb2tLZWVwaW5nXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gZm9yRWFjaEZ1bmN0aW9uIEZ1bmN0aW9uIHRvIHBlcmZvcm0gdHJhdmVyc2FsIHdpdGguXG4gKiBAcGFyYW0gez8qfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IHRvIHBlcmZvcm0gY29udGV4dCB3aXRoLlxuICovXG5mdW5jdGlvbiBGb3JFYWNoQm9va0tlZXBpbmcoZm9yRWFjaEZ1bmN0aW9uLCBmb3JFYWNoQ29udGV4dCkge1xuICB0aGlzLmZ1bmMgPSBmb3JFYWNoRnVuY3Rpb247XG4gIHRoaXMuY29udGV4dCA9IGZvckVhY2hDb250ZXh0O1xuICB0aGlzLmNvdW50ID0gMDtcbn1cbkZvckVhY2hCb29rS2VlcGluZy5wcm90b3R5cGUuZGVzdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5mdW5jID0gbnVsbDtcbiAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgdGhpcy5jb3VudCA9IDA7XG59O1xuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKEZvckVhY2hCb29rS2VlcGluZywgdHdvQXJndW1lbnRQb29sZXIpO1xuXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGQoYm9va0tlZXBpbmcsIGNoaWxkLCBuYW1lKSB7XG4gIHZhciBmdW5jID0gYm9va0tlZXBpbmcuZnVuYztcbiAgdmFyIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG4gIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogVGhlIHByb3ZpZGVkIGZvckVhY2hGdW5jKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZvckVhY2hGdW5jXG4gKiBAcGFyYW0geyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgZm9yIGZvckVhY2hDb250ZXh0LlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gRm9yRWFjaEJvb2tLZWVwaW5nLmdldFBvb2xlZChmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIEZvckVhY2hCb29rS2VlcGluZy5yZWxlYXNlKHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogUG9vbGVkQ2xhc3MgcmVwcmVzZW50aW5nIHRoZSBib29ra2VlcGluZyBhc3NvY2lhdGVkIHdpdGggcGVyZm9ybWluZyBhIGNoaWxkXG4gKiBtYXBwaW5nLiBBbGxvd3MgYXZvaWRpbmcgYmluZGluZyBjYWxsYmFja3MuXG4gKlxuICogQGNvbnN0cnVjdG9yIE1hcEJvb2tLZWVwaW5nXG4gKiBAcGFyYW0geyEqfSBtYXBSZXN1bHQgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gbWFwRnVuY3Rpb24gRnVuY3Rpb24gdG8gcGVyZm9ybSBtYXBwaW5nIHdpdGguXG4gKiBAcGFyYW0gez8qfSBtYXBDb250ZXh0IENvbnRleHQgdG8gcGVyZm9ybSBtYXBwaW5nIHdpdGguXG4gKi9cbmZ1bmN0aW9uIE1hcEJvb2tLZWVwaW5nKG1hcFJlc3VsdCwga2V5UHJlZml4LCBtYXBGdW5jdGlvbiwgbWFwQ29udGV4dCkge1xuICB0aGlzLnJlc3VsdCA9IG1hcFJlc3VsdDtcbiAgdGhpcy5rZXlQcmVmaXggPSBrZXlQcmVmaXg7XG4gIHRoaXMuZnVuYyA9IG1hcEZ1bmN0aW9uO1xuICB0aGlzLmNvbnRleHQgPSBtYXBDb250ZXh0O1xuICB0aGlzLmNvdW50ID0gMDtcbn1cbk1hcEJvb2tLZWVwaW5nLnByb3RvdHlwZS5kZXN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJlc3VsdCA9IG51bGw7XG4gIHRoaXMua2V5UHJlZml4ID0gbnVsbDtcbiAgdGhpcy5mdW5jID0gbnVsbDtcbiAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgdGhpcy5jb3VudCA9IDA7XG59O1xuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKE1hcEJvb2tLZWVwaW5nLCBmb3VyQXJndW1lbnRQb29sZXIpO1xuXG5mdW5jdGlvbiBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0KGJvb2tLZWVwaW5nLCBjaGlsZCwgY2hpbGRLZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGJvb2tLZWVwaW5nLnJlc3VsdDtcbiAgdmFyIGtleVByZWZpeCA9IGJvb2tLZWVwaW5nLmtleVByZWZpeDtcbiAgdmFyIGZ1bmMgPSBib29rS2VlcGluZy5mdW5jO1xuICB2YXIgY29udGV4dCA9IGJvb2tLZWVwaW5nLmNvbnRleHQ7XG5cbiAgdmFyIG1hcHBlZENoaWxkID0gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChtYXBwZWRDaGlsZCwgcmVzdWx0LCBjaGlsZEtleSwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChtYXBwZWRDaGlsZCkpIHtcbiAgICAgIG1hcHBlZENoaWxkID0gUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZUtleShtYXBwZWRDaGlsZCxcbiAgICAgIC8vIEtlZXAgYm90aCB0aGUgKG1hcHBlZCkgYW5kIG9sZCBrZXlzIGlmIHRoZXkgZGlmZmVyLCBqdXN0IGFzXG4gICAgICAvLyB0cmF2ZXJzZUFsbENoaWxkcmVuIHVzZWQgdG8gZG8gZm9yIG9iamVjdHMgYXMgY2hpbGRyZW5cbiAgICAgIGtleVByZWZpeCArIChtYXBwZWRDaGlsZCAhPT0gY2hpbGQgPyBlc2NhcGVVc2VyUHJvdmlkZWRLZXkobWFwcGVkQ2hpbGQua2V5IHx8ICcnKSArICcvJyA6ICcnKSArIGNoaWxkS2V5KTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2gobWFwcGVkQ2hpbGQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIGFycmF5LCBwcmVmaXgsIGZ1bmMsIGNvbnRleHQpIHtcbiAgdmFyIGVzY2FwZWRQcmVmaXggPSAnJztcbiAgaWYgKHByZWZpeCAhPSBudWxsKSB7XG4gICAgZXNjYXBlZFByZWZpeCA9IGVzY2FwZVVzZXJQcm92aWRlZEtleShwcmVmaXgpICsgJy8nO1xuICB9XG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBNYXBCb29rS2VlcGluZy5nZXRQb29sZWQoYXJyYXksIGVzY2FwZWRQcmVmaXgsIGZ1bmMsIGNvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0LCB0cmF2ZXJzZUNvbnRleHQpO1xuICBNYXBCb29rS2VlcGluZy5yZWxlYXNlKHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogTWFwcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBrZXksIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZnVuYyBUaGUgbWFwIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgZm9yIG1hcEZ1bmN0aW9uLlxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGZ1bmMsIGNvbnRleHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGREdW1teSh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhc1xuICogYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAqL1xuZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbiwgY29udGV4dCkge1xuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaFNpbmdsZUNoaWxkRHVtbXksIG51bGwpO1xufVxuXG4vKipcbiAqIEZsYXR0ZW4gYSBjaGlsZHJlbiBvYmplY3QgKHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCkgYW5kXG4gKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhcHByb3ByaWF0ZWx5IHJlLWtleWVkIGNoaWxkcmVuLlxuICovXG5mdW5jdGlvbiB0b0FycmF5KGNoaWxkcmVuKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgUmVhY3RDaGlsZHJlbiA9IHtcbiAgZm9yRWFjaDogZm9yRWFjaENoaWxkcmVuLFxuICBtYXA6IG1hcENoaWxkcmVuLFxuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsOiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsLFxuICBjb3VudDogY291bnRDaGlsZHJlbixcbiAgdG9BcnJheTogdG9BcnJheVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENoaWxkcmVuO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RDaGlsZHJlbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSB0cmF2ZXJzZUFsbENoaWxkcmVuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdEluc3RhbmNlSGFuZGxlcyA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZUhhbmRsZXMnKTtcblxudmFyIGdldEl0ZXJhdG9yRm4gPSByZXF1aXJlKCcuL2dldEl0ZXJhdG9yRm4nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgU0VQQVJBVE9SID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuU0VQQVJBVE9SO1xudmFyIFNVQlNFUEFSQVRPUiA9ICc6JztcblxuLyoqXG4gKiBUT0RPOiBUZXN0IHRoYXQgYSBzaW5nbGUgY2hpbGQgYW5kIGFuIGFycmF5IHdpdGggb25lIGl0ZW0gaGF2ZSB0aGUgc2FtZSBrZXlcbiAqIHBhdHRlcm4uXG4gKi9cblxudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZXJMb29rdXAgPSB7XG4gICc9JzogJz0wJyxcbiAgJy4nOiAnPTEnLFxuICAnOic6ICc9Midcbn07XG5cbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9bPS46XS9nO1xuXG52YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xuXG5mdW5jdGlvbiB1c2VyUHJvdmlkZWRLZXlFc2NhcGVyKG1hdGNoKSB7XG4gIHJldHVybiB1c2VyUHJvdmlkZWRLZXlFc2NhcGVyTG9va3VwW21hdGNoXTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGtleSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIGEgY29tcG9uZW50IHdpdGhpbiBhIHNldC5cbiAqXG4gKiBAcGFyYW0geyp9IGNvbXBvbmVudCBBIGNvbXBvbmVudCB0aGF0IGNvdWxkIGNvbnRhaW4gYSBtYW51YWwga2V5LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IHRoYXQgaXMgdXNlZCBpZiBhIG1hbnVhbCBrZXkgaXMgbm90IHByb3ZpZGVkLlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRDb21wb25lbnRLZXkoY29tcG9uZW50LCBpbmRleCkge1xuICBpZiAoY29tcG9uZW50ICYmIGNvbXBvbmVudC5rZXkgIT0gbnVsbCkge1xuICAgIC8vIEV4cGxpY2l0IGtleVxuICAgIHJldHVybiB3cmFwVXNlclByb3ZpZGVkS2V5KGNvbXBvbmVudC5rZXkpO1xuICB9XG4gIC8vIEltcGxpY2l0IGtleSBkZXRlcm1pbmVkIGJ5IHRoZSBpbmRleCBpbiB0aGUgc2V0XG4gIHJldHVybiBpbmRleC50b1N0cmluZygzNik7XG59XG5cbi8qKlxuICogRXNjYXBlIGEgY29tcG9uZW50IGtleSBzbyB0aGF0IGl0IGlzIHNhZmUgdG8gdXNlIGluIGEgcmVhY3RpZC5cbiAqXG4gKiBAcGFyYW0geyp9IHRleHQgQ29tcG9uZW50IGtleSB0byBiZSBlc2NhcGVkLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHRleHQpIHtcbiAgcmV0dXJuICgnJyArIHRleHQpLnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsIHVzZXJQcm92aWRlZEtleUVzY2FwZXIpO1xufVxuXG4vKipcbiAqIFdyYXAgYSBga2V5YCB2YWx1ZSBleHBsaWNpdGx5IHByb3ZpZGVkIGJ5IHRoZSB1c2VyIHRvIGRpc3Rpbmd1aXNoIGl0IGZyb21cbiAqIGltcGxpY2l0bHktZ2VuZXJhdGVkIGtleXMgZ2VuZXJhdGVkIGJ5IGEgY29tcG9uZW50J3MgaW5kZXggaW4gaXRzIHBhcmVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFZhbHVlIG9mIGEgdXNlci1wcm92aWRlZCBga2V5YCBhdHRyaWJ1dGVcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gd3JhcFVzZXJQcm92aWRlZEtleShrZXkpIHtcbiAgcmV0dXJuICckJyArIGVzY2FwZVVzZXJQcm92aWRlZEtleShrZXkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lU29GYXIgTmFtZSBvZiB0aGUga2V5IHBhdGggc28gZmFyLlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aXRoIGVhY2ggY2hpbGQgZm91bmQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgVXNlZCB0byBwYXNzIGluZm9ybWF0aW9uIHRocm91Z2hvdXQgdGhlIHRyYXZlcnNhbFxuICogcHJvY2Vzcy5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgbmFtZVNvRmFyLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xuXG4gIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyBBbGwgb2YgdGhlIGFib3ZlIGFyZSBwZXJjZWl2ZWQgYXMgbnVsbC5cbiAgICBjaGlsZHJlbiA9IG51bGw7XG4gIH1cblxuICBpZiAoY2hpbGRyZW4gPT09IG51bGwgfHwgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZSA9PT0gJ251bWJlcicgfHwgUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSkge1xuICAgIGNhbGxiYWNrKHRyYXZlcnNlQ29udGV4dCwgY2hpbGRyZW4sXG4gICAgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzLlxuICAgIG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGRyZW4sIDApIDogbmFtZVNvRmFyKTtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBjaGlsZDtcbiAgdmFyIG5leHROYW1lO1xuICB2YXIgc3VidHJlZUNvdW50ID0gMDsgLy8gQ291bnQgb2YgY2hpbGRyZW4gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3VidHJlZS5cbiAgdmFyIG5leHROYW1lUHJlZml4ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiA6IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUjtcblxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaSk7XG4gICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcbiAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGNoaWxkcmVuKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IGNoaWxkcmVuLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGlpID0gMDtcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGNoaWxkID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhkaWRXYXJuQWJvdXRNYXBzLCAnVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3QgeWV0IGZ1bGx5IHN1cHBvcnRlZC4gSXQgaXMgYW4gJyArICdleHBlcmltZW50YWwgZmVhdHVyZSB0aGF0IG1pZ2h0IGJlIHJlbW92ZWQuIENvbnZlcnQgaXQgdG8gYSAnICsgJ3NlcXVlbmNlIC8gaXRlcmFibGUgb2Yga2V5ZWQgUmVhY3RFbGVtZW50cyBpbnN0ZWFkLicpIDogdW5kZWZpbmVkO1xuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgIGNoaWxkID0gZW50cnlbMV07XG4gICAgICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgd3JhcFVzZXJQcm92aWRlZEtleShlbnRyeVswXSkgKyBTVUJTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIDApO1xuICAgICAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBhZGRlbmR1bSA9ICcgSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSAnICsgJ2luc3RlYWQgb3Igd3JhcCB0aGUgb2JqZWN0IHVzaW5nIGNyZWF0ZUZyYWdtZW50KG9iamVjdCkgZnJvbSB0aGUgJyArICdSZWFjdCBhZGQtb25zLic7XG4gICAgICAgIGlmIChjaGlsZHJlbi5faXNSZWFjdEVsZW1lbnQpIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgSXQgbG9va3MgbGlrZSB5b3VcXCdyZSB1c2luZyBhbiBlbGVtZW50IGNyZWF0ZWQgYnkgYSBkaWZmZXJlbnQgJyArICd2ZXJzaW9uIG9mIFJlYWN0LiBNYWtlIHN1cmUgdG8gdXNlIG9ubHkgb25lIGNvcHkgb2YgUmVhY3QuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgICAgIHZhciBuYW1lID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCk7XG4gICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIGFkZGVuZHVtICs9ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9IFN0cmluZyhjaGlsZHJlbik7XG4gICAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiAlcykuJXMnLCBjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcsIGFkZGVuZHVtKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN1YnRyZWVDb3VudDtcbn1cblxuLyoqXG4gKiBUcmF2ZXJzZXMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLCBidXRcbiAqIG1pZ2h0IGFsc28gYmUgc3BlY2lmaWVkIHRocm91Z2ggYXR0cmlidXRlczpcbiAqXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMuY2hpbGRyZW4sIC4uLilgXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMubGVmdFBhbmVsQ2hpbGRyZW4sIC4uLilgXG4gKlxuICogVGhlIGB0cmF2ZXJzZUNvbnRleHRgIGlzIGFuIG9wdGlvbmFsIGFyZ3VtZW50IHRoYXQgaXMgcGFzc2VkIHRocm91Z2ggdGhlXG4gKiBlbnRpcmUgdHJhdmVyc2FsLiBJdCBjYW4gYmUgdXNlZCB0byBzdG9yZSBhY2N1bXVsYXRpb25zIG9yIGFueXRoaW5nIGVsc2UgdGhhdFxuICogdGhlIGNhbGxiYWNrIG1pZ2h0IGZpbmQgcmVsZXZhbnQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBvYmplY3QuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgVG8gaW52b2tlIHVwb24gdHJhdmVyc2luZyBlYWNoIGNoaWxkLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IENvbnRleHQgZm9yIHRyYXZlcnNhbC5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sICcnLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0cmF2ZXJzZUFsbENoaWxkcmVuO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvdHJhdmVyc2VBbGxDaGlsZHJlbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVNlbGVjdFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIExpbmtlZFZhbHVlVXRpbHMgPSByZXF1aXJlKCcuL0xpbmtlZFZhbHVlVXRpbHMnKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciB2YWx1ZUNvbnRleHRLZXkgPSAnX19SZWFjdERPTVNlbGVjdF92YWx1ZSQnICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG5cbmZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnNJZlBlbmRpbmdVcGRhdGVBbmRNb3VudGVkKCkge1xuICBpZiAodGhpcy5fcm9vdE5vZGVJRCAmJiB0aGlzLl93cmFwcGVyU3RhdGUucGVuZGluZ1VwZGF0ZSkge1xuICAgIHRoaXMuX3dyYXBwZXJTdGF0ZS5wZW5kaW5nVXBkYXRlID0gZmFsc2U7XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcblxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICB1cGRhdGVPcHRpb25zKHRoaXMsIEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpLCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikge1xuICBpZiAob3duZXIpIHtcbiAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgdmFsdWVQcm9wTmFtZXMgPSBbJ3ZhbHVlJywgJ2RlZmF1bHRWYWx1ZSddO1xuXG4vKipcbiAqIFZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tTZWxlY3RQcm9wVHlwZXMoaW5zdCwgcHJvcHMpIHtcbiAgdmFyIG93bmVyID0gaW5zdC5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICBMaW5rZWRWYWx1ZVV0aWxzLmNoZWNrUHJvcFR5cGVzKCdzZWxlY3QnLCBwcm9wcywgb3duZXIpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVQcm9wTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcE5hbWUgPSB2YWx1ZVByb3BOYW1lc1tpXTtcbiAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAocHJvcHMubXVsdGlwbGUpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKEFycmF5LmlzQXJyYXkocHJvcHNbcHJvcE5hbWVdKSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhbiBhcnJheSBpZiAnICsgJ2BtdWx0aXBsZWAgaXMgdHJ1ZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpKSA6IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIUFycmF5LmlzQXJyYXkocHJvcHNbcHJvcE5hbWVdKSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhIHNjYWxhciAnICsgJ3ZhbHVlIGlmIGBtdWx0aXBsZWAgaXMgZmFsc2UuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSkgOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFjdERPTUNvbXBvbmVudH0gaW5zdFxuICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBsZVxuICogQHBhcmFtIHsqfSBwcm9wVmFsdWUgQSBzdHJpbmdhYmxlICh3aXRoIGBtdWx0aXBsZWAsIGEgbGlzdCBvZiBzdHJpbmdhYmxlcykuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zKGluc3QsIG11bHRpcGxlLCBwcm9wVmFsdWUpIHtcbiAgdmFyIHNlbGVjdGVkVmFsdWUsIGk7XG4gIHZhciBvcHRpb25zID0gUmVhY3RNb3VudC5nZXROb2RlKGluc3QuX3Jvb3ROb2RlSUQpLm9wdGlvbnM7XG5cbiAgaWYgKG11bHRpcGxlKSB7XG4gICAgc2VsZWN0ZWRWYWx1ZSA9IHt9O1xuICAgIGZvciAoaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNlbGVjdGVkVmFsdWVbJycgKyBwcm9wVmFsdWVbaV1dID0gdHJ1ZTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IHNlbGVjdGVkVmFsdWUuaGFzT3duUHJvcGVydHkob3B0aW9uc1tpXS52YWx1ZSk7XG4gICAgICBpZiAob3B0aW9uc1tpXS5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uc1tpXS5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBEbyBub3Qgc2V0IGBzZWxlY3QudmFsdWVgIGFzIGV4YWN0IGJlaGF2aW9yIGlzbid0IGNvbnNpc3RlbnQgYWNyb3NzIGFsbFxuICAgIC8vIGJyb3dzZXJzIGZvciBhbGwgY2FzZXMuXG4gICAgc2VsZWN0ZWRWYWx1ZSA9ICcnICsgcHJvcFZhbHVlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAob3B0aW9uc1tpXS52YWx1ZSA9PT0gc2VsZWN0ZWRWYWx1ZSkge1xuICAgICAgICBvcHRpb25zW2ldLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgIG9wdGlvbnNbMF0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8c2VsZWN0PiBuYXRpdmUgY29tcG9uZW50IHRoYXQgYWxsb3dzIG9wdGlvbmFsbHkgc2V0dGluZyB0aGVcbiAqIHByb3BzIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLiBJZiBgbXVsdGlwbGVgIGlzIGZhbHNlLCB0aGUgcHJvcCBtdXN0IGJlIGFcbiAqIHN0cmluZ2FibGUuIElmIGBtdWx0aXBsZWAgaXMgdHJ1ZSwgdGhlIHByb3AgbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmdhYmxlcy5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBjaGFuZ2UgdGhlXG4gKiBzZWxlY3RlZCBvcHRpb24gd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gKlxuICogSWYgaXQgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgb3B0aW9ucyB3aWxsIG5vdFxuICogdXBkYXRlIGluIHJlc3BvbnNlIHRvIHVzZXIgYWN0aW9ucy4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBvcHRpb25zIHRvIHVwZGF0ZS5cbiAqXG4gKiBJZiBgZGVmYXVsdFZhbHVlYCBpcyBwcm92aWRlZCwgYW55IG9wdGlvbnMgd2l0aCB0aGUgc3VwcGxpZWQgdmFsdWVzIHdpbGwgYmVcbiAqIHNlbGVjdGVkLlxuICovXG52YXIgUmVhY3RET01TZWxlY3QgPSB7XG4gIHZhbHVlQ29udGV4dEtleTogdmFsdWVDb250ZXh0S2V5LFxuXG4gIGdldE5hdGl2ZVByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgb25DaGFuZ2U6IGluc3QuX3dyYXBwZXJTdGF0ZS5vbkNoYW5nZSxcbiAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICB9KTtcbiAgfSxcblxuICBtb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjaGVja1NlbGVjdFByb3BUeXBlcyhpbnN0LCBwcm9wcyk7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgaW5zdC5fd3JhcHBlclN0YXRlID0ge1xuICAgICAgcGVuZGluZ1VwZGF0ZTogZmFsc2UsXG4gICAgICBpbml0aWFsVmFsdWU6IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IHByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICAgIG9uQ2hhbmdlOiBfaGFuZGxlQ2hhbmdlLmJpbmQoaW5zdCksXG4gICAgICB3YXNNdWx0aXBsZTogQm9vbGVhbihwcm9wcy5tdWx0aXBsZSlcbiAgICB9O1xuICB9LFxuXG4gIHByb2Nlc3NDaGlsZENvbnRleHQ6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcywgY29udGV4dCkge1xuICAgIC8vIFBhc3MgZG93biBpbml0aWFsIHZhbHVlIHNvIGluaXRpYWwgZ2VuZXJhdGVkIG1hcmt1cCBoYXMgY29ycmVjdFxuICAgIC8vIGBzZWxlY3RlZGAgYXR0cmlidXRlc1xuICAgIHZhciBjaGlsZENvbnRleHQgPSBhc3NpZ24oe30sIGNvbnRleHQpO1xuICAgIGNoaWxkQ29udGV4dFt2YWx1ZUNvbnRleHRLZXldID0gaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZTtcbiAgICByZXR1cm4gY2hpbGRDb250ZXh0O1xuICB9LFxuXG4gIHBvc3RVcGRhdGVXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIHZhciBwcm9wcyA9IGluc3QuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgLy8gQWZ0ZXIgdGhlIGluaXRpYWwgbW91bnQsIHdlIGNvbnRyb2wgc2VsZWN0ZWQtbmVzcyBtYW51YWxseSBzbyBkb24ndCBwYXNzXG4gICAgLy8gdGhlIGNvbnRleHQgdmFsdWUgZG93blxuICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUgPSB1bmRlZmluZWQ7XG5cbiAgICB2YXIgd2FzTXVsdGlwbGUgPSBpbnN0Ll93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGU7XG4gICAgaW5zdC5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlID0gQm9vbGVhbihwcm9wcy5tdWx0aXBsZSk7XG5cbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLnBlbmRpbmdVcGRhdGUgPSBmYWxzZTtcbiAgICAgIHVwZGF0ZU9wdGlvbnMoaW5zdCwgQm9vbGVhbihwcm9wcy5tdWx0aXBsZSksIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHdhc011bHRpcGxlICE9PSBCb29sZWFuKHByb3BzLm11bHRpcGxlKSkge1xuICAgICAgLy8gRm9yIHNpbXBsaWNpdHksIHJlYXBwbHkgYGRlZmF1bHRWYWx1ZWAgaWYgYG11bHRpcGxlYCBpcyB0b2dnbGVkLlxuICAgICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZU9wdGlvbnMoaW5zdCwgQm9vbGVhbihwcm9wcy5tdWx0aXBsZSksIHByb3BzLmRlZmF1bHRWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXZlcnQgdGhlIHNlbGVjdCBiYWNrIHRvIGl0cyBkZWZhdWx0IHVuc2VsZWN0ZWQgc3RhdGUuXG4gICAgICAgIHVwZGF0ZU9wdGlvbnMoaW5zdCwgQm9vbGVhbihwcm9wcy5tdWx0aXBsZSksIHByb3BzLm11bHRpcGxlID8gW10gOiAnJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBfaGFuZGxlQ2hhbmdlKGV2ZW50KSB7XG4gIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICB2YXIgcmV0dXJuVmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmV4ZWN1dGVPbkNoYW5nZShwcm9wcywgZXZlbnQpO1xuXG4gIHRoaXMuX3dyYXBwZXJTdGF0ZS5wZW5kaW5nVXBkYXRlID0gdHJ1ZTtcbiAgUmVhY3RVcGRhdGVzLmFzYXAodXBkYXRlT3B0aW9uc0lmUGVuZGluZ1VwZGF0ZUFuZE1vdW50ZWQsIHRoaXMpO1xuICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01TZWxlY3Q7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTVNlbGVjdC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVRleHRhcmVhXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHJlcXVpcmUoJy4vTGlua2VkVmFsdWVVdGlscycpO1xudmFyIFJlYWN0RE9NSURPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9SZWFjdERPTUlET3BlcmF0aW9ucycpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiBmb3JjZVVwZGF0ZUlmTW91bnRlZCgpIHtcbiAgaWYgKHRoaXMuX3Jvb3ROb2RlSUQpIHtcbiAgICAvLyBET00gY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWQ7IHVwZGF0ZVxuICAgIFJlYWN0RE9NVGV4dGFyZWEudXBkYXRlV3JhcHBlcih0aGlzKTtcbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8dGV4dGFyZWE+IG5hdGl2ZSBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyBgdmFsdWVgLCBhbmRcbiAqIGBkZWZhdWx0VmFsdWVgLiBUaGlzIGRpZmZlcnMgZnJvbSB0aGUgdHJhZGl0aW9uYWwgRE9NIEFQSSBiZWNhdXNlIHZhbHVlIGlzXG4gKiB1c3VhbGx5IHNldCBhcyBQQ0RBVEEgY2hpbGRyZW4uXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgYWZmZWN0IHRoZVxuICogdmFsdWUgd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGxcbiAqIG5vdCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byBiZSB1cGRhdGVkLlxuICpcbiAqIFRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhbiBlbXB0eSB2YWx1ZSwgdGhlIHByb3BcbiAqIGBkZWZhdWx0VmFsdWVgIGlmIHNwZWNpZmllZCwgb3IgdGhlIGNoaWxkcmVuIGNvbnRlbnQgKGRlcHJlY2F0ZWQpLlxuICovXG52YXIgUmVhY3RET01UZXh0YXJlYSA9IHtcbiAgZ2V0TmF0aXZlUHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcywgY29udGV4dCkge1xuICAgICEocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBkb2VzIG5vdCBtYWtlIHNlbnNlIG9uIDx0ZXh0YXJlYT4uJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgLy8gQWx3YXlzIHNldCBjaGlsZHJlbiB0byB0aGUgc2FtZSB0aGluZy4gSW4gSUU5LCB0aGUgc2VsZWN0aW9uIHJhbmdlIHdpbGxcbiAgICAvLyBnZXQgcmVzZXQgaWYgYHRleHRDb250ZW50YCBpcyBtdXRhdGVkLlxuICAgIHZhciBuYXRpdmVQcm9wcyA9IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIGNoaWxkcmVuOiBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlLFxuICAgICAgb25DaGFuZ2U6IGluc3QuX3dyYXBwZXJTdGF0ZS5vbkNoYW5nZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5hdGl2ZVByb3BzO1xuICB9LFxuXG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIExpbmtlZFZhbHVlVXRpbHMuY2hlY2tQcm9wVHlwZXMoJ3RleHRhcmVhJywgcHJvcHMsIGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcik7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgY2hpbGRyZW4gY29udGVudCBpbiA8dGV4dGFyZWE+LlxuICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICAgIGlmIChjaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBpbnN0ZWFkIG9mIHNldHRpbmcgJyArICdjaGlsZHJlbiBvbiA8dGV4dGFyZWE+LicpIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgIShkZWZhdWx0VmFsdWUgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnSWYgeW91IHN1cHBseSBgZGVmYXVsdFZhbHVlYCBvbiBhIDx0ZXh0YXJlYT4sIGRvIG5vdCBwYXNzIGNoaWxkcmVuLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAhKGNoaWxkcmVuLmxlbmd0aCA8PSAxKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICc8dGV4dGFyZWE+IGNhbiBvbmx5IGhhdmUgYXQgbW9zdCBvbmUgY2hpbGQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuWzBdO1xuICAgICAgfVxuXG4gICAgICBkZWZhdWx0VmFsdWUgPSAnJyArIGNoaWxkcmVuO1xuICAgIH1cbiAgICBpZiAoZGVmYXVsdFZhbHVlID09IG51bGwpIHtcbiAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcblxuICAgIGluc3QuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICAgIC8vIFdlIHNhdmUgdGhlIGluaXRpYWwgdmFsdWUgc28gdGhhdCBgUmVhY3RET01Db21wb25lbnRgIGRvZXNuJ3QgdXBkYXRlXG4gICAgICAvLyBgdGV4dENvbnRlbnRgICh1bm5lY2Vzc2FyeSBzaW5jZSB3ZSB1cGRhdGUgdmFsdWUpLlxuICAgICAgLy8gVGhlIGluaXRpYWwgdmFsdWUgY2FuIGJlIGEgYm9vbGVhbiBvciBvYmplY3Qgc28gdGhhdCdzIHdoeSBpdCdzXG4gICAgICAvLyBmb3JjZWQgdG8gYmUgYSBzdHJpbmcuXG4gICAgICBpbml0aWFsVmFsdWU6ICcnICsgKHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IGRlZmF1bHRWYWx1ZSksXG4gICAgICBvbkNoYW5nZTogX2hhbmRsZUNoYW5nZS5iaW5kKGluc3QpXG4gICAgfTtcbiAgfSxcblxuICB1cGRhdGVXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIHZhciBwcm9wcyA9IGluc3QuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGRvIHRoaXMgYXMgbmVjZXNzYXJ5LCBqc2RvbSBkb2Vzbid0LlxuICAgICAgUmVhY3RET01JRE9wZXJhdGlvbnMudXBkYXRlUHJvcGVydHlCeUlEKGluc3QuX3Jvb3ROb2RlSUQsICd2YWx1ZScsICcnICsgdmFsdWUpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gX2hhbmRsZUNoYW5nZShldmVudCkge1xuICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgdmFyIHJldHVyblZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5leGVjdXRlT25DaGFuZ2UocHJvcHMsIGV2ZW50KTtcbiAgUmVhY3RVcGRhdGVzLmFzYXAoZm9yY2VVcGRhdGVJZk1vdW50ZWQsIHRoaXMpO1xuICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01UZXh0YXJlYTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NVGV4dGFyZWEuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RNdWx0aUNoaWxkXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMnKTtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG52YXIgUmVhY3RDaGlsZFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0Q2hpbGRSZWNvbmNpbGVyJyk7XG5cbnZhciBmbGF0dGVuQ2hpbGRyZW4gPSByZXF1aXJlKCcuL2ZsYXR0ZW5DaGlsZHJlbicpO1xuXG4vKipcbiAqIFVwZGF0aW5nIGNoaWxkcmVuIG9mIGEgY29tcG9uZW50IG1heSB0cmlnZ2VyIHJlY3Vyc2l2ZSB1cGRhdGVzLiBUaGUgZGVwdGggaXNcbiAqIHVzZWQgdG8gYmF0Y2ggcmVjdXJzaXZlIHVwZGF0ZXMgdG8gcmVuZGVyIG1hcmt1cCBtb3JlIGVmZmljaWVudGx5LlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgdXBkYXRlRGVwdGggPSAwO1xuXG4vKipcbiAqIFF1ZXVlIG9mIHVwZGF0ZSBjb25maWd1cmF0aW9uIG9iamVjdHMuXG4gKlxuICogRWFjaCBvYmplY3QgaGFzIGEgYHR5cGVgIHByb3BlcnR5IHRoYXQgaXMgaW4gYFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzYC5cbiAqXG4gKiBAdHlwZSB7YXJyYXk8b2JqZWN0Pn1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciB1cGRhdGVRdWV1ZSA9IFtdO1xuXG4vKipcbiAqIFF1ZXVlIG9mIG1hcmt1cCB0byBiZSByZW5kZXJlZC5cbiAqXG4gKiBAdHlwZSB7YXJyYXk8c3RyaW5nPn1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBtYXJrdXBRdWV1ZSA9IFtdO1xuXG4vKipcbiAqIEVucXVldWVzIG1hcmt1cCB0byBiZSByZW5kZXJlZCBhbmQgaW5zZXJ0ZWQgYXQgYSBzdXBwbGllZCBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50SUQgSUQgb2YgdGhlIHBhcmVudCBjb21wb25lbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCB0aGF0IHJlbmRlcnMgaW50byBhbiBlbGVtZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggRGVzdGluYXRpb24gaW5kZXguXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbnF1ZXVlSW5zZXJ0TWFya3VwKHBhcmVudElELCBtYXJrdXAsIHRvSW5kZXgpIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICB1cGRhdGVRdWV1ZS5wdXNoKHtcbiAgICBwYXJlbnRJRDogcGFyZW50SUQsXG4gICAgcGFyZW50Tm9kZTogbnVsbCxcbiAgICB0eXBlOiBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5JTlNFUlRfTUFSS1VQLFxuICAgIG1hcmt1cEluZGV4OiBtYXJrdXBRdWV1ZS5wdXNoKG1hcmt1cCkgLSAxLFxuICAgIGNvbnRlbnQ6IG51bGwsXG4gICAgZnJvbUluZGV4OiBudWxsLFxuICAgIHRvSW5kZXg6IHRvSW5kZXhcbiAgfSk7XG59XG5cbi8qKlxuICogRW5xdWV1ZXMgbW92aW5nIGFuIGV4aXN0aW5nIGVsZW1lbnQgdG8gYW5vdGhlciBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50SUQgSUQgb2YgdGhlIHBhcmVudCBjb21wb25lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFNvdXJjZSBpbmRleCBvZiB0aGUgZXhpc3RpbmcgZWxlbWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IERlc3RpbmF0aW9uIGluZGV4IG9mIHRoZSBlbGVtZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZU1vdmUocGFyZW50SUQsIGZyb21JbmRleCwgdG9JbmRleCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHVwZGF0ZVF1ZXVlLnB1c2goe1xuICAgIHBhcmVudElEOiBwYXJlbnRJRCxcbiAgICBwYXJlbnROb2RlOiBudWxsLFxuICAgIHR5cGU6IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLk1PVkVfRVhJU1RJTkcsXG4gICAgbWFya3VwSW5kZXg6IG51bGwsXG4gICAgY29udGVudDogbnVsbCxcbiAgICBmcm9tSW5kZXg6IGZyb21JbmRleCxcbiAgICB0b0luZGV4OiB0b0luZGV4XG4gIH0pO1xufVxuXG4vKipcbiAqIEVucXVldWVzIHJlbW92aW5nIGFuIGVsZW1lbnQgYXQgYW4gaW5kZXguXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudElEIElEIG9mIHRoZSBwYXJlbnQgY29tcG9uZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBJbmRleCBvZiB0aGUgZWxlbWVudCB0byByZW1vdmUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbnF1ZXVlUmVtb3ZlKHBhcmVudElELCBmcm9tSW5kZXgpIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICB1cGRhdGVRdWV1ZS5wdXNoKHtcbiAgICBwYXJlbnRJRDogcGFyZW50SUQsXG4gICAgcGFyZW50Tm9kZTogbnVsbCxcbiAgICB0eXBlOiBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5SRU1PVkVfTk9ERSxcbiAgICBtYXJrdXBJbmRleDogbnVsbCxcbiAgICBjb250ZW50OiBudWxsLFxuICAgIGZyb21JbmRleDogZnJvbUluZGV4LFxuICAgIHRvSW5kZXg6IG51bGxcbiAgfSk7XG59XG5cbi8qKlxuICogRW5xdWV1ZXMgc2V0dGluZyB0aGUgbWFya3VwIG9mIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50SUQgSUQgb2YgdGhlIHBhcmVudCBjb21wb25lbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCB0aGF0IHJlbmRlcnMgaW50byBhbiBlbGVtZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZVNldE1hcmt1cChwYXJlbnRJRCwgbWFya3VwKSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgdXBkYXRlUXVldWUucHVzaCh7XG4gICAgcGFyZW50SUQ6IHBhcmVudElELFxuICAgIHBhcmVudE5vZGU6IG51bGwsXG4gICAgdHlwZTogUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuU0VUX01BUktVUCxcbiAgICBtYXJrdXBJbmRleDogbnVsbCxcbiAgICBjb250ZW50OiBtYXJrdXAsXG4gICAgZnJvbUluZGV4OiBudWxsLFxuICAgIHRvSW5kZXg6IG51bGxcbiAgfSk7XG59XG5cbi8qKlxuICogRW5xdWV1ZXMgc2V0dGluZyB0aGUgdGV4dCBjb250ZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRJRCBJRCBvZiB0aGUgcGFyZW50IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0Q29udGVudCBUZXh0IGNvbnRlbnQgdG8gc2V0LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZVRleHRDb250ZW50KHBhcmVudElELCB0ZXh0Q29udGVudCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHVwZGF0ZVF1ZXVlLnB1c2goe1xuICAgIHBhcmVudElEOiBwYXJlbnRJRCxcbiAgICBwYXJlbnROb2RlOiBudWxsLFxuICAgIHR5cGU6IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlRFWFRfQ09OVEVOVCxcbiAgICBtYXJrdXBJbmRleDogbnVsbCxcbiAgICBjb250ZW50OiB0ZXh0Q29udGVudCxcbiAgICBmcm9tSW5kZXg6IG51bGwsXG4gICAgdG9JbmRleDogbnVsbFxuICB9KTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzZXMgYW55IGVucXVldWVkIHVwZGF0ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc1F1ZXVlKCkge1xuICBpZiAodXBkYXRlUXVldWUubGVuZ3RoKSB7XG4gICAgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5wcm9jZXNzQ2hpbGRyZW5VcGRhdGVzKHVwZGF0ZVF1ZXVlLCBtYXJrdXBRdWV1ZSk7XG4gICAgY2xlYXJRdWV1ZSgpO1xuICB9XG59XG5cbi8qKlxuICogQ2xlYXJzIGFueSBlbnF1ZXVlZCB1cGRhdGVzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNsZWFyUXVldWUoKSB7XG4gIHVwZGF0ZVF1ZXVlLmxlbmd0aCA9IDA7XG4gIG1hcmt1cFF1ZXVlLmxlbmd0aCA9IDA7XG59XG5cbi8qKlxuICogUmVhY3RNdWx0aUNoaWxkIGFyZSBjYXBhYmxlIG9mIHJlY29uY2lsaW5nIG11bHRpcGxlIGNoaWxkcmVuLlxuICpcbiAqIEBjbGFzcyBSZWFjdE11bHRpQ2hpbGRcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RNdWx0aUNoaWxkID0ge1xuXG4gIC8qKlxuICAgKiBQcm92aWRlcyBjb21tb24gZnVuY3Rpb25hbGl0eSBmb3IgY29tcG9uZW50cyB0aGF0IG11c3QgcmVjb25jaWxlIG11bHRpcGxlXG4gICAqIGNoaWxkcmVuLiBUaGlzIGlzIHVzZWQgYnkgYFJlYWN0RE9NQ29tcG9uZW50YCB0byBtb3VudCwgdXBkYXRlLCBhbmRcbiAgICogdW5tb3VudCBjaGlsZCBjb21wb25lbnRzLlxuICAgKlxuICAgKiBAbGVuZHMge1JlYWN0TXVsdGlDaGlsZC5wcm90b3R5cGV9XG4gICAqL1xuICBNaXhpbjoge1xuXG4gICAgX3JlY29uY2lsZXJJbnN0YW50aWF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAobmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudEVsZW1lbnQpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdENoaWxkUmVjb25jaWxlci5pbnN0YW50aWF0ZUNoaWxkcmVuKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLmluc3RhbnRpYXRlQ2hpbGRyZW4obmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgX3JlY29uY2lsZXJVcGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKHByZXZDaGlsZHJlbiwgbmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICB2YXIgbmV4dENoaWxkcmVuO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgICBuZXh0Q2hpbGRyZW4gPSBmbGF0dGVuQ2hpbGRyZW4obmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVwZGF0ZUNoaWxkcmVuKHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5leHRDaGlsZHJlbiA9IGZsYXR0ZW5DaGlsZHJlbihuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cyk7XG4gICAgICByZXR1cm4gUmVhY3RDaGlsZFJlY29uY2lsZXIudXBkYXRlQ2hpbGRyZW4ocHJldkNoaWxkcmVuLCBuZXh0Q2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgXCJtb3VudCBpbWFnZVwiIGZvciBlYWNoIG9mIHRoZSBzdXBwbGllZCBjaGlsZHJlbi4gSW4gdGhlIGNhc2VcbiAgICAgKiBvZiBgUmVhY3RET01Db21wb25lbnRgLCBhIG1vdW50IGltYWdlIGlzIGEgc3RyaW5nIG9mIG1hcmt1cC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmVzdGVkQ2hpbGRyZW4gTmVzdGVkIGNoaWxkIG1hcHMuXG4gICAgICogQHJldHVybiB7YXJyYXl9IEFuIGFycmF5IG9mIG1vdW50ZWQgcmVwcmVzZW50YXRpb25zLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIG1vdW50Q2hpbGRyZW46IGZ1bmN0aW9uIChuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX3JlY29uY2lsZXJJbnN0YW50aWF0ZUNoaWxkcmVuKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICB2YXIgbW91bnRJbWFnZXMgPSBbXTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChjaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW25hbWVdO1xuICAgICAgICAgIC8vIElubGluZWQgZm9yIHBlcmZvcm1hbmNlLCBzZWUgYFJlYWN0SW5zdGFuY2VIYW5kbGVzLmNyZWF0ZVJlYWN0SURgLlxuICAgICAgICAgIHZhciByb290SUQgPSB0aGlzLl9yb290Tm9kZUlEICsgbmFtZTtcbiAgICAgICAgICB2YXIgbW91bnRJbWFnZSA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudChjaGlsZCwgcm9vdElELCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgICAgY2hpbGQuX21vdW50SW5kZXggPSBpbmRleCsrO1xuICAgICAgICAgIG1vdW50SW1hZ2VzLnB1c2gobW91bnRJbWFnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtb3VudEltYWdlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgYW55IHJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSB0ZXh0IGNvbnRlbnQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5leHRDb250ZW50IFN0cmluZyBvZiBjb250ZW50LlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVwZGF0ZVRleHRDb250ZW50OiBmdW5jdGlvbiAobmV4dENvbnRlbnQpIHtcbiAgICAgIHVwZGF0ZURlcHRoKys7XG4gICAgICB2YXIgZXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgICAgIC8vIFJlbW92ZSBhbnkgcmVuZGVyZWQgY2hpbGRyZW4uXG4gICAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVubW91bnRDaGlsZHJlbihwcmV2Q2hpbGRyZW4pO1xuICAgICAgICAvLyBUT0RPOiBUaGUgc2V0VGV4dENvbnRlbnQgb3BlcmF0aW9uIHNob3VsZCBiZSBlbm91Z2hcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAocHJldkNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLl91bm1vdW50Q2hpbGQocHJldkNoaWxkcmVuW25hbWVdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IG5ldyB0ZXh0IGNvbnRlbnQuXG4gICAgICAgIHRoaXMuc2V0VGV4dENvbnRlbnQobmV4dENvbnRlbnQpO1xuICAgICAgICBlcnJvclRocm93biA9IGZhbHNlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdXBkYXRlRGVwdGgtLTtcbiAgICAgICAgaWYgKCF1cGRhdGVEZXB0aCkge1xuICAgICAgICAgIGlmIChlcnJvclRocm93bikge1xuICAgICAgICAgICAgY2xlYXJRdWV1ZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9jZXNzUXVldWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgYW55IHJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSBtYXJrdXAgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5leHRNYXJrdXAgU3RyaW5nIG9mIG1hcmt1cC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1cGRhdGVNYXJrdXA6IGZ1bmN0aW9uIChuZXh0TWFya3VwKSB7XG4gICAgICB1cGRhdGVEZXB0aCsrO1xuICAgICAgdmFyIGVycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLl9yZW5kZXJlZENoaWxkcmVuO1xuICAgICAgICAvLyBSZW1vdmUgYW55IHJlbmRlcmVkIGNoaWxkcmVuLlxuICAgICAgICBSZWFjdENoaWxkUmVjb25jaWxlci51bm1vdW50Q2hpbGRyZW4ocHJldkNoaWxkcmVuKTtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAocHJldkNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLl91bm1vdW50Q2hpbGRCeU5hbWUocHJldkNoaWxkcmVuW25hbWVdLCBuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRNYXJrdXAobmV4dE1hcmt1cCk7XG4gICAgICAgIGVycm9yVGhyb3duID0gZmFsc2U7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1cGRhdGVEZXB0aC0tO1xuICAgICAgICBpZiAoIXVwZGF0ZURlcHRoKSB7XG4gICAgICAgICAgaWYgKGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgICBjbGVhclF1ZXVlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb2Nlc3NRdWV1ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSByZW5kZXJlZCBjaGlsZHJlbiB3aXRoIG5ldyBjaGlsZHJlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMgTmVzdGVkIGNoaWxkIGVsZW1lbnQgbWFwcy5cbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIHVwZGF0ZURlcHRoKys7XG4gICAgICB2YXIgZXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fdXBkYXRlQ2hpbGRyZW4obmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgZXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVwZGF0ZURlcHRoLS07XG4gICAgICAgIGlmICghdXBkYXRlRGVwdGgpIHtcbiAgICAgICAgICBpZiAoZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAgIGNsZWFyUXVldWUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvY2Vzc1F1ZXVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEltcHJvdmUgcGVyZm9ybWFuY2UgYnkgaXNvbGF0aW5nIHRoaXMgaG90IGNvZGUgcGF0aCBmcm9tIHRoZSB0cnkvY2F0Y2hcbiAgICAgKiBibG9jayBpbiBgdXBkYXRlQ2hpbGRyZW5gLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cyBOZXN0ZWQgY2hpbGQgZWxlbWVudCBtYXBzLlxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAZmluYWxcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3VwZGF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAobmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB0aGlzLl9yZWNvbmNpbGVyVXBkYXRlQ2hpbGRyZW4ocHJldkNoaWxkcmVuLCBuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IG5leHRDaGlsZHJlbjtcbiAgICAgIGlmICghbmV4dENoaWxkcmVuICYmICFwcmV2Q2hpbGRyZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG5hbWU7XG4gICAgICAvLyBgbmV4dEluZGV4YCB3aWxsIGluY3JlbWVudCBmb3IgZWFjaCBjaGlsZCBpbiBgbmV4dENoaWxkcmVuYCwgYnV0XG4gICAgICAvLyBgbGFzdEluZGV4YCB3aWxsIGJlIHRoZSBsYXN0IGluZGV4IHZpc2l0ZWQgaW4gYHByZXZDaGlsZHJlbmAuXG4gICAgICB2YXIgbGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciBuZXh0SW5kZXggPSAwO1xuICAgICAgZm9yIChuYW1lIGluIG5leHRDaGlsZHJlbikge1xuICAgICAgICBpZiAoIW5leHRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2Q2hpbGQgPSBwcmV2Q2hpbGRyZW4gJiYgcHJldkNoaWxkcmVuW25hbWVdO1xuICAgICAgICB2YXIgbmV4dENoaWxkID0gbmV4dENoaWxkcmVuW25hbWVdO1xuICAgICAgICBpZiAocHJldkNoaWxkID09PSBuZXh0Q2hpbGQpIHtcbiAgICAgICAgICB0aGlzLm1vdmVDaGlsZChwcmV2Q2hpbGQsIG5leHRJbmRleCwgbGFzdEluZGV4KTtcbiAgICAgICAgICBsYXN0SW5kZXggPSBNYXRoLm1heChwcmV2Q2hpbGQuX21vdW50SW5kZXgsIGxhc3RJbmRleCk7XG4gICAgICAgICAgcHJldkNoaWxkLl9tb3VudEluZGV4ID0gbmV4dEluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChwcmV2Q2hpbGQpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBgbGFzdEluZGV4YCBiZWZvcmUgYF9tb3VudEluZGV4YCBnZXRzIHVuc2V0IGJ5IHVubW91bnRpbmcuXG4gICAgICAgICAgICBsYXN0SW5kZXggPSBNYXRoLm1heChwcmV2Q2hpbGQuX21vdW50SW5kZXgsIGxhc3RJbmRleCk7XG4gICAgICAgICAgICB0aGlzLl91bm1vdW50Q2hpbGQocHJldkNoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVGhlIGNoaWxkIG11c3QgYmUgaW5zdGFudGlhdGVkIGJlZm9yZSBpdCdzIG1vdW50ZWQuXG4gICAgICAgICAgdGhpcy5fbW91bnRDaGlsZEJ5TmFtZUF0SW5kZXgobmV4dENoaWxkLCBuYW1lLCBuZXh0SW5kZXgsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0SW5kZXgrKztcbiAgICAgIH1cbiAgICAgIC8vIFJlbW92ZSBjaGlsZHJlbiB0aGF0IGFyZSBubyBsb25nZXIgcHJlc2VudC5cbiAgICAgIGZvciAobmFtZSBpbiBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKHByZXZDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAhKG5leHRDaGlsZHJlbiAmJiBuZXh0Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpKSB7XG4gICAgICAgICAgdGhpcy5fdW5tb3VudENoaWxkKHByZXZDaGlsZHJlbltuYW1lXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5tb3VudHMgYWxsIHJlbmRlcmVkIGNoaWxkcmVuLiBUaGlzIHNob3VsZCBiZSB1c2VkIHRvIGNsZWFuIHVwIGNoaWxkcmVuXG4gICAgICogd2hlbiB0aGlzIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1bm1vdW50Q2hpbGRyZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByZW5kZXJlZENoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVubW91bnRDaGlsZHJlbihyZW5kZXJlZENoaWxkcmVuKTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW4gPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhIGNoaWxkIGNvbXBvbmVudCB0byB0aGUgc3VwcGxpZWQgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gbW92ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9JbmRleCBEZXN0aW5hdGlvbiBpbmRleCBvZiB0aGUgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGFzdEluZGV4IExhc3QgaW5kZXggdmlzaXRlZCBvZiB0aGUgc2libGluZ3Mgb2YgYGNoaWxkYC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgbW92ZUNoaWxkOiBmdW5jdGlvbiAoY2hpbGQsIHRvSW5kZXgsIGxhc3RJbmRleCkge1xuICAgICAgLy8gSWYgdGhlIGluZGV4IG9mIGBjaGlsZGAgaXMgbGVzcyB0aGFuIGBsYXN0SW5kZXhgLCB0aGVuIGl0IG5lZWRzIHRvXG4gICAgICAvLyBiZSBtb3ZlZC4gT3RoZXJ3aXNlLCB3ZSBkbyBub3QgbmVlZCB0byBtb3ZlIGl0IGJlY2F1c2UgYSBjaGlsZCB3aWxsIGJlXG4gICAgICAvLyBpbnNlcnRlZCBvciBtb3ZlZCBiZWZvcmUgYGNoaWxkYC5cbiAgICAgIGlmIChjaGlsZC5fbW91bnRJbmRleCA8IGxhc3RJbmRleCkge1xuICAgICAgICBlbnF1ZXVlTW92ZSh0aGlzLl9yb290Tm9kZUlELCBjaGlsZC5fbW91bnRJbmRleCwgdG9JbmRleCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjaGlsZCBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gY3JlYXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb3VudEltYWdlIE1hcmt1cCB0byBpbnNlcnQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNyZWF0ZUNoaWxkOiBmdW5jdGlvbiAoY2hpbGQsIG1vdW50SW1hZ2UpIHtcbiAgICAgIGVucXVldWVJbnNlcnRNYXJrdXAodGhpcy5fcm9vdE5vZGVJRCwgbW91bnRJbWFnZSwgY2hpbGQuX21vdW50SW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgY2hpbGQgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ2hpbGQgdG8gcmVtb3ZlLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICByZW1vdmVDaGlsZDogZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICBlbnF1ZXVlUmVtb3ZlKHRoaXMuX3Jvb3ROb2RlSUQsIGNoaWxkLl9tb3VudEluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGlzIHRleHQgY29udGVudCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dENvbnRlbnQgVGV4dCBjb250ZW50IHRvIHNldC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2V0VGV4dENvbnRlbnQ6IGZ1bmN0aW9uICh0ZXh0Q29udGVudCkge1xuICAgICAgZW5xdWV1ZVRleHRDb250ZW50KHRoaXMuX3Jvb3ROb2RlSUQsIHRleHRDb250ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGlzIG1hcmt1cCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCB0byBzZXQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNldE1hcmt1cDogZnVuY3Rpb24gKG1hcmt1cCkge1xuICAgICAgZW5xdWV1ZVNldE1hcmt1cCh0aGlzLl9yb290Tm9kZUlELCBtYXJrdXApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3VudHMgYSBjaGlsZCB3aXRoIHRoZSBzdXBwbGllZCBuYW1lLlxuICAgICAqXG4gICAgICogTk9URTogVGhpcyBpcyBwYXJ0IG9mIGB1cGRhdGVDaGlsZHJlbmAgYW5kIGlzIGhlcmUgZm9yIHJlYWRhYmlsaXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIG1vdW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIGNoaWxkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0byBpbnNlcnQgdGhlIGNoaWxkLlxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tb3VudENoaWxkQnlOYW1lQXRJbmRleDogZnVuY3Rpb24gKGNoaWxkLCBuYW1lLCBpbmRleCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIC8vIElubGluZWQgZm9yIHBlcmZvcm1hbmNlLCBzZWUgYFJlYWN0SW5zdGFuY2VIYW5kbGVzLmNyZWF0ZVJlYWN0SURgLlxuICAgICAgdmFyIHJvb3RJRCA9IHRoaXMuX3Jvb3ROb2RlSUQgKyBuYW1lO1xuICAgICAgdmFyIG1vdW50SW1hZ2UgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQoY2hpbGQsIHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgY2hpbGQuX21vdW50SW5kZXggPSBpbmRleDtcbiAgICAgIHRoaXMuY3JlYXRlQ2hpbGQoY2hpbGQsIG1vdW50SW1hZ2UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbm1vdW50cyBhIHJlbmRlcmVkIGNoaWxkLlxuICAgICAqXG4gICAgICogTk9URTogVGhpcyBpcyBwYXJ0IG9mIGB1cGRhdGVDaGlsZHJlbmAgYW5kIGlzIGhlcmUgZm9yIHJlYWRhYmlsaXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIHVubW91bnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdW5tb3VudENoaWxkOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgY2hpbGQuX21vdW50SW5kZXggPSBudWxsO1xuICAgIH1cblxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNdWx0aUNoaWxkO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RNdWx0aUNoaWxkLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q2hpbGRSZWNvbmNpbGVyXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG5cbnZhciBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgdHJhdmVyc2VBbGxDaGlsZHJlbiA9IHJlcXVpcmUoJy4vdHJhdmVyc2VBbGxDaGlsZHJlbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIGluc3RhbnRpYXRlQ2hpbGQoY2hpbGRJbnN0YW5jZXMsIGNoaWxkLCBuYW1lKSB7XG4gIC8vIFdlIGZvdW5kIGEgY29tcG9uZW50IGluc3RhbmNlLlxuICB2YXIga2V5VW5pcXVlID0gY2hpbGRJbnN0YW5jZXNbbmFtZV0gPT09IHVuZGVmaW5lZDtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhrZXlVbmlxdWUsICdmbGF0dGVuQ2hpbGRyZW4oLi4uKTogRW5jb3VudGVyZWQgdHdvIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUga2V5LCAnICsgJ2Alc2AuIENoaWxkIGtleXMgbXVzdCBiZSB1bmlxdWU7IHdoZW4gdHdvIGNoaWxkcmVuIHNoYXJlIGEga2V5LCBvbmx5ICcgKyAndGhlIGZpcnN0IGNoaWxkIHdpbGwgYmUgdXNlZC4nLCBuYW1lKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoY2hpbGQgIT0gbnVsbCAmJiBrZXlVbmlxdWUpIHtcbiAgICBjaGlsZEluc3RhbmNlc1tuYW1lXSA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQoY2hpbGQsIG51bGwpO1xuICB9XG59XG5cbi8qKlxuICogUmVhY3RDaGlsZFJlY29uY2lsZXIgcHJvdmlkZXMgaGVscGVycyBmb3IgaW5pdGlhbGl6aW5nIG9yIHVwZGF0aW5nIGEgc2V0IG9mXG4gKiBjaGlsZHJlbi4gSXRzIG91dHB1dCBpcyBzdWl0YWJsZSBmb3IgcGFzc2luZyBpdCBvbnRvIFJlYWN0TXVsdGlDaGlsZCB3aGljaFxuICogZG9lcyBkaWZmZWQgcmVvcmRlcmluZyBhbmQgaW5zZXJ0aW9uLlxuICovXG52YXIgUmVhY3RDaGlsZFJlY29uY2lsZXIgPSB7XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBcIm1vdW50IGltYWdlXCIgZm9yIGVhY2ggb2YgdGhlIHN1cHBsaWVkIGNoaWxkcmVuLiBJbiB0aGUgY2FzZVxuICAgKiBvZiBgUmVhY3RET01Db21wb25lbnRgLCBhIG1vdW50IGltYWdlIGlzIGEgc3RyaW5nIG9mIG1hcmt1cC5cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXN0ZWRDaGlsZE5vZGVzIE5lc3RlZCBjaGlsZCBtYXBzLlxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBBIHNldCBvZiBjaGlsZCBpbnN0YW5jZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgaW5zdGFudGlhdGVDaGlsZHJlbjogZnVuY3Rpb24gKG5lc3RlZENoaWxkTm9kZXMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgaWYgKG5lc3RlZENoaWxkTm9kZXMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBjaGlsZEluc3RhbmNlcyA9IHt9O1xuICAgIHRyYXZlcnNlQWxsQ2hpbGRyZW4obmVzdGVkQ2hpbGROb2RlcywgaW5zdGFudGlhdGVDaGlsZCwgY2hpbGRJbnN0YW5jZXMpO1xuICAgIHJldHVybiBjaGlsZEluc3RhbmNlcztcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgcmVuZGVyZWQgY2hpbGRyZW4gYW5kIHJldHVybnMgYSBuZXcgc2V0IG9mIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZDaGlsZHJlbiBQcmV2aW91c2x5IGluaXRpYWxpemVkIHNldCBvZiBjaGlsZHJlbi5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q2hpbGRyZW4gRmxhdCBjaGlsZCBlbGVtZW50IG1hcHMuXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7P29iamVjdH0gQSBuZXcgc2V0IG9mIGNoaWxkIGluc3RhbmNlcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB1cGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIC8vIFdlIGN1cnJlbnRseSBkb24ndCBoYXZlIGEgd2F5IHRvIHRyYWNrIG1vdmVzIGhlcmUgYnV0IGlmIHdlIHVzZSBpdGVyYXRvcnNcbiAgICAvLyBpbnN0ZWFkIG9mIGZvci4uaW4gd2UgY2FuIHppcCB0aGUgaXRlcmF0b3JzIGFuZCBjaGVjayBpZiBhbiBpdGVtIGhhc1xuICAgIC8vIG1vdmVkLlxuICAgIC8vIFRPRE86IElmIG5vdGhpbmcgaGFzIGNoYW5nZWQsIHJldHVybiB0aGUgcHJldkNoaWxkcmVuIG9iamVjdCBzbyB0aGF0IHdlXG4gICAgLy8gY2FuIHF1aWNrbHkgYmFpbG91dCBpZiBub3RoaW5nIGhhcyBjaGFuZ2VkLlxuICAgIGlmICghbmV4dENoaWxkcmVuICYmICFwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgbmFtZTtcbiAgICBmb3IgKG5hbWUgaW4gbmV4dENoaWxkcmVuKSB7XG4gICAgICBpZiAoIW5leHRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBwcmV2Q2hpbGQgPSBwcmV2Q2hpbGRyZW4gJiYgcHJldkNoaWxkcmVuW25hbWVdO1xuICAgICAgdmFyIHByZXZFbGVtZW50ID0gcHJldkNoaWxkICYmIHByZXZDaGlsZC5fY3VycmVudEVsZW1lbnQ7XG4gICAgICB2YXIgbmV4dEVsZW1lbnQgPSBuZXh0Q2hpbGRyZW5bbmFtZV07XG4gICAgICBpZiAocHJldkNoaWxkICE9IG51bGwgJiYgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KSkge1xuICAgICAgICBSZWFjdFJlY29uY2lsZXIucmVjZWl2ZUNvbXBvbmVudChwcmV2Q2hpbGQsIG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIG5leHRDaGlsZHJlbltuYW1lXSA9IHByZXZDaGlsZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcmV2Q2hpbGQpIHtcbiAgICAgICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChwcmV2Q2hpbGQsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBjaGlsZCBtdXN0IGJlIGluc3RhbnRpYXRlZCBiZWZvcmUgaXQncyBtb3VudGVkLlxuICAgICAgICB2YXIgbmV4dENoaWxkSW5zdGFuY2UgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5leHRFbGVtZW50LCBudWxsKTtcbiAgICAgICAgbmV4dENoaWxkcmVuW25hbWVdID0gbmV4dENoaWxkSW5zdGFuY2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFVubW91bnQgY2hpbGRyZW4gdGhhdCBhcmUgbm8gbG9uZ2VyIHByZXNlbnQuXG4gICAgZm9yIChuYW1lIGluIHByZXZDaGlsZHJlbikge1xuICAgICAgaWYgKHByZXZDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAhKG5leHRDaGlsZHJlbiAmJiBuZXh0Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpKSB7XG4gICAgICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHByZXZDaGlsZHJlbltuYW1lXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXh0Q2hpbGRyZW47XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVubW91bnRzIGFsbCByZW5kZXJlZCBjaGlsZHJlbi4gVGhpcyBzaG91bGQgYmUgdXNlZCB0byBjbGVhbiB1cCBjaGlsZHJlblxuICAgKiB3aGVuIHRoaXMgY29tcG9uZW50IGlzIHVubW91bnRlZC5cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSByZW5kZXJlZENoaWxkcmVuIFByZXZpb3VzbHkgaW5pdGlhbGl6ZWQgc2V0IG9mIGNoaWxkcmVuLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVubW91bnRDaGlsZHJlbjogZnVuY3Rpb24gKHJlbmRlcmVkQ2hpbGRyZW4pIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIHJlbmRlcmVkQ2hpbGRyZW4pIHtcbiAgICAgIGlmIChyZW5kZXJlZENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHZhciByZW5kZXJlZENoaWxkID0gcmVuZGVyZWRDaGlsZHJlbltuYW1lXTtcbiAgICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocmVuZGVyZWRDaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDaGlsZFJlY29uY2lsZXI7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdENoaWxkUmVjb25jaWxlci5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBmbGF0dGVuQ2hpbGRyZW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB0cmF2ZXJzZUFsbENoaWxkcmVuID0gcmVxdWlyZSgnLi90cmF2ZXJzZUFsbENoaWxkcmVuJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0cmF2ZXJzZUNvbnRleHQgQ29udGV4dCBwYXNzZWQgdGhyb3VnaCB0cmF2ZXJzYWwuXG4gKiBAcGFyYW0gez9SZWFjdENvbXBvbmVudH0gY2hpbGQgUmVhY3QgY2hpbGQgY29tcG9uZW50LlxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lIFN0cmluZyBuYW1lIG9mIGtleSBwYXRoIHRvIGNoaWxkLlxuICovXG5mdW5jdGlvbiBmbGF0dGVuU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lKSB7XG4gIC8vIFdlIGZvdW5kIGEgY29tcG9uZW50IGluc3RhbmNlLlxuICB2YXIgcmVzdWx0ID0gdHJhdmVyc2VDb250ZXh0O1xuICB2YXIga2V5VW5pcXVlID0gcmVzdWx0W25hbWVdID09PSB1bmRlZmluZWQ7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoa2V5VW5pcXVlLCAnZmxhdHRlbkNoaWxkcmVuKC4uLik6IEVuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgJyArICdgJXNgLiBDaGlsZCBrZXlzIG11c3QgYmUgdW5pcXVlOyB3aGVuIHR3byBjaGlsZHJlbiBzaGFyZSBhIGtleSwgb25seSAnICsgJ3RoZSBmaXJzdCBjaGlsZCB3aWxsIGJlIHVzZWQuJywgbmFtZSkgOiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGtleVVuaXF1ZSAmJiBjaGlsZCAhPSBudWxsKSB7XG4gICAgcmVzdWx0W25hbWVdID0gY2hpbGQ7XG4gIH1cbn1cblxuLyoqXG4gKiBGbGF0dGVucyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuIEFueSBudWxsXG4gKiBjaGlsZHJlbiB3aWxsIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0aW5nIG9iamVjdC5cbiAqIEByZXR1cm4geyFvYmplY3R9IGZsYXR0ZW5lZCBjaGlsZHJlbiBrZXllZCBieSBuYW1lLlxuICovXG5mdW5jdGlvbiBmbGF0dGVuQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHt9O1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmbGF0dGVuU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0dGVuQ2hpbGRyZW47XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9mbGF0dGVuQ2hpbGRyZW4uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgc2hhbGxvd0VxdWFsXG4gKiBAdHlwZWNoZWNrc1xuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFBlcmZvcm1zIGVxdWFsaXR5IGJ5IGl0ZXJhdGluZyB0aHJvdWdoIGtleXMgb24gYW4gb2JqZWN0IGFuZCByZXR1cm5pbmcgZmFsc2VcbiAqIHdoZW4gYW55IGtleSBoYXMgdmFsdWVzIHdoaWNoIGFyZSBub3Qgc3RyaWN0bHkgZXF1YWwgYmV0d2VlbiB0aGUgYXJndW1lbnRzLlxuICogUmV0dXJucyB0cnVlIHdoZW4gdGhlIHZhbHVlcyBvZiBhbGwga2V5cyBhcmUgc3RyaWN0bHkgZXF1YWwuXG4gKi9cbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCKSB7XG4gIGlmIChvYmpBID09PSBvYmpCKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iakEgIT09ICdvYmplY3QnIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09ICdvYmplY3QnIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG5cbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cbiAgdmFyIGJIYXNPd25Qcm9wZXJ0eSA9IGhhc093blByb3BlcnR5LmJpbmQob2JqQik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWJIYXNPd25Qcm9wZXJ0eShrZXlzQVtpXSkgfHwgb2JqQVtrZXlzQVtpXV0gIT09IG9iakJba2V5c0FbaV1dKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hhbGxvd0VxdWFsO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9zaGFsbG93RXF1YWwuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFdmVudExpc3RlbmVyXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCdmYmpzL2xpYi9FdmVudExpc3RlbmVyJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xudmFyIFJlYWN0SW5zdGFuY2VIYW5kbGVzID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlSGFuZGxlcycpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgZ2V0RXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL2dldEV2ZW50VGFyZ2V0Jyk7XG52YXIgZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9nZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbicpO1xuXG52YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFID0gMTE7XG5cbi8qKlxuICogRmluZHMgdGhlIHBhcmVudCBSZWFjdCBjb21wb25lbnQgb2YgYG5vZGVgLlxuICpcbiAqIEBwYXJhbSB7Kn0gbm9kZVxuICogQHJldHVybiB7P0RPTUV2ZW50VGFyZ2V0fSBQYXJlbnQgY29udGFpbmVyLCBvciBgbnVsbGAgaWYgdGhlIHNwZWNpZmllZCBub2RlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIG5vdCBuZXN0ZWQuXG4gKi9cbmZ1bmN0aW9uIGZpbmRQYXJlbnQobm9kZSkge1xuICAvLyBUT0RPOiBJdCBtYXkgYmUgYSBnb29kIGlkZWEgdG8gY2FjaGUgdGhpcyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IERPTVxuICAvLyB0cmF2ZXJzYWwsIGJ1dCBjYWNoaW5nIGlzIGRpZmZpY3VsdCB0byBkbyBjb3JyZWN0bHkgd2l0aG91dCB1c2luZyBhXG4gIC8vIG11dGF0aW9uIG9ic2VydmVyIHRvIGxpc3RlbiBmb3IgYWxsIERPTSBjaGFuZ2VzLlxuICB2YXIgbm9kZUlEID0gUmVhY3RNb3VudC5nZXRJRChub2RlKTtcbiAgdmFyIHJvb3RJRCA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLmdldFJlYWN0Um9vdElERnJvbU5vZGVJRChub2RlSUQpO1xuICB2YXIgY29udGFpbmVyID0gUmVhY3RNb3VudC5maW5kUmVhY3RDb250YWluZXJGb3JJRChyb290SUQpO1xuICB2YXIgcGFyZW50ID0gUmVhY3RNb3VudC5nZXRGaXJzdFJlYWN0RE9NKGNvbnRhaW5lcik7XG4gIHJldHVybiBwYXJlbnQ7XG59XG5cbi8vIFVzZWQgdG8gc3RvcmUgYW5jZXN0b3IgaGllcmFyY2h5IGluIHRvcCBsZXZlbCBjYWxsYmFja1xuZnVuY3Rpb24gVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgdGhpcy50b3BMZXZlbFR5cGUgPSB0b3BMZXZlbFR5cGU7XG4gIHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgdGhpcy5hbmNlc3RvcnMgPSBbXTtcbn1cbmFzc2lnbihUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcucHJvdG90eXBlLCB7XG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnRvcExldmVsVHlwZSA9IG51bGw7XG4gICAgdGhpcy5uYXRpdmVFdmVudCA9IG51bGw7XG4gICAgdGhpcy5hbmNlc3RvcnMubGVuZ3RoID0gMDtcbiAgfVxufSk7XG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nLCBQb29sZWRDbGFzcy50d29Bcmd1bWVudFBvb2xlcik7XG5cbmZ1bmN0aW9uIGhhbmRsZVRvcExldmVsSW1wbChib29rS2VlcGluZykge1xuICAvLyBUT0RPOiBSZS1lbmFibGUgZXZlbnQucGF0aCBoYW5kbGluZ1xuICAvL1xuICAvLyBpZiAoYm9va0tlZXBpbmcubmF0aXZlRXZlbnQucGF0aCAmJiBib29rS2VlcGluZy5uYXRpdmVFdmVudC5wYXRoLmxlbmd0aCA+IDEpIHtcbiAgLy8gICAvLyBOZXcgYnJvd3NlcnMgaGF2ZSBhIHBhdGggYXR0cmlidXRlIG9uIG5hdGl2ZSBldmVudHNcbiAgLy8gICBoYW5kbGVUb3BMZXZlbFdpdGhQYXRoKGJvb2tLZWVwaW5nKTtcbiAgLy8gfSBlbHNlIHtcbiAgLy8gICAvLyBMZWdhY3kgYnJvd3NlcnMgZG9uJ3QgaGF2ZSBhIHBhdGggYXR0cmlidXRlIG9uIG5hdGl2ZSBldmVudHNcbiAgLy8gICBoYW5kbGVUb3BMZXZlbFdpdGhvdXRQYXRoKGJvb2tLZWVwaW5nKTtcbiAgLy8gfVxuXG4gIHZvaWQgaGFuZGxlVG9wTGV2ZWxXaXRoUGF0aDsgLy8gdGVtcG9yYXJpbHkgdW51c2VkXG4gIGhhbmRsZVRvcExldmVsV2l0aG91dFBhdGgoYm9va0tlZXBpbmcpO1xufVxuXG4vLyBMZWdhY3kgYnJvd3NlcnMgZG9uJ3QgaGF2ZSBhIHBhdGggYXR0cmlidXRlIG9uIG5hdGl2ZSBldmVudHNcbmZ1bmN0aW9uIGhhbmRsZVRvcExldmVsV2l0aG91dFBhdGgoYm9va0tlZXBpbmcpIHtcbiAgdmFyIHRvcExldmVsVGFyZ2V0ID0gUmVhY3RNb3VudC5nZXRGaXJzdFJlYWN0RE9NKGdldEV2ZW50VGFyZ2V0KGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50KSkgfHwgd2luZG93O1xuXG4gIC8vIExvb3AgdGhyb3VnaCB0aGUgaGllcmFyY2h5LCBpbiBjYXNlIHRoZXJlJ3MgYW55IG5lc3RlZCBjb21wb25lbnRzLlxuICAvLyBJdCdzIGltcG9ydGFudCB0aGF0IHdlIGJ1aWxkIHRoZSBhcnJheSBvZiBhbmNlc3RvcnMgYmVmb3JlIGNhbGxpbmcgYW55XG4gIC8vIGV2ZW50IGhhbmRsZXJzLCBiZWNhdXNlIGV2ZW50IGhhbmRsZXJzIGNhbiBtb2RpZnkgdGhlIERPTSwgbGVhZGluZyB0b1xuICAvLyBpbmNvbnNpc3RlbmNpZXMgd2l0aCBSZWFjdE1vdW50J3Mgbm9kZSBjYWNoZS4gU2VlICMxMTA1LlxuICB2YXIgYW5jZXN0b3IgPSB0b3BMZXZlbFRhcmdldDtcbiAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgYm9va0tlZXBpbmcuYW5jZXN0b3JzLnB1c2goYW5jZXN0b3IpO1xuICAgIGFuY2VzdG9yID0gZmluZFBhcmVudChhbmNlc3Rvcik7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5sZW5ndGg7IGkrKykge1xuICAgIHRvcExldmVsVGFyZ2V0ID0gYm9va0tlZXBpbmcuYW5jZXN0b3JzW2ldO1xuICAgIHZhciB0b3BMZXZlbFRhcmdldElEID0gUmVhY3RNb3VudC5nZXRJRCh0b3BMZXZlbFRhcmdldCkgfHwgJyc7XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9oYW5kbGVUb3BMZXZlbChib29rS2VlcGluZy50b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBib29rS2VlcGluZy5uYXRpdmVFdmVudCwgZ2V0RXZlbnRUYXJnZXQoYm9va0tlZXBpbmcubmF0aXZlRXZlbnQpKTtcbiAgfVxufVxuXG4vLyBOZXcgYnJvd3NlcnMgaGF2ZSBhIHBhdGggYXR0cmlidXRlIG9uIG5hdGl2ZSBldmVudHNcbmZ1bmN0aW9uIGhhbmRsZVRvcExldmVsV2l0aFBhdGgoYm9va0tlZXBpbmcpIHtcbiAgdmFyIHBhdGggPSBib29rS2VlcGluZy5uYXRpdmVFdmVudC5wYXRoO1xuICB2YXIgY3VycmVudE5hdGl2ZVRhcmdldCA9IHBhdGhbMF07XG4gIHZhciBldmVudHNGaXJlZCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjdXJyZW50UGF0aEVsZW1lbnQgPSBwYXRoW2ldO1xuICAgIGlmIChjdXJyZW50UGF0aEVsZW1lbnQubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSkge1xuICAgICAgY3VycmVudE5hdGl2ZVRhcmdldCA9IHBhdGhbaSArIDFdO1xuICAgIH1cbiAgICAvLyBUT0RPOiBzbG93XG4gICAgdmFyIHJlYWN0UGFyZW50ID0gUmVhY3RNb3VudC5nZXRGaXJzdFJlYWN0RE9NKGN1cnJlbnRQYXRoRWxlbWVudCk7XG4gICAgaWYgKHJlYWN0UGFyZW50ID09PSBjdXJyZW50UGF0aEVsZW1lbnQpIHtcbiAgICAgIHZhciBjdXJyZW50UGF0aEVsZW1lbnRJRCA9IFJlYWN0TW91bnQuZ2V0SUQoY3VycmVudFBhdGhFbGVtZW50KTtcbiAgICAgIHZhciBuZXdSb290SUQgPSBSZWFjdEluc3RhbmNlSGFuZGxlcy5nZXRSZWFjdFJvb3RJREZyb21Ob2RlSUQoY3VycmVudFBhdGhFbGVtZW50SUQpO1xuICAgICAgYm9va0tlZXBpbmcuYW5jZXN0b3JzLnB1c2goY3VycmVudFBhdGhFbGVtZW50KTtcblxuICAgICAgdmFyIHRvcExldmVsVGFyZ2V0SUQgPSBSZWFjdE1vdW50LmdldElEKGN1cnJlbnRQYXRoRWxlbWVudCkgfHwgJyc7XG4gICAgICBldmVudHNGaXJlZCsrO1xuICAgICAgUmVhY3RFdmVudExpc3RlbmVyLl9oYW5kbGVUb3BMZXZlbChib29rS2VlcGluZy50b3BMZXZlbFR5cGUsIGN1cnJlbnRQYXRoRWxlbWVudCwgdG9wTGV2ZWxUYXJnZXRJRCwgYm9va0tlZXBpbmcubmF0aXZlRXZlbnQsIGN1cnJlbnROYXRpdmVUYXJnZXQpO1xuXG4gICAgICAvLyBKdW1wIHRvIHRoZSByb290IG9mIHRoaXMgUmVhY3QgcmVuZGVyIHRyZWVcbiAgICAgIHdoaWxlIChjdXJyZW50UGF0aEVsZW1lbnRJRCAhPT0gbmV3Um9vdElEKSB7XG4gICAgICAgIGkrKztcbiAgICAgICAgY3VycmVudFBhdGhFbGVtZW50ID0gcGF0aFtpXTtcbiAgICAgICAgY3VycmVudFBhdGhFbGVtZW50SUQgPSBSZWFjdE1vdW50LmdldElEKGN1cnJlbnRQYXRoRWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChldmVudHNGaXJlZCA9PT0gMCkge1xuICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5faGFuZGxlVG9wTGV2ZWwoYm9va0tlZXBpbmcudG9wTGV2ZWxUeXBlLCB3aW5kb3csICcnLCBib29rS2VlcGluZy5uYXRpdmVFdmVudCwgZ2V0RXZlbnRUYXJnZXQoYm9va0tlZXBpbmcubmF0aXZlRXZlbnQpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzY3JvbGxWYWx1ZU1vbml0b3IoY2IpIHtcbiAgdmFyIHNjcm9sbFBvc2l0aW9uID0gZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24od2luZG93KTtcbiAgY2Ioc2Nyb2xsUG9zaXRpb24pO1xufVxuXG52YXIgUmVhY3RFdmVudExpc3RlbmVyID0ge1xuICBfZW5hYmxlZDogdHJ1ZSxcbiAgX2hhbmRsZVRvcExldmVsOiBudWxsLFxuXG4gIFdJTkRPV19IQU5ETEU6IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IHdpbmRvdyA6IG51bGwsXG5cbiAgc2V0SGFuZGxlVG9wTGV2ZWw6IGZ1bmN0aW9uIChoYW5kbGVUb3BMZXZlbCkge1xuICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5faGFuZGxlVG9wTGV2ZWwgPSBoYW5kbGVUb3BMZXZlbDtcbiAgfSxcblxuICBzZXRFbmFibGVkOiBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5fZW5hYmxlZCA9ICEhZW5hYmxlZDtcbiAgfSxcblxuICBpc0VuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUmVhY3RFdmVudExpc3RlbmVyLl9lbmFibGVkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmFwcyB0b3AtbGV2ZWwgZXZlbnRzIGJ5IHVzaW5nIGV2ZW50IGJ1YmJsaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBoYW5kbGVyQmFzZU5hbWUgRXZlbnQgbmFtZSAoZS5nLiBcImNsaWNrXCIpLlxuICAgKiBAcGFyYW0ge29iamVjdH0gaGFuZGxlIEVsZW1lbnQgb24gd2hpY2ggdG8gYXR0YWNoIGxpc3RlbmVyLlxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIHJlbW92ZSBmdW5jdGlvbiB3aGljaCB3aWxsIGZvcmNlZnVsbHlcbiAgICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRyYXBCdWJibGVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBoYW5kbGU7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIEV2ZW50TGlzdGVuZXIubGlzdGVuKGVsZW1lbnQsIGhhbmRsZXJCYXNlTmFtZSwgUmVhY3RFdmVudExpc3RlbmVyLmRpc3BhdGNoRXZlbnQuYmluZChudWxsLCB0b3BMZXZlbFR5cGUpKTtcbiAgfSxcblxuICAvKipcbiAgICogVHJhcHMgYSB0b3AtbGV2ZWwgZXZlbnQgYnkgdXNpbmcgZXZlbnQgY2FwdHVyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBoYW5kbGVyQmFzZU5hbWUgRXZlbnQgbmFtZSAoZS5nLiBcImNsaWNrXCIpLlxuICAgKiBAcGFyYW0ge29iamVjdH0gaGFuZGxlIEVsZW1lbnQgb24gd2hpY2ggdG8gYXR0YWNoIGxpc3RlbmVyLlxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIHJlbW92ZSBmdW5jdGlvbiB3aGljaCB3aWxsIGZvcmNlZnVsbHlcbiAgICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRyYXBDYXB0dXJlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSkge1xuICAgIHZhciBlbGVtZW50ID0gaGFuZGxlO1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBFdmVudExpc3RlbmVyLmNhcHR1cmUoZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLCBSZWFjdEV2ZW50TGlzdGVuZXIuZGlzcGF0Y2hFdmVudC5iaW5kKG51bGwsIHRvcExldmVsVHlwZSkpO1xuICB9LFxuXG4gIG1vbml0b3JTY3JvbGxWYWx1ZTogZnVuY3Rpb24gKHJlZnJlc2gpIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBzY3JvbGxWYWx1ZU1vbml0b3IuYmluZChudWxsLCByZWZyZXNoKTtcbiAgICBFdmVudExpc3RlbmVyLmxpc3Rlbih3aW5kb3csICdzY3JvbGwnLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgICBpZiAoIVJlYWN0RXZlbnRMaXN0ZW5lci5fZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBib29rS2VlcGluZyA9IFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZy5nZXRQb29sZWQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEV2ZW50IHF1ZXVlIGJlaW5nIHByb2Nlc3NlZCBpbiB0aGUgc2FtZSBjeWNsZSBhbGxvd3NcbiAgICAgIC8vIGBwcmV2ZW50RGVmYXVsdGAuXG4gICAgICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMoaGFuZGxlVG9wTGV2ZWxJbXBsLCBib29rS2VlcGluZyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZy5yZWxlYXNlKGJvb2tLZWVwaW5nKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFdmVudExpc3RlbmVyO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RFdmVudExpc3RlbmVyLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudExpc3RlbmVyXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBVcHN0cmVhbSB2ZXJzaW9uIG9mIGV2ZW50IGxpc3RlbmVyLiBEb2VzIG5vdCB0YWtlIGludG8gYWNjb3VudCBzcGVjaWZpY1xuICogbmF0dXJlIG9mIHBsYXRmb3JtLlxuICovXG52YXIgRXZlbnRMaXN0ZW5lciA9IHtcbiAgLyoqXG4gICAqIExpc3RlbiB0byBET00gZXZlbnRzIGR1cmluZyB0aGUgYnViYmxlIHBoYXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0YXJnZXQgRE9NIGVsZW1lbnQgdG8gcmVnaXN0ZXIgbGlzdGVuZXIgb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgRXZlbnQgdHlwZSwgZS5nLiAnY2xpY2snIG9yICdtb3VzZW92ZXInLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3Qgd2l0aCBhIGByZW1vdmVgIG1ldGhvZC5cbiAgICovXG4gIGxpc3RlbjogZnVuY3Rpb24gKHRhcmdldCwgZXZlbnRUeXBlLCBjYWxsYmFjaykge1xuICAgIGlmICh0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0LmF0dGFjaEV2ZW50KSB7XG4gICAgICB0YXJnZXQuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50VHlwZSwgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGFyZ2V0LmRldGFjaEV2ZW50KCdvbicgKyBldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIExpc3RlbiB0byBET00gZXZlbnRzIGR1cmluZyB0aGUgY2FwdHVyZSBwaGFzZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdGFyZ2V0IERPTSBlbGVtZW50IHRvIHJlZ2lzdGVyIGxpc3RlbmVyIG9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIEV2ZW50IHR5cGUsIGUuZy4gJ2NsaWNrJyBvciAnbW91c2VvdmVyJy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggYSBgcmVtb3ZlYCBtZXRob2QuXG4gICAqL1xuICBjYXB0dXJlOiBmdW5jdGlvbiAodGFyZ2V0LCBldmVudFR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdBdHRlbXB0ZWQgdG8gbGlzdGVuIHRvIGV2ZW50cyBkdXJpbmcgdGhlIGNhcHR1cmUgcGhhc2Ugb24gYSAnICsgJ2Jyb3dzZXIgdGhhdCBkb2VzIG5vdCBzdXBwb3J0IHRoZSBjYXB0dXJlIHBoYXNlLiBZb3VyIGFwcGxpY2F0aW9uICcgKyAnd2lsbCBub3QgcmVjZWl2ZSBzb21lIGV2ZW50cy4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZW1wdHlGdW5jdGlvblxuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgcmVnaXN0ZXJEZWZhdWx0OiBmdW5jdGlvbiAoKSB7fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudExpc3RlbmVyO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9FdmVudExpc3RlbmVyLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHZXRzIHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIHN1cHBsaWVkIGVsZW1lbnQgb3Igd2luZG93LlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWVzIGFyZSB1bmJvdW5kZWQsIHVubGlrZSBgZ2V0U2Nyb2xsUG9zaXRpb25gLiBUaGlzIG1lYW5zIHRoZXlcbiAqIG1heSBiZSBuZWdhdGl2ZSBvciBleGNlZWQgdGhlIGVsZW1lbnQgYm91bmRhcmllcyAod2hpY2ggaXMgcG9zc2libGUgdXNpbmdcbiAqIGluZXJ0aWFsIHNjcm9sbGluZykuXG4gKlxuICogQHBhcmFtIHtET01XaW5kb3d8RE9NRWxlbWVudH0gc2Nyb2xsYWJsZVxuICogQHJldHVybiB7b2JqZWN0fSBNYXAgd2l0aCBgeGAgYW5kIGB5YCBrZXlzLlxuICovXG5mdW5jdGlvbiBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbihzY3JvbGxhYmxlKSB7XG4gIGlmIChzY3JvbGxhYmxlID09PSB3aW5kb3cpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogd2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgICAgeTogd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3BcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogc2Nyb2xsYWJsZS5zY3JvbGxMZWZ0LFxuICAgIHk6IHNjcm9sbGFibGUuc2Nyb2xsVG9wXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb247XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL2dldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0SW5qZWN0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luSHViJyk7XG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0Q2xhc3MgPSByZXF1aXJlKCcuL1JlYWN0Q2xhc3MnKTtcbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVtcHR5Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdE5hdGl2ZUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3ROYXRpdmVDb21wb25lbnQnKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKCcuL1JlYWN0UGVyZicpO1xudmFyIFJlYWN0Um9vdEluZGV4ID0gcmVxdWlyZSgnLi9SZWFjdFJvb3RJbmRleCcpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBSZWFjdEluamVjdGlvbiA9IHtcbiAgQ29tcG9uZW50OiBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LmluamVjdGlvbixcbiAgQ2xhc3M6IFJlYWN0Q2xhc3MuaW5qZWN0aW9uLFxuICBET01Qcm9wZXJ0eTogRE9NUHJvcGVydHkuaW5qZWN0aW9uLFxuICBFbXB0eUNvbXBvbmVudDogUmVhY3RFbXB0eUNvbXBvbmVudC5pbmplY3Rpb24sXG4gIEV2ZW50UGx1Z2luSHViOiBFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24sXG4gIEV2ZW50RW1pdHRlcjogUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmluamVjdGlvbixcbiAgTmF0aXZlQ29tcG9uZW50OiBSZWFjdE5hdGl2ZUNvbXBvbmVudC5pbmplY3Rpb24sXG4gIFBlcmY6IFJlYWN0UGVyZi5pbmplY3Rpb24sXG4gIFJvb3RJbmRleDogUmVhY3RSb290SW5kZXguaW5qZWN0aW9uLFxuICBVcGRhdGVzOiBSZWFjdFVwZGF0ZXMuaW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5qZWN0aW9uO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RJbmplY3Rpb24uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDbGFzc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudCcpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9ucycpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcycpO1xudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdE5vb3BVcGRhdGVRdWV1ZScpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIGtleU1pcnJvciA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU1pcnJvcicpO1xudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgTUlYSU5TX0tFWSA9IGtleU9mKHsgbWl4aW5zOiBudWxsIH0pO1xuXG4vKipcbiAqIFBvbGljaWVzIHRoYXQgZGVzY3JpYmUgbWV0aG9kcyBpbiBgUmVhY3RDbGFzc0ludGVyZmFjZWAuXG4gKi9cbnZhciBTcGVjUG9saWN5ID0ga2V5TWlycm9yKHtcbiAgLyoqXG4gICAqIFRoZXNlIG1ldGhvZHMgbWF5IGJlIGRlZmluZWQgb25seSBvbmNlIGJ5IHRoZSBjbGFzcyBzcGVjaWZpY2F0aW9uIG9yIG1peGluLlxuICAgKi9cbiAgREVGSU5FX09OQ0U6IG51bGwsXG4gIC8qKlxuICAgKiBUaGVzZSBtZXRob2RzIG1heSBiZSBkZWZpbmVkIGJ5IGJvdGggdGhlIGNsYXNzIHNwZWNpZmljYXRpb24gYW5kIG1peGlucy5cbiAgICogU3Vic2VxdWVudCBkZWZpbml0aW9ucyB3aWxsIGJlIGNoYWluZWQuIFRoZXNlIG1ldGhvZHMgbXVzdCByZXR1cm4gdm9pZC5cbiAgICovXG4gIERFRklORV9NQU5ZOiBudWxsLFxuICAvKipcbiAgICogVGhlc2UgbWV0aG9kcyBhcmUgb3ZlcnJpZGluZyB0aGUgYmFzZSBjbGFzcy5cbiAgICovXG4gIE9WRVJSSURFX0JBU0U6IG51bGwsXG4gIC8qKlxuICAgKiBUaGVzZSBtZXRob2RzIGFyZSBzaW1pbGFyIHRvIERFRklORV9NQU5ZLCBleGNlcHQgd2UgYXNzdW1lIHRoZXkgcmV0dXJuXG4gICAqIG9iamVjdHMuIFdlIHRyeSB0byBtZXJnZSB0aGUga2V5cyBvZiB0aGUgcmV0dXJuIHZhbHVlcyBvZiBhbGwgdGhlIG1peGVkIGluXG4gICAqIGZ1bmN0aW9ucy4gSWYgdGhlcmUgaXMgYSBrZXkgY29uZmxpY3Qgd2UgdGhyb3cuXG4gICAqL1xuICBERUZJTkVfTUFOWV9NRVJHRUQ6IG51bGxcbn0pO1xuXG52YXIgaW5qZWN0ZWRNaXhpbnMgPSBbXTtcblxudmFyIHdhcm5lZFNldFByb3BzID0gZmFsc2U7XG5mdW5jdGlvbiB3YXJuU2V0UHJvcHMoKSB7XG4gIGlmICghd2FybmVkU2V0UHJvcHMpIHtcbiAgICB3YXJuZWRTZXRQcm9wcyA9IHRydWU7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdzZXRQcm9wcyguLi4pIGFuZCByZXBsYWNlUHJvcHMoLi4uKSBhcmUgZGVwcmVjYXRlZC4gJyArICdJbnN0ZWFkLCBjYWxsIHJlbmRlciBhZ2FpbiBhdCB0aGUgdG9wIGxldmVsLicpIDogdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogQ29tcG9zaXRlIGNvbXBvbmVudHMgYXJlIGhpZ2hlci1sZXZlbCBjb21wb25lbnRzIHRoYXQgY29tcG9zZSBvdGhlciBjb21wb3NpdGVcbiAqIG9yIG5hdGl2ZSBjb21wb25lbnRzLlxuICpcbiAqIFRvIGNyZWF0ZSBhIG5ldyB0eXBlIG9mIGBSZWFjdENsYXNzYCwgcGFzcyBhIHNwZWNpZmljYXRpb24gb2ZcbiAqIHlvdXIgbmV3IGNsYXNzIHRvIGBSZWFjdC5jcmVhdGVDbGFzc2AuIFRoZSBvbmx5IHJlcXVpcmVtZW50IG9mIHlvdXIgY2xhc3NcbiAqIHNwZWNpZmljYXRpb24gaXMgdGhhdCB5b3UgaW1wbGVtZW50IGEgYHJlbmRlcmAgbWV0aG9kLlxuICpcbiAqICAgdmFyIE15Q29tcG9uZW50ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gKiAgICAgICByZXR1cm4gPGRpdj5IZWxsbyBXb3JsZDwvZGl2PjtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIFRoZSBjbGFzcyBzcGVjaWZpY2F0aW9uIHN1cHBvcnRzIGEgc3BlY2lmaWMgcHJvdG9jb2wgb2YgbWV0aG9kcyB0aGF0IGhhdmVcbiAqIHNwZWNpYWwgbWVhbmluZyAoZS5nLiBgcmVuZGVyYCkuIFNlZSBgUmVhY3RDbGFzc0ludGVyZmFjZWAgZm9yXG4gKiBtb3JlIHRoZSBjb21wcmVoZW5zaXZlIHByb3RvY29sLiBBbnkgb3RoZXIgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBpbiB0aGVcbiAqIGNsYXNzIHNwZWNpZmljYXRpb24gd2lsbCBiZSBhdmFpbGFibGUgb24gdGhlIHByb3RvdHlwZS5cbiAqXG4gKiBAaW50ZXJmYWNlIFJlYWN0Q2xhc3NJbnRlcmZhY2VcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RDbGFzc0ludGVyZmFjZSA9IHtcblxuICAvKipcbiAgICogQW4gYXJyYXkgb2YgTWl4aW4gb2JqZWN0cyB0byBpbmNsdWRlIHdoZW4gZGVmaW5pbmcgeW91ciBjb21wb25lbnQuXG4gICAqXG4gICAqIEB0eXBlIHthcnJheX1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBtaXhpbnM6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEFuIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgdGhhdCBzaG91bGQgYmUgZGVmaW5lZCBvblxuICAgKiB0aGUgY29tcG9uZW50J3MgY29uc3RydWN0b3IgaW5zdGVhZCBvZiBpdHMgcHJvdG90eXBlIChzdGF0aWMgbWV0aG9kcykuXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgc3RhdGljczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogRGVmaW5pdGlvbiBvZiBwcm9wIHR5cGVzIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBwcm9wVHlwZXM6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIERlZmluaXRpb24gb2YgY29udGV4dCB0eXBlcyBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29udGV4dFR5cGVzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBEZWZpbml0aW9uIG9mIGNvbnRleHQgdHlwZXMgdGhpcyBjb21wb25lbnQgc2V0cyBmb3IgaXRzIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNoaWxkQ29udGV4dFR5cGVzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8vID09PT0gRGVmaW5pdGlvbiBtZXRob2RzID09PT1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC4gVmFsdWVzIGluIHRoZSBtYXBwaW5nIHdpbGwgYmUgc2V0IG9uXG4gICAqIGB0aGlzLnByb3BzYCBpZiB0aGF0IHByb3AgaXMgbm90IHNwZWNpZmllZCAoaS5lLiB1c2luZyBhbiBgaW5gIGNoZWNrKS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCBiZWZvcmUgYGdldEluaXRpYWxTdGF0ZWAgYW5kIHRoZXJlZm9yZSBjYW5ub3QgcmVseVxuICAgKiBvbiBgdGhpcy5zdGF0ZWAgb3IgdXNlIGB0aGlzLnNldFN0YXRlYC5cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGdldERlZmF1bHRQcm9wczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQsXG5cbiAgLyoqXG4gICAqIEludm9rZWQgb25jZSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgYmUgdXNlZFxuICAgKiBhcyB0aGUgaW5pdGlhbCB2YWx1ZSBvZiBgdGhpcy5zdGF0ZWAuXG4gICAqXG4gICAqICAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICogICAgIHJldHVybiB7XG4gICAqICAgICAgIGlzT246IGZhbHNlLFxuICAgKiAgICAgICBmb29CYXo6IG5ldyBCYXpGb28oKVxuICAgKiAgICAgfVxuICAgKiAgIH1cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGdldEluaXRpYWxTdGF0ZTogU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQsXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBnZXRDaGlsZENvbnRleHQ6IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VELFxuXG4gIC8qKlxuICAgKiBVc2VzIHByb3BzIGZyb20gYHRoaXMucHJvcHNgIGFuZCBzdGF0ZSBmcm9tIGB0aGlzLnN0YXRlYCB0byByZW5kZXIgdGhlXG4gICAqIHN0cnVjdHVyZSBvZiB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBObyBndWFyYW50ZWVzIGFyZSBtYWRlIGFib3V0IHdoZW4gb3IgaG93IG9mdGVuIHRoaXMgbWV0aG9kIGlzIGludm9rZWQsIHNvXG4gICAqIGl0IG11c3Qgbm90IGhhdmUgc2lkZSBlZmZlY3RzLlxuICAgKlxuICAgKiAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAqICAgICB2YXIgbmFtZSA9IHRoaXMucHJvcHMubmFtZTtcbiAgICogICAgIHJldHVybiA8ZGl2PkhlbGxvLCB7bmFtZX0hPC9kaXY+O1xuICAgKiAgIH1cbiAgICpcbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9XG4gICAqIEBub3NpZGVlZmZlY3RzXG4gICAqIEByZXF1aXJlZFxuICAgKi9cbiAgcmVuZGVyOiBTcGVjUG9saWN5LkRFRklORV9PTkNFLFxuXG4gIC8vID09PT0gRGVsZWdhdGUgbWV0aG9kcyA9PT09XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGluaXRpYWxseSBjcmVhdGVkIGFuZCBhYm91dCB0byBiZSBtb3VudGVkLlxuICAgKiBUaGlzIG1heSBoYXZlIHNpZGUgZWZmZWN0cywgYnV0IGFueSBleHRlcm5hbCBzdWJzY3JpcHRpb25zIG9yIGRhdGEgY3JlYXRlZFxuICAgKiBieSB0aGlzIG1ldGhvZCBtdXN0IGJlIGNsZWFuZWQgdXAgaW4gYGNvbXBvbmVudFdpbGxVbm1vdW50YC5cbiAgICpcbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnRXaWxsTW91bnQ6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWQgYW5kIGhhcyBhIERPTSByZXByZXNlbnRhdGlvbi5cbiAgICogSG93ZXZlciwgdGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgdGhlIERPTSBub2RlIGlzIGluIHRoZSBkb2N1bWVudC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gb3BlcmF0ZSBvbiB0aGUgRE9NIHdoZW4gdGhlIGNvbXBvbmVudCBoYXNcbiAgICogYmVlbiBtb3VudGVkIChpbml0aWFsaXplZCBhbmQgcmVuZGVyZWQpIGZvciB0aGUgZmlyc3QgdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSByb290Tm9kZSBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGNvbXBvbmVudC5cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnREaWRNb3VudDogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogSW52b2tlZCBiZWZvcmUgdGhlIGNvbXBvbmVudCByZWNlaXZlcyBuZXcgcHJvcHMuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIHJlYWN0IHRvIGEgcHJvcCB0cmFuc2l0aW9uIGJ5IHVwZGF0aW5nIHRoZVxuICAgKiBzdGF0ZSB1c2luZyBgdGhpcy5zZXRTdGF0ZWAuIEN1cnJlbnQgcHJvcHMgYXJlIGFjY2Vzc2VkIHZpYSBgdGhpcy5wcm9wc2AuXG4gICAqXG4gICAqICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24obmV4dFByb3BzLCBuZXh0Q29udGV4dCkge1xuICAgKiAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAqICAgICAgIGxpa2VzSW5jcmVhc2luZzogbmV4dFByb3BzLmxpa2VDb3VudCA+IHRoaXMucHJvcHMubGlrZUNvdW50XG4gICAqICAgICB9KTtcbiAgICogICB9XG4gICAqXG4gICAqIE5PVEU6IFRoZXJlIGlzIG5vIGVxdWl2YWxlbnQgYGNvbXBvbmVudFdpbGxSZWNlaXZlU3RhdGVgLiBBbiBpbmNvbWluZyBwcm9wXG4gICAqIHRyYW5zaXRpb24gbWF5IGNhdXNlIGEgc3RhdGUgY2hhbmdlLCBidXQgdGhlIG9wcG9zaXRlIGlzIG5vdCB0cnVlLiBJZiB5b3VcbiAgICogbmVlZCBpdCwgeW91IGFyZSBwcm9iYWJseSBsb29raW5nIGZvciBgY29tcG9uZW50V2lsbFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoaWxlIGRlY2lkaW5nIGlmIHRoZSBjb21wb25lbnQgc2hvdWxkIGJlIHVwZGF0ZWQgYXMgYSByZXN1bHQgb2ZcbiAgICogcmVjZWl2aW5nIG5ldyBwcm9wcywgc3RhdGUgYW5kL29yIGNvbnRleHQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIGByZXR1cm4gZmFsc2VgIHdoZW4geW91J3JlIGNlcnRhaW4gdGhhdCB0aGVcbiAgICogdHJhbnNpdGlvbiB0byB0aGUgbmV3IHByb3BzL3N0YXRlL2NvbnRleHQgd2lsbCBub3QgcmVxdWlyZSBhIGNvbXBvbmVudFxuICAgKiB1cGRhdGUuXG4gICAqXG4gICAqICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiBmdW5jdGlvbihuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQpIHtcbiAgICogICAgIHJldHVybiAhZXF1YWwobmV4dFByb3BzLCB0aGlzLnByb3BzKSB8fFxuICAgKiAgICAgICAhZXF1YWwobmV4dFN0YXRlLCB0aGlzLnN0YXRlKSB8fFxuICAgKiAgICAgICAhZXF1YWwobmV4dENvbnRleHQsIHRoaXMuY29udGV4dCk7XG4gICAqICAgfVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dFN0YXRlXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENvbnRleHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgY29tcG9uZW50IHNob3VsZCB1cGRhdGUuXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiBTcGVjUG9saWN5LkRFRklORV9PTkNFLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBhYm91dCB0byB1cGRhdGUgZHVlIHRvIGEgdHJhbnNpdGlvbiBmcm9tXG4gICAqIGB0aGlzLnByb3BzYCwgYHRoaXMuc3RhdGVgIGFuZCBgdGhpcy5jb250ZXh0YCB0byBgbmV4dFByb3BzYCwgYG5leHRTdGF0ZWBcbiAgICogYW5kIGBuZXh0Q29udGV4dGAuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIHBlcmZvcm0gcHJlcGFyYXRpb24gYmVmb3JlIGFuIHVwZGF0ZSBvY2N1cnMuXG4gICAqXG4gICAqIE5PVEU6IFlvdSAqKmNhbm5vdCoqIHVzZSBgdGhpcy5zZXRTdGF0ZSgpYCBpbiB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRTdGF0ZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0XG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnRXaWxsVXBkYXRlOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCdzIERPTSByZXByZXNlbnRhdGlvbiBoYXMgYmVlbiB1cGRhdGVkLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBvcGVyYXRlIG9uIHRoZSBET00gd2hlbiB0aGUgY29tcG9uZW50IGhhc1xuICAgKiBiZWVuIHVwZGF0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcmV2UHJvcHNcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2U3RhdGVcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2Q29udGV4dFxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHJvb3ROb2RlIERPTSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgY29tcG9uZW50LlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudERpZFVwZGF0ZTogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgYWJvdXQgdG8gYmUgcmVtb3ZlZCBmcm9tIGl0cyBwYXJlbnQgYW5kIGhhdmVcbiAgICogaXRzIERPTSByZXByZXNlbnRhdGlvbiBkZXN0cm95ZWQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIGRlYWxsb2NhdGUgYW55IGV4dGVybmFsIHJlc291cmNlcy5cbiAgICpcbiAgICogTk9URTogVGhlcmUgaXMgbm8gYGNvbXBvbmVudERpZFVubW91bnRgIHNpbmNlIHlvdXIgY29tcG9uZW50IHdpbGwgaGF2ZSBiZWVuXG4gICAqIGRlc3Ryb3llZCBieSB0aGF0IHBvaW50LlxuICAgKlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8vID09PT0gQWR2YW5jZWQgbWV0aG9kcyA9PT09XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGNvbXBvbmVudCdzIGN1cnJlbnRseSBtb3VudGVkIERPTSByZXByZXNlbnRhdGlvbi5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhpcyBpbXBsZW1lbnRzIFJlYWN0J3MgcmVuZGVyaW5nIGFuZCByZWNvbmNpbGlhdGlvbiBhbGdvcml0aG0uXG4gICAqIFNvcGhpc3RpY2F0ZWQgY2xpZW50cyBtYXkgd2lzaCB0byBvdmVycmlkZSB0aGlzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAb3ZlcnJpZGFibGVcbiAgICovXG4gIHVwZGF0ZUNvbXBvbmVudDogU3BlY1BvbGljeS5PVkVSUklERV9CQVNFXG5cbn07XG5cbi8qKlxuICogTWFwcGluZyBmcm9tIGNsYXNzIHNwZWNpZmljYXRpb24ga2V5cyB0byBzcGVjaWFsIHByb2Nlc3NpbmcgZnVuY3Rpb25zLlxuICpcbiAqIEFsdGhvdWdoIHRoZXNlIGFyZSBkZWNsYXJlZCBsaWtlIGluc3RhbmNlIHByb3BlcnRpZXMgaW4gdGhlIHNwZWNpZmljYXRpb25cbiAqIHdoZW4gZGVmaW5pbmcgY2xhc3NlcyB1c2luZyBgUmVhY3QuY3JlYXRlQ2xhc3NgLCB0aGV5IGFyZSBhY3R1YWxseSBzdGF0aWNcbiAqIGFuZCBhcmUgYWNjZXNzaWJsZSBvbiB0aGUgY29uc3RydWN0b3IgaW5zdGVhZCBvZiB0aGUgcHJvdG90eXBlLiBEZXNwaXRlXG4gKiBiZWluZyBzdGF0aWMsIHRoZXkgbXVzdCBiZSBkZWZpbmVkIG91dHNpZGUgb2YgdGhlIFwic3RhdGljc1wiIGtleSB1bmRlclxuICogd2hpY2ggYWxsIG90aGVyIHN0YXRpYyBtZXRob2RzIGFyZSBkZWZpbmVkLlxuICovXG52YXIgUkVTRVJWRURfU1BFQ19LRVlTID0ge1xuICBkaXNwbGF5TmFtZTogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBkaXNwbGF5TmFtZSkge1xuICAgIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gIH0sXG4gIG1peGluczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBtaXhpbnMpIHtcbiAgICBpZiAobWl4aW5zKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1peGlucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3RvciwgbWl4aW5zW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNoaWxkQ29udGV4dFR5cGVzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGNoaWxkQ29udGV4dFR5cGVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgY2hpbGRDb250ZXh0VHlwZXMsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMuY2hpbGRDb250ZXh0KTtcbiAgICB9XG4gICAgQ29uc3RydWN0b3IuY2hpbGRDb250ZXh0VHlwZXMgPSBhc3NpZ24oe30sIENvbnN0cnVjdG9yLmNoaWxkQ29udGV4dFR5cGVzLCBjaGlsZENvbnRleHRUeXBlcyk7XG4gIH0sXG4gIGNvbnRleHRUeXBlczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBjb250ZXh0VHlwZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBjb250ZXh0VHlwZXMsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMuY29udGV4dCk7XG4gICAgfVxuICAgIENvbnN0cnVjdG9yLmNvbnRleHRUeXBlcyA9IGFzc2lnbih7fSwgQ29uc3RydWN0b3IuY29udGV4dFR5cGVzLCBjb250ZXh0VHlwZXMpO1xuICB9LFxuICAvKipcbiAgICogU3BlY2lhbCBjYXNlIGdldERlZmF1bHRQcm9wcyB3aGljaCBzaG91bGQgbW92ZSBpbnRvIHN0YXRpY3MgYnV0IHJlcXVpcmVzXG4gICAqIGF1dG9tYXRpYyBtZXJnaW5nLlxuICAgKi9cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGdldERlZmF1bHRQcm9wcykge1xuICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcyA9IGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcywgZ2V0RGVmYXVsdFByb3BzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzID0gZ2V0RGVmYXVsdFByb3BzO1xuICAgIH1cbiAgfSxcbiAgcHJvcFR5cGVzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3BUeXBlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIHByb3BUeXBlcywgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5wcm9wKTtcbiAgICB9XG4gICAgQ29uc3RydWN0b3IucHJvcFR5cGVzID0gYXNzaWduKHt9LCBDb25zdHJ1Y3Rvci5wcm9wVHlwZXMsIHByb3BUeXBlcyk7XG4gIH0sXG4gIHN0YXRpY3M6IGZ1bmN0aW9uIChDb25zdHJ1Y3Rvciwgc3RhdGljcykge1xuICAgIG1peFN0YXRpY1NwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzdGF0aWNzKTtcbiAgfSxcbiAgYXV0b2JpbmQ6IGZ1bmN0aW9uICgpIHt9IH07XG5cbi8vIG5vb3BcbmZ1bmN0aW9uIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgdHlwZURlZiwgbG9jYXRpb24pIHtcbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gdHlwZURlZikge1xuICAgIGlmICh0eXBlRGVmLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgLy8gdXNlIGEgd2FybmluZyBpbnN0ZWFkIG9mIGFuIGludmFyaWFudCBzbyBjb21wb25lbnRzXG4gICAgICAvLyBkb24ndCBzaG93IHVwIGluIHByb2QgYnV0IG5vdCBpbiBfX0RFVl9fXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgdHlwZURlZltwcm9wTmFtZV0gPT09ICdmdW5jdGlvbicsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tICcgKyAnUmVhY3QuUHJvcFR5cGVzLicsIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCBwcm9wTmFtZSkgOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUocHJvdG8sIG5hbWUpIHtcbiAgdmFyIHNwZWNQb2xpY3kgPSBSZWFjdENsYXNzSW50ZXJmYWNlLmhhc093blByb3BlcnR5KG5hbWUpID8gUmVhY3RDbGFzc0ludGVyZmFjZVtuYW1lXSA6IG51bGw7XG5cbiAgLy8gRGlzYWxsb3cgb3ZlcnJpZGluZyBvZiBiYXNlIGNsYXNzIG1ldGhvZHMgdW5sZXNzIGV4cGxpY2l0bHkgYWxsb3dlZC5cbiAgaWYgKFJlYWN0Q2xhc3NNaXhpbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICEoc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5PVkVSUklERV9CQVNFKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzSW50ZXJmYWNlOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gb3ZlcnJpZGUgJyArICdgJXNgIGZyb20geW91ciBjbGFzcyBzcGVjaWZpY2F0aW9uLiBFbnN1cmUgdGhhdCB5b3VyIG1ldGhvZCBuYW1lcyAnICsgJ2RvIG5vdCBvdmVybGFwIHdpdGggUmVhY3QgbWV0aG9kcy4nLCBuYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBEaXNhbGxvdyBkZWZpbmluZyBtZXRob2RzIG1vcmUgdGhhbiBvbmNlIHVubGVzcyBleHBsaWNpdGx5IGFsbG93ZWQuXG4gIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICEoc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWSB8fCBzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzc0ludGVyZmFjZTogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSAnICsgJ2Alc2Agb24geW91ciBjb21wb25lbnQgbW9yZSB0aGFuIG9uY2UuIFRoaXMgY29uZmxpY3QgbWF5IGJlIGR1ZSAnICsgJ3RvIGEgbWl4aW4uJywgbmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogTWl4aW4gaGVscGVyIHdoaWNoIGhhbmRsZXMgcG9saWN5IHZhbGlkYXRpb24gYW5kIHJlc2VydmVkXG4gKiBzcGVjaWZpY2F0aW9uIGtleXMgd2hlbiBidWlsZGluZyBSZWFjdCBjbGFzc3Nlcy5cbiAqL1xuZnVuY3Rpb24gbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHNwZWMpIHtcbiAgaWYgKCFzcGVjKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgISh0eXBlb2Ygc3BlYyAhPT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogWW91XFwncmUgYXR0ZW1wdGluZyB0byAnICsgJ3VzZSBhIGNvbXBvbmVudCBjbGFzcyBhcyBhIG1peGluLiBJbnN0ZWFkLCBqdXN0IHVzZSBhIHJlZ3VsYXIgb2JqZWN0LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgISFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoc3BlYykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogWW91XFwncmUgYXR0ZW1wdGluZyB0byAnICsgJ3VzZSBhIGNvbXBvbmVudCBhcyBhIG1peGluLiBJbnN0ZWFkLCBqdXN0IHVzZSBhIHJlZ3VsYXIgb2JqZWN0LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICB2YXIgcHJvdG8gPSBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbiAgLy8gQnkgaGFuZGxpbmcgbWl4aW5zIGJlZm9yZSBhbnkgb3RoZXIgcHJvcGVydGllcywgd2UgZW5zdXJlIHRoZSBzYW1lXG4gIC8vIGNoYWluaW5nIG9yZGVyIGlzIGFwcGxpZWQgdG8gbWV0aG9kcyB3aXRoIERFRklORV9NQU5ZIHBvbGljeSwgd2hldGhlclxuICAvLyBtaXhpbnMgYXJlIGxpc3RlZCBiZWZvcmUgb3IgYWZ0ZXIgdGhlc2UgbWV0aG9kcyBpbiB0aGUgc3BlYy5cbiAgaWYgKHNwZWMuaGFzT3duUHJvcGVydHkoTUlYSU5TX0tFWSkpIHtcbiAgICBSRVNFUlZFRF9TUEVDX0tFWVMubWl4aW5zKENvbnN0cnVjdG9yLCBzcGVjLm1peGlucyk7XG4gIH1cblxuICBmb3IgKHZhciBuYW1lIGluIHNwZWMpIHtcbiAgICBpZiAoIXNwZWMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChuYW1lID09PSBNSVhJTlNfS0VZKSB7XG4gICAgICAvLyBXZSBoYXZlIGFscmVhZHkgaGFuZGxlZCBtaXhpbnMgaW4gYSBzcGVjaWFsIGNhc2UgYWJvdmUuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcGVydHkgPSBzcGVjW25hbWVdO1xuICAgIHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUocHJvdG8sIG5hbWUpO1xuXG4gICAgaWYgKFJFU0VSVkVEX1NQRUNfS0VZUy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgUkVTRVJWRURfU1BFQ19LRVlTW25hbWVdKENvbnN0cnVjdG9yLCBwcm9wZXJ0eSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNldHVwIG1ldGhvZHMgb24gcHJvdG90eXBlOlxuICAgICAgLy8gVGhlIGZvbGxvd2luZyBtZW1iZXIgbWV0aG9kcyBzaG91bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgYm91bmQ6XG4gICAgICAvLyAxLiBFeHBlY3RlZCBSZWFjdENsYXNzIG1ldGhvZHMgKGluIHRoZSBcImludGVyZmFjZVwiKS5cbiAgICAgIC8vIDIuIE92ZXJyaWRkZW4gbWV0aG9kcyAodGhhdCB3ZXJlIG1peGVkIGluKS5cbiAgICAgIHZhciBpc1JlYWN0Q2xhc3NNZXRob2QgPSBSZWFjdENsYXNzSW50ZXJmYWNlLmhhc093blByb3BlcnR5KG5hbWUpO1xuICAgICAgdmFyIGlzQWxyZWFkeURlZmluZWQgPSBwcm90by5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgICAgIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHByb3BlcnR5ID09PSAnZnVuY3Rpb24nO1xuICAgICAgdmFyIHNob3VsZEF1dG9CaW5kID0gaXNGdW5jdGlvbiAmJiAhaXNSZWFjdENsYXNzTWV0aG9kICYmICFpc0FscmVhZHlEZWZpbmVkICYmIHNwZWMuYXV0b2JpbmQgIT09IGZhbHNlO1xuXG4gICAgICBpZiAoc2hvdWxkQXV0b0JpbmQpIHtcbiAgICAgICAgaWYgKCFwcm90by5fX3JlYWN0QXV0b0JpbmRNYXApIHtcbiAgICAgICAgICBwcm90by5fX3JlYWN0QXV0b0JpbmRNYXAgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBwcm90by5fX3JlYWN0QXV0b0JpbmRNYXBbbmFtZV0gPSBwcm9wZXJ0eTtcbiAgICAgICAgcHJvdG9bbmFtZV0gPSBwcm9wZXJ0eTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc0FscmVhZHlEZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIHNwZWNQb2xpY3kgPSBSZWFjdENsYXNzSW50ZXJmYWNlW25hbWVdO1xuXG4gICAgICAgICAgLy8gVGhlc2UgY2FzZXMgc2hvdWxkIGFscmVhZHkgYmUgY2F1Z2h0IGJ5IHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUuXG4gICAgICAgICAgIShpc1JlYWN0Q2xhc3NNZXRob2QgJiYgKHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VEIHx8IHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTlkpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBVbmV4cGVjdGVkIHNwZWMgcG9saWN5ICVzIGZvciBrZXkgJXMgJyArICd3aGVuIG1peGluZyBpbiBjb21wb25lbnQgc3BlY3MuJywgc3BlY1BvbGljeSwgbmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgLy8gRm9yIG1ldGhvZHMgd2hpY2ggYXJlIGRlZmluZWQgbW9yZSB0aGFuIG9uY2UsIGNhbGwgdGhlIGV4aXN0aW5nXG4gICAgICAgICAgLy8gbWV0aG9kcyBiZWZvcmUgY2FsbGluZyB0aGUgbmV3IHByb3BlcnR5LCBtZXJnaW5nIGlmIGFwcHJvcHJpYXRlLlxuICAgICAgICAgIGlmIChzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCkge1xuICAgICAgICAgICAgcHJvdG9bbmFtZV0gPSBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihwcm90b1tuYW1lXSwgcHJvcGVydHkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWSkge1xuICAgICAgICAgICAgcHJvdG9bbmFtZV0gPSBjcmVhdGVDaGFpbmVkRnVuY3Rpb24ocHJvdG9bbmFtZV0sIHByb3BlcnR5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvdG9bbmFtZV0gPSBwcm9wZXJ0eTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgLy8gQWRkIHZlcmJvc2UgZGlzcGxheU5hbWUgdG8gdGhlIGZ1bmN0aW9uLCB3aGljaCBoZWxwcyB3aGVuIGxvb2tpbmdcbiAgICAgICAgICAgIC8vIGF0IHByb2ZpbGluZyB0b29scy5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdmdW5jdGlvbicgJiYgc3BlYy5kaXNwbGF5TmFtZSkge1xuICAgICAgICAgICAgICBwcm90b1tuYW1lXS5kaXNwbGF5TmFtZSA9IHNwZWMuZGlzcGxheU5hbWUgKyAnXycgKyBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtaXhTdGF0aWNTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3RhdGljcykge1xuICBpZiAoIXN0YXRpY3MpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIgbmFtZSBpbiBzdGF0aWNzKSB7XG4gICAgdmFyIHByb3BlcnR5ID0gc3RhdGljc1tuYW1lXTtcbiAgICBpZiAoIXN0YXRpY3MuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBpc1Jlc2VydmVkID0gKG5hbWUgaW4gUkVTRVJWRURfU1BFQ19LRVlTKTtcbiAgICAhIWlzUmVzZXJ2ZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSBhIHJlc2VydmVkICcgKyAncHJvcGVydHksIGAlc2AsIHRoYXQgc2hvdWxkblxcJ3QgYmUgb24gdGhlIFwic3RhdGljc1wiIGtleS4gRGVmaW5lIGl0ICcgKyAnYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgaW5zdGVhZDsgaXQgd2lsbCBzdGlsbCBiZSBhY2Nlc3NpYmxlIG9uIHRoZSAnICsgJ2NvbnN0cnVjdG9yLicsIG5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIHZhciBpc0luaGVyaXRlZCA9IChuYW1lIGluIENvbnN0cnVjdG9yKTtcbiAgICAhIWlzSW5oZXJpdGVkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgJyArICdgJXNgIG9uIHlvdXIgY29tcG9uZW50IG1vcmUgdGhhbiBvbmNlLiBUaGlzIGNvbmZsaWN0IG1heSBiZSAnICsgJ2R1ZSB0byBhIG1peGluLicsIG5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICBDb25zdHJ1Y3RvcltuYW1lXSA9IHByb3BlcnR5O1xuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9iamVjdHMsIGJ1dCB0aHJvdyBpZiBib3RoIGNvbnRhaW4gdGhlIHNhbWUga2V5LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvbmUgVGhlIGZpcnN0IG9iamVjdCwgd2hpY2ggaXMgbXV0YXRlZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSB0d28gVGhlIHNlY29uZCBvYmplY3RcbiAqIEByZXR1cm4ge29iamVjdH0gb25lIGFmdGVyIGl0IGhhcyBiZWVuIG11dGF0ZWQgdG8gY29udGFpbiBldmVyeXRoaW5nIGluIHR3by5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhvbmUsIHR3bykge1xuICAhKG9uZSAmJiB0d28gJiYgdHlwZW9mIG9uZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHR3byA9PT0gJ29iamVjdCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ21lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoKTogQ2Fubm90IG1lcmdlIG5vbi1vYmplY3RzLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICBmb3IgKHZhciBrZXkgaW4gdHdvKSB7XG4gICAgaWYgKHR3by5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAhKG9uZVtrZXldID09PSB1bmRlZmluZWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ21lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoKTogJyArICdUcmllZCB0byBtZXJnZSB0d28gb2JqZWN0cyB3aXRoIHRoZSBzYW1lIGtleTogYCVzYC4gVGhpcyBjb25mbGljdCAnICsgJ21heSBiZSBkdWUgdG8gYSBtaXhpbjsgaW4gcGFydGljdWxhciwgdGhpcyBtYXkgYmUgY2F1c2VkIGJ5IHR3byAnICsgJ2dldEluaXRpYWxTdGF0ZSgpIG9yIGdldERlZmF1bHRQcm9wcygpIG1ldGhvZHMgcmV0dXJuaW5nIG9iamVjdHMgJyArICd3aXRoIGNsYXNoaW5nIGtleXMuJywga2V5KSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICBvbmVba2V5XSA9IHR3b1trZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb25lO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdHdvIGZ1bmN0aW9ucyBhbmQgbWVyZ2VzIHRoZWlyIHJldHVybiB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gb25lIEZ1bmN0aW9uIHRvIGludm9rZSBmaXJzdC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHR3byBGdW5jdGlvbiB0byBpbnZva2Ugc2Vjb25kLlxuICogQHJldHVybiB7ZnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgdHdvIGFyZ3VtZW50IGZ1bmN0aW9ucy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKG9uZSwgdHdvKSB7XG4gIHJldHVybiBmdW5jdGlvbiBtZXJnZWRSZXN1bHQoKSB7XG4gICAgdmFyIGEgPSBvbmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB2YXIgYiA9IHR3by5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChhID09IG51bGwpIHtcbiAgICAgIHJldHVybiBiO1xuICAgIH0gZWxzZSBpZiAoYiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgdmFyIGMgPSB7fTtcbiAgICBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKGMsIGEpO1xuICAgIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoYywgYik7XG4gICAgcmV0dXJuIGM7XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0d28gZnVuY3Rpb25zIGFuZCBpZ25vcmVzIHRoZWlyIHJldHVybiB2YWxlcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbmUgRnVuY3Rpb24gdG8gaW52b2tlIGZpcnN0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHdvIEZ1bmN0aW9uIHRvIGludm9rZSBzZWNvbmQuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gRnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSB0d28gYXJndW1lbnQgZnVuY3Rpb25zLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKG9uZSwgdHdvKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjaGFpbmVkRnVuY3Rpb24oKSB7XG4gICAgb25lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdHdvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbi8qKlxuICogQmluZHMgYSBtZXRob2QgdG8gdGhlIGNvbXBvbmVudC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50IENvbXBvbmVudCB3aG9zZSBtZXRob2QgaXMgZ29pbmcgdG8gYmUgYm91bmQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXRob2QgTWV0aG9kIHRvIGJlIGJvdW5kLlxuICogQHJldHVybiB7ZnVuY3Rpb259IFRoZSBib3VuZCBtZXRob2QuXG4gKi9cbmZ1bmN0aW9uIGJpbmRBdXRvQmluZE1ldGhvZChjb21wb25lbnQsIG1ldGhvZCkge1xuICB2YXIgYm91bmRNZXRob2QgPSBtZXRob2QuYmluZChjb21wb25lbnQpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZENvbnRleHQgPSBjb21wb25lbnQ7XG4gICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kTWV0aG9kID0gbWV0aG9kO1xuICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZEFyZ3VtZW50cyA9IG51bGw7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQuY29uc3RydWN0b3IuZGlzcGxheU5hbWU7XG4gICAgdmFyIF9iaW5kID0gYm91bmRNZXRob2QuYmluZDtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBibG9jay1zY29wZWQtdmFyLCBuby11bmRlZiAqL1xuICAgIGJvdW5kTWV0aG9kLmJpbmQgPSBmdW5jdGlvbiAobmV3VGhpcykge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICAvLyBVc2VyIGlzIHRyeWluZyB0byBiaW5kKCkgYW4gYXV0b2JvdW5kIG1ldGhvZDsgd2UgZWZmZWN0aXZlbHkgd2lsbFxuICAgICAgLy8gaWdub3JlIHRoZSB2YWx1ZSBvZiBcInRoaXNcIiB0aGF0IHRoZSB1c2VyIGlzIHRyeWluZyB0byB1c2UsIHNvXG4gICAgICAvLyBsZXQncyB3YXJuLlxuICAgICAgaWYgKG5ld1RoaXMgIT09IGNvbXBvbmVudCAmJiBuZXdUaGlzICE9PSBudWxsKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYmluZCgpOiBSZWFjdCBjb21wb25lbnQgbWV0aG9kcyBtYXkgb25seSBiZSBib3VuZCB0byB0aGUgJyArICdjb21wb25lbnQgaW5zdGFuY2UuIFNlZSAlcycsIGNvbXBvbmVudE5hbWUpIDogdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIGlmICghYXJncy5sZW5ndGgpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdiaW5kKCk6IFlvdSBhcmUgYmluZGluZyBhIGNvbXBvbmVudCBtZXRob2QgdG8gdGhlIGNvbXBvbmVudC4gJyArICdSZWFjdCBkb2VzIHRoaXMgZm9yIHlvdSBhdXRvbWF0aWNhbGx5IGluIGEgaGlnaC1wZXJmb3JtYW5jZSAnICsgJ3dheSwgc28geW91IGNhbiBzYWZlbHkgcmVtb3ZlIHRoaXMgY2FsbC4gU2VlICVzJywgY29tcG9uZW50TmFtZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBib3VuZE1ldGhvZDtcbiAgICAgIH1cbiAgICAgIHZhciByZWJvdW5kTWV0aG9kID0gX2JpbmQuYXBwbHkoYm91bmRNZXRob2QsIGFyZ3VtZW50cyk7XG4gICAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZENvbnRleHQgPSBjb21wb25lbnQ7XG4gICAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZE1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQXJndW1lbnRzID0gYXJncztcbiAgICAgIHJldHVybiByZWJvdW5kTWV0aG9kO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSAqL1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGJvdW5kTWV0aG9kO1xufVxuXG4vKipcbiAqIEJpbmRzIGFsbCBhdXRvLWJvdW5kIG1ldGhvZHMgaW4gYSBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudCBDb21wb25lbnQgd2hvc2UgbWV0aG9kIGlzIGdvaW5nIHRvIGJlIGJvdW5kLlxuICovXG5mdW5jdGlvbiBiaW5kQXV0b0JpbmRNZXRob2RzKGNvbXBvbmVudCkge1xuICBmb3IgKHZhciBhdXRvQmluZEtleSBpbiBjb21wb25lbnQuX19yZWFjdEF1dG9CaW5kTWFwKSB7XG4gICAgaWYgKGNvbXBvbmVudC5fX3JlYWN0QXV0b0JpbmRNYXAuaGFzT3duUHJvcGVydHkoYXV0b0JpbmRLZXkpKSB7XG4gICAgICB2YXIgbWV0aG9kID0gY29tcG9uZW50Ll9fcmVhY3RBdXRvQmluZE1hcFthdXRvQmluZEtleV07XG4gICAgICBjb21wb25lbnRbYXV0b0JpbmRLZXldID0gYmluZEF1dG9CaW5kTWV0aG9kKGNvbXBvbmVudCwgbWV0aG9kKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBZGQgbW9yZSB0byB0aGUgUmVhY3RDbGFzcyBiYXNlIGNsYXNzLiBUaGVzZSBhcmUgYWxsIGxlZ2FjeSBmZWF0dXJlcyBhbmRcbiAqIHRoZXJlZm9yZSBub3QgYWxyZWFkeSBwYXJ0IG9mIHRoZSBtb2Rlcm4gUmVhY3RDb21wb25lbnQuXG4gKi9cbnZhciBSZWFjdENsYXNzTWl4aW4gPSB7XG5cbiAgLyoqXG4gICAqIFRPRE86IFRoaXMgd2lsbCBiZSBkZXByZWNhdGVkIGJlY2F1c2Ugc3RhdGUgc2hvdWxkIGFsd2F5cyBrZWVwIGEgY29uc2lzdGVudFxuICAgKiB0eXBlIHNpZ25hdHVyZSBhbmQgdGhlIG9ubHkgdXNlIGNhc2UgZm9yIHRoaXMsIGlzIHRvIGF2b2lkIHRoYXQuXG4gICAqL1xuICByZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChuZXdTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZSh0aGlzLCBuZXdTdGF0ZSk7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVyLmlzTW91bnRlZCh0aGlzKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgcHJvcHMuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsUHJvcHMgU3Vic2V0IG9mIHRoZSBuZXh0IHByb3BzLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHByb3BzIGFyZSB1cGRhdGVkLlxuICAgKiBAZmluYWxcbiAgICogQHB1YmxpY1xuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgc2V0UHJvcHM6IGZ1bmN0aW9uIChwYXJ0aWFsUHJvcHMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm5TZXRQcm9wcygpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFByb3BzKHRoaXMsIHBhcnRpYWxQcm9wcyk7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2UgYWxsIHRoZSBwcm9wcy5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5ld1Byb3BzIFN1YnNldCBvZiB0aGUgbmV4dCBwcm9wcy5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBwcm9wcyBhcmUgdXBkYXRlZC5cbiAgICogQGZpbmFsXG4gICAqIEBwdWJsaWNcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHJlcGxhY2VQcm9wczogZnVuY3Rpb24gKG5ld1Byb3BzLCBjYWxsYmFjaykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuU2V0UHJvcHMoKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVyLmVucXVldWVSZXBsYWNlUHJvcHModGhpcywgbmV3UHJvcHMpO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgdGhpcy51cGRhdGVyLmVucXVldWVDYWxsYmFjayh0aGlzLCBjYWxsYmFjayk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgUmVhY3RDbGFzc0NvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHt9O1xuYXNzaWduKFJlYWN0Q2xhc3NDb21wb25lbnQucHJvdG90eXBlLCBSZWFjdENvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0Q2xhc3NNaXhpbik7XG5cbi8qKlxuICogTW9kdWxlIGZvciBjcmVhdGluZyBjb21wb3NpdGUgY29tcG9uZW50cy5cbiAqXG4gKiBAY2xhc3MgUmVhY3RDbGFzc1xuICovXG52YXIgUmVhY3RDbGFzcyA9IHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNvbXBvc2l0ZSBjb21wb25lbnQgY2xhc3MgZ2l2ZW4gYSBjbGFzcyBzcGVjaWZpY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gc3BlYyBDbGFzcyBzcGVjaWZpY2F0aW9uICh3aGljaCBtdXN0IGRlZmluZSBgcmVuZGVyYCkuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBDb21wb25lbnQgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNyZWF0ZUNsYXNzOiBmdW5jdGlvbiAoc3BlYykge1xuICAgIHZhciBDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAgICAgLy8gVGhpcyBjb25zdHJ1Y3RvciBpcyBvdmVycmlkZGVuIGJ5IG1vY2tzLiBUaGUgYXJndW1lbnQgaXMgdXNlZFxuICAgICAgLy8gYnkgbW9ja3MgdG8gYXNzZXJ0IG9uIHdoYXQgZ2V0cyBtb3VudGVkLlxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0aGlzIGluc3RhbmNlb2YgQ29uc3RydWN0b3IsICdTb21ldGhpbmcgaXMgY2FsbGluZyBhIFJlYWN0IGNvbXBvbmVudCBkaXJlY3RseS4gVXNlIGEgZmFjdG9yeSBvciAnICsgJ0pTWCBpbnN0ZWFkLiBTZWU6IGh0dHBzOi8vZmIubWUvcmVhY3QtbGVnYWN5ZmFjdG9yeScpIDogdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICAvLyBXaXJlIHVwIGF1dG8tYmluZGluZ1xuICAgICAgaWYgKHRoaXMuX19yZWFjdEF1dG9CaW5kTWFwKSB7XG4gICAgICAgIGJpbmRBdXRvQmluZE1ldGhvZHModGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgICAgIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG5cbiAgICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuXG4gICAgICAvLyBSZWFjdENsYXNzZXMgZG9lc24ndCBoYXZlIGNvbnN0cnVjdG9ycy4gSW5zdGVhZCwgdGhleSB1c2UgdGhlXG4gICAgICAvLyBnZXRJbml0aWFsU3RhdGUgYW5kIGNvbXBvbmVudFdpbGxNb3VudCBtZXRob2RzIGZvciBpbml0aWFsaXphdGlvbi5cblxuICAgICAgdmFyIGluaXRpYWxTdGF0ZSA9IHRoaXMuZ2V0SW5pdGlhbFN0YXRlID8gdGhpcy5nZXRJbml0aWFsU3RhdGUoKSA6IG51bGw7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAvLyBXZSBhbGxvdyBhdXRvLW1vY2tzIHRvIHByb2NlZWQgYXMgaWYgdGhleSdyZSByZXR1cm5pbmcgbnVsbC5cbiAgICAgICAgaWYgKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICd1bmRlZmluZWQnICYmIHRoaXMuZ2V0SW5pdGlhbFN0YXRlLl9pc01vY2tGdW5jdGlvbikge1xuICAgICAgICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgYmFkIHByYWN0aWNlLiBDb25zaWRlciB3YXJuaW5nIGhlcmUgYW5kXG4gICAgICAgICAgLy8gZGVwcmVjYXRpbmcgdGhpcyBjb252ZW5pZW5jZS5cbiAgICAgICAgICBpbml0aWFsU3RhdGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAhKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGluaXRpYWxTdGF0ZSkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldEluaXRpYWxTdGF0ZSgpOiBtdXN0IHJldHVybiBhbiBvYmplY3Qgb3IgbnVsbCcsIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy5zdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgICB9O1xuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IG5ldyBSZWFjdENsYXNzQ29tcG9uZW50KCk7XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG5cbiAgICBpbmplY3RlZE1peGlucy5mb3JFYWNoKG1peFNwZWNJbnRvQ29tcG9uZW50LmJpbmQobnVsbCwgQ29uc3RydWN0b3IpKTtcblxuICAgIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzcGVjKTtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIGRlZmF1bHRQcm9wcyBwcm9wZXJ0eSBhZnRlciBhbGwgbWl4aW5zIGhhdmUgYmVlbiBtZXJnZWQuXG4gICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xuICAgICAgQ29uc3RydWN0b3IuZGVmYXVsdFByb3BzID0gQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKCk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB0YWcgdG8gaW5kaWNhdGUgdGhhdCB0aGUgdXNlIG9mIHRoZXNlIG1ldGhvZCBuYW1lcyBpcyBvayxcbiAgICAgIC8vIHNpbmNlIGl0J3MgdXNlZCB3aXRoIGNyZWF0ZUNsYXNzLiBJZiBpdCdzIG5vdCwgdGhlbiBpdCdzIGxpa2VseSBhXG4gICAgICAvLyBtaXN0YWtlIHNvIHdlJ2xsIHdhcm4geW91IHRvIHVzZSB0aGUgc3RhdGljIHByb3BlcnR5LCBwcm9wZXJ0eVxuICAgICAgLy8gaW5pdGlhbGl6ZXIgb3IgY29uc3RydWN0b3IgcmVzcGVjdGl2ZWx5LlxuICAgICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xuICAgICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChDb25zdHJ1Y3Rvci5wcm90b3R5cGUuZ2V0SW5pdGlhbFN0YXRlKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgPSB7fTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAhQ29uc3RydWN0b3IucHJvdG90eXBlLnJlbmRlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdjcmVhdGVDbGFzcyguLi4pOiBDbGFzcyBzcGVjaWZpY2F0aW9uIG11c3QgaW1wbGVtZW50IGEgYHJlbmRlcmAgbWV0aG9kLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICsgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICsgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsIHNwZWMuZGlzcGxheU5hbWUgfHwgJ0EgY29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIHNwZWMuZGlzcGxheU5hbWUgfHwgJ0EgY29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gUmVkdWNlIHRpbWUgc3BlbnQgZG9pbmcgbG9va3VwcyBieSBzZXR0aW5nIHRoZXNlIG9uIHRoZSBwcm90b3R5cGUuXG4gICAgZm9yICh2YXIgbWV0aG9kTmFtZSBpbiBSZWFjdENsYXNzSW50ZXJmYWNlKSB7XG4gICAgICBpZiAoIUNvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2ROYW1lXSkge1xuICAgICAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfSxcblxuICBpbmplY3Rpb246IHtcbiAgICBpbmplY3RNaXhpbjogZnVuY3Rpb24gKG1peGluKSB7XG4gICAgICBpbmplY3RlZE1peGlucy5wdXNoKG1peGluKTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENsYXNzO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RDbGFzcy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENvbXBvbmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdE5vb3BVcGRhdGVRdWV1ZScpO1xuXG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL2NhbkRlZmluZVByb3BlcnR5Jyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIFJlYWN0Q29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5SZWFjdENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuXG4vKipcbiAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgdG8gbXV0YXRlXG4gKiBzdGF0ZS4gWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGNhbGxzIHRvIGBzZXRTdGF0ZWAgd2lsbCBydW4gc3luY2hyb25vdXNseSxcbiAqIGFzIHRoZXkgbWF5IGV2ZW50dWFsbHkgYmUgYmF0Y2hlZCB0b2dldGhlci4gIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbFxuICogY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNhbGwgdG8gc2V0U3RhdGUgaXMgYWN0dWFsbHlcbiAqIGNvbXBsZXRlZC5cbiAqXG4gKiBXaGVuIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQgdG8gc2V0U3RhdGUsIGl0IHdpbGwgYmUgY2FsbGVkIGF0IHNvbWUgcG9pbnQgaW5cbiAqIHRoZSBmdXR1cmUgKG5vdCBzeW5jaHJvbm91c2x5KS4gSXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgdXAgdG8gZGF0ZVxuICogY29tcG9uZW50IGFyZ3VtZW50cyAoc3RhdGUsIHByb3BzLCBjb250ZXh0KS4gVGhlc2UgdmFsdWVzIGNhbiBiZSBkaWZmZXJlbnRcbiAqIGZyb20gdGhpcy4qIGJlY2F1c2UgeW91ciBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGFmdGVyIHJlY2VpdmVQcm9wcyBidXQgYmVmb3JlXG4gKiBzaG91bGRDb21wb25lbnRVcGRhdGUsIGFuZCB0aGlzIG5ldyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHdpbGwgbm90IHlldCBiZVxuICogYXNzaWduZWQgdG8gdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSBvciBmdW5jdGlvbiB0b1xuICogICAgICAgIHByb2R1Y2UgbmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIGN1cnJlbnQgc3RhdGUuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuUmVhY3RDb21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgISh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nIHx8IHBhcnRpYWxTdGF0ZSA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdzZXRTdGF0ZSguLi4pOiB0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhICcgKyAnZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwYXJ0aWFsU3RhdGUgIT0gbnVsbCwgJ3NldFN0YXRlKC4uLik6IFlvdSBwYXNzZWQgYW4gdW5kZWZpbmVkIG9yIG51bGwgc3RhdGUgb2JqZWN0OyAnICsgJ2luc3RlYWQsIHVzZSBmb3JjZVVwZGF0ZSgpLicpIDogdW5kZWZpbmVkO1xuICB9XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcywgcGFydGlhbFN0YXRlKTtcbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgdGhpcy51cGRhdGVyLmVucXVldWVDYWxsYmFjayh0aGlzLCBjYWxsYmFjayk7XG4gIH1cbn07XG5cbi8qKlxuICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gKlxuICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gKlxuICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAqXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHVwZGF0ZSBpcyBjb21wbGV0ZS5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5SZWFjdENvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzKTtcbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgdGhpcy51cGRhdGVyLmVucXVldWVDYWxsYmFjayh0aGlzLCBjYWxsYmFjayk7XG4gIH1cbn07XG5cbi8qKlxuICogRGVwcmVjYXRlZCBBUElzLiBUaGVzZSBBUElzIHVzZWQgdG8gZXhpc3Qgb24gY2xhc3NpYyBSZWFjdCBjbGFzc2VzIGJ1dCBzaW5jZVxuICogd2Ugd291bGQgbGlrZSB0byBkZXByZWNhdGUgdGhlbSwgd2UncmUgbm90IGdvaW5nIHRvIG1vdmUgdGhlbSBvdmVyIHRvIHRoaXNcbiAqIG1vZGVybiBiYXNlIGNsYXNzLiBJbnN0ZWFkLCB3ZSBkZWZpbmUgYSBnZXR0ZXIgdGhhdCB3YXJucyBpZiBpdCdzIGFjY2Vzc2VkLlxuICovXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgZGVwcmVjYXRlZEFQSXMgPSB7XG4gICAgZ2V0RE9NTm9kZTogWydnZXRET01Ob2RlJywgJ1VzZSBSZWFjdERPTS5maW5kRE9NTm9kZShjb21wb25lbnQpIGluc3RlYWQuJ10sXG4gICAgaXNNb3VudGVkOiBbJ2lzTW91bnRlZCcsICdJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiAnICsgJ2NvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLiddLFxuICAgIHJlcGxhY2VQcm9wczogWydyZXBsYWNlUHJvcHMnLCAnSW5zdGVhZCwgY2FsbCByZW5kZXIgYWdhaW4gYXQgdGhlIHRvcCBsZXZlbC4nXSxcbiAgICByZXBsYWNlU3RhdGU6IFsncmVwbGFjZVN0YXRlJywgJ1JlZmFjdG9yIHlvdXIgY29kZSB0byB1c2Ugc2V0U3RhdGUgaW5zdGVhZCAoc2VlICcgKyAnaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zMjM2KS4nXSxcbiAgICBzZXRQcm9wczogWydzZXRQcm9wcycsICdJbnN0ZWFkLCBjYWxsIHJlbmRlciBhZ2FpbiBhdCB0aGUgdG9wIGxldmVsLiddXG4gIH07XG4gIHZhciBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgaW5mbykge1xuICAgIGlmIChjYW5EZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWN0Q29tcG9uZW50LnByb3RvdHlwZSwgbWV0aG9kTmFtZSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzKC4uLikgaXMgZGVwcmVjYXRlZCBpbiBwbGFpbiBKYXZhU2NyaXB0IFJlYWN0IGNsYXNzZXMuICVzJywgaW5mb1swXSwgaW5mb1sxXSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBmb3IgKHZhciBmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpIHtcbiAgICBpZiAoZGVwcmVjYXRlZEFQSXMuaGFzT3duUHJvcGVydHkoZm5OYW1lKSkge1xuICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb25lbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3ROb29wVXBkYXRlUXVldWVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiB3YXJuVERaKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIG9yIG1vdW50aW5nIGNvbXBvbmVudC4gJyArICdUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuICcgKyAnVGhpcyBpcyBhIG5vLW9wLiBQbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY2FsbGVyTmFtZSwgcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3IgJiYgcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJycpIDogdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgYWJzdHJhY3QgQVBJIGZvciBhbiB1cGRhdGUgcXVldWUuXG4gKi9cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHtcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVucXVldWUgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgYWxsIHRoZSBwZW5kaW5nIHVwZGF0ZXNcbiAgICogaGF2ZSBwcm9jZXNzZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIHVzZSBhcyBgdGhpc2AgY29udGV4dC5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVDYWxsYmFjazogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaykge30sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICB3YXJuVERaKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSkge1xuICAgIHdhcm5URFoocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUpIHtcbiAgICB3YXJuVERaKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgcHJvcHMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFByb3BzIFN1YnNldCBvZiB0aGUgbmV4dCBwcm9wcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0UHJvcHM6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFByb3BzKSB7XG4gICAgd2FyblREWihwdWJsaWNJbnN0YW5jZSwgJ3NldFByb3BzJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgcHJvcHMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgTmV3IHByb3BzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlUHJvcHM6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcHJvcHMpIHtcbiAgICB3YXJuVERaKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVByb3BzJyk7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb25cbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2FsbGJhY2tRdWV1ZSA9IHJlcXVpcmUoJy4vQ2FsbGJhY2tRdWV1ZScpO1xudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyJyk7XG52YXIgUmVhY3RET01GZWF0dXJlRmxhZ3MgPSByZXF1aXJlKCcuL1JlYWN0RE9NRmVhdHVyZUZsYWdzJyk7XG52YXIgUmVhY3RJbnB1dFNlbGVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnB1dFNlbGVjdGlvbicpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9UcmFuc2FjdGlvbicpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG5cbi8qKlxuICogRW5zdXJlcyB0aGF0LCB3aGVuIHBvc3NpYmxlLCB0aGUgc2VsZWN0aW9uIHJhbmdlIChjdXJyZW50bHkgc2VsZWN0ZWQgdGV4dFxuICogaW5wdXQpIGlzIG5vdCBkaXN0dXJiZWQgYnkgcGVyZm9ybWluZyB0aGUgdHJhbnNhY3Rpb24uXG4gKi9cbnZhciBTRUxFQ1RJT05fUkVTVE9SQVRJT04gPSB7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHtTZWxlY3Rpb259IFNlbGVjdGlvbiBpbmZvcm1hdGlvbi5cbiAgICovXG4gIGluaXRpYWxpemU6IFJlYWN0SW5wdXRTZWxlY3Rpb24uZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb24sXG4gIC8qKlxuICAgKiBAcGFyYW0ge1NlbGVjdGlvbn0gc2VsIFNlbGVjdGlvbiBpbmZvcm1hdGlvbiByZXR1cm5lZCBmcm9tIGBpbml0aWFsaXplYC5cbiAgICovXG4gIGNsb3NlOiBSZWFjdElucHV0U2VsZWN0aW9uLnJlc3RvcmVTZWxlY3Rpb25cbn07XG5cbi8qKlxuICogU3VwcHJlc3NlcyBldmVudHMgKGJsdXIvZm9jdXMpIHRoYXQgY291bGQgYmUgaW5hZHZlcnRlbnRseSBkaXNwYXRjaGVkIGR1ZSB0b1xuICogaGlnaCBsZXZlbCBET00gbWFuaXB1bGF0aW9ucyAobGlrZSB0ZW1wb3JhcmlseSByZW1vdmluZyBhIHRleHQgaW5wdXQgZnJvbSB0aGVcbiAqIERPTSkuXG4gKi9cbnZhciBFVkVOVF9TVVBQUkVTU0lPTiA9IHtcbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBlbmFibGVkIHN0YXR1cyBvZiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBiZWZvcmVcbiAgICogdGhlIHJlY29uY2lsaWF0aW9uLlxuICAgKi9cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjdXJyZW50bHlFbmFibGVkID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmlzRW5hYmxlZCgpO1xuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5zZXRFbmFibGVkKGZhbHNlKTtcbiAgICByZXR1cm4gY3VycmVudGx5RW5hYmxlZDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBwcmV2aW91c2x5RW5hYmxlZCBFbmFibGVkIHN0YXR1cyBvZlxuICAgKiAgIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJgIGJlZm9yZSB0aGUgcmVjb25jaWxpYXRpb24gb2NjdXJyZWQuIGBjbG9zZWBcbiAgICogICByZXN0b3JlcyB0aGUgcHJldmlvdXMgdmFsdWUuXG4gICAqL1xuICBjbG9zZTogZnVuY3Rpb24gKHByZXZpb3VzbHlFbmFibGVkKSB7XG4gICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnNldEVuYWJsZWQocHJldmlvdXNseUVuYWJsZWQpO1xuICB9XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgcXVldWUgZm9yIGNvbGxlY3RpbmcgYGNvbXBvbmVudERpZE1vdW50YCBhbmRcbiAqIGBjb21wb25lbnREaWRVcGRhdGVgIGNhbGxiYWNrcyBkdXJpbmcgdGhlIHRoZSB0cmFuc2FjdGlvbi5cbiAqL1xudmFyIE9OX0RPTV9SRUFEWV9RVUVVRUlORyA9IHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBpbnRlcm5hbCBgb25ET01SZWFkeWAgcXVldWUuXG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkucmVzZXQoKTtcbiAgfSxcblxuICAvKipcbiAgICogQWZ0ZXIgRE9NIGlzIGZsdXNoZWQsIGludm9rZSBhbGwgcmVnaXN0ZXJlZCBgb25ET01SZWFkeWAgY2FsbGJhY2tzLlxuICAgKi9cbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeS5ub3RpZnlBbGwoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFeGVjdXRlZCB3aXRoaW4gdGhlIHNjb3BlIG9mIHRoZSBgVHJhbnNhY3Rpb25gIGluc3RhbmNlLiBDb25zaWRlciB0aGVzZSBhc1xuICogYmVpbmcgbWVtYmVyIG1ldGhvZHMsIGJ1dCB3aXRoIGFuIGltcGxpZWQgb3JkZXJpbmcgd2hpbGUgYmVpbmcgaXNvbGF0ZWQgZnJvbVxuICogZWFjaCBvdGhlci5cbiAqL1xudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW1NFTEVDVElPTl9SRVNUT1JBVElPTiwgRVZFTlRfU1VQUFJFU1NJT04sIE9OX0RPTV9SRUFEWV9RVUVVRUlOR107XG5cbi8qKlxuICogQ3VycmVudGx5OlxuICogLSBUaGUgb3JkZXIgdGhhdCB0aGVzZSBhcmUgbGlzdGVkIGluIHRoZSB0cmFuc2FjdGlvbiBpcyBjcml0aWNhbDpcbiAqIC0gU3VwcHJlc3NlcyBldmVudHMuXG4gKiAtIFJlc3RvcmVzIHNlbGVjdGlvbiByYW5nZS5cbiAqXG4gKiBGdXR1cmU6XG4gKiAtIFJlc3RvcmUgZG9jdW1lbnQvb3ZlcmZsb3cgc2Nyb2xsIHBvc2l0aW9ucyB0aGF0IHdlcmUgdW5pbnRlbnRpb25hbGx5XG4gKiAgIG1vZGlmaWVkIHZpYSBET00gaW5zZXJ0aW9ucyBhYm92ZSB0aGUgdG9wIHZpZXdwb3J0IGJvdW5kYXJ5LlxuICogLSBJbXBsZW1lbnQvaW50ZWdyYXRlIHdpdGggY3VzdG9taXplZCBjb25zdHJhaW50IGJhc2VkIGxheW91dCBzeXN0ZW0gYW5kIGtlZXBcbiAqICAgdHJhY2sgb2Ygd2hpY2ggZGltZW5zaW9ucyBtdXN0IGJlIHJlbWVhc3VyZWQuXG4gKlxuICogQGNsYXNzIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb25cbiAqL1xuZnVuY3Rpb24gUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbihmb3JjZUhUTUwpIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xuICAvLyBPbmx5IHNlcnZlci1zaWRlIHJlbmRlcmluZyByZWFsbHkgbmVlZHMgdGhpcyBvcHRpb24gKHNlZVxuICAvLyBgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdgKSwgYnV0IHNlcnZlci1zaWRlIHVzZXNcbiAgLy8gYFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb25gIGluc3RlYWQuIFRoaXMgb3B0aW9uIGlzIGhlcmUgc28gdGhhdCBpdCdzXG4gIC8vIGFjY2Vzc2libGUgYW5kIGRlZmF1bHRzIHRvIGZhbHNlIHdoZW4gYFJlYWN0RE9NQ29tcG9uZW50YCBhbmRcbiAgLy8gYFJlYWN0VGV4dENvbXBvbmVudGAgY2hlY2tzIGl0IGluIGBtb3VudENvbXBvbmVudGAuYFxuICB0aGlzLnJlbmRlclRvU3RhdGljTWFya3VwID0gZmFsc2U7XG4gIHRoaXMucmVhY3RNb3VudFJlYWR5ID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQobnVsbCk7XG4gIHRoaXMudXNlQ3JlYXRlRWxlbWVudCA9ICFmb3JjZUhUTUwgJiYgUmVhY3RET01GZWF0dXJlRmxhZ3MudXNlQ3JlYXRlRWxlbWVudDtcbn1cblxudmFyIE1peGluID0ge1xuICAvKipcbiAgICogQHNlZSBUcmFuc2FjdGlvblxuICAgKiBAYWJzdHJhY3RcbiAgICogQGZpbmFsXG4gICAqIEByZXR1cm4ge2FycmF5PG9iamVjdD59IExpc3Qgb2Ygb3BlcmF0aW9uIHdyYXAgcHJvY2VkdXJlcy5cbiAgICogICBUT0RPOiBjb252ZXJ0IHRvIGFycmF5PFRyYW5zYWN0aW9uV3JhcHBlcj5cbiAgICovXG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVFJBTlNBQ1RJT05fV1JBUFBFUlM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHF1ZXVlIHRvIGNvbGxlY3QgYG9uRE9NUmVhZHlgIGNhbGxiYWNrcyB3aXRoLlxuICAgKi9cbiAgZ2V0UmVhY3RNb3VudFJlYWR5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhY3RNb3VudFJlYWR5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciB0aGlzLCBhbmQgd2lsbCBpbnZva2UgdGhpcyBiZWZvcmUgYWxsb3dpbmcgdGhpc1xuICAgKiBpbnN0YW5jZSB0byBiZSByZXVzZWQuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgQ2FsbGJhY2tRdWV1ZS5yZWxlYXNlKHRoaXMucmVhY3RNb3VudFJlYWR5KTtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeSA9IG51bGw7XG4gIH1cbn07XG5cbmFzc2lnbihSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLnByb3RvdHlwZSwgVHJhbnNhY3Rpb24uTWl4aW4sIE1peGluKTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb247XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0SW5wdXRTZWxlY3Rpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTVNlbGVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RET01TZWxlY3Rpb24nKTtcblxudmFyIGNvbnRhaW5zTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2NvbnRhaW5zTm9kZScpO1xudmFyIGZvY3VzTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2ZvY3VzTm9kZScpO1xudmFyIGdldEFjdGl2ZUVsZW1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50Jyk7XG5cbmZ1bmN0aW9uIGlzSW5Eb2N1bWVudChub2RlKSB7XG4gIHJldHVybiBjb250YWluc05vZGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBub2RlKTtcbn1cblxuLyoqXG4gKiBAUmVhY3RJbnB1dFNlbGVjdGlvbjogUmVhY3QgaW5wdXQgc2VsZWN0aW9uIG1vZHVsZS4gQmFzZWQgb24gU2VsZWN0aW9uLmpzLFxuICogYnV0IG1vZGlmaWVkIHRvIGJlIHN1aXRhYmxlIGZvciByZWFjdCBhbmQgaGFzIGEgY291cGxlIG9mIGJ1ZyBmaXhlcyAoZG9lc24ndFxuICogYXNzdW1lIGJ1dHRvbnMgaGF2ZSByYW5nZSBzZWxlY3Rpb25zIGFsbG93ZWQpLlxuICogSW5wdXQgc2VsZWN0aW9uIG1vZHVsZSBmb3IgUmVhY3QuXG4gKi9cbnZhciBSZWFjdElucHV0U2VsZWN0aW9uID0ge1xuXG4gIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllczogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBub2RlTmFtZSAmJiAobm9kZU5hbWUgPT09ICdpbnB1dCcgJiYgZWxlbS50eXBlID09PSAndGV4dCcgfHwgbm9kZU5hbWUgPT09ICd0ZXh0YXJlYScgfHwgZWxlbS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJyk7XG4gIH0sXG5cbiAgZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvY3VzZWRFbGVtOiBmb2N1c2VkRWxlbSxcbiAgICAgIHNlbGVjdGlvblJhbmdlOiBSZWFjdElucHV0U2VsZWN0aW9uLmhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhmb2N1c2VkRWxlbSkgPyBSZWFjdElucHV0U2VsZWN0aW9uLmdldFNlbGVjdGlvbihmb2N1c2VkRWxlbSkgOiBudWxsXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogQHJlc3RvcmVTZWxlY3Rpb246IElmIGFueSBzZWxlY3Rpb24gaW5mb3JtYXRpb24gd2FzIHBvdGVudGlhbGx5IGxvc3QsXG4gICAqIHJlc3RvcmUgaXQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gcGVyZm9ybWluZyBvcGVyYXRpb25zIHRoYXQgY291bGQgcmVtb3ZlIGRvbVxuICAgKiBub2RlcyBhbmQgcGxhY2UgdGhlbSBiYWNrIGluLCByZXN1bHRpbmcgaW4gZm9jdXMgYmVpbmcgbG9zdC5cbiAgICovXG4gIHJlc3RvcmVTZWxlY3Rpb246IGZ1bmN0aW9uIChwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uKSB7XG4gICAgdmFyIGN1ckZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICAgIHZhciBwcmlvckZvY3VzZWRFbGVtID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5mb2N1c2VkRWxlbTtcbiAgICB2YXIgcHJpb3JTZWxlY3Rpb25SYW5nZSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uc2VsZWN0aW9uUmFuZ2U7XG4gICAgaWYgKGN1ckZvY3VzZWRFbGVtICE9PSBwcmlvckZvY3VzZWRFbGVtICYmIGlzSW5Eb2N1bWVudChwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgICAgaWYgKFJlYWN0SW5wdXRTZWxlY3Rpb24uaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKHByaW9yRm9jdXNlZEVsZW0pKSB7XG4gICAgICAgIFJlYWN0SW5wdXRTZWxlY3Rpb24uc2V0U2VsZWN0aW9uKHByaW9yRm9jdXNlZEVsZW0sIHByaW9yU2VsZWN0aW9uUmFuZ2UpO1xuICAgICAgfVxuICAgICAgZm9jdXNOb2RlKHByaW9yRm9jdXNlZEVsZW0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGdldFNlbGVjdGlvbjogR2V0cyB0aGUgc2VsZWN0aW9uIGJvdW5kcyBvZiBhIGZvY3VzZWQgdGV4dGFyZWEsIGlucHV0IG9yXG4gICAqIGNvbnRlbnRFZGl0YWJsZSBub2RlLlxuICAgKiAtQGlucHV0OiBMb29rIHVwIHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dFxuICAgKiAtQHJldHVybiB7c3RhcnQ6IHNlbGVjdGlvblN0YXJ0LCBlbmQ6IHNlbGVjdGlvbkVuZH1cbiAgICovXG4gIGdldFNlbGVjdGlvbjogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgdmFyIHNlbGVjdGlvbjtcblxuICAgIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIGlucHV0KSB7XG4gICAgICAvLyBNb2Rlcm4gYnJvd3NlciB3aXRoIGlucHV0IG9yIHRleHRhcmVhLlxuICAgICAgc2VsZWN0aW9uID0ge1xuICAgICAgICBzdGFydDogaW5wdXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgIGVuZDogaW5wdXQuc2VsZWN0aW9uRW5kXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uICYmIChpbnB1dC5ub2RlTmFtZSAmJiBpbnB1dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnKSkge1xuICAgICAgLy8gSUU4IGlucHV0LlxuICAgICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAvLyBUaGVyZSBjYW4gb25seSBiZSBvbmUgc2VsZWN0aW9uIHBlciBkb2N1bWVudCBpbiBJRSwgc28gaXQgbXVzdFxuICAgICAgLy8gYmUgaW4gb3VyIGVsZW1lbnQuXG4gICAgICBpZiAocmFuZ2UucGFyZW50RWxlbWVudCgpID09PSBpbnB1dCkge1xuICAgICAgICBzZWxlY3Rpb24gPSB7XG4gICAgICAgICAgc3RhcnQ6IC1yYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIC1pbnB1dC52YWx1ZS5sZW5ndGgpLFxuICAgICAgICAgIGVuZDogLXJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIC1pbnB1dC52YWx1ZS5sZW5ndGgpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvbnRlbnQgZWRpdGFibGUgb3Igb2xkIElFIHRleHRhcmVhLlxuICAgICAgc2VsZWN0aW9uID0gUmVhY3RET01TZWxlY3Rpb24uZ2V0T2Zmc2V0cyhpbnB1dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGVjdGlvbiB8fCB7IHN0YXJ0OiAwLCBlbmQ6IDAgfTtcbiAgfSxcblxuICAvKipcbiAgICogQHNldFNlbGVjdGlvbjogU2V0cyB0aGUgc2VsZWN0aW9uIGJvdW5kcyBvZiBhIHRleHRhcmVhIG9yIGlucHV0IGFuZCBmb2N1c2VzXG4gICAqIHRoZSBpbnB1dC5cbiAgICogLUBpbnB1dCAgICAgU2V0IHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dCBvciB0ZXh0YXJlYVxuICAgKiAtQG9mZnNldHMgICBPYmplY3Qgb2Ygc2FtZSBmb3JtIHRoYXQgaXMgcmV0dXJuZWQgZnJvbSBnZXQqXG4gICAqL1xuICBzZXRTZWxlY3Rpb246IGZ1bmN0aW9uIChpbnB1dCwgb2Zmc2V0cykge1xuICAgIHZhciBzdGFydCA9IG9mZnNldHMuc3RhcnQ7XG4gICAgdmFyIGVuZCA9IG9mZnNldHMuZW5kO1xuICAgIGlmICh0eXBlb2YgZW5kID09PSAndW5kZWZpbmVkJykge1xuICAgICAgZW5kID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcbiAgICAgIGlucHV0LnNlbGVjdGlvblN0YXJ0ID0gc3RhcnQ7XG4gICAgICBpbnB1dC5zZWxlY3Rpb25FbmQgPSBNYXRoLm1pbihlbmQsIGlucHV0LnZhbHVlLmxlbmd0aCk7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudC5zZWxlY3Rpb24gJiYgKGlucHV0Lm5vZGVOYW1lICYmIGlucHV0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcpKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBpbnB1dC5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgICAgcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCBzdGFydCk7XG4gICAgICByYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBlbmQgLSBzdGFydCk7XG4gICAgICByYW5nZS5zZWxlY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3RET01TZWxlY3Rpb24uc2V0T2Zmc2V0cyhpbnB1dCwgb2Zmc2V0cyk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5wdXRTZWxlY3Rpb247XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdElucHV0U2VsZWN0aW9uLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NU2VsZWN0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldCA9IHJlcXVpcmUoJy4vZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldCcpO1xudmFyIGdldFRleHRDb250ZW50QWNjZXNzb3IgPSByZXF1aXJlKCcuL2dldFRleHRDb250ZW50QWNjZXNzb3InKTtcblxuLyoqXG4gKiBXaGlsZSBgaXNDb2xsYXBzZWRgIGlzIGF2YWlsYWJsZSBvbiB0aGUgU2VsZWN0aW9uIG9iamVjdCBhbmQgYGNvbGxhcHNlZGBcbiAqIGlzIGF2YWlsYWJsZSBvbiB0aGUgUmFuZ2Ugb2JqZWN0LCBJRTExIHNvbWV0aW1lcyBnZXRzIHRoZW0gd3JvbmcuXG4gKiBJZiB0aGUgYW5jaG9yL2ZvY3VzIG5vZGVzIGFuZCBvZmZzZXRzIGFyZSB0aGUgc2FtZSwgdGhlIHJhbmdlIGlzIGNvbGxhcHNlZC5cbiAqL1xuZnVuY3Rpb24gaXNDb2xsYXBzZWQoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KSB7XG4gIHJldHVybiBhbmNob3JOb2RlID09PSBmb2N1c05vZGUgJiYgYW5jaG9yT2Zmc2V0ID09PSBmb2N1c09mZnNldDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGFwcHJvcHJpYXRlIGFuY2hvciBhbmQgZm9jdXMgbm9kZS9vZmZzZXQgcGFpcnMgZm9yIElFLlxuICpcbiAqIFRoZSBjYXRjaCBoZXJlIGlzIHRoYXQgSUUncyBzZWxlY3Rpb24gQVBJIGRvZXNuJ3QgcHJvdmlkZSBpbmZvcm1hdGlvblxuICogYWJvdXQgd2hldGhlciB0aGUgc2VsZWN0aW9uIGlzIGZvcndhcmQgb3IgYmFja3dhcmQsIHNvIHdlIGhhdmUgdG9cbiAqIGJlaGF2ZSBhcyB0aG91Z2ggaXQncyBhbHdheXMgZm9yd2FyZC5cbiAqXG4gKiBJRSB0ZXh0IGRpZmZlcnMgZnJvbSBtb2Rlcm4gc2VsZWN0aW9uIGluIHRoYXQgaXQgYmVoYXZlcyBhcyB0aG91Z2hcbiAqIGJsb2NrIGVsZW1lbnRzIGVuZCB3aXRoIGEgbmV3IGxpbmUuIFRoaXMgbWVhbnMgY2hhcmFjdGVyIG9mZnNldHMgd2lsbFxuICogZGlmZmVyIGJldHdlZW4gdGhlIHR3byBBUElzLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRJRU9mZnNldHMobm9kZSkge1xuICB2YXIgc2VsZWN0aW9uID0gZG9jdW1lbnQuc2VsZWN0aW9uO1xuICB2YXIgc2VsZWN0ZWRSYW5nZSA9IHNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICB2YXIgc2VsZWN0ZWRMZW5ndGggPSBzZWxlY3RlZFJhbmdlLnRleHQubGVuZ3RoO1xuXG4gIC8vIER1cGxpY2F0ZSBzZWxlY3Rpb24gc28gd2UgY2FuIG1vdmUgcmFuZ2Ugd2l0aG91dCBicmVha2luZyB1c2VyIHNlbGVjdGlvbi5cbiAgdmFyIGZyb21TdGFydCA9IHNlbGVjdGVkUmFuZ2UuZHVwbGljYXRlKCk7XG4gIGZyb21TdGFydC5tb3ZlVG9FbGVtZW50VGV4dChub2RlKTtcbiAgZnJvbVN0YXJ0LnNldEVuZFBvaW50KCdFbmRUb1N0YXJ0Jywgc2VsZWN0ZWRSYW5nZSk7XG5cbiAgdmFyIHN0YXJ0T2Zmc2V0ID0gZnJvbVN0YXJ0LnRleHQubGVuZ3RoO1xuICB2YXIgZW5kT2Zmc2V0ID0gc3RhcnRPZmZzZXQgKyBzZWxlY3RlZExlbmd0aDtcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydE9mZnNldCxcbiAgICBlbmQ6IGVuZE9mZnNldFxuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0TW9kZXJuT2Zmc2V0cyhub2RlKSB7XG4gIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uICYmIHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblxuICBpZiAoIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yTm9kZTtcbiAgdmFyIGFuY2hvck9mZnNldCA9IHNlbGVjdGlvbi5hbmNob3JPZmZzZXQ7XG4gIHZhciBmb2N1c05vZGUgPSBzZWxlY3Rpb24uZm9jdXNOb2RlO1xuICB2YXIgZm9jdXNPZmZzZXQgPSBzZWxlY3Rpb24uZm9jdXNPZmZzZXQ7XG5cbiAgdmFyIGN1cnJlbnRSYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuXG4gIC8vIEluIEZpcmVmb3gsIHJhbmdlLnN0YXJ0Q29udGFpbmVyIGFuZCByYW5nZS5lbmRDb250YWluZXIgY2FuIGJlIFwiYW5vbnltb3VzXG4gIC8vIGRpdnNcIiwgZS5nLiB0aGUgdXAvZG93biBidXR0b25zIG9uIGFuIDxpbnB1dCB0eXBlPVwibnVtYmVyXCI+LiBBbm9ueW1vdXNcbiAgLy8gZGl2cyBkbyBub3Qgc2VlbSB0byBleHBvc2UgcHJvcGVydGllcywgdHJpZ2dlcmluZyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcbiAgLy8gZXJyb3JcIiBpZiBhbnkgb2YgaXRzIHByb3BlcnRpZXMgYXJlIGFjY2Vzc2VkLiBUaGUgb25seSBzZWVtaW5nbHkgcG9zc2libGVcbiAgLy8gd2F5IHRvIGF2b2lkIGVycm9yaW5nIGlzIHRvIGFjY2VzcyBhIHByb3BlcnR5IHRoYXQgdHlwaWNhbGx5IHdvcmtzIGZvclxuICAvLyBub24tYW5vbnltb3VzIGRpdnMgYW5kIGNhdGNoIGFueSBlcnJvciB0aGF0IG1heSBvdGhlcndpc2UgYXJpc2UuIFNlZVxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0yMDg0MjdcbiAgdHJ5IHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgICBjdXJyZW50UmFuZ2Uuc3RhcnRDb250YWluZXIubm9kZVR5cGU7XG4gICAgY3VycmVudFJhbmdlLmVuZENvbnRhaW5lci5ub2RlVHlwZTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBJZiB0aGUgbm9kZSBhbmQgb2Zmc2V0IHZhbHVlcyBhcmUgdGhlIHNhbWUsIHRoZSBzZWxlY3Rpb24gaXMgY29sbGFwc2VkLlxuICAvLyBgU2VsZWN0aW9uLmlzQ29sbGFwc2VkYCBpcyBhdmFpbGFibGUgbmF0aXZlbHksIGJ1dCBJRSBzb21ldGltZXMgZ2V0c1xuICAvLyB0aGlzIHZhbHVlIHdyb25nLlxuICB2YXIgaXNTZWxlY3Rpb25Db2xsYXBzZWQgPSBpc0NvbGxhcHNlZChzZWxlY3Rpb24uYW5jaG9yTm9kZSwgc2VsZWN0aW9uLmFuY2hvck9mZnNldCwgc2VsZWN0aW9uLmZvY3VzTm9kZSwgc2VsZWN0aW9uLmZvY3VzT2Zmc2V0KTtcblxuICB2YXIgcmFuZ2VMZW5ndGggPSBpc1NlbGVjdGlvbkNvbGxhcHNlZCA/IDAgOiBjdXJyZW50UmFuZ2UudG9TdHJpbmcoKS5sZW5ndGg7XG5cbiAgdmFyIHRlbXBSYW5nZSA9IGN1cnJlbnRSYW5nZS5jbG9uZVJhbmdlKCk7XG4gIHRlbXBSYW5nZS5zZWxlY3ROb2RlQ29udGVudHMobm9kZSk7XG4gIHRlbXBSYW5nZS5zZXRFbmQoY3VycmVudFJhbmdlLnN0YXJ0Q29udGFpbmVyLCBjdXJyZW50UmFuZ2Uuc3RhcnRPZmZzZXQpO1xuXG4gIHZhciBpc1RlbXBSYW5nZUNvbGxhcHNlZCA9IGlzQ29sbGFwc2VkKHRlbXBSYW5nZS5zdGFydENvbnRhaW5lciwgdGVtcFJhbmdlLnN0YXJ0T2Zmc2V0LCB0ZW1wUmFuZ2UuZW5kQ29udGFpbmVyLCB0ZW1wUmFuZ2UuZW5kT2Zmc2V0KTtcblxuICB2YXIgc3RhcnQgPSBpc1RlbXBSYW5nZUNvbGxhcHNlZCA/IDAgOiB0ZW1wUmFuZ2UudG9TdHJpbmcoKS5sZW5ndGg7XG4gIHZhciBlbmQgPSBzdGFydCArIHJhbmdlTGVuZ3RoO1xuXG4gIC8vIERldGVjdCB3aGV0aGVyIHRoZSBzZWxlY3Rpb24gaXMgYmFja3dhcmQuXG4gIHZhciBkZXRlY3Rpb25SYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gIGRldGVjdGlvblJhbmdlLnNldFN0YXJ0KGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCk7XG4gIGRldGVjdGlvblJhbmdlLnNldEVuZChmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KTtcbiAgdmFyIGlzQmFja3dhcmQgPSBkZXRlY3Rpb25SYW5nZS5jb2xsYXBzZWQ7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogaXNCYWNrd2FyZCA/IGVuZCA6IHN0YXJ0LFxuICAgIGVuZDogaXNCYWNrd2FyZCA/IHN0YXJ0IDogZW5kXG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICovXG5mdW5jdGlvbiBzZXRJRU9mZnNldHMobm9kZSwgb2Zmc2V0cykge1xuICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKS5kdXBsaWNhdGUoKTtcbiAgdmFyIHN0YXJ0LCBlbmQ7XG5cbiAgaWYgKHR5cGVvZiBvZmZzZXRzLmVuZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzdGFydCA9IG9mZnNldHMuc3RhcnQ7XG4gICAgZW5kID0gc3RhcnQ7XG4gIH0gZWxzZSBpZiAob2Zmc2V0cy5zdGFydCA+IG9mZnNldHMuZW5kKSB7XG4gICAgc3RhcnQgPSBvZmZzZXRzLmVuZDtcbiAgICBlbmQgPSBvZmZzZXRzLnN0YXJ0O1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydDtcbiAgICBlbmQgPSBvZmZzZXRzLmVuZDtcbiAgfVxuXG4gIHJhbmdlLm1vdmVUb0VsZW1lbnRUZXh0KG5vZGUpO1xuICByYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIHN0YXJ0KTtcbiAgcmFuZ2Uuc2V0RW5kUG9pbnQoJ0VuZFRvU3RhcnQnLCByYW5nZSk7XG4gIHJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIGVuZCAtIHN0YXJ0KTtcbiAgcmFuZ2Uuc2VsZWN0KCk7XG59XG5cbi8qKlxuICogSW4gbW9kZXJuIG5vbi1JRSBicm93c2Vycywgd2UgY2FuIHN1cHBvcnQgYm90aCBmb3J3YXJkIGFuZCBiYWNrd2FyZFxuICogc2VsZWN0aW9ucy5cbiAqXG4gKiBOb3RlOiBJRTEwKyBzdXBwb3J0cyB0aGUgU2VsZWN0aW9uIG9iamVjdCwgYnV0IGl0IGRvZXMgbm90IHN1cHBvcnRcbiAqIHRoZSBgZXh0ZW5kYCBtZXRob2QsIHdoaWNoIG1lYW5zIHRoYXQgZXZlbiBpbiBtb2Rlcm4gSUUsIGl0J3Mgbm90IHBvc3NpYmxlXG4gKiB0byBwcm9ncmFtYXRpY2FsbHkgY3JlYXRlIGEgYmFja3dhcmQgc2VsZWN0aW9uLiBUaHVzLCBmb3IgYWxsIElFXG4gKiB2ZXJzaW9ucywgd2UgdXNlIHRoZSBvbGQgSUUgQVBJIHRvIGNyZWF0ZSBvdXIgc2VsZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gKi9cbmZ1bmN0aW9uIHNldE1vZGVybk9mZnNldHMobm9kZSwgb2Zmc2V0cykge1xuICBpZiAoIXdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICB2YXIgbGVuZ3RoID0gbm9kZVtnZXRUZXh0Q29udGVudEFjY2Vzc29yKCldLmxlbmd0aDtcbiAgdmFyIHN0YXJ0ID0gTWF0aC5taW4ob2Zmc2V0cy5zdGFydCwgbGVuZ3RoKTtcbiAgdmFyIGVuZCA9IHR5cGVvZiBvZmZzZXRzLmVuZCA9PT0gJ3VuZGVmaW5lZCcgPyBzdGFydCA6IE1hdGgubWluKG9mZnNldHMuZW5kLCBsZW5ndGgpO1xuXG4gIC8vIElFIDExIHVzZXMgbW9kZXJuIHNlbGVjdGlvbiwgYnV0IGRvZXNuJ3Qgc3VwcG9ydCB0aGUgZXh0ZW5kIG1ldGhvZC5cbiAgLy8gRmxpcCBiYWNrd2FyZCBzZWxlY3Rpb25zLCBzbyB3ZSBjYW4gc2V0IHdpdGggYSBzaW5nbGUgcmFuZ2UuXG4gIGlmICghc2VsZWN0aW9uLmV4dGVuZCAmJiBzdGFydCA+IGVuZCkge1xuICAgIHZhciB0ZW1wID0gZW5kO1xuICAgIGVuZCA9IHN0YXJ0O1xuICAgIHN0YXJ0ID0gdGVtcDtcbiAgfVxuXG4gIHZhciBzdGFydE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgc3RhcnQpO1xuICB2YXIgZW5kTWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBlbmQpO1xuXG4gIGlmIChzdGFydE1hcmtlciAmJiBlbmRNYXJrZXIpIHtcbiAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIHJhbmdlLnNldFN0YXJ0KHN0YXJ0TWFya2VyLm5vZGUsIHN0YXJ0TWFya2VyLm9mZnNldCk7XG4gICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgc2VsZWN0aW9uLmV4dGVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlLnNldEVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCk7XG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgdXNlSUVPZmZzZXRzID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdzZWxlY3Rpb24nIGluIGRvY3VtZW50ICYmICEoJ2dldFNlbGVjdGlvbicgaW4gd2luZG93KTtcblxudmFyIFJlYWN0RE9NU2VsZWN0aW9uID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqL1xuICBnZXRPZmZzZXRzOiB1c2VJRU9mZnNldHMgPyBnZXRJRU9mZnNldHMgOiBnZXRNb2Rlcm5PZmZzZXRzLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAgICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAgICovXG4gIHNldE9mZnNldHM6IHVzZUlFT2Zmc2V0cyA/IHNldElFT2Zmc2V0cyA6IHNldE1vZGVybk9mZnNldHNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01TZWxlY3Rpb247XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTVNlbGVjdGlvbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdpdmVuIGFueSBub2RlIHJldHVybiB0aGUgZmlyc3QgbGVhZiBub2RlIHdpdGhvdXQgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5mdW5jdGlvbiBnZXRMZWFmTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlICYmIG5vZGUuZmlyc3RDaGlsZCkge1xuICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBuZXh0IHNpYmxpbmcgd2l0aGluIGEgY29udGFpbmVyLiBUaGlzIHdpbGwgd2FsayB1cCB0aGVcbiAqIERPTSBpZiBhIG5vZGUncyBzaWJsaW5ncyBoYXZlIGJlZW4gZXhoYXVzdGVkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7P0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cbmZ1bmN0aW9uIGdldFNpYmxpbmdOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5uZXh0U2libGluZykge1xuICAgICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgb2JqZWN0IGRlc2NyaWJpbmcgdGhlIG5vZGVzIHdoaWNoIGNvbnRhaW4gY2hhcmFjdGVycyBhdCBvZmZzZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSByb290XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KHJvb3QsIG9mZnNldCkge1xuICB2YXIgbm9kZSA9IGdldExlYWZOb2RlKHJvb3QpO1xuICB2YXIgbm9kZVN0YXJ0ID0gMDtcbiAgdmFyIG5vZGVFbmQgPSAwO1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgIG5vZGVFbmQgPSBub2RlU3RhcnQgKyBub2RlLnRleHRDb250ZW50Lmxlbmd0aDtcblxuICAgICAgaWYgKG5vZGVTdGFydCA8PSBvZmZzZXQgJiYgbm9kZUVuZCA+PSBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgIG9mZnNldDogb2Zmc2V0IC0gbm9kZVN0YXJ0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG5vZGVTdGFydCA9IG5vZGVFbmQ7XG4gICAgfVxuXG4gICAgbm9kZSA9IGdldExlYWZOb2RlKGdldFNpYmxpbmdOb2RlKG5vZGUpKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9nZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEFjdGl2ZUVsZW1lbnRcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgZmItd3d3L3R5cGVvZi11bmRlZmluZWQgKi9cblxuLyoqXG4gKiBTYW1lIGFzIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgYnV0IHdyYXBzIGluIGEgdHJ5LWNhdGNoIGJsb2NrLiBJbiBJRSBpdCBpc1xuICogbm90IHNhZmUgdG8gY2FsbCBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGlmIHRoZXJlIGlzIG5vdGhpbmcgZm9jdXNlZC5cbiAqXG4gKiBUaGUgYWN0aXZlRWxlbWVudCB3aWxsIGJlIG51bGwgb25seSBpZiB0aGUgZG9jdW1lbnQgb3IgZG9jdW1lbnQgYm9keSBpcyBub3RcbiAqIHlldCBkZWZpbmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGdldEFjdGl2ZUVsZW1lbnQoKSAvKj9ET01FbGVtZW50Ki97XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCB8fCBkb2N1bWVudC5ib2R5O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBY3RpdmVFbGVtZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFNlbGVjdEV2ZW50UGx1Z2luXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdElucHV0U2VsZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdElucHV0U2VsZWN0aW9uJyk7XG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbnZhciBnZXRBY3RpdmVFbGVtZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudCcpO1xudmFyIGlzVGV4dElucHV0RWxlbWVudCA9IHJlcXVpcmUoJy4vaXNUZXh0SW5wdXRFbGVtZW50Jyk7XG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2ZianMvbGliL3NoYWxsb3dFcXVhbCcpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbnZhciBza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDw9IDExO1xuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgc2VsZWN0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TZWxlY3Q6IG51bGwgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblNlbGVjdENhcHR1cmU6IG51bGwgfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wQmx1ciwgdG9wTGV2ZWxUeXBlcy50b3BDb250ZXh0TWVudSwgdG9wTGV2ZWxUeXBlcy50b3BGb2N1cywgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duLCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93biwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZVVwLCB0b3BMZXZlbFR5cGVzLnRvcFNlbGVjdGlvbkNoYW5nZV1cbiAgfVxufTtcblxudmFyIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJRCA9IG51bGw7XG52YXIgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG52YXIgbW91c2VEb3duID0gZmFsc2U7XG5cbi8vIFRyYWNrIHdoZXRoZXIgYSBsaXN0ZW5lciBleGlzdHMgZm9yIHRoaXMgcGx1Z2luLiBJZiBub25lIGV4aXN0LCB3ZSBkb1xuLy8gbm90IGV4dHJhY3QgZXZlbnRzLlxudmFyIGhhc0xpc3RlbmVyID0gZmFsc2U7XG52YXIgT05fU0VMRUNUX0tFWSA9IGtleU9mKHsgb25TZWxlY3Q6IG51bGwgfSk7XG5cbi8qKlxuICogR2V0IGFuIG9iamVjdCB3aGljaCBpcyBhIHVuaXF1ZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKlxuICogVGhlIHJldHVybiB2YWx1ZSB3aWxsIG5vdCBiZSBjb25zaXN0ZW50IGFjcm9zcyBub2RlcyBvciBicm93c2VycywgYnV0XG4gKiB0d28gaWRlbnRpY2FsIHNlbGVjdGlvbnMgb24gdGhlIHNhbWUgbm9kZSB3aWxsIHJldHVybiBpZGVudGljYWwgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKG5vZGUpIHtcbiAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gbm9kZSAmJiBSZWFjdElucHV0U2VsZWN0aW9uLmhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhub2RlKSkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogbm9kZS5zZWxlY3Rpb25TdGFydCxcbiAgICAgIGVuZDogbm9kZS5zZWxlY3Rpb25FbmRcbiAgICB9O1xuICB9IGVsc2UgaWYgKHdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIHJldHVybiB7XG4gICAgICBhbmNob3JOb2RlOiBzZWxlY3Rpb24uYW5jaG9yTm9kZSxcbiAgICAgIGFuY2hvck9mZnNldDogc2VsZWN0aW9uLmFuY2hvck9mZnNldCxcbiAgICAgIGZvY3VzTm9kZTogc2VsZWN0aW9uLmZvY3VzTm9kZSxcbiAgICAgIGZvY3VzT2Zmc2V0OiBzZWxlY3Rpb24uZm9jdXNPZmZzZXRcbiAgICB9O1xuICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbikge1xuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBwYXJlbnRFbGVtZW50OiByYW5nZS5wYXJlbnRFbGVtZW50KCksXG4gICAgICB0ZXh0OiByYW5nZS50ZXh0LFxuICAgICAgdG9wOiByYW5nZS5ib3VuZGluZ1RvcCxcbiAgICAgIGxlZnQ6IHJhbmdlLmJvdW5kaW5nTGVmdFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBQb2xsIHNlbGVjdGlvbiB0byBzZWUgd2hldGhlciBpdCdzIGNoYW5nZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAvLyBFbnN1cmUgd2UgaGF2ZSB0aGUgcmlnaHQgZWxlbWVudCwgYW5kIHRoYXQgdGhlIHVzZXIgaXMgbm90IGRyYWdnaW5nIGFcbiAgLy8gc2VsZWN0aW9uICh0aGlzIG1hdGNoZXMgbmF0aXZlIGBzZWxlY3RgIGV2ZW50IGJlaGF2aW9yKS4gSW4gSFRNTDUsIHNlbGVjdFxuICAvLyBmaXJlcyBvbmx5IG9uIGlucHV0IGFuZCB0ZXh0YXJlYSB0aHVzIGlmIHRoZXJlJ3Mgbm8gZm9jdXNlZCBlbGVtZW50IHdlXG4gIC8vIHdvbid0IGRpc3BhdGNoLlxuICBpZiAobW91c2VEb3duIHx8IGFjdGl2ZUVsZW1lbnQgPT0gbnVsbCB8fCBhY3RpdmVFbGVtZW50ICE9PSBnZXRBY3RpdmVFbGVtZW50KCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIE9ubHkgZmlyZSB3aGVuIHNlbGVjdGlvbiBoYXMgYWN0dWFsbHkgY2hhbmdlZC5cbiAgdmFyIGN1cnJlbnRTZWxlY3Rpb24gPSBnZXRTZWxlY3Rpb24oYWN0aXZlRWxlbWVudCk7XG4gIGlmICghbGFzdFNlbGVjdGlvbiB8fCAhc2hhbGxvd0VxdWFsKGxhc3RTZWxlY3Rpb24sIGN1cnJlbnRTZWxlY3Rpb24pKSB7XG4gICAgbGFzdFNlbGVjdGlvbiA9IGN1cnJlbnRTZWxlY3Rpb247XG5cbiAgICB2YXIgc3ludGhldGljRXZlbnQgPSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5zZWxlY3QsIGFjdGl2ZUVsZW1lbnRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICAgIHN5bnRoZXRpY0V2ZW50LnR5cGUgPSAnc2VsZWN0JztcbiAgICBzeW50aGV0aWNFdmVudC50YXJnZXQgPSBhY3RpdmVFbGVtZW50O1xuXG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKHN5bnRoZXRpY0V2ZW50KTtcblxuICAgIHJldHVybiBzeW50aGV0aWNFdmVudDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uU2VsZWN0YCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgc2VsZWN0IGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gY29udGVudEVkaXRhYmxlXG4gKlxuICogVGhpcyBkaWZmZXJzIGZyb20gbmF0aXZlIGJyb3dzZXIgaW1wbGVtZW50YXRpb25zIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqIC0gRmlyZXMgb24gY29udGVudEVkaXRhYmxlIGZpZWxkcyBhcyB3ZWxsIGFzIGlucHV0cy5cbiAqIC0gRmlyZXMgZm9yIGNvbGxhcHNlZCBzZWxlY3Rpb24uXG4gKiAtIEZpcmVzIGFmdGVyIHVzZXIgaW5wdXQuXG4gKi9cbnZhciBTZWxlY3RFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRvcExldmVsVGFyZ2V0IFRoZSBsaXN0ZW5pbmcgY29tcG9uZW50IHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVGFyZ2V0SUQgSUQgb2YgYHRvcExldmVsVGFyZ2V0YC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuZXh0cmFjdEV2ZW50c31cbiAgICovXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICBpZiAoIWhhc0xpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgLy8gVHJhY2sgdGhlIGlucHV0IG5vZGUgdGhhdCBoYXMgZm9jdXMuXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRm9jdXM6XG4gICAgICAgIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodG9wTGV2ZWxUYXJnZXQpIHx8IHRvcExldmVsVGFyZ2V0LmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudCA9IHRvcExldmVsVGFyZ2V0O1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnRJRCA9IHRvcExldmVsVGFyZ2V0SUQ7XG4gICAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQmx1cjpcbiAgICAgICAgYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gICAgICAgIGFjdGl2ZUVsZW1lbnRJRCA9IG51bGw7XG4gICAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICBicmVhaztcblxuICAgICAgLy8gRG9uJ3QgZmlyZSB0aGUgZXZlbnQgd2hpbGUgdGhlIHVzZXIgaXMgZHJhZ2dpbmcuIFRoaXMgbWF0Y2hlcyB0aGVcbiAgICAgIC8vIHNlbWFudGljcyBvZiB0aGUgbmF0aXZlIHNlbGVjdCBldmVudC5cbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd246XG4gICAgICAgIG1vdXNlRG93biA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbnRleHRNZW51OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlVXA6XG4gICAgICAgIG1vdXNlRG93biA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICAgICAgLy8gQ2hyb21lIGFuZCBJRSBmaXJlIG5vbi1zdGFuZGFyZCBldmVudCB3aGVuIHNlbGVjdGlvbiBpcyBjaGFuZ2VkIChhbmRcbiAgICAgIC8vIHNvbWV0aW1lcyB3aGVuIGl0IGhhc24ndCkuIElFJ3MgZXZlbnQgZmlyZXMgb3V0IG9mIG9yZGVyIHdpdGggcmVzcGVjdFxuICAgICAgLy8gdG8ga2V5IGFuZCBpbnB1dCBldmVudHMgb24gZGVsZXRpb24sIHNvIHdlIGRpc2NhcmQgaXQuXG4gICAgICAvL1xuICAgICAgLy8gRmlyZWZveCBkb2Vzbid0IHN1cHBvcnQgc2VsZWN0aW9uY2hhbmdlLCBzbyBjaGVjayBzZWxlY3Rpb24gc3RhdHVzXG4gICAgICAvLyBhZnRlciBlYWNoIGtleSBlbnRyeS4gVGhlIHNlbGVjdGlvbiBjaGFuZ2VzIGFmdGVyIGtleWRvd24gYW5kIGJlZm9yZVxuICAgICAgLy8ga2V5dXAsIGJ1dCB3ZSBjaGVjayBvbiBrZXlkb3duIGFzIHdlbGwgaW4gdGhlIGNhc2Ugb2YgaG9sZGluZyBkb3duIGFcbiAgICAgIC8vIGtleSwgd2hlbiBtdWx0aXBsZSBrZXlkb3duIGV2ZW50cyBhcmUgZmlyZWQgYnV0IG9ubHkgb25lIGtleXVwIGlzLlxuICAgICAgLy8gVGhpcyBpcyBhbHNvIG91ciBhcHByb2FjaCBmb3IgSUUgaGFuZGxpbmcsIGZvciB0aGUgcmVhc29uIGFib3ZlLlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFNlbGVjdGlvbkNoYW5nZTpcbiAgICAgICAgaWYgKHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5RG93bjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcDpcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgZGlkUHV0TGlzdGVuZXI6IGZ1bmN0aW9uIChpZCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gT05fU0VMRUNUX0tFWSkge1xuICAgICAgaGFzTGlzdGVuZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZWxlY3RFdmVudFBsdWdpbjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1NlbGVjdEV2ZW50UGx1Z2luLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFNlcnZlclJlYWN0Um9vdEluZGV4XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTaXplIG9mIHRoZSByZWFjdFJvb3QgSUQgc3BhY2UuIFdlIGdlbmVyYXRlIHJhbmRvbSBudW1iZXJzIGZvciBSZWFjdCByb290XG4gKiBJRHMgYW5kIGlmIHRoZXJlJ3MgYSBjb2xsaXNpb24gdGhlIGV2ZW50cyBhbmQgRE9NIHVwZGF0ZSBzeXN0ZW0gd2lsbFxuICogZ2V0IGNvbmZ1c2VkLiBJbiB0aGUgZnV0dXJlIHdlIG5lZWQgYSB3YXkgdG8gZ2VuZXJhdGUgR1VJRHMgYnV0IGZvclxuICogbm93IHRoaXMgd2lsbCB3b3JrIG9uIGEgc21hbGxlciBzY2FsZS5cbiAqL1xudmFyIEdMT0JBTF9NT1VOVF9QT0lOVF9NQVggPSBNYXRoLnBvdygyLCA1Myk7XG5cbnZhciBTZXJ2ZXJSZWFjdFJvb3RJbmRleCA9IHtcbiAgY3JlYXRlUmVhY3RSb290SW5kZXg6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKE1hdGgucmFuZG9tKCkgKiBHTE9CQUxfTU9VTlRfUE9JTlRfTUFYKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXJ2ZXJSZWFjdFJvb3RJbmRleDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1NlcnZlclJlYWN0Um9vdEluZGV4LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFNpbXBsZUV2ZW50UGx1Z2luXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgRXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJ2ZianMvbGliL0V2ZW50TGlzdGVuZXInKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xudmFyIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNDbGlwYm9hcmRFdmVudCcpO1xudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xudmFyIFN5bnRoZXRpY0ZvY3VzRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0ZvY3VzRXZlbnQnKTtcbnZhciBTeW50aGV0aWNLZXlib2FyZEV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNLZXlib2FyZEV2ZW50Jyk7XG52YXIgU3ludGhldGljTW91c2VFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljTW91c2VFdmVudCcpO1xudmFyIFN5bnRoZXRpY0RyYWdFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRHJhZ0V2ZW50Jyk7XG52YXIgU3ludGhldGljVG91Y2hFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVG91Y2hFdmVudCcpO1xudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcbnZhciBTeW50aGV0aWNXaGVlbEV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNXaGVlbEV2ZW50Jyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGdldEV2ZW50Q2hhckNvZGUgPSByZXF1aXJlKCcuL2dldEV2ZW50Q2hhckNvZGUnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIGFib3J0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25BYm9ydDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQWJvcnRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBibHVyOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25CbHVyOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25CbHVyQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgY2FuUGxheToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ2FuUGxheTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ2FuUGxheUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGNhblBsYXlUaHJvdWdoOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25DYW5QbGF5VGhyb3VnaDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ2FuUGxheVRocm91Z2hDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBjbGljazoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ2xpY2s6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNsaWNrQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgY29udGV4dE1lbnU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNvbnRleHRNZW51OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Db250ZXh0TWVudUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGNvcHk6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNvcHk6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNvcHlDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBjdXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkN1dDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ3V0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZG91YmxlQ2xpY2s6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRvdWJsZUNsaWNrOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Eb3VibGVDbGlja0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyYWc6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyYWc6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnRW5kOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnRW5kOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EcmFnRW5kQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZ0VudGVyOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnRW50ZXI6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdFbnRlckNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdFeGl0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnRXhpdDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ0V4aXRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnTGVhdmU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyYWdMZWF2ZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ0xlYXZlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZ092ZXI6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyYWdPdmVyOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EcmFnT3ZlckNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdTdGFydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ1N0YXJ0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EcmFnU3RhcnRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcm9wOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Ecm9wOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Ecm9wQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHVyYXRpb25DaGFuZ2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkR1cmF0aW9uQ2hhbmdlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EdXJhdGlvbkNoYW5nZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGVtcHRpZWQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkVtcHRpZWQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkVtcHRpZWRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBlbmNyeXB0ZWQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkVuY3J5cHRlZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRW5jcnlwdGVkQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZW5kZWQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkVuZGVkOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25FbmRlZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGVycm9yOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25FcnJvcjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRXJyb3JDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBmb2N1czoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRm9jdXM6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkZvY3VzQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgaW5wdXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbklucHV0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25JbnB1dENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGtleURvd246IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbktleURvd246IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbktleURvd25DYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBrZXlQcmVzczoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uS2V5UHJlc3M6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbktleVByZXNzQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAga2V5VXA6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbktleVVwOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25LZXlVcENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGxvYWQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkxvYWQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkxvYWRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBsb2FkZWREYXRhOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Mb2FkZWREYXRhOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Mb2FkZWREYXRhQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbG9hZGVkTWV0YWRhdGE6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkxvYWRlZE1ldGFkYXRhOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Mb2FkZWRNZXRhZGF0YUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGxvYWRTdGFydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTG9hZFN0YXJ0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Mb2FkU3RhcnRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICAvLyBOb3RlOiBXZSBkbyBub3QgYWxsb3cgbGlzdGVuaW5nIHRvIG1vdXNlT3ZlciBldmVudHMuIEluc3RlYWQsIHVzZSB0aGVcbiAgLy8gb25Nb3VzZUVudGVyL29uTW91c2VMZWF2ZSBjcmVhdGVkIGJ5IGBFbnRlckxlYXZlRXZlbnRQbHVnaW5gLlxuICBtb3VzZURvd246IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbk1vdXNlRG93bjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTW91c2VEb3duQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbW91c2VNb3ZlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Nb3VzZU1vdmU6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbk1vdXNlTW92ZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIG1vdXNlT3V0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Nb3VzZU91dDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTW91c2VPdXRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBtb3VzZU92ZXI6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbk1vdXNlT3ZlcjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTW91c2VPdmVyQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbW91c2VVcDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTW91c2VVcDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTW91c2VVcENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHBhc3RlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25QYXN0ZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uUGFzdGVDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBwYXVzZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUGF1c2U6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblBhdXNlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgcGxheToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUGxheTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uUGxheUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHBsYXlpbmc6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblBsYXlpbmc6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblBsYXlpbmdDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBwcm9ncmVzczoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUHJvZ3Jlc3M6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblByb2dyZXNzQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgcmF0ZUNoYW5nZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUmF0ZUNoYW5nZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uUmF0ZUNoYW5nZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHJlc2V0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25SZXNldDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uUmVzZXRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBzY3JvbGw6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblNjcm9sbDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uU2Nyb2xsQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgc2Vla2VkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TZWVrZWQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblNlZWtlZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHNlZWtpbmc6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblNlZWtpbmc6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblNlZWtpbmdDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBzdGFsbGVkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TdGFsbGVkOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TdGFsbGVkQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgc3VibWl0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TdWJtaXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblN1Ym1pdENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHN1c3BlbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblN1c3BlbmQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblN1c3BlbmRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB0aW1lVXBkYXRlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25UaW1lVXBkYXRlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25UaW1lVXBkYXRlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgdG91Y2hDYW5jZWw6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblRvdWNoQ2FuY2VsOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Ub3VjaENhbmNlbENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHRvdWNoRW5kOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Ub3VjaEVuZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVG91Y2hFbmRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB0b3VjaE1vdmU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblRvdWNoTW92ZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVG91Y2hNb3ZlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgdG91Y2hTdGFydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uVG91Y2hTdGFydDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVG91Y2hTdGFydENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHZvbHVtZUNoYW5nZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uVm9sdW1lQ2hhbmdlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Wb2x1bWVDaGFuZ2VDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB3YWl0aW5nOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25XYWl0aW5nOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25XYWl0aW5nQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgd2hlZWw6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbldoZWVsOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25XaGVlbENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH1cbn07XG5cbnZhciB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcgPSB7XG4gIHRvcEFib3J0OiBldmVudFR5cGVzLmFib3J0LFxuICB0b3BCbHVyOiBldmVudFR5cGVzLmJsdXIsXG4gIHRvcENhblBsYXk6IGV2ZW50VHlwZXMuY2FuUGxheSxcbiAgdG9wQ2FuUGxheVRocm91Z2g6IGV2ZW50VHlwZXMuY2FuUGxheVRocm91Z2gsXG4gIHRvcENsaWNrOiBldmVudFR5cGVzLmNsaWNrLFxuICB0b3BDb250ZXh0TWVudTogZXZlbnRUeXBlcy5jb250ZXh0TWVudSxcbiAgdG9wQ29weTogZXZlbnRUeXBlcy5jb3B5LFxuICB0b3BDdXQ6IGV2ZW50VHlwZXMuY3V0LFxuICB0b3BEb3VibGVDbGljazogZXZlbnRUeXBlcy5kb3VibGVDbGljayxcbiAgdG9wRHJhZzogZXZlbnRUeXBlcy5kcmFnLFxuICB0b3BEcmFnRW5kOiBldmVudFR5cGVzLmRyYWdFbmQsXG4gIHRvcERyYWdFbnRlcjogZXZlbnRUeXBlcy5kcmFnRW50ZXIsXG4gIHRvcERyYWdFeGl0OiBldmVudFR5cGVzLmRyYWdFeGl0LFxuICB0b3BEcmFnTGVhdmU6IGV2ZW50VHlwZXMuZHJhZ0xlYXZlLFxuICB0b3BEcmFnT3ZlcjogZXZlbnRUeXBlcy5kcmFnT3ZlcixcbiAgdG9wRHJhZ1N0YXJ0OiBldmVudFR5cGVzLmRyYWdTdGFydCxcbiAgdG9wRHJvcDogZXZlbnRUeXBlcy5kcm9wLFxuICB0b3BEdXJhdGlvbkNoYW5nZTogZXZlbnRUeXBlcy5kdXJhdGlvbkNoYW5nZSxcbiAgdG9wRW1wdGllZDogZXZlbnRUeXBlcy5lbXB0aWVkLFxuICB0b3BFbmNyeXB0ZWQ6IGV2ZW50VHlwZXMuZW5jcnlwdGVkLFxuICB0b3BFbmRlZDogZXZlbnRUeXBlcy5lbmRlZCxcbiAgdG9wRXJyb3I6IGV2ZW50VHlwZXMuZXJyb3IsXG4gIHRvcEZvY3VzOiBldmVudFR5cGVzLmZvY3VzLFxuICB0b3BJbnB1dDogZXZlbnRUeXBlcy5pbnB1dCxcbiAgdG9wS2V5RG93bjogZXZlbnRUeXBlcy5rZXlEb3duLFxuICB0b3BLZXlQcmVzczogZXZlbnRUeXBlcy5rZXlQcmVzcyxcbiAgdG9wS2V5VXA6IGV2ZW50VHlwZXMua2V5VXAsXG4gIHRvcExvYWQ6IGV2ZW50VHlwZXMubG9hZCxcbiAgdG9wTG9hZGVkRGF0YTogZXZlbnRUeXBlcy5sb2FkZWREYXRhLFxuICB0b3BMb2FkZWRNZXRhZGF0YTogZXZlbnRUeXBlcy5sb2FkZWRNZXRhZGF0YSxcbiAgdG9wTG9hZFN0YXJ0OiBldmVudFR5cGVzLmxvYWRTdGFydCxcbiAgdG9wTW91c2VEb3duOiBldmVudFR5cGVzLm1vdXNlRG93bixcbiAgdG9wTW91c2VNb3ZlOiBldmVudFR5cGVzLm1vdXNlTW92ZSxcbiAgdG9wTW91c2VPdXQ6IGV2ZW50VHlwZXMubW91c2VPdXQsXG4gIHRvcE1vdXNlT3ZlcjogZXZlbnRUeXBlcy5tb3VzZU92ZXIsXG4gIHRvcE1vdXNlVXA6IGV2ZW50VHlwZXMubW91c2VVcCxcbiAgdG9wUGFzdGU6IGV2ZW50VHlwZXMucGFzdGUsXG4gIHRvcFBhdXNlOiBldmVudFR5cGVzLnBhdXNlLFxuICB0b3BQbGF5OiBldmVudFR5cGVzLnBsYXksXG4gIHRvcFBsYXlpbmc6IGV2ZW50VHlwZXMucGxheWluZyxcbiAgdG9wUHJvZ3Jlc3M6IGV2ZW50VHlwZXMucHJvZ3Jlc3MsXG4gIHRvcFJhdGVDaGFuZ2U6IGV2ZW50VHlwZXMucmF0ZUNoYW5nZSxcbiAgdG9wUmVzZXQ6IGV2ZW50VHlwZXMucmVzZXQsXG4gIHRvcFNjcm9sbDogZXZlbnRUeXBlcy5zY3JvbGwsXG4gIHRvcFNlZWtlZDogZXZlbnRUeXBlcy5zZWVrZWQsXG4gIHRvcFNlZWtpbmc6IGV2ZW50VHlwZXMuc2Vla2luZyxcbiAgdG9wU3RhbGxlZDogZXZlbnRUeXBlcy5zdGFsbGVkLFxuICB0b3BTdWJtaXQ6IGV2ZW50VHlwZXMuc3VibWl0LFxuICB0b3BTdXNwZW5kOiBldmVudFR5cGVzLnN1c3BlbmQsXG4gIHRvcFRpbWVVcGRhdGU6IGV2ZW50VHlwZXMudGltZVVwZGF0ZSxcbiAgdG9wVG91Y2hDYW5jZWw6IGV2ZW50VHlwZXMudG91Y2hDYW5jZWwsXG4gIHRvcFRvdWNoRW5kOiBldmVudFR5cGVzLnRvdWNoRW5kLFxuICB0b3BUb3VjaE1vdmU6IGV2ZW50VHlwZXMudG91Y2hNb3ZlLFxuICB0b3BUb3VjaFN0YXJ0OiBldmVudFR5cGVzLnRvdWNoU3RhcnQsXG4gIHRvcFZvbHVtZUNoYW5nZTogZXZlbnRUeXBlcy52b2x1bWVDaGFuZ2UsXG4gIHRvcFdhaXRpbmc6IGV2ZW50VHlwZXMud2FpdGluZyxcbiAgdG9wV2hlZWw6IGV2ZW50VHlwZXMud2hlZWxcbn07XG5cbmZvciAodmFyIHR5cGUgaW4gdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnKSB7XG4gIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0eXBlXS5kZXBlbmRlbmNpZXMgPSBbdHlwZV07XG59XG5cbnZhciBPTl9DTElDS19LRVkgPSBrZXlPZih7IG9uQ2xpY2s6IG51bGwgfSk7XG52YXIgb25DbGlja0xpc3RlbmVycyA9IHt9O1xuXG52YXIgU2ltcGxlRXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmV4dHJhY3RFdmVudHN9XG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGRpc3BhdGNoQ29uZmlnID0gdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnW3RvcExldmVsVHlwZV07XG4gICAgaWYgKCFkaXNwYXRjaENvbmZpZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBFdmVudENvbnN0cnVjdG9yO1xuICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQWJvcnQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ2FuUGxheTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDYW5QbGF5VGhyb3VnaDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEdXJhdGlvbkNoYW5nZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BFbXB0aWVkOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEVuY3J5cHRlZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BFbmRlZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BFcnJvcjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BJbnB1dDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BMb2FkOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcExvYWRlZERhdGE6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTG9hZGVkTWV0YWRhdGE6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTG9hZFN0YXJ0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFBhdXNlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFBsYXk6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUGxheWluZzpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BQcm9ncmVzczpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BSYXRlQ2hhbmdlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFJlc2V0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFNlZWtlZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTZWVraW5nOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFN0YWxsZWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU3VibWl0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFN1c3BlbmQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVGltZVVwZGF0ZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BWb2x1bWVDaGFuZ2U6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wV2FpdGluZzpcbiAgICAgICAgLy8gSFRNTCBFdmVudHNcbiAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmRleC5odG1sI2V2ZW50cy0wXG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3M6XG4gICAgICAgIC8vIEZpcmVGb3ggY3JlYXRlcyBhIGtleXByZXNzIGV2ZW50IGZvciBmdW5jdGlvbiBrZXlzIHRvby4gVGhpcyByZW1vdmVzXG4gICAgICAgIC8vIHRoZSB1bndhbnRlZCBrZXlwcmVzcyBldmVudHMuIEVudGVyIGlzIGhvd2V2ZXIgYm90aCBwcmludGFibGUgYW5kXG4gICAgICAgIC8vIG5vbi1wcmludGFibGUuIE9uZSB3b3VsZCBleHBlY3QgVGFiIHRvIGJlIGFzIHdlbGwgKGJ1dCBpdCBpc24ndCkuXG4gICAgICAgIGlmIChnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5RG93bjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEJsdXI6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRm9jdXM6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDbGljazpcbiAgICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEgY2xpY2sgZXZlbnQgb24gcmlnaHQgbW91c2UgY2xpY2tzLiBUaGlzIHJlbW92ZXMgdGhlXG4gICAgICAgIC8vIHVud2FudGVkIGNsaWNrIGV2ZW50cy5cbiAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmJ1dHRvbiA9PT0gMikge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29udGV4dE1lbnU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRG91YmxlQ2xpY2s6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlTW92ZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU92ZXI6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VVcDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY01vdXNlRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWc6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ0VuZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnRW50ZXI6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ0V4aXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ0xlYXZlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdPdmVyOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdTdGFydDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcm9wOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRHJhZ0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUb3VjaENhbmNlbDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUb3VjaEVuZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUb3VjaE1vdmU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVG91Y2hTdGFydDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1RvdWNoRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFNjcm9sbDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1VJRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFdoZWVsOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljV2hlZWxFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29weTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDdXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUGFzdGU6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNDbGlwYm9hcmRFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgICFFdmVudENvbnN0cnVjdG9yID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1NpbXBsZUV2ZW50UGx1Z2luOiBVbmhhbmRsZWQgZXZlbnQgdHlwZSwgYCVzYC4nLCB0b3BMZXZlbFR5cGUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgZXZlbnQgPSBFdmVudENvbnN0cnVjdG9yLmdldFBvb2xlZChkaXNwYXRjaENvbmZpZywgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICAgIHJldHVybiBldmVudDtcbiAgfSxcblxuICBkaWRQdXRMaXN0ZW5lcjogZnVuY3Rpb24gKGlkLCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgIC8vIE1vYmlsZSBTYWZhcmkgZG9lcyBub3QgZmlyZSBwcm9wZXJseSBidWJibGUgY2xpY2sgZXZlbnRzIG9uXG4gICAgLy8gbm9uLWludGVyYWN0aXZlIGVsZW1lbnRzLCB3aGljaCBtZWFucyBkZWxlZ2F0ZWQgY2xpY2sgbGlzdGVuZXJzIGRvIG5vdFxuICAgIC8vIGZpcmUuIFRoZSB3b3JrYXJvdW5kIGZvciB0aGlzIGJ1ZyBpbnZvbHZlcyBhdHRhY2hpbmcgYW4gZW1wdHkgY2xpY2tcbiAgICAvLyBsaXN0ZW5lciBvbiB0aGUgdGFyZ2V0IG5vZGUuXG4gICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgPT09IE9OX0NMSUNLX0tFWSkge1xuICAgICAgdmFyIG5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUoaWQpO1xuICAgICAgaWYgKCFvbkNsaWNrTGlzdGVuZXJzW2lkXSkge1xuICAgICAgICBvbkNsaWNrTGlzdGVuZXJzW2lkXSA9IEV2ZW50TGlzdGVuZXIubGlzdGVuKG5vZGUsICdjbGljaycsIGVtcHR5RnVuY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB3aWxsRGVsZXRlTGlzdGVuZXI6IGZ1bmN0aW9uIChpZCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSBPTl9DTElDS19LRVkpIHtcbiAgICAgIG9uQ2xpY2tMaXN0ZW5lcnNbaWRdLnJlbW92ZSgpO1xuICAgICAgZGVsZXRlIG9uQ2xpY2tMaXN0ZW5lcnNbaWRdO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNpbXBsZUV2ZW50UGx1Z2luO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvU2ltcGxlRXZlbnRQbHVnaW4uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljQ2xpcGJvYXJkRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jbGlwYm9hcmQtYXBpcy9cbiAqL1xudmFyIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlID0ge1xuICBjbGlwYm9hcmREYXRhOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2NsaXBib2FyZERhdGEnIGluIGV2ZW50ID8gZXZlbnQuY2xpcGJvYXJkRGF0YSA6IHdpbmRvdy5jbGlwYm9hcmREYXRhO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNDbGlwYm9hcmRFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50LCBDbGlwYm9hcmRFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNDbGlwYm9hcmRFdmVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNGb2N1c0V2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEZvY3VzRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRm9jdXNFdmVudEludGVyZmFjZSA9IHtcbiAgcmVsYXRlZFRhcmdldDogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRm9jdXNFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNGb2N1c0V2ZW50LCBGb2N1c0V2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvU3ludGhldGljRm9jdXNFdmVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNLZXlib2FyZEV2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcblxudmFyIGdldEV2ZW50Q2hhckNvZGUgPSByZXF1aXJlKCcuL2dldEV2ZW50Q2hhckNvZGUnKTtcbnZhciBnZXRFdmVudEtleSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRLZXknKTtcbnZhciBnZXRFdmVudE1vZGlmaWVyU3RhdGUgPSByZXF1aXJlKCcuL2dldEV2ZW50TW9kaWZpZXJTdGF0ZScpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgS2V5Ym9hcmRFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBLZXlib2FyZEV2ZW50SW50ZXJmYWNlID0ge1xuICBrZXk6IGdldEV2ZW50S2V5LFxuICBsb2NhdGlvbjogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgcmVwZWF0OiBudWxsLFxuICBsb2NhbGU6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgLy8gTGVnYWN5IEludGVyZmFjZVxuICBjaGFyQ29kZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYGNoYXJDb2RlYCBpcyB0aGUgcmVzdWx0IG9mIGEgS2V5UHJlc3MgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gdGhlIGFjdHVhbCBwcmludGFibGUgY2hhcmFjdGVyLlxuXG4gICAgLy8gS2V5UHJlc3MgaXMgZGVwcmVjYXRlZCwgYnV0IGl0cyByZXBsYWNlbWVudCBpcyBub3QgeWV0IGZpbmFsIGFuZCBub3RcbiAgICAvLyBpbXBsZW1lbnRlZCBpbiBhbnkgbWFqb3IgYnJvd3Nlci4gT25seSBLZXlQcmVzcyBoYXMgY2hhckNvZGUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICAgIHJldHVybiBnZXRFdmVudENoYXJDb2RlKGV2ZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIGtleUNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBrZXlDb2RlYCBpcyB0aGUgcmVzdWx0IG9mIGEgS2V5RG93bi9VcCBldmVudCBhbmQgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2ZcbiAgICAvLyBwaHlzaWNhbCBrZXlib2FyZCBrZXkuXG5cbiAgICAvLyBUaGUgYWN0dWFsIG1lYW5pbmcgb2YgdGhlIHZhbHVlIGRlcGVuZHMgb24gdGhlIHVzZXJzJyBrZXlib2FyZCBsYXlvdXRcbiAgICAvLyB3aGljaCBjYW5ub3QgYmUgZGV0ZWN0ZWQuIEFzc3VtaW5nIHRoYXQgaXQgaXMgYSBVUyBrZXlib2FyZCBsYXlvdXRcbiAgICAvLyBwcm92aWRlcyBhIHN1cnByaXNpbmdseSBhY2N1cmF0ZSBtYXBwaW5nIGZvciBVUyBhbmQgRXVyb3BlYW4gdXNlcnMuXG4gICAgLy8gRHVlIHRvIHRoaXMsIGl0IGlzIGxlZnQgdG8gdGhlIHVzZXIgdG8gaW1wbGVtZW50IGF0IHRoaXMgdGltZS5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAgIHJldHVybiBldmVudC5rZXlDb2RlO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAgd2hpY2g6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGB3aGljaGAgaXMgYW4gYWxpYXMgZm9yIGVpdGhlciBga2V5Q29kZWAgb3IgYGNoYXJDb2RlYCBkZXBlbmRpbmcgb24gdGhlXG4gICAgLy8gdHlwZSBvZiB0aGUgZXZlbnQuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICAgIHJldHVybiBnZXRFdmVudENoYXJDb2RlKGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0tleWJvYXJkRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljS2V5Ym9hcmRFdmVudCwgS2V5Ym9hcmRFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljS2V5Ym9hcmRFdmVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY0tleWJvYXJkRXZlbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0RXZlbnRDaGFyQ29kZVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogYGNoYXJDb2RlYCByZXByZXNlbnRzIHRoZSBhY3R1YWwgXCJjaGFyYWN0ZXIgY29kZVwiIGFuZCBpcyBzYWZlIHRvIHVzZSB3aXRoXG4gKiBgU3RyaW5nLmZyb21DaGFyQ29kZWAuIEFzIHN1Y2gsIG9ubHkga2V5cyB0aGF0IGNvcnJlc3BvbmQgdG8gcHJpbnRhYmxlXG4gKiBjaGFyYWN0ZXJzIHByb2R1Y2UgYSB2YWxpZCBgY2hhckNvZGVgLCB0aGUgb25seSBleGNlcHRpb24gdG8gdGhpcyBpcyBFbnRlci5cbiAqIFRoZSBUYWIta2V5IGlzIGNvbnNpZGVyZWQgbm9uLXByaW50YWJsZSBhbmQgZG9lcyBub3QgaGF2ZSBhIGBjaGFyQ29kZWAsXG4gKiBwcmVzdW1hYmx5IGJlY2F1c2UgaXQgZG9lcyBub3QgcHJvZHVjZSBhIHRhYi1jaGFyYWN0ZXIgaW4gYnJvd3NlcnMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7bnVtYmVyfSBOb3JtYWxpemVkIGBjaGFyQ29kZWAgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGNoYXJDb2RlO1xuICB2YXIga2V5Q29kZSA9IG5hdGl2ZUV2ZW50LmtleUNvZGU7XG5cbiAgaWYgKCdjaGFyQ29kZScgaW4gbmF0aXZlRXZlbnQpIHtcbiAgICBjaGFyQ29kZSA9IG5hdGl2ZUV2ZW50LmNoYXJDb2RlO1xuXG4gICAgLy8gRkYgZG9lcyBub3Qgc2V0IGBjaGFyQ29kZWAgZm9yIHRoZSBFbnRlci1rZXksIGNoZWNrIGFnYWluc3QgYGtleUNvZGVgLlxuICAgIGlmIChjaGFyQ29kZSA9PT0gMCAmJiBrZXlDb2RlID09PSAxMykge1xuICAgICAgY2hhckNvZGUgPSAxMztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBgY2hhckNvZGVgLCBidXQgYGtleUNvZGVgIGhhcyB0aGUgY29ycmVjdCB2YWx1ZS5cbiAgICBjaGFyQ29kZSA9IGtleUNvZGU7XG4gIH1cblxuICAvLyBTb21lIG5vbi1wcmludGFibGUga2V5cyBhcmUgcmVwb3J0ZWQgaW4gYGNoYXJDb2RlYC9ga2V5Q29kZWAsIGRpc2NhcmQgdGhlbS5cbiAgLy8gTXVzdCBub3QgZGlzY2FyZCB0aGUgKG5vbi0pcHJpbnRhYmxlIEVudGVyLWtleS5cbiAgaWYgKGNoYXJDb2RlID49IDMyIHx8IGNoYXJDb2RlID09PSAxMykge1xuICAgIHJldHVybiBjaGFyQ29kZTtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEV2ZW50Q2hhckNvZGU7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9nZXRFdmVudENoYXJDb2RlLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEV2ZW50S2V5XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGdldEV2ZW50Q2hhckNvZGUgPSByZXF1aXJlKCcuL2dldEV2ZW50Q2hhckNvZGUnKTtcblxuLyoqXG4gKiBOb3JtYWxpemF0aW9uIG9mIGRlcHJlY2F0ZWQgSFRNTDUgYGtleWAgdmFsdWVzXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgbm9ybWFsaXplS2V5ID0ge1xuICAnRXNjJzogJ0VzY2FwZScsXG4gICdTcGFjZWJhcic6ICcgJyxcbiAgJ0xlZnQnOiAnQXJyb3dMZWZ0JyxcbiAgJ1VwJzogJ0Fycm93VXAnLFxuICAnUmlnaHQnOiAnQXJyb3dSaWdodCcsXG4gICdEb3duJzogJ0Fycm93RG93bicsXG4gICdEZWwnOiAnRGVsZXRlJyxcbiAgJ1dpbic6ICdPUycsXG4gICdNZW51JzogJ0NvbnRleHRNZW51JyxcbiAgJ0FwcHMnOiAnQ29udGV4dE1lbnUnLFxuICAnU2Nyb2xsJzogJ1Njcm9sbExvY2snLFxuICAnTW96UHJpbnRhYmxlS2V5JzogJ1VuaWRlbnRpZmllZCdcbn07XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBsZWdhY3kgYGtleUNvZGVgIHRvIEhUTUw1IGBrZXlgXG4gKiBPbmx5IHNwZWNpYWwga2V5cyBzdXBwb3J0ZWQsIGFsbCBvdGhlcnMgZGVwZW5kIG9uIGtleWJvYXJkIGxheW91dCBvciBicm93c2VyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgdHJhbnNsYXRlVG9LZXkgPSB7XG4gIDg6ICdCYWNrc3BhY2UnLFxuICA5OiAnVGFiJyxcbiAgMTI6ICdDbGVhcicsXG4gIDEzOiAnRW50ZXInLFxuICAxNjogJ1NoaWZ0JyxcbiAgMTc6ICdDb250cm9sJyxcbiAgMTg6ICdBbHQnLFxuICAxOTogJ1BhdXNlJyxcbiAgMjA6ICdDYXBzTG9jaycsXG4gIDI3OiAnRXNjYXBlJyxcbiAgMzI6ICcgJyxcbiAgMzM6ICdQYWdlVXAnLFxuICAzNDogJ1BhZ2VEb3duJyxcbiAgMzU6ICdFbmQnLFxuICAzNjogJ0hvbWUnLFxuICAzNzogJ0Fycm93TGVmdCcsXG4gIDM4OiAnQXJyb3dVcCcsXG4gIDM5OiAnQXJyb3dSaWdodCcsXG4gIDQwOiAnQXJyb3dEb3duJyxcbiAgNDU6ICdJbnNlcnQnLFxuICA0NjogJ0RlbGV0ZScsXG4gIDExMjogJ0YxJywgMTEzOiAnRjInLCAxMTQ6ICdGMycsIDExNTogJ0Y0JywgMTE2OiAnRjUnLCAxMTc6ICdGNicsXG4gIDExODogJ0Y3JywgMTE5OiAnRjgnLCAxMjA6ICdGOScsIDEyMTogJ0YxMCcsIDEyMjogJ0YxMScsIDEyMzogJ0YxMicsXG4gIDE0NDogJ051bUxvY2snLFxuICAxNDU6ICdTY3JvbGxMb2NrJyxcbiAgMjI0OiAnTWV0YSdcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIGBrZXlgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudEtleShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQua2V5KSB7XG4gICAgLy8gTm9ybWFsaXplIGluY29uc2lzdGVudCB2YWx1ZXMgcmVwb3J0ZWQgYnkgYnJvd3NlcnMgZHVlIHRvXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIG9mIGEgd29ya2luZyBkcmFmdCBzcGVjaWZpY2F0aW9uLlxuXG4gICAgLy8gRmlyZUZveCBpbXBsZW1lbnRzIGBrZXlgIGJ1dCByZXR1cm5zIGBNb3pQcmludGFibGVLZXlgIGZvciBhbGxcbiAgICAvLyBwcmludGFibGUgY2hhcmFjdGVycyAobm9ybWFsaXplZCB0byBgVW5pZGVudGlmaWVkYCksIGlnbm9yZSBpdC5cbiAgICB2YXIga2V5ID0gbm9ybWFsaXplS2V5W25hdGl2ZUV2ZW50LmtleV0gfHwgbmF0aXZlRXZlbnQua2V5O1xuICAgIGlmIChrZXkgIT09ICdVbmlkZW50aWZpZWQnKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgfVxuXG4gIC8vIEJyb3dzZXIgZG9lcyBub3QgaW1wbGVtZW50IGBrZXlgLCBwb2x5ZmlsbCBhcyBtdWNoIG9mIGl0IGFzIHdlIGNhbi5cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICB2YXIgY2hhckNvZGUgPSBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KTtcblxuICAgIC8vIFRoZSBlbnRlci1rZXkgaXMgdGVjaG5pY2FsbHkgYm90aCBwcmludGFibGUgYW5kIG5vbi1wcmludGFibGUgYW5kIGNhblxuICAgIC8vIHRodXMgYmUgY2FwdHVyZWQgYnkgYGtleXByZXNzYCwgbm8gb3RoZXIgbm9uLXByaW50YWJsZSBrZXkgc2hvdWxkLlxuICAgIHJldHVybiBjaGFyQ29kZSA9PT0gMTMgPyAnRW50ZXInIDogU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gIH1cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBuYXRpdmVFdmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgLy8gV2hpbGUgdXNlciBrZXlib2FyZCBsYXlvdXQgZGV0ZXJtaW5lcyB0aGUgYWN0dWFsIG1lYW5pbmcgb2YgZWFjaFxuICAgIC8vIGBrZXlDb2RlYCB2YWx1ZSwgYWxtb3N0IGFsbCBmdW5jdGlvbiBrZXlzIGhhdmUgYSB1bml2ZXJzYWwgdmFsdWUuXG4gICAgcmV0dXJuIHRyYW5zbGF0ZVRvS2V5W25hdGl2ZUV2ZW50LmtleUNvZGVdIHx8ICdVbmlkZW50aWZpZWQnO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudEtleTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL2dldEV2ZW50S2V5LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0RyYWdFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNNb3VzZUV2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBEcmFnRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRHJhZ0V2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhVHJhbnNmZXI6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0RyYWdFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICBTeW50aGV0aWNNb3VzZUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNNb3VzZUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNEcmFnRXZlbnQsIERyYWdFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljRHJhZ0V2ZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvU3ludGhldGljRHJhZ0V2ZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY1RvdWNoRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xuXG52YXIgZ2V0RXZlbnRNb2RpZmllclN0YXRlID0gcmVxdWlyZSgnLi9nZXRFdmVudE1vZGlmaWVyU3RhdGUnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFRvdWNoRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvdG91Y2gtZXZlbnRzL1xuICovXG52YXIgVG91Y2hFdmVudEludGVyZmFjZSA9IHtcbiAgdG91Y2hlczogbnVsbCxcbiAgdGFyZ2V0VG91Y2hlczogbnVsbCxcbiAgY2hhbmdlZFRvdWNoZXM6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljVG91Y2hFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNUb3VjaEV2ZW50LCBUb3VjaEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNUb3VjaEV2ZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvU3ludGhldGljVG91Y2hFdmVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNXaGVlbEV2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFdoZWVsRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgV2hlZWxFdmVudEludGVyZmFjZSA9IHtcbiAgZGVsdGFYOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWCcgaW4gZXZlbnQgPyBldmVudC5kZWx0YVggOlxuICAgIC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWGAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChyaWdodCBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFYJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWCA6IDA7XG4gIH0sXG4gIGRlbHRhWTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVknIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFZIDpcbiAgICAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVlgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFZJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWSA6XG4gICAgLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFgIGZvciBJRTw5IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhIDogMDtcbiAgfSxcbiAgZGVsdGFaOiBudWxsLFxuXG4gIC8vIEJyb3dzZXJzIHdpdGhvdXQgXCJkZWx0YU1vZGVcIiBpcyByZXBvcnRpbmcgaW4gcmF3IHdoZWVsIGRlbHRhIHdoZXJlIG9uZVxuICAvLyBub3RjaCBvbiB0aGUgc2Nyb2xsIGlzIGFsd2F5cyArLy0gMTIwLCByb3VnaGx5IGVxdWl2YWxlbnQgdG8gcGl4ZWxzLlxuICAvLyBBIGdvb2QgYXBwcm94aW1hdGlvbiBvZiBET01fREVMVEFfTElORSAoMSkgaXMgNSUgb2Ygdmlld3BvcnQgc2l6ZSBvclxuICAvLyB+NDAgcGl4ZWxzLCBmb3IgRE9NX0RFTFRBX1NDUkVFTiAoMikgaXQgaXMgODcuNSUgb2Ygdmlld3BvcnQgc2l6ZS5cbiAgZGVsdGFNb2RlOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNNb3VzZUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNXaGVlbEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIFN5bnRoZXRpY01vdXNlRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY01vdXNlRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1doZWVsRXZlbnQsIFdoZWVsRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1doZWVsRXZlbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNXaGVlbEV2ZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFNWR0RPTVByb3BlcnR5Q29uZmlnXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG5cbnZhciBNVVNUX1VTRV9BVFRSSUJVVEUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uTVVTVF9VU0VfQVRUUklCVVRFO1xuXG52YXIgTlMgPSB7XG4gIHhsaW5rOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsXG4gIHhtbDogJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZSdcbn07XG5cbnZhciBTVkdET01Qcm9wZXJ0eUNvbmZpZyA9IHtcbiAgUHJvcGVydGllczoge1xuICAgIGNsaXBQYXRoOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgY3g6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBjeTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBkeDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGR5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZmlsbDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZpbGxPcGFjaXR5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZm9udEZhbWlseTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZvbnRTaXplOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZng6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmeTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGdyYWRpZW50VHJhbnNmb3JtOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZ3JhZGllbnRVbml0czogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG1hcmtlckVuZDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG1hcmtlck1pZDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG1hcmtlclN0YXJ0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgb2Zmc2V0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgb3BhY2l0eTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHBhdHRlcm5Db250ZW50VW5pdHM6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBwYXR0ZXJuVW5pdHM6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBwb2ludHM6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcjogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHJ4OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcnk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzcHJlYWRNZXRob2Q6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzdG9wQ29sb3I6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzdG9wT3BhY2l0eTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHN0cm9rZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHN0cm9rZURhc2hhcnJheTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHN0cm9rZUxpbmVjYXA6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzdHJva2VPcGFjaXR5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3Ryb2tlV2lkdGg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB0ZXh0QW5jaG9yOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgdHJhbnNmb3JtOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgdmVyc2lvbjogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHZpZXdCb3g6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4MTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHgyOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHhsaW5rQWN0dWF0ZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHhsaW5rQXJjcm9sZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHhsaW5rSHJlZjogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHhsaW5rUm9sZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHhsaW5rU2hvdzogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHhsaW5rVGl0bGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bGlua1R5cGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bWxCYXNlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeG1sTGFuZzogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHhtbFNwYWNlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeTE6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB5MjogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHk6IE1VU1RfVVNFX0FUVFJJQlVURVxuICB9LFxuICBET01BdHRyaWJ1dGVOYW1lc3BhY2VzOiB7XG4gICAgeGxpbmtBY3R1YXRlOiBOUy54bGluayxcbiAgICB4bGlua0FyY3JvbGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rSHJlZjogTlMueGxpbmssXG4gICAgeGxpbmtSb2xlOiBOUy54bGluayxcbiAgICB4bGlua1Nob3c6IE5TLnhsaW5rLFxuICAgIHhsaW5rVGl0bGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rVHlwZTogTlMueGxpbmssXG4gICAgeG1sQmFzZTogTlMueG1sLFxuICAgIHhtbExhbmc6IE5TLnhtbCxcbiAgICB4bWxTcGFjZTogTlMueG1sXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzOiB7XG4gICAgY2xpcFBhdGg6ICdjbGlwLXBhdGgnLFxuICAgIGZpbGxPcGFjaXR5OiAnZmlsbC1vcGFjaXR5JyxcbiAgICBmb250RmFtaWx5OiAnZm9udC1mYW1pbHknLFxuICAgIGZvbnRTaXplOiAnZm9udC1zaXplJyxcbiAgICBncmFkaWVudFRyYW5zZm9ybTogJ2dyYWRpZW50VHJhbnNmb3JtJyxcbiAgICBncmFkaWVudFVuaXRzOiAnZ3JhZGllbnRVbml0cycsXG4gICAgbWFya2VyRW5kOiAnbWFya2VyLWVuZCcsXG4gICAgbWFya2VyTWlkOiAnbWFya2VyLW1pZCcsXG4gICAgbWFya2VyU3RhcnQ6ICdtYXJrZXItc3RhcnQnLFxuICAgIHBhdHRlcm5Db250ZW50VW5pdHM6ICdwYXR0ZXJuQ29udGVudFVuaXRzJyxcbiAgICBwYXR0ZXJuVW5pdHM6ICdwYXR0ZXJuVW5pdHMnLFxuICAgIHByZXNlcnZlQXNwZWN0UmF0aW86ICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJyxcbiAgICBzcHJlYWRNZXRob2Q6ICdzcHJlYWRNZXRob2QnLFxuICAgIHN0b3BDb2xvcjogJ3N0b3AtY29sb3InLFxuICAgIHN0b3BPcGFjaXR5OiAnc3RvcC1vcGFjaXR5JyxcbiAgICBzdHJva2VEYXNoYXJyYXk6ICdzdHJva2UtZGFzaGFycmF5JyxcbiAgICBzdHJva2VMaW5lY2FwOiAnc3Ryb2tlLWxpbmVjYXAnLFxuICAgIHN0cm9rZU9wYWNpdHk6ICdzdHJva2Utb3BhY2l0eScsXG4gICAgc3Ryb2tlV2lkdGg6ICdzdHJva2Utd2lkdGgnLFxuICAgIHRleHRBbmNob3I6ICd0ZXh0LWFuY2hvcicsXG4gICAgdmlld0JveDogJ3ZpZXdCb3gnLFxuICAgIHhsaW5rQWN0dWF0ZTogJ3hsaW5rOmFjdHVhdGUnLFxuICAgIHhsaW5rQXJjcm9sZTogJ3hsaW5rOmFyY3JvbGUnLFxuICAgIHhsaW5rSHJlZjogJ3hsaW5rOmhyZWYnLFxuICAgIHhsaW5rUm9sZTogJ3hsaW5rOnJvbGUnLFxuICAgIHhsaW5rU2hvdzogJ3hsaW5rOnNob3cnLFxuICAgIHhsaW5rVGl0bGU6ICd4bGluazp0aXRsZScsXG4gICAgeGxpbmtUeXBlOiAneGxpbms6dHlwZScsXG4gICAgeG1sQmFzZTogJ3htbDpiYXNlJyxcbiAgICB4bWxMYW5nOiAneG1sOmxhbmcnLFxuICAgIHhtbFNwYWNlOiAneG1sOnNwYWNlJ1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNWR0RPTVByb3BlcnR5Q29uZmlnO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvU1ZHRE9NUHJvcGVydHlDb25maWcuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3REZWZhdWx0UGVyZlxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMgPSByZXF1aXJlKCcuL1JlYWN0RGVmYXVsdFBlcmZBbmFseXNpcycpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKCcuL1JlYWN0UGVyZicpO1xuXG52YXIgcGVyZm9ybWFuY2VOb3cgPSByZXF1aXJlKCdmYmpzL2xpYi9wZXJmb3JtYW5jZU5vdycpO1xuXG5mdW5jdGlvbiByb3VuZEZsb2F0KHZhbCkge1xuICByZXR1cm4gTWF0aC5mbG9vcih2YWwgKiAxMDApIC8gMTAwO1xufVxuXG5mdW5jdGlvbiBhZGRWYWx1ZShvYmosIGtleSwgdmFsKSB7XG4gIG9ialtrZXldID0gKG9ialtrZXldIHx8IDApICsgdmFsO1xufVxuXG52YXIgUmVhY3REZWZhdWx0UGVyZiA9IHtcbiAgX2FsbE1lYXN1cmVtZW50czogW10sIC8vIGxhc3QgaXRlbSBpbiB0aGUgbGlzdCBpcyB0aGUgY3VycmVudCBvbmVcbiAgX21vdW50U3RhY2s6IFswXSxcbiAgX2luamVjdGVkOiBmYWxzZSxcblxuICBzdGFydDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghUmVhY3REZWZhdWx0UGVyZi5faW5qZWN0ZWQpIHtcbiAgICAgIFJlYWN0UGVyZi5pbmplY3Rpb24uaW5qZWN0TWVhc3VyZShSZWFjdERlZmF1bHRQZXJmLm1lYXN1cmUpO1xuICAgIH1cblxuICAgIFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50cy5sZW5ndGggPSAwO1xuICAgIFJlYWN0UGVyZi5lbmFibGVNZWFzdXJlID0gdHJ1ZTtcbiAgfSxcblxuICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgUmVhY3RQZXJmLmVuYWJsZU1lYXN1cmUgPSBmYWxzZTtcbiAgfSxcblxuICBnZXRMYXN0TWVhc3VyZW1lbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50cztcbiAgfSxcblxuICBwcmludEV4Y2x1c2l2ZTogZnVuY3Rpb24gKG1lYXN1cmVtZW50cykge1xuICAgIG1lYXN1cmVtZW50cyA9IG1lYXN1cmVtZW50cyB8fCBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHM7XG4gICAgdmFyIHN1bW1hcnkgPSBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0RXhjbHVzaXZlU3VtbWFyeShtZWFzdXJlbWVudHMpO1xuICAgIGNvbnNvbGUudGFibGUoc3VtbWFyeS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdDb21wb25lbnQgY2xhc3MgbmFtZSc6IGl0ZW0uY29tcG9uZW50TmFtZSxcbiAgICAgICAgJ1RvdGFsIGluY2x1c2l2ZSB0aW1lIChtcyknOiByb3VuZEZsb2F0KGl0ZW0uaW5jbHVzaXZlKSxcbiAgICAgICAgJ0V4Y2x1c2l2ZSBtb3VudCB0aW1lIChtcyknOiByb3VuZEZsb2F0KGl0ZW0uZXhjbHVzaXZlKSxcbiAgICAgICAgJ0V4Y2x1c2l2ZSByZW5kZXIgdGltZSAobXMpJzogcm91bmRGbG9hdChpdGVtLnJlbmRlciksXG4gICAgICAgICdNb3VudCB0aW1lIHBlciBpbnN0YW5jZSAobXMpJzogcm91bmRGbG9hdChpdGVtLmV4Y2x1c2l2ZSAvIGl0ZW0uY291bnQpLFxuICAgICAgICAnUmVuZGVyIHRpbWUgcGVyIGluc3RhbmNlIChtcyknOiByb3VuZEZsb2F0KGl0ZW0ucmVuZGVyIC8gaXRlbS5jb3VudCksXG4gICAgICAgICdJbnN0YW5jZXMnOiBpdGVtLmNvdW50XG4gICAgICB9O1xuICAgIH0pKTtcbiAgICAvLyBUT0RPOiBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0VG90YWxUaW1lKCkgZG9lcyBub3QgcmV0dXJuIHRoZSBjb3JyZWN0XG4gICAgLy8gbnVtYmVyLlxuICB9LFxuXG4gIHByaW50SW5jbHVzaXZlOiBmdW5jdGlvbiAobWVhc3VyZW1lbnRzKSB7XG4gICAgbWVhc3VyZW1lbnRzID0gbWVhc3VyZW1lbnRzIHx8IFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50cztcbiAgICB2YXIgc3VtbWFyeSA9IFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5nZXRJbmNsdXNpdmVTdW1tYXJ5KG1lYXN1cmVtZW50cyk7XG4gICAgY29uc29sZS50YWJsZShzdW1tYXJ5Lm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ093bmVyID4gY29tcG9uZW50JzogaXRlbS5jb21wb25lbnROYW1lLFxuICAgICAgICAnSW5jbHVzaXZlIHRpbWUgKG1zKSc6IHJvdW5kRmxvYXQoaXRlbS50aW1lKSxcbiAgICAgICAgJ0luc3RhbmNlcyc6IGl0ZW0uY291bnRcbiAgICAgIH07XG4gICAgfSkpO1xuICAgIGNvbnNvbGUubG9nKCdUb3RhbCB0aW1lOicsIFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5nZXRUb3RhbFRpbWUobWVhc3VyZW1lbnRzKS50b0ZpeGVkKDIpICsgJyBtcycpO1xuICB9LFxuXG4gIGdldE1lYXN1cmVtZW50c1N1bW1hcnlNYXA6IGZ1bmN0aW9uIChtZWFzdXJlbWVudHMpIHtcbiAgICB2YXIgc3VtbWFyeSA9IFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5nZXRJbmNsdXNpdmVTdW1tYXJ5KG1lYXN1cmVtZW50cywgdHJ1ZSk7XG4gICAgcmV0dXJuIHN1bW1hcnkubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnT3duZXIgPiBjb21wb25lbnQnOiBpdGVtLmNvbXBvbmVudE5hbWUsXG4gICAgICAgICdXYXN0ZWQgdGltZSAobXMpJzogaXRlbS50aW1lLFxuICAgICAgICAnSW5zdGFuY2VzJzogaXRlbS5jb3VudFxuICAgICAgfTtcbiAgICB9KTtcbiAgfSxcblxuICBwcmludFdhc3RlZDogZnVuY3Rpb24gKG1lYXN1cmVtZW50cykge1xuICAgIG1lYXN1cmVtZW50cyA9IG1lYXN1cmVtZW50cyB8fCBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHM7XG4gICAgY29uc29sZS50YWJsZShSZWFjdERlZmF1bHRQZXJmLmdldE1lYXN1cmVtZW50c1N1bW1hcnlNYXAobWVhc3VyZW1lbnRzKSk7XG4gICAgY29uc29sZS5sb2coJ1RvdGFsIHRpbWU6JywgUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmdldFRvdGFsVGltZShtZWFzdXJlbWVudHMpLnRvRml4ZWQoMikgKyAnIG1zJyk7XG4gIH0sXG5cbiAgcHJpbnRET006IGZ1bmN0aW9uIChtZWFzdXJlbWVudHMpIHtcbiAgICBtZWFzdXJlbWVudHMgPSBtZWFzdXJlbWVudHMgfHwgUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzO1xuICAgIHZhciBzdW1tYXJ5ID0gUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmdldERPTVN1bW1hcnkobWVhc3VyZW1lbnRzKTtcbiAgICBjb25zb2xlLnRhYmxlKHN1bW1hcnkubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICByZXN1bHRbRE9NUHJvcGVydHkuSURfQVRUUklCVVRFX05BTUVdID0gaXRlbS5pZDtcbiAgICAgIHJlc3VsdC50eXBlID0gaXRlbS50eXBlO1xuICAgICAgcmVzdWx0LmFyZ3MgPSBKU09OLnN0cmluZ2lmeShpdGVtLmFyZ3MpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KSk7XG4gICAgY29uc29sZS5sb2coJ1RvdGFsIHRpbWU6JywgUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmdldFRvdGFsVGltZShtZWFzdXJlbWVudHMpLnRvRml4ZWQoMikgKyAnIG1zJyk7XG4gIH0sXG5cbiAgX3JlY29yZFdyaXRlOiBmdW5jdGlvbiAoaWQsIGZuTmFtZSwgdG90YWxUaW1lLCBhcmdzKSB7XG4gICAgLy8gVE9ETzogdG90YWxUaW1lIGlzbid0IHRoYXQgdXNlZnVsIHNpbmNlIGl0IGRvZXNuJ3QgY291bnQgcGFpbnRzL3JlZmxvd3NcbiAgICB2YXIgd3JpdGVzID0gUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzW1JlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50cy5sZW5ndGggLSAxXS53cml0ZXM7XG4gICAgd3JpdGVzW2lkXSA9IHdyaXRlc1tpZF0gfHwgW107XG4gICAgd3JpdGVzW2lkXS5wdXNoKHtcbiAgICAgIHR5cGU6IGZuTmFtZSxcbiAgICAgIHRpbWU6IHRvdGFsVGltZSxcbiAgICAgIGFyZ3M6IGFyZ3NcbiAgICB9KTtcbiAgfSxcblxuICBtZWFzdXJlOiBmdW5jdGlvbiAobW9kdWxlTmFtZSwgZm5OYW1lLCBmdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHZhciB0b3RhbFRpbWU7XG4gICAgICB2YXIgcnY7XG4gICAgICB2YXIgc3RhcnQ7XG5cbiAgICAgIGlmIChmbk5hbWUgPT09ICdfcmVuZGVyTmV3Um9vdENvbXBvbmVudCcgfHwgZm5OYW1lID09PSAnZmx1c2hCYXRjaGVkVXBkYXRlcycpIHtcbiAgICAgICAgLy8gQSBcIm1lYXN1cmVtZW50XCIgaXMgYSBzZXQgb2YgbWV0cmljcyByZWNvcmRlZCBmb3IgZWFjaCBmbHVzaC4gV2Ugd2FudFxuICAgICAgICAvLyB0byBncm91cCB0aGUgbWV0cmljcyBmb3IgYSBnaXZlbiBmbHVzaCB0b2dldGhlciBzbyB3ZSBjYW4gbG9vayBhdCB0aGVcbiAgICAgICAgLy8gY29tcG9uZW50cyB0aGF0IHJlbmRlcmVkIGFuZCB0aGUgRE9NIG9wZXJhdGlvbnMgdGhhdCBhY3R1YWxseVxuICAgICAgICAvLyBoYXBwZW5lZCB0byBkZXRlcm1pbmUgdGhlIGFtb3VudCBvZiBcIndhc3RlZCB3b3JrXCIgcGVyZm9ybWVkLlxuICAgICAgICBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHMucHVzaCh7XG4gICAgICAgICAgZXhjbHVzaXZlOiB7fSxcbiAgICAgICAgICBpbmNsdXNpdmU6IHt9LFxuICAgICAgICAgIHJlbmRlcjoge30sXG4gICAgICAgICAgY291bnRzOiB7fSxcbiAgICAgICAgICB3cml0ZXM6IHt9LFxuICAgICAgICAgIGRpc3BsYXlOYW1lczoge30sXG4gICAgICAgICAgdG90YWxUaW1lOiAwLFxuICAgICAgICAgIGNyZWF0ZWQ6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBzdGFydCA9IHBlcmZvcm1hbmNlTm93KCk7XG4gICAgICAgIHJ2ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzW1JlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50cy5sZW5ndGggLSAxXS50b3RhbFRpbWUgPSBwZXJmb3JtYW5jZU5vdygpIC0gc3RhcnQ7XG4gICAgICAgIHJldHVybiBydjtcbiAgICAgIH0gZWxzZSBpZiAoZm5OYW1lID09PSAnX21vdW50SW1hZ2VJbnRvTm9kZScgfHwgbW9kdWxlTmFtZSA9PT0gJ1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlcicgfHwgbW9kdWxlTmFtZSA9PT0gJ1JlYWN0RE9NSURPcGVyYXRpb25zJyB8fCBtb2R1bGVOYW1lID09PSAnQ1NTUHJvcGVydHlPcGVyYXRpb25zJyB8fCBtb2R1bGVOYW1lID09PSAnRE9NQ2hpbGRyZW5PcGVyYXRpb25zJyB8fCBtb2R1bGVOYW1lID09PSAnRE9NUHJvcGVydHlPcGVyYXRpb25zJykge1xuICAgICAgICBzdGFydCA9IHBlcmZvcm1hbmNlTm93KCk7XG4gICAgICAgIHJ2ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgdG90YWxUaW1lID0gcGVyZm9ybWFuY2VOb3coKSAtIHN0YXJ0O1xuXG4gICAgICAgIGlmIChmbk5hbWUgPT09ICdfbW91bnRJbWFnZUludG9Ob2RlJykge1xuICAgICAgICAgIHZhciBtb3VudElEID0gUmVhY3RNb3VudC5nZXRJRChhcmdzWzFdKTtcbiAgICAgICAgICBSZWFjdERlZmF1bHRQZXJmLl9yZWNvcmRXcml0ZShtb3VudElELCBmbk5hbWUsIHRvdGFsVGltZSwgYXJnc1swXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZm5OYW1lID09PSAnZGFuZ2Vyb3VzbHlQcm9jZXNzQ2hpbGRyZW5VcGRhdGVzJykge1xuICAgICAgICAgIC8vIHNwZWNpYWwgZm9ybWF0XG4gICAgICAgICAgYXJnc1swXS5mb3JFYWNoKGZ1bmN0aW9uICh1cGRhdGUpIHtcbiAgICAgICAgICAgIHZhciB3cml0ZUFyZ3MgPSB7fTtcbiAgICAgICAgICAgIGlmICh1cGRhdGUuZnJvbUluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHdyaXRlQXJncy5mcm9tSW5kZXggPSB1cGRhdGUuZnJvbUluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVwZGF0ZS50b0luZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHdyaXRlQXJncy50b0luZGV4ID0gdXBkYXRlLnRvSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXBkYXRlLnRleHRDb250ZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHdyaXRlQXJncy50ZXh0Q29udGVudCA9IHVwZGF0ZS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cGRhdGUubWFya3VwSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgd3JpdGVBcmdzLm1hcmt1cCA9IGFyZ3NbMV1bdXBkYXRlLm1hcmt1cEluZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlYWN0RGVmYXVsdFBlcmYuX3JlY29yZFdyaXRlKHVwZGF0ZS5wYXJlbnRJRCwgdXBkYXRlLnR5cGUsIHRvdGFsVGltZSwgd3JpdGVBcmdzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBiYXNpYyBmb3JtYXRcbiAgICAgICAgICB2YXIgaWQgPSBhcmdzWzBdO1xuICAgICAgICAgIGlmICh0eXBlb2YgaWQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZCA9IFJlYWN0TW91bnQuZ2V0SUQoYXJnc1swXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFJlYWN0RGVmYXVsdFBlcmYuX3JlY29yZFdyaXRlKGlkLCBmbk5hbWUsIHRvdGFsVGltZSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydjtcbiAgICAgIH0gZWxzZSBpZiAobW9kdWxlTmFtZSA9PT0gJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JyAmJiAoZm5OYW1lID09PSAnbW91bnRDb21wb25lbnQnIHx8IGZuTmFtZSA9PT0gJ3VwZGF0ZUNvbXBvbmVudCcgfHwgLy8gVE9ETzogcmVjZWl2ZUNvbXBvbmVudCgpP1xuICAgICAgZm5OYW1lID09PSAnX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCcpKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGUgPT09IFJlYWN0TW91bnQuVG9wTGV2ZWxXcmFwcGVyKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcm9vdE5vZGVJRCA9IGZuTmFtZSA9PT0gJ21vdW50Q29tcG9uZW50JyA/IGFyZ3NbMF0gOiB0aGlzLl9yb290Tm9kZUlEO1xuICAgICAgICB2YXIgaXNSZW5kZXIgPSBmbk5hbWUgPT09ICdfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50JztcbiAgICAgICAgdmFyIGlzTW91bnQgPSBmbk5hbWUgPT09ICdtb3VudENvbXBvbmVudCc7XG5cbiAgICAgICAgdmFyIG1vdW50U3RhY2sgPSBSZWFjdERlZmF1bHRQZXJmLl9tb3VudFN0YWNrO1xuICAgICAgICB2YXIgZW50cnkgPSBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHNbUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmIChpc1JlbmRlcikge1xuICAgICAgICAgIGFkZFZhbHVlKGVudHJ5LmNvdW50cywgcm9vdE5vZGVJRCwgMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNNb3VudCkge1xuICAgICAgICAgIGVudHJ5LmNyZWF0ZWRbcm9vdE5vZGVJRF0gPSB0cnVlO1xuICAgICAgICAgIG1vdW50U3RhY2sucHVzaCgwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgcnYgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB0b3RhbFRpbWUgPSBwZXJmb3JtYW5jZU5vdygpIC0gc3RhcnQ7XG5cbiAgICAgICAgaWYgKGlzUmVuZGVyKSB7XG4gICAgICAgICAgYWRkVmFsdWUoZW50cnkucmVuZGVyLCByb290Tm9kZUlELCB0b3RhbFRpbWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTW91bnQpIHtcbiAgICAgICAgICB2YXIgc3ViTW91bnRUaW1lID0gbW91bnRTdGFjay5wb3AoKTtcbiAgICAgICAgICBtb3VudFN0YWNrW21vdW50U3RhY2subGVuZ3RoIC0gMV0gKz0gdG90YWxUaW1lO1xuICAgICAgICAgIGFkZFZhbHVlKGVudHJ5LmV4Y2x1c2l2ZSwgcm9vdE5vZGVJRCwgdG90YWxUaW1lIC0gc3ViTW91bnRUaW1lKTtcbiAgICAgICAgICBhZGRWYWx1ZShlbnRyeS5pbmNsdXNpdmUsIHJvb3ROb2RlSUQsIHRvdGFsVGltZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkVmFsdWUoZW50cnkuaW5jbHVzaXZlLCByb290Tm9kZUlELCB0b3RhbFRpbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZW50cnkuZGlzcGxheU5hbWVzW3Jvb3ROb2RlSURdID0ge1xuICAgICAgICAgIGN1cnJlbnQ6IHRoaXMuZ2V0TmFtZSgpLFxuICAgICAgICAgIG93bmVyOiB0aGlzLl9jdXJyZW50RWxlbWVudC5fb3duZXIgPyB0aGlzLl9jdXJyZW50RWxlbWVudC5fb3duZXIuZ2V0TmFtZSgpIDogJzxyb290PidcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gcnY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RGVmYXVsdFBlcmY7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERlZmF1bHRQZXJmLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xuXG4vLyBEb24ndCB0cnkgdG8gc2F2ZSB1c2VycyBsZXNzIHRoYW4gMS4ybXMgKGEgbnVtYmVyIEkgbWFkZSB1cClcbnZhciBET05UX0NBUkVfVEhSRVNIT0xEID0gMS4yO1xudmFyIERPTV9PUEVSQVRJT05fVFlQRVMgPSB7XG4gICdfbW91bnRJbWFnZUludG9Ob2RlJzogJ3NldCBpbm5lckhUTUwnLFxuICBJTlNFUlRfTUFSS1VQOiAnc2V0IGlubmVySFRNTCcsXG4gIE1PVkVfRVhJU1RJTkc6ICdtb3ZlJyxcbiAgUkVNT1ZFX05PREU6ICdyZW1vdmUnLFxuICBTRVRfTUFSS1VQOiAnc2V0IGlubmVySFRNTCcsXG4gIFRFWFRfQ09OVEVOVDogJ3NldCB0ZXh0Q29udGVudCcsXG4gICdzZXRWYWx1ZUZvclByb3BlcnR5JzogJ3VwZGF0ZSBhdHRyaWJ1dGUnLFxuICAnc2V0VmFsdWVGb3JBdHRyaWJ1dGUnOiAndXBkYXRlIGF0dHJpYnV0ZScsXG4gICdkZWxldGVWYWx1ZUZvclByb3BlcnR5JzogJ3JlbW92ZSBhdHRyaWJ1dGUnLFxuICAnc2V0VmFsdWVGb3JTdHlsZXMnOiAndXBkYXRlIHN0eWxlcycsXG4gICdyZXBsYWNlTm9kZVdpdGhNYXJrdXAnOiAncmVwbGFjZScsXG4gICd1cGRhdGVUZXh0Q29udGVudCc6ICdzZXQgdGV4dENvbnRlbnQnXG59O1xuXG5mdW5jdGlvbiBnZXRUb3RhbFRpbWUobWVhc3VyZW1lbnRzKSB7XG4gIC8vIFRPRE86IHJldHVybiBudW1iZXIgb2YgRE9NIG9wcz8gY291bGQgYmUgbWlzbGVhZGluZy5cbiAgLy8gVE9ETzogbWVhc3VyZSBkcm9wcGVkIGZyYW1lcyBhZnRlciByZWNvbmNpbGU/XG4gIC8vIFRPRE86IGxvZyB0b3RhbCB0aW1lIG9mIGVhY2ggcmVjb25jaWxlIGFuZCB0aGUgdG9wLWxldmVsIGNvbXBvbmVudFxuICAvLyBjbGFzcyB0aGF0IHRyaWdnZXJlZCBpdC5cbiAgdmFyIHRvdGFsVGltZSA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWVhc3VyZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG1lYXN1cmVtZW50ID0gbWVhc3VyZW1lbnRzW2ldO1xuICAgIHRvdGFsVGltZSArPSBtZWFzdXJlbWVudC50b3RhbFRpbWU7XG4gIH1cbiAgcmV0dXJuIHRvdGFsVGltZTtcbn1cblxuZnVuY3Rpb24gZ2V0RE9NU3VtbWFyeShtZWFzdXJlbWVudHMpIHtcbiAgdmFyIGl0ZW1zID0gW107XG4gIG1lYXN1cmVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtZWFzdXJlbWVudCkge1xuICAgIE9iamVjdC5rZXlzKG1lYXN1cmVtZW50LndyaXRlcykuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgIG1lYXN1cmVtZW50LndyaXRlc1tpZF0uZm9yRWFjaChmdW5jdGlvbiAod3JpdGUpIHtcbiAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIHR5cGU6IERPTV9PUEVSQVRJT05fVFlQRVNbd3JpdGUudHlwZV0gfHwgd3JpdGUudHlwZSxcbiAgICAgICAgICBhcmdzOiB3cml0ZS5hcmdzXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gaXRlbXM7XG59XG5cbmZ1bmN0aW9uIGdldEV4Y2x1c2l2ZVN1bW1hcnkobWVhc3VyZW1lbnRzKSB7XG4gIHZhciBjYW5kaWRhdGVzID0ge307XG4gIHZhciBkaXNwbGF5TmFtZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1lYXN1cmVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1tpXTtcbiAgICB2YXIgYWxsSURzID0gYXNzaWduKHt9LCBtZWFzdXJlbWVudC5leGNsdXNpdmUsIG1lYXN1cmVtZW50LmluY2x1c2l2ZSk7XG5cbiAgICBmb3IgKHZhciBpZCBpbiBhbGxJRHMpIHtcbiAgICAgIGRpc3BsYXlOYW1lID0gbWVhc3VyZW1lbnQuZGlzcGxheU5hbWVzW2lkXS5jdXJyZW50O1xuXG4gICAgICBjYW5kaWRhdGVzW2Rpc3BsYXlOYW1lXSA9IGNhbmRpZGF0ZXNbZGlzcGxheU5hbWVdIHx8IHtcbiAgICAgICAgY29tcG9uZW50TmFtZTogZGlzcGxheU5hbWUsXG4gICAgICAgIGluY2x1c2l2ZTogMCxcbiAgICAgICAgZXhjbHVzaXZlOiAwLFxuICAgICAgICByZW5kZXI6IDAsXG4gICAgICAgIGNvdW50OiAwXG4gICAgICB9O1xuICAgICAgaWYgKG1lYXN1cmVtZW50LnJlbmRlcltpZF0pIHtcbiAgICAgICAgY2FuZGlkYXRlc1tkaXNwbGF5TmFtZV0ucmVuZGVyICs9IG1lYXN1cmVtZW50LnJlbmRlcltpZF07XG4gICAgICB9XG4gICAgICBpZiAobWVhc3VyZW1lbnQuZXhjbHVzaXZlW2lkXSkge1xuICAgICAgICBjYW5kaWRhdGVzW2Rpc3BsYXlOYW1lXS5leGNsdXNpdmUgKz0gbWVhc3VyZW1lbnQuZXhjbHVzaXZlW2lkXTtcbiAgICAgIH1cbiAgICAgIGlmIChtZWFzdXJlbWVudC5pbmNsdXNpdmVbaWRdKSB7XG4gICAgICAgIGNhbmRpZGF0ZXNbZGlzcGxheU5hbWVdLmluY2x1c2l2ZSArPSBtZWFzdXJlbWVudC5pbmNsdXNpdmVbaWRdO1xuICAgICAgfVxuICAgICAgaWYgKG1lYXN1cmVtZW50LmNvdW50c1tpZF0pIHtcbiAgICAgICAgY2FuZGlkYXRlc1tkaXNwbGF5TmFtZV0uY291bnQgKz0gbWVhc3VyZW1lbnQuY291bnRzW2lkXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBOb3cgbWFrZSBhIHNvcnRlZCBhcnJheSB3aXRoIHRoZSByZXN1bHRzLlxuICB2YXIgYXJyID0gW107XG4gIGZvciAoZGlzcGxheU5hbWUgaW4gY2FuZGlkYXRlcykge1xuICAgIGlmIChjYW5kaWRhdGVzW2Rpc3BsYXlOYW1lXS5leGNsdXNpdmUgPj0gRE9OVF9DQVJFX1RIUkVTSE9MRCkge1xuICAgICAgYXJyLnB1c2goY2FuZGlkYXRlc1tkaXNwbGF5TmFtZV0pO1xuICAgIH1cbiAgfVxuXG4gIGFyci5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIuZXhjbHVzaXZlIC0gYS5leGNsdXNpdmU7XG4gIH0pO1xuXG4gIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIGdldEluY2x1c2l2ZVN1bW1hcnkobWVhc3VyZW1lbnRzLCBvbmx5Q2xlYW4pIHtcbiAgdmFyIGNhbmRpZGF0ZXMgPSB7fTtcbiAgdmFyIGluY2x1c2l2ZUtleTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1lYXN1cmVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1tpXTtcbiAgICB2YXIgYWxsSURzID0gYXNzaWduKHt9LCBtZWFzdXJlbWVudC5leGNsdXNpdmUsIG1lYXN1cmVtZW50LmluY2x1c2l2ZSk7XG4gICAgdmFyIGNsZWFuQ29tcG9uZW50cztcblxuICAgIGlmIChvbmx5Q2xlYW4pIHtcbiAgICAgIGNsZWFuQ29tcG9uZW50cyA9IGdldFVuY2hhbmdlZENvbXBvbmVudHMobWVhc3VyZW1lbnQpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGlkIGluIGFsbElEcykge1xuICAgICAgaWYgKG9ubHlDbGVhbiAmJiAhY2xlYW5Db21wb25lbnRzW2lkXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gbWVhc3VyZW1lbnQuZGlzcGxheU5hbWVzW2lkXTtcblxuICAgICAgLy8gSW5jbHVzaXZlIHRpbWUgaXMgbm90IHVzZWZ1bCBmb3IgbWFueSBjb21wb25lbnRzIHdpdGhvdXQga25vd2luZyB3aGVyZVxuICAgICAgLy8gdGhleSBhcmUgaW5zdGFudGlhdGVkLiBTbyB3ZSBhZ2dyZWdhdGUgaW5jbHVzaXZlIHRpbWUgd2l0aCBib3RoIHRoZVxuICAgICAgLy8gb3duZXIgYW5kIGN1cnJlbnQgZGlzcGxheU5hbWUgYXMgdGhlIGtleS5cbiAgICAgIGluY2x1c2l2ZUtleSA9IGRpc3BsYXlOYW1lLm93bmVyICsgJyA+ICcgKyBkaXNwbGF5TmFtZS5jdXJyZW50O1xuXG4gICAgICBjYW5kaWRhdGVzW2luY2x1c2l2ZUtleV0gPSBjYW5kaWRhdGVzW2luY2x1c2l2ZUtleV0gfHwge1xuICAgICAgICBjb21wb25lbnROYW1lOiBpbmNsdXNpdmVLZXksXG4gICAgICAgIHRpbWU6IDAsXG4gICAgICAgIGNvdW50OiAwXG4gICAgICB9O1xuXG4gICAgICBpZiAobWVhc3VyZW1lbnQuaW5jbHVzaXZlW2lkXSkge1xuICAgICAgICBjYW5kaWRhdGVzW2luY2x1c2l2ZUtleV0udGltZSArPSBtZWFzdXJlbWVudC5pbmNsdXNpdmVbaWRdO1xuICAgICAgfVxuICAgICAgaWYgKG1lYXN1cmVtZW50LmNvdW50c1tpZF0pIHtcbiAgICAgICAgY2FuZGlkYXRlc1tpbmNsdXNpdmVLZXldLmNvdW50ICs9IG1lYXN1cmVtZW50LmNvdW50c1tpZF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gTm93IG1ha2UgYSBzb3J0ZWQgYXJyYXkgd2l0aCB0aGUgcmVzdWx0cy5cbiAgdmFyIGFyciA9IFtdO1xuICBmb3IgKGluY2x1c2l2ZUtleSBpbiBjYW5kaWRhdGVzKSB7XG4gICAgaWYgKGNhbmRpZGF0ZXNbaW5jbHVzaXZlS2V5XS50aW1lID49IERPTlRfQ0FSRV9USFJFU0hPTEQpIHtcbiAgICAgIGFyci5wdXNoKGNhbmRpZGF0ZXNbaW5jbHVzaXZlS2V5XSk7XG4gICAgfVxuICB9XG5cbiAgYXJyLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi50aW1lIC0gYS50aW1lO1xuICB9KTtcblxuICByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiBnZXRVbmNoYW5nZWRDb21wb25lbnRzKG1lYXN1cmVtZW50KSB7XG4gIC8vIEZvciBhIGdpdmVuIHJlY29uY2lsZSwgbG9vayBhdCB3aGljaCBjb21wb25lbnRzIGRpZCBub3QgYWN0dWFsbHlcbiAgLy8gcmVuZGVyIGFueXRoaW5nIHRvIHRoZSBET00gYW5kIHJldHVybiBhIG1hcHBpbmcgb2YgdGhlaXIgSUQgdG9cbiAgLy8gdGhlIGFtb3VudCBvZiB0aW1lIGl0IHRvb2sgdG8gcmVuZGVyIHRoZSBlbnRpcmUgc3VidHJlZS5cbiAgdmFyIGNsZWFuQ29tcG9uZW50cyA9IHt9O1xuICB2YXIgZGlydHlMZWFmSURzID0gT2JqZWN0LmtleXMobWVhc3VyZW1lbnQud3JpdGVzKTtcbiAgdmFyIGFsbElEcyA9IGFzc2lnbih7fSwgbWVhc3VyZW1lbnQuZXhjbHVzaXZlLCBtZWFzdXJlbWVudC5pbmNsdXNpdmUpO1xuXG4gIGZvciAodmFyIGlkIGluIGFsbElEcykge1xuICAgIHZhciBpc0RpcnR5ID0gZmFsc2U7XG4gICAgLy8gRm9yIGVhY2ggY29tcG9uZW50IHRoYXQgcmVuZGVyZWQsIHNlZSBpZiBhIGNvbXBvbmVudCB0aGF0IHRyaWdnZXJlZFxuICAgIC8vIGEgRE9NIG9wIGlzIGluIGl0cyBzdWJ0cmVlLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlydHlMZWFmSURzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZGlydHlMZWFmSURzW2ldLmluZGV4T2YoaWQpID09PSAwKSB7XG4gICAgICAgIGlzRGlydHkgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gY2hlY2sgaWYgY29tcG9uZW50IG5ld2x5IGNyZWF0ZWRcbiAgICBpZiAobWVhc3VyZW1lbnQuY3JlYXRlZFtpZF0pIHtcbiAgICAgIGlzRGlydHkgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWlzRGlydHkgJiYgbWVhc3VyZW1lbnQuY291bnRzW2lkXSA+IDApIHtcbiAgICAgIGNsZWFuQ29tcG9uZW50c1tpZF0gPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2xlYW5Db21wb25lbnRzO1xufVxuXG52YXIgUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzID0ge1xuICBnZXRFeGNsdXNpdmVTdW1tYXJ5OiBnZXRFeGNsdXNpdmVTdW1tYXJ5LFxuICBnZXRJbmNsdXNpdmVTdW1tYXJ5OiBnZXRJbmNsdXNpdmVTdW1tYXJ5LFxuICBnZXRET01TdW1tYXJ5OiBnZXRET01TdW1tYXJ5LFxuICBnZXRUb3RhbFRpbWU6IGdldFRvdGFsVGltZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXM7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgcGVyZm9ybWFuY2VOb3dcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGVyZm9ybWFuY2UgPSByZXF1aXJlKCcuL3BlcmZvcm1hbmNlJyk7XG5cbnZhciBwZXJmb3JtYW5jZU5vdztcblxuLyoqXG4gKiBEZXRlY3QgaWYgd2UgY2FuIHVzZSBgd2luZG93LnBlcmZvcm1hbmNlLm5vdygpYCBhbmQgZ3JhY2VmdWxseSBmYWxsYmFjayB0b1xuICogYERhdGUubm93KClgIGlmIGl0IGRvZXNuJ3QgZXhpc3QuIFdlIG5lZWQgdG8gc3VwcG9ydCBGaXJlZm94IDwgMTUgZm9yIG5vd1xuICogYmVjYXVzZSBvZiBGYWNlYm9vaydzIHRlc3RpbmcgaW5mcmFzdHJ1Y3R1cmUuXG4gKi9cbmlmIChwZXJmb3JtYW5jZS5ub3cpIHtcbiAgcGVyZm9ybWFuY2VOb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO1xuICB9O1xufSBlbHNlIHtcbiAgcGVyZm9ybWFuY2VOb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIERhdGUubm93KCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGVyZm9ybWFuY2VOb3c7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL3BlcmZvcm1hbmNlTm93LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHBlcmZvcm1hbmNlXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgcGVyZm9ybWFuY2U7XG5cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgcGVyZm9ybWFuY2UgPSB3aW5kb3cucGVyZm9ybWFuY2UgfHwgd2luZG93Lm1zUGVyZm9ybWFuY2UgfHwgd2luZG93LndlYmtpdFBlcmZvcm1hbmNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBlcmZvcm1hbmNlIHx8IHt9O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9wZXJmb3JtYW5jZS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFZlcnNpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gJzAuMTQuOCc7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFZlcnNpb24uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4qIEBwcm92aWRlc01vZHVsZSByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lclxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TW91bnQucmVuZGVyU3VidHJlZUludG9Db250YWluZXI7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lci5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVNlcnZlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RGVmYXVsdEluamVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3REZWZhdWx0SW5qZWN0aW9uJyk7XG52YXIgUmVhY3RTZXJ2ZXJSZW5kZXJpbmcgPSByZXF1aXJlKCcuL1JlYWN0U2VydmVyUmVuZGVyaW5nJyk7XG52YXIgUmVhY3RWZXJzaW9uID0gcmVxdWlyZSgnLi9SZWFjdFZlcnNpb24nKTtcblxuUmVhY3REZWZhdWx0SW5qZWN0aW9uLmluamVjdCgpO1xuXG52YXIgUmVhY3RET01TZXJ2ZXIgPSB7XG4gIHJlbmRlclRvU3RyaW5nOiBSZWFjdFNlcnZlclJlbmRlcmluZy5yZW5kZXJUb1N0cmluZyxcbiAgcmVuZGVyVG9TdGF0aWNNYXJrdXA6IFJlYWN0U2VydmVyUmVuZGVyaW5nLnJlbmRlclRvU3RhdGljTWFya3VwLFxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01TZXJ2ZXI7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTVNlcnZlci5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneSA9IHJlcXVpcmUoJy4vUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneScpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RJbnN0YW5jZUhhbmRsZXMgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VIYW5kbGVzJyk7XG52YXIgUmVhY3RNYXJrdXBDaGVja3N1bSA9IHJlcXVpcmUoJy4vUmVhY3RNYXJrdXBDaGVja3N1bScpO1xudmFyIFJlYWN0U2VydmVyQmF0Y2hpbmdTdHJhdGVneSA9IHJlcXVpcmUoJy4vUmVhY3RTZXJ2ZXJCYXRjaGluZ1N0cmF0ZWd5Jyk7XG52YXIgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbicpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBIVE1MIG1hcmt1cFxuICovXG5mdW5jdGlvbiByZW5kZXJUb1N0cmluZyhlbGVtZW50KSB7XG4gICFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncmVuZGVyVG9TdHJpbmcoKTogWW91IG11c3QgcGFzcyBhIHZhbGlkIFJlYWN0RWxlbWVudC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIHRyYW5zYWN0aW9uO1xuICB0cnkge1xuICAgIFJlYWN0VXBkYXRlcy5pbmplY3Rpb24uaW5qZWN0QmF0Y2hpbmdTdHJhdGVneShSZWFjdFNlcnZlckJhdGNoaW5nU3RyYXRlZ3kpO1xuXG4gICAgdmFyIGlkID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuY3JlYXRlUmVhY3RSb290SUQoKTtcbiAgICB0cmFuc2FjdGlvbiA9IFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKGZhbHNlKTtcblxuICAgIHJldHVybiB0cmFuc2FjdGlvbi5wZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQoZWxlbWVudCwgbnVsbCk7XG4gICAgICB2YXIgbWFya3VwID0gY29tcG9uZW50SW5zdGFuY2UubW91bnRDb21wb25lbnQoaWQsIHRyYW5zYWN0aW9uLCBlbXB0eU9iamVjdCk7XG4gICAgICByZXR1cm4gUmVhY3RNYXJrdXBDaGVja3N1bS5hZGRDaGVja3N1bVRvTWFya3VwKG1hcmt1cCk7XG4gICAgfSwgbnVsbCk7XG4gIH0gZmluYWxseSB7XG4gICAgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5yZWxlYXNlKHRyYW5zYWN0aW9uKTtcbiAgICAvLyBSZXZlcnQgdG8gdGhlIERPTSBiYXRjaGluZyBzdHJhdGVneSBzaW5jZSB0aGVzZSB0d28gcmVuZGVyZXJzXG4gICAgLy8gY3VycmVudGx5IHNoYXJlIHRoZXNlIHN0YXRlZnVsIG1vZHVsZXMuXG4gICAgUmVhY3RVcGRhdGVzLmluamVjdGlvbi5pbmplY3RCYXRjaGluZ1N0cmF0ZWd5KFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIEhUTUwgbWFya3VwLCB3aXRob3V0IHRoZSBleHRyYSBSZWFjdCBJRCBhbmQgY2hlY2tzdW1cbiAqIChmb3IgZ2VuZXJhdGluZyBzdGF0aWMgcGFnZXMpXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclRvU3RhdGljTWFya3VwKGVsZW1lbnQpIHtcbiAgIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdyZW5kZXJUb1N0YXRpY01hcmt1cCgpOiBZb3UgbXVzdCBwYXNzIGEgdmFsaWQgUmVhY3RFbGVtZW50LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICB2YXIgdHJhbnNhY3Rpb247XG4gIHRyeSB7XG4gICAgUmVhY3RVcGRhdGVzLmluamVjdGlvbi5pbmplY3RCYXRjaGluZ1N0cmF0ZWd5KFJlYWN0U2VydmVyQmF0Y2hpbmdTdHJhdGVneSk7XG5cbiAgICB2YXIgaWQgPSBSZWFjdEluc3RhbmNlSGFuZGxlcy5jcmVhdGVSZWFjdFJvb3RJRCgpO1xuICAgIHRyYW5zYWN0aW9uID0gUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5nZXRQb29sZWQodHJ1ZSk7XG5cbiAgICByZXR1cm4gdHJhbnNhY3Rpb24ucGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KGVsZW1lbnQsIG51bGwpO1xuICAgICAgcmV0dXJuIGNvbXBvbmVudEluc3RhbmNlLm1vdW50Q29tcG9uZW50KGlkLCB0cmFuc2FjdGlvbiwgZW1wdHlPYmplY3QpO1xuICAgIH0sIG51bGwpO1xuICB9IGZpbmFsbHkge1xuICAgIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24ucmVsZWFzZSh0cmFuc2FjdGlvbik7XG4gICAgLy8gUmV2ZXJ0IHRvIHRoZSBET00gYmF0Y2hpbmcgc3RyYXRlZ3kgc2luY2UgdGhlc2UgdHdvIHJlbmRlcmVyc1xuICAgIC8vIGN1cnJlbnRseSBzaGFyZSB0aGVzZSBzdGF0ZWZ1bCBtb2R1bGVzLlxuICAgIFJlYWN0VXBkYXRlcy5pbmplY3Rpb24uaW5qZWN0QmF0Y2hpbmdTdHJhdGVneShSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcmVuZGVyVG9TdHJpbmc6IHJlbmRlclRvU3RyaW5nLFxuICByZW5kZXJUb1N0YXRpY01hcmt1cDogcmVuZGVyVG9TdGF0aWNNYXJrdXBcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFNlcnZlclJlbmRlcmluZy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFNlcnZlckJhdGNoaW5nU3RyYXRlZ3lcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RTZXJ2ZXJCYXRjaGluZ1N0cmF0ZWd5ID0ge1xuICBpc0JhdGNoaW5nVXBkYXRlczogZmFsc2UsXG4gIGJhdGNoZWRVcGRhdGVzOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAvLyBEb24ndCBkbyBhbnl0aGluZyBoZXJlLiBEdXJpbmcgdGhlIHNlcnZlciByZW5kZXJpbmcgd2UgZG9uJ3Qgd2FudCB0b1xuICAgIC8vIHNjaGVkdWxlIGFueSB1cGRhdGVzLiBXZSB3aWxsIHNpbXBseSBpZ25vcmUgdGhlbS5cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFNlcnZlckJhdGNoaW5nU3RyYXRlZ3k7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFNlcnZlckJhdGNoaW5nU3RyYXRlZ3kuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvblxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcbnZhciBDYWxsYmFja1F1ZXVlID0gcmVxdWlyZSgnLi9DYWxsYmFja1F1ZXVlJyk7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1RyYW5zYWN0aW9uJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgYENhbGxiYWNrUXVldWVgIHF1ZXVlIGZvciBjb2xsZWN0aW5nIGBvbkRPTVJlYWR5YCBjYWxsYmFja3NcbiAqIGR1cmluZyB0aGUgcGVyZm9ybWluZyBvZiB0aGUgdHJhbnNhY3Rpb24uXG4gKi9cbnZhciBPTl9ET01fUkVBRFlfUVVFVUVJTkcgPSB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgaW50ZXJuYWwgYG9uRE9NUmVhZHlgIHF1ZXVlLlxuICAgKi9cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5LnJlc2V0KCk7XG4gIH0sXG5cbiAgY2xvc2U6IGVtcHR5RnVuY3Rpb25cbn07XG5cbi8qKlxuICogRXhlY3V0ZWQgd2l0aGluIHRoZSBzY29wZSBvZiB0aGUgYFRyYW5zYWN0aW9uYCBpbnN0YW5jZS4gQ29uc2lkZXIgdGhlc2UgYXNcbiAqIGJlaW5nIG1lbWJlciBtZXRob2RzLCBidXQgd2l0aCBhbiBpbXBsaWVkIG9yZGVyaW5nIHdoaWxlIGJlaW5nIGlzb2xhdGVkIGZyb21cbiAqIGVhY2ggb3RoZXIuXG4gKi9cbnZhciBUUkFOU0FDVElPTl9XUkFQUEVSUyA9IFtPTl9ET01fUkVBRFlfUVVFVUVJTkddO1xuXG4vKipcbiAqIEBjbGFzcyBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHJlbmRlclRvU3RhdGljTWFya3VwXG4gKi9cbmZ1bmN0aW9uIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24ocmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xuICB0aGlzLnJlbmRlclRvU3RhdGljTWFya3VwID0gcmVuZGVyVG9TdGF0aWNNYXJrdXA7XG4gIHRoaXMucmVhY3RNb3VudFJlYWR5ID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQobnVsbCk7XG4gIHRoaXMudXNlQ3JlYXRlRWxlbWVudCA9IGZhbHNlO1xufVxuXG52YXIgTWl4aW4gPSB7XG4gIC8qKlxuICAgKiBAc2VlIFRyYW5zYWN0aW9uXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAZmluYWxcbiAgICogQHJldHVybiB7YXJyYXl9IEVtcHR5IGxpc3Qgb2Ygb3BlcmF0aW9uIHdyYXAgcHJvY2VkdXJlcy5cbiAgICovXG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVFJBTlNBQ1RJT05fV1JBUFBFUlM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHF1ZXVlIHRvIGNvbGxlY3QgYG9uRE9NUmVhZHlgIGNhbGxiYWNrcyB3aXRoLlxuICAgKi9cbiAgZ2V0UmVhY3RNb3VudFJlYWR5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhY3RNb3VudFJlYWR5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciB0aGlzLCBhbmQgd2lsbCBpbnZva2UgdGhpcyBiZWZvcmUgYWxsb3dpbmcgdGhpc1xuICAgKiBpbnN0YW5jZSB0byBiZSByZXVzZWQuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgQ2FsbGJhY2tRdWV1ZS5yZWxlYXNlKHRoaXMucmVhY3RNb3VudFJlYWR5KTtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeSA9IG51bGw7XG4gIH1cbn07XG5cbmFzc2lnbihSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLnByb3RvdHlwZSwgVHJhbnNhY3Rpb24uTWl4aW4sIE1peGluKTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb247XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0SXNvbW9ycGhpY1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q2hpbGRyZW4gPSByZXF1aXJlKCcuL1JlYWN0Q2hpbGRyZW4nKTtcbnZhciBSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnQnKTtcbnZhciBSZWFjdENsYXNzID0gcmVxdWlyZSgnLi9SZWFjdENsYXNzJyk7XG52YXIgUmVhY3RET01GYWN0b3JpZXMgPSByZXF1aXJlKCcuL1JlYWN0RE9NRmFjdG9yaWVzJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudFZhbGlkYXRvcicpO1xudmFyIFJlYWN0UHJvcFR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlcycpO1xudmFyIFJlYWN0VmVyc2lvbiA9IHJlcXVpcmUoJy4vUmVhY3RWZXJzaW9uJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBvbmx5Q2hpbGQgPSByZXF1aXJlKCcuL29ubHlDaGlsZCcpO1xuXG52YXIgY3JlYXRlRWxlbWVudCA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50O1xudmFyIGNyZWF0ZUZhY3RvcnkgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeTtcbnZhciBjbG9uZUVsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY2xvbmVFbGVtZW50O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBjcmVhdGVFbGVtZW50ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUVsZW1lbnQ7XG4gIGNyZWF0ZUZhY3RvcnkgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRmFjdG9yeTtcbiAgY2xvbmVFbGVtZW50ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNsb25lRWxlbWVudDtcbn1cblxudmFyIFJlYWN0ID0ge1xuXG4gIC8vIE1vZGVyblxuXG4gIENoaWxkcmVuOiB7XG4gICAgbWFwOiBSZWFjdENoaWxkcmVuLm1hcCxcbiAgICBmb3JFYWNoOiBSZWFjdENoaWxkcmVuLmZvckVhY2gsXG4gICAgY291bnQ6IFJlYWN0Q2hpbGRyZW4uY291bnQsXG4gICAgdG9BcnJheTogUmVhY3RDaGlsZHJlbi50b0FycmF5LFxuICAgIG9ubHk6IG9ubHlDaGlsZFxuICB9LFxuXG4gIENvbXBvbmVudDogUmVhY3RDb21wb25lbnQsXG5cbiAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCxcbiAgY2xvbmVFbGVtZW50OiBjbG9uZUVsZW1lbnQsXG4gIGlzVmFsaWRFbGVtZW50OiBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQsXG5cbiAgLy8gQ2xhc3NpY1xuXG4gIFByb3BUeXBlczogUmVhY3RQcm9wVHlwZXMsXG4gIGNyZWF0ZUNsYXNzOiBSZWFjdENsYXNzLmNyZWF0ZUNsYXNzLFxuICBjcmVhdGVGYWN0b3J5OiBjcmVhdGVGYWN0b3J5LFxuICBjcmVhdGVNaXhpbjogZnVuY3Rpb24gKG1peGluKSB7XG4gICAgLy8gQ3VycmVudGx5IGEgbm9vcC4gV2lsbCBiZSB1c2VkIHRvIHZhbGlkYXRlIGFuZCB0cmFjZSBtaXhpbnMuXG4gICAgcmV0dXJuIG1peGluO1xuICB9LFxuXG4gIC8vIFRoaXMgbG9va3MgRE9NIHNwZWNpZmljIGJ1dCB0aGVzZSBhcmUgYWN0dWFsbHkgaXNvbW9ycGhpYyBoZWxwZXJzXG4gIC8vIHNpbmNlIHRoZXkgYXJlIGp1c3QgZ2VuZXJhdGluZyBET00gc3RyaW5ncy5cbiAgRE9NOiBSZWFjdERPTUZhY3RvcmllcyxcblxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXG5cbiAgLy8gSG9vayBmb3IgSlNYIHNwcmVhZCwgZG9uJ3QgdXNlIHRoaXMgZm9yIGFueXRoaW5nIGVsc2UuXG4gIF9fc3ByZWFkOiBhc3NpZ25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3Q7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdElzb21vcnBoaWMuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01GYWN0b3JpZXNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudFZhbGlkYXRvcicpO1xuXG52YXIgbWFwT2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvbWFwT2JqZWN0Jyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgZmFjdG9yeSB0aGF0IGNyZWF0ZXMgSFRNTCB0YWcgZWxlbWVudHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUYWcgbmFtZSAoZS5nLiBgZGl2YCkuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVET01GYWN0b3J5KHRhZykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHJldHVybiBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRmFjdG9yeSh0YWcpO1xuICB9XG4gIHJldHVybiBSZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeSh0YWcpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXBwaW5nIGZyb20gc3VwcG9ydGVkIEhUTUwgdGFncyB0byBgUmVhY3RET01Db21wb25lbnRgIGNsYXNzZXMuXG4gKiBUaGlzIGlzIGFsc28gYWNjZXNzaWJsZSB2aWEgYFJlYWN0LkRPTWAuXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgUmVhY3RET01GYWN0b3JpZXMgPSBtYXBPYmplY3Qoe1xuICBhOiAnYScsXG4gIGFiYnI6ICdhYmJyJyxcbiAgYWRkcmVzczogJ2FkZHJlc3MnLFxuICBhcmVhOiAnYXJlYScsXG4gIGFydGljbGU6ICdhcnRpY2xlJyxcbiAgYXNpZGU6ICdhc2lkZScsXG4gIGF1ZGlvOiAnYXVkaW8nLFxuICBiOiAnYicsXG4gIGJhc2U6ICdiYXNlJyxcbiAgYmRpOiAnYmRpJyxcbiAgYmRvOiAnYmRvJyxcbiAgYmlnOiAnYmlnJyxcbiAgYmxvY2txdW90ZTogJ2Jsb2NrcXVvdGUnLFxuICBib2R5OiAnYm9keScsXG4gIGJyOiAnYnInLFxuICBidXR0b246ICdidXR0b24nLFxuICBjYW52YXM6ICdjYW52YXMnLFxuICBjYXB0aW9uOiAnY2FwdGlvbicsXG4gIGNpdGU6ICdjaXRlJyxcbiAgY29kZTogJ2NvZGUnLFxuICBjb2w6ICdjb2wnLFxuICBjb2xncm91cDogJ2NvbGdyb3VwJyxcbiAgZGF0YTogJ2RhdGEnLFxuICBkYXRhbGlzdDogJ2RhdGFsaXN0JyxcbiAgZGQ6ICdkZCcsXG4gIGRlbDogJ2RlbCcsXG4gIGRldGFpbHM6ICdkZXRhaWxzJyxcbiAgZGZuOiAnZGZuJyxcbiAgZGlhbG9nOiAnZGlhbG9nJyxcbiAgZGl2OiAnZGl2JyxcbiAgZGw6ICdkbCcsXG4gIGR0OiAnZHQnLFxuICBlbTogJ2VtJyxcbiAgZW1iZWQ6ICdlbWJlZCcsXG4gIGZpZWxkc2V0OiAnZmllbGRzZXQnLFxuICBmaWdjYXB0aW9uOiAnZmlnY2FwdGlvbicsXG4gIGZpZ3VyZTogJ2ZpZ3VyZScsXG4gIGZvb3RlcjogJ2Zvb3RlcicsXG4gIGZvcm06ICdmb3JtJyxcbiAgaDE6ICdoMScsXG4gIGgyOiAnaDInLFxuICBoMzogJ2gzJyxcbiAgaDQ6ICdoNCcsXG4gIGg1OiAnaDUnLFxuICBoNjogJ2g2JyxcbiAgaGVhZDogJ2hlYWQnLFxuICBoZWFkZXI6ICdoZWFkZXInLFxuICBoZ3JvdXA6ICdoZ3JvdXAnLFxuICBocjogJ2hyJyxcbiAgaHRtbDogJ2h0bWwnLFxuICBpOiAnaScsXG4gIGlmcmFtZTogJ2lmcmFtZScsXG4gIGltZzogJ2ltZycsXG4gIGlucHV0OiAnaW5wdXQnLFxuICBpbnM6ICdpbnMnLFxuICBrYmQ6ICdrYmQnLFxuICBrZXlnZW46ICdrZXlnZW4nLFxuICBsYWJlbDogJ2xhYmVsJyxcbiAgbGVnZW5kOiAnbGVnZW5kJyxcbiAgbGk6ICdsaScsXG4gIGxpbms6ICdsaW5rJyxcbiAgbWFpbjogJ21haW4nLFxuICBtYXA6ICdtYXAnLFxuICBtYXJrOiAnbWFyaycsXG4gIG1lbnU6ICdtZW51JyxcbiAgbWVudWl0ZW06ICdtZW51aXRlbScsXG4gIG1ldGE6ICdtZXRhJyxcbiAgbWV0ZXI6ICdtZXRlcicsXG4gIG5hdjogJ25hdicsXG4gIG5vc2NyaXB0OiAnbm9zY3JpcHQnLFxuICBvYmplY3Q6ICdvYmplY3QnLFxuICBvbDogJ29sJyxcbiAgb3B0Z3JvdXA6ICdvcHRncm91cCcsXG4gIG9wdGlvbjogJ29wdGlvbicsXG4gIG91dHB1dDogJ291dHB1dCcsXG4gIHA6ICdwJyxcbiAgcGFyYW06ICdwYXJhbScsXG4gIHBpY3R1cmU6ICdwaWN0dXJlJyxcbiAgcHJlOiAncHJlJyxcbiAgcHJvZ3Jlc3M6ICdwcm9ncmVzcycsXG4gIHE6ICdxJyxcbiAgcnA6ICdycCcsXG4gIHJ0OiAncnQnLFxuICBydWJ5OiAncnVieScsXG4gIHM6ICdzJyxcbiAgc2FtcDogJ3NhbXAnLFxuICBzY3JpcHQ6ICdzY3JpcHQnLFxuICBzZWN0aW9uOiAnc2VjdGlvbicsXG4gIHNlbGVjdDogJ3NlbGVjdCcsXG4gIHNtYWxsOiAnc21hbGwnLFxuICBzb3VyY2U6ICdzb3VyY2UnLFxuICBzcGFuOiAnc3BhbicsXG4gIHN0cm9uZzogJ3N0cm9uZycsXG4gIHN0eWxlOiAnc3R5bGUnLFxuICBzdWI6ICdzdWInLFxuICBzdW1tYXJ5OiAnc3VtbWFyeScsXG4gIHN1cDogJ3N1cCcsXG4gIHRhYmxlOiAndGFibGUnLFxuICB0Ym9keTogJ3Rib2R5JyxcbiAgdGQ6ICd0ZCcsXG4gIHRleHRhcmVhOiAndGV4dGFyZWEnLFxuICB0Zm9vdDogJ3Rmb290JyxcbiAgdGg6ICd0aCcsXG4gIHRoZWFkOiAndGhlYWQnLFxuICB0aW1lOiAndGltZScsXG4gIHRpdGxlOiAndGl0bGUnLFxuICB0cjogJ3RyJyxcbiAgdHJhY2s6ICd0cmFjaycsXG4gIHU6ICd1JyxcbiAgdWw6ICd1bCcsXG4gICd2YXInOiAndmFyJyxcbiAgdmlkZW86ICd2aWRlbycsXG4gIHdicjogJ3dicicsXG5cbiAgLy8gU1ZHXG4gIGNpcmNsZTogJ2NpcmNsZScsXG4gIGNsaXBQYXRoOiAnY2xpcFBhdGgnLFxuICBkZWZzOiAnZGVmcycsXG4gIGVsbGlwc2U6ICdlbGxpcHNlJyxcbiAgZzogJ2cnLFxuICBpbWFnZTogJ2ltYWdlJyxcbiAgbGluZTogJ2xpbmUnLFxuICBsaW5lYXJHcmFkaWVudDogJ2xpbmVhckdyYWRpZW50JyxcbiAgbWFzazogJ21hc2snLFxuICBwYXRoOiAncGF0aCcsXG4gIHBhdHRlcm46ICdwYXR0ZXJuJyxcbiAgcG9seWdvbjogJ3BvbHlnb24nLFxuICBwb2x5bGluZTogJ3BvbHlsaW5lJyxcbiAgcmFkaWFsR3JhZGllbnQ6ICdyYWRpYWxHcmFkaWVudCcsXG4gIHJlY3Q6ICdyZWN0JyxcbiAgc3RvcDogJ3N0b3AnLFxuICBzdmc6ICdzdmcnLFxuICB0ZXh0OiAndGV4dCcsXG4gIHRzcGFuOiAndHNwYW4nXG5cbn0sIGNyZWF0ZURPTUZhY3RvcnkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NRmFjdG9yaWVzO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01GYWN0b3JpZXMuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFbGVtZW50VmFsaWRhdG9yXG4gKi9cblxuLyoqXG4gKiBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgcHJvdmlkZXMgYSB3cmFwcGVyIGFyb3VuZCBhIGVsZW1lbnQgZmFjdG9yeVxuICogd2hpY2ggdmFsaWRhdGVzIHRoZSBwcm9wcyBwYXNzZWQgdG8gdGhlIGVsZW1lbnQuIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmVcbiAqIHVzZWQgb25seSBpbiBERVYgYW5kIGNvdWxkIGJlIHJlcGxhY2VkIGJ5IGEgc3RhdGljIHR5cGUgY2hlY2tlciBmb3IgbGFuZ3VhZ2VzXG4gKiB0aGF0IHN1cHBvcnQgaXQuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25zID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25zJyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzJyk7XG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG5cbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vY2FuRGVmaW5lUHJvcGVydHknKTtcbnZhciBnZXRJdGVyYXRvckZuID0gcmVxdWlyZSgnLi9nZXRJdGVyYXRvckZuJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIHZhciBuYW1lID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuXG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcblxuICB2YXIgYWRkZW5kYSA9IGdldEFkZGVuZGFGb3JLZXlVc2UoJ3VuaXF1ZUtleScsIGVsZW1lbnQsIHBhcmVudFR5cGUpO1xuICBpZiAoYWRkZW5kYSA9PT0gbnVsbCkge1xuICAgIC8vIHdlIGFscmVhZHkgc2hvd2VkIHRoZSB3YXJuaW5nXG4gICAgcmV0dXJuO1xuICB9XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzJXMnLCBhZGRlbmRhLnBhcmVudE9yT3duZXIgfHwgJycsIGFkZGVuZGEuY2hpbGRPd25lciB8fCAnJywgYWRkZW5kYS51cmwgfHwgJycpIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFNoYXJlZCB3YXJuaW5nIGFuZCBtb25pdG9yaW5nIGNvZGUgZm9yIHRoZSBrZXkgd2FybmluZ3MuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVR5cGUgQSBrZXkgdXNlZCBmb3IgZGUtZHVwaW5nIHdhcm5pbmdzLlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgQ29tcG9uZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKiBAcmV0dXJucyB7P29iamVjdH0gQSBzZXQgb2YgYWRkZW5kYSB0byB1c2UgaW4gdGhlIHdhcm5pbmcgbWVzc2FnZSwgb3IgbnVsbFxuICogaWYgdGhlIHdhcm5pbmcgaGFzIGFscmVhZHkgYmVlbiBzaG93biBiZWZvcmUgKGFuZCBzaG91bGRuJ3QgYmUgc2hvd24gYWdhaW4pLlxuICovXG5mdW5jdGlvbiBnZXRBZGRlbmRhRm9yS2V5VXNlKG1lc3NhZ2VUeXBlLCBlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIHZhciBhZGRlbmR1bSA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICBpZiAoIWFkZGVuZHVtKSB7XG4gICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG4gICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgIGFkZGVuZHVtID0gJyBDaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDwnICsgcGFyZW50TmFtZSArICc+Lic7XG4gICAgfVxuICB9XG5cbiAgdmFyIG1lbW9pemVyID0gb3duZXJIYXNLZXlVc2VXYXJuaW5nW21lc3NhZ2VUeXBlXSB8fCAob3duZXJIYXNLZXlVc2VXYXJuaW5nW21lc3NhZ2VUeXBlXSA9IHt9KTtcbiAgaWYgKG1lbW9pemVyW2FkZGVuZHVtXSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIG1lbW9pemVyW2FkZGVuZHVtXSA9IHRydWU7XG5cbiAgdmFyIGFkZGVuZGEgPSB7XG4gICAgcGFyZW50T3JPd25lcjogYWRkZW5kdW0sXG4gICAgdXJsOiAnIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLFxuICAgIGNoaWxkT3duZXI6IG51bGxcbiAgfTtcblxuICAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICBhZGRlbmRhLmNoaWxkT3duZXIgPSAnIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tICcgKyBlbGVtZW50Ll9vd25lci5nZXROYW1lKCkgKyAnLic7XG4gIH1cblxuICByZXR1cm4gYWRkZW5kYTtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcbiAgICAgIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcbiAgICAvLyBFbnRyeSBpdGVyYXRvcnMgcHJvdmlkZSBpbXBsaWNpdCBrZXlzLlxuICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBwcm9wcyBhcmUgdmFsaWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHtvYmplY3R9IHByb3BUeXBlcyBNYXAgb2YgcHJvcCBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyhjb21wb25lbnROYW1lLCBwcm9wVHlwZXMsIHByb3BzLCBsb2NhdGlvbikge1xuICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wVHlwZXMpIHtcbiAgICBpZiAocHJvcFR5cGVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgdmFyIGVycm9yO1xuICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICEodHlwZW9mIHByb3BUeXBlc1twcm9wTmFtZV0gPT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gJyArICdSZWFjdC5Qcm9wVHlwZXMuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHByb3BOYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGVycm9yID0gcHJvcFR5cGVzW3Byb3BOYW1lXShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGVycm9yID0gZXg7XG4gICAgICB9XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghZXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciwgJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCBwcm9wTmFtZSwgdHlwZW9mIGVycm9yKSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgIHZhciBhZGRlbmR1bSA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ZhaWxlZCBwcm9wVHlwZTogJXMlcycsIGVycm9yLm1lc3NhZ2UsIGFkZGVuZHVtKSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB2YXIgY29tcG9uZW50Q2xhc3MgPSBlbGVtZW50LnR5cGU7XG4gIGlmICh0eXBlb2YgY29tcG9uZW50Q2xhc3MgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5hbWUgPSBjb21wb25lbnRDbGFzcy5kaXNwbGF5TmFtZSB8fCBjb21wb25lbnRDbGFzcy5uYW1lO1xuICBpZiAoY29tcG9uZW50Q2xhc3MucHJvcFR5cGVzKSB7XG4gICAgY2hlY2tQcm9wVHlwZXMobmFtZSwgY29tcG9uZW50Q2xhc3MucHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLnByb3ApO1xuICB9XG4gIGlmICh0eXBlb2YgY29tcG9uZW50Q2xhc3MuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoY29tcG9uZW50Q2xhc3MuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpIDogdW5kZWZpbmVkO1xuICB9XG59XG5cbnZhciBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgPSB7XG5cbiAgY3JlYXRlRWxlbWVudDogZnVuY3Rpb24gKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICAgIHZhciB2YWxpZFR5cGUgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbic7XG4gICAgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHZhbGlkVHlwZSwgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQ6IHR5cGUgc2hvdWxkIG5vdCBiZSBudWxsLCB1bmRlZmluZWQsIGJvb2xlYW4sIG9yICcgKyAnbnVtYmVyLiBJdCBzaG91bGQgYmUgYSBzdHJpbmcgKGZvciBET00gZWxlbWVudHMpIG9yIGEgUmVhY3RDbGFzcyAnICsgJyhmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpLiVzJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkpIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuICAgIGlmICh2YWxpZFR5cGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfSxcblxuICBjcmVhdGVGYWN0b3J5OiBmdW5jdGlvbiAodHlwZSkge1xuICAgIHZhciB2YWxpZGF0ZWRGYWN0b3J5ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUVsZW1lbnQuYmluZChudWxsLCB0eXBlKTtcbiAgICAvLyBMZWdhY3kgaG9vayBUT0RPOiBXYXJuIGlmIHRoaXMgaXMgYWNjZXNzZWRcbiAgICB2YWxpZGF0ZWRGYWN0b3J5LnR5cGUgPSB0eXBlO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChjYW5EZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRhdGVkRmFjdG9yeSwgJ3R5cGUnLCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ZhY3RvcnkudHlwZSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdGhlIGNsYXNzIGRpcmVjdGx5ICcgKyAnYmVmb3JlIHBhc3NpbmcgaXQgdG8gY3JlYXRlRmFjdG9yeS4nKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndHlwZScsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHR5cGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsaWRhdGVkRmFjdG9yeTtcbiAgfSxcblxuICBjbG9uZUVsZW1lbnQ6IGZ1bmN0aW9uIChlbGVtZW50LCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudC5jbG9uZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCBuZXdFbGVtZW50LnR5cGUpO1xuICAgIH1cbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhuZXdFbGVtZW50KTtcbiAgICByZXR1cm4gbmV3RWxlbWVudDtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RWxlbWVudFZhbGlkYXRvcjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RWxlbWVudFZhbGlkYXRvci5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBtYXBPYmplY3RcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogRXhlY3V0ZXMgdGhlIHByb3ZpZGVkIGBjYWxsYmFja2Agb25jZSBmb3IgZWFjaCBlbnVtZXJhYmxlIG93biBwcm9wZXJ0eSBpbiB0aGVcbiAqIG9iamVjdCBhbmQgY29uc3RydWN0cyBhIG5ldyBvYmplY3QgZnJvbSB0aGUgcmVzdWx0cy4gVGhlIGBjYWxsYmFja2AgaXNcbiAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gKlxuICogIC0gdGhlIHByb3BlcnR5IHZhbHVlXG4gKiAgLSB0aGUgcHJvcGVydHkgbmFtZVxuICogIC0gdGhlIG9iamVjdCBiZWluZyB0cmF2ZXJzZWRcbiAqXG4gKiBQcm9wZXJ0aWVzIHRoYXQgYXJlIGFkZGVkIGFmdGVyIHRoZSBjYWxsIHRvIGBtYXBPYmplY3RgIHdpbGwgbm90IGJlIHZpc2l0ZWRcbiAqIGJ5IGBjYWxsYmFja2AuIElmIHRoZSB2YWx1ZXMgb2YgZXhpc3RpbmcgcHJvcGVydGllcyBhcmUgY2hhbmdlZCwgdGhlIHZhbHVlXG4gKiBwYXNzZWQgdG8gYGNhbGxiYWNrYCB3aWxsIGJlIHRoZSB2YWx1ZSBhdCB0aGUgdGltZSBgbWFwT2JqZWN0YCB2aXNpdHMgdGhlbS5cbiAqIFByb3BlcnRpZXMgdGhhdCBhcmUgZGVsZXRlZCBiZWZvcmUgYmVpbmcgdmlzaXRlZCBhcmUgbm90IHZpc2l0ZWQuXG4gKlxuICogQGdyZXAgZnVuY3Rpb24gb2JqZWN0TWFwKClcbiAqIEBncmVwIGZ1bmN0aW9uIG9iak1hcCgpXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IGNvbnRleHRcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIG1hcE9iamVjdChvYmplY3QsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gIGlmICghb2JqZWN0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmb3IgKHZhciBuYW1lIGluIG9iamVjdCkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgbmFtZSkpIHtcbiAgICAgIHJlc3VsdFtuYW1lXSA9IGNhbGxiYWNrLmNhbGwoY29udGV4dCwgb2JqZWN0W25hbWVdLCBuYW1lLCBvYmplY3QpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcE9iamVjdDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvbWFwT2JqZWN0LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIG9ubHlDaGlsZFxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgY2hpbGQgaW4gYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuIGFuZCB2ZXJpZmllcyB0aGF0IHRoZXJlXG4gKiBpcyBvbmx5IG9uZSBjaGlsZCBpbiB0aGUgY29sbGVjdGlvbi4gVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gb2YgdGhpc1xuICogZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGEgc2luZ2xlIGNoaWxkIGdldHMgcGFzc2VkIHdpdGhvdXQgYSB3cmFwcGVyLCBidXQgdGhlXG4gKiBwdXJwb3NlIG9mIHRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHRvIGFic3RyYWN0IGF3YXkgdGhlIHBhcnRpY3VsYXIgc3RydWN0dXJlXG4gKiBvZiBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGNoaWxkcmVuIENoaWxkIGNvbGxlY3Rpb24gc3RydWN0dXJlLlxuICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IFRoZSBmaXJzdCBhbmQgb25seSBgUmVhY3RDb21wb25lbnRgIGNvbnRhaW5lZCBpbiB0aGVcbiAqIHN0cnVjdHVyZS5cbiAqL1xuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gICFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ29ubHlDaGlsZCBtdXN0IGJlIHBhc3NlZCBhIGNoaWxkcmVuIHdpdGggZXhhY3RseSBvbmUgY2hpbGQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb25seUNoaWxkO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvb25seUNoaWxkLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGRlcHJlY2F0ZWRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIFRoaXMgd2lsbCBsb2cgYSBzaW5nbGUgZGVwcmVjYXRpb24gbm90aWNlIHBlciBmdW5jdGlvbiBhbmQgZm9yd2FyZCB0aGUgY2FsbFxuICogb24gdG8gdGhlIG5ldyBBUEkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZuTmFtZSBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXdNb2R1bGUgVGhlIG1vZHVsZSB0aGF0IGZuIHdpbGwgZXhpc3QgaW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXdQYWNrYWdlIFRoZSBtb2R1bGUgdGhhdCBmbiB3aWxsIGV4aXN0IGluXG4gKiBAcGFyYW0geyp9IGN0eCBUaGUgY29udGV4dCB0aGlzIGZvcndhcmRlZCBjYWxsIHNob3VsZCBydW4gaW5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBmb3J3YXJkIG9uIHRvXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCB3YXJuIG9uY2UgYW5kIHRoZW4gY2FsbCBmblxuICovXG5mdW5jdGlvbiBkZXByZWNhdGVkKGZuTmFtZSwgbmV3TW9kdWxlLCBuZXdQYWNrYWdlLCBjdHgsIGZuKSB7XG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgbmV3Rm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh3YXJuZWQsXG4gICAgICAvLyBSZXF1aXJlIGV4YW1wbGVzIGluIHRoaXMgc3RyaW5nIG11c3QgYmUgc3BsaXQgdG8gcHJldmVudCBSZWFjdCdzXG4gICAgICAvLyBidWlsZCB0b29scyBmcm9tIG1pc3Rha2luZyB0aGVtIGZvciByZWFsIHJlcXVpcmVzLlxuICAgICAgLy8gT3RoZXJ3aXNlIHRoZSBidWlsZCB0b29scyB3aWxsIGF0dGVtcHQgdG8gYnVpbGQgYSAnJXMnIG1vZHVsZS5cbiAgICAgICdSZWFjdC4lcyBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlICVzLiVzIGZyb20gcmVxdWlyZScgKyAnKFxcJyVzXFwnKSAnICsgJ2luc3RlYWQuJywgZm5OYW1lLCBuZXdNb2R1bGUsIGZuTmFtZSwgbmV3UGFja2FnZSkgOiB1bmRlZmluZWQ7XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIC8vIFdlIG5lZWQgdG8gbWFrZSBzdXJlIGFsbCBwcm9wZXJ0aWVzIG9mIHRoZSBvcmlnaW5hbCBmbiBhcmUgY29waWVkIG92ZXIuXG4gICAgLy8gSW4gcGFydGljdWxhciwgdGhpcyBpcyBuZWVkZWQgdG8gc3VwcG9ydCBQcm9wVHlwZXNcbiAgICByZXR1cm4gYXNzaWduKG5ld0ZuLCBmbik7XG4gIH1cblxuICByZXR1cm4gZm47XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlZDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL2RlcHJlY2F0ZWQuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0RE9NJyk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QtZG9tL2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5jcmVhdGVNZW1vcnlIaXN0b3J5ID0gZXhwb3J0cy5oYXNoSGlzdG9yeSA9IGV4cG9ydHMuYnJvd3Nlckhpc3RvcnkgPSBleHBvcnRzLmFwcGx5Um91dGVyTWlkZGxld2FyZSA9IGV4cG9ydHMuZm9ybWF0UGF0dGVybiA9IGV4cG9ydHMudXNlUm91dGVySGlzdG9yeSA9IGV4cG9ydHMubWF0Y2ggPSBleHBvcnRzLnJvdXRlclNoYXBlID0gZXhwb3J0cy5sb2NhdGlvblNoYXBlID0gZXhwb3J0cy5Qcm9wVHlwZXMgPSBleHBvcnRzLlJvdXRpbmdDb250ZXh0ID0gZXhwb3J0cy5Sb3V0ZXJDb250ZXh0ID0gZXhwb3J0cy5jcmVhdGVSb3V0ZXMgPSBleHBvcnRzLnVzZVJvdXRlcyA9IGV4cG9ydHMuUm91dGVDb250ZXh0ID0gZXhwb3J0cy5MaWZlY3ljbGUgPSBleHBvcnRzLkhpc3RvcnkgPSBleHBvcnRzLlJvdXRlID0gZXhwb3J0cy5SZWRpcmVjdCA9IGV4cG9ydHMuSW5kZXhSb3V0ZSA9IGV4cG9ydHMuSW5kZXhSZWRpcmVjdCA9IGV4cG9ydHMud2l0aFJvdXRlciA9IGV4cG9ydHMuSW5kZXhMaW5rID0gZXhwb3J0cy5MaW5rID0gZXhwb3J0cy5Sb3V0ZXIgPSB1bmRlZmluZWQ7XG5cbnZhciBfUm91dGVVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVVdGlscycpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2NyZWF0ZVJvdXRlcycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9Sb3V0ZVV0aWxzLmNyZWF0ZVJvdXRlcztcbiAgfVxufSk7XG5cbnZhciBfUHJvcFR5cGVzMiA9IHJlcXVpcmUoJy4vUHJvcFR5cGVzJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnbG9jYXRpb25TaGFwZScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9Qcm9wVHlwZXMyLmxvY2F0aW9uU2hhcGU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdyb3V0ZXJTaGFwZScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9Qcm9wVHlwZXMyLnJvdXRlclNoYXBlO1xuICB9XG59KTtcblxudmFyIF9QYXR0ZXJuVXRpbHMgPSByZXF1aXJlKCcuL1BhdHRlcm5VdGlscycpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2Zvcm1hdFBhdHRlcm4nLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfUGF0dGVyblV0aWxzLmZvcm1hdFBhdHRlcm47XG4gIH1cbn0pO1xuXG52YXIgX1JvdXRlcjIgPSByZXF1aXJlKCcuL1JvdXRlcicpO1xuXG52YXIgX1JvdXRlcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Sb3V0ZXIyKTtcblxudmFyIF9MaW5rMiA9IHJlcXVpcmUoJy4vTGluaycpO1xuXG52YXIgX0xpbmszID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTGluazIpO1xuXG52YXIgX0luZGV4TGluazIgPSByZXF1aXJlKCcuL0luZGV4TGluaycpO1xuXG52YXIgX0luZGV4TGluazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9JbmRleExpbmsyKTtcblxudmFyIF93aXRoUm91dGVyMiA9IHJlcXVpcmUoJy4vd2l0aFJvdXRlcicpO1xuXG52YXIgX3dpdGhSb3V0ZXIzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2l0aFJvdXRlcjIpO1xuXG52YXIgX0luZGV4UmVkaXJlY3QyID0gcmVxdWlyZSgnLi9JbmRleFJlZGlyZWN0Jyk7XG5cbnZhciBfSW5kZXhSZWRpcmVjdDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9JbmRleFJlZGlyZWN0Mik7XG5cbnZhciBfSW5kZXhSb3V0ZTIgPSByZXF1aXJlKCcuL0luZGV4Um91dGUnKTtcblxudmFyIF9JbmRleFJvdXRlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0luZGV4Um91dGUyKTtcblxudmFyIF9SZWRpcmVjdDIgPSByZXF1aXJlKCcuL1JlZGlyZWN0Jyk7XG5cbnZhciBfUmVkaXJlY3QzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUmVkaXJlY3QyKTtcblxudmFyIF9Sb3V0ZTIgPSByZXF1aXJlKCcuL1JvdXRlJyk7XG5cbnZhciBfUm91dGUzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUm91dGUyKTtcblxudmFyIF9IaXN0b3J5MiA9IHJlcXVpcmUoJy4vSGlzdG9yeScpO1xuXG52YXIgX0hpc3RvcnkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSGlzdG9yeTIpO1xuXG52YXIgX0xpZmVjeWNsZTIgPSByZXF1aXJlKCcuL0xpZmVjeWNsZScpO1xuXG52YXIgX0xpZmVjeWNsZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9MaWZlY3ljbGUyKTtcblxudmFyIF9Sb3V0ZUNvbnRleHQyID0gcmVxdWlyZSgnLi9Sb3V0ZUNvbnRleHQnKTtcblxudmFyIF9Sb3V0ZUNvbnRleHQzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUm91dGVDb250ZXh0Mik7XG5cbnZhciBfdXNlUm91dGVzMiA9IHJlcXVpcmUoJy4vdXNlUm91dGVzJyk7XG5cbnZhciBfdXNlUm91dGVzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3VzZVJvdXRlczIpO1xuXG52YXIgX1JvdXRlckNvbnRleHQyID0gcmVxdWlyZSgnLi9Sb3V0ZXJDb250ZXh0Jyk7XG5cbnZhciBfUm91dGVyQ29udGV4dDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Sb3V0ZXJDb250ZXh0Mik7XG5cbnZhciBfUm91dGluZ0NvbnRleHQyID0gcmVxdWlyZSgnLi9Sb3V0aW5nQ29udGV4dCcpO1xuXG52YXIgX1JvdXRpbmdDb250ZXh0MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JvdXRpbmdDb250ZXh0Mik7XG5cbnZhciBfUHJvcFR5cGVzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Byb3BUeXBlczIpO1xuXG52YXIgX21hdGNoMiA9IHJlcXVpcmUoJy4vbWF0Y2gnKTtcblxudmFyIF9tYXRjaDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXRjaDIpO1xuXG52YXIgX3VzZVJvdXRlckhpc3RvcnkyID0gcmVxdWlyZSgnLi91c2VSb3V0ZXJIaXN0b3J5Jyk7XG5cbnZhciBfdXNlUm91dGVySGlzdG9yeTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VSb3V0ZXJIaXN0b3J5Mik7XG5cbnZhciBfYXBwbHlSb3V0ZXJNaWRkbGV3YXJlMiA9IHJlcXVpcmUoJy4vYXBwbHlSb3V0ZXJNaWRkbGV3YXJlJyk7XG5cbnZhciBfYXBwbHlSb3V0ZXJNaWRkbGV3YXJlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FwcGx5Um91dGVyTWlkZGxld2FyZTIpO1xuXG52YXIgX2Jyb3dzZXJIaXN0b3J5MiA9IHJlcXVpcmUoJy4vYnJvd3Nlckhpc3RvcnknKTtcblxudmFyIF9icm93c2VySGlzdG9yeTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9icm93c2VySGlzdG9yeTIpO1xuXG52YXIgX2hhc2hIaXN0b3J5MiA9IHJlcXVpcmUoJy4vaGFzaEhpc3RvcnknKTtcblxudmFyIF9oYXNoSGlzdG9yeTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oYXNoSGlzdG9yeTIpO1xuXG52YXIgX2NyZWF0ZU1lbW9yeUhpc3RvcnkyID0gcmVxdWlyZSgnLi9jcmVhdGVNZW1vcnlIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlTWVtb3J5SGlzdG9yeTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVNZW1vcnlIaXN0b3J5Mik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuUm91dGVyID0gX1JvdXRlcjMuZGVmYXVsdDsgLyogY29tcG9uZW50cyAqL1xuXG5leHBvcnRzLkxpbmsgPSBfTGluazMuZGVmYXVsdDtcbmV4cG9ydHMuSW5kZXhMaW5rID0gX0luZGV4TGluazMuZGVmYXVsdDtcbmV4cG9ydHMud2l0aFJvdXRlciA9IF93aXRoUm91dGVyMy5kZWZhdWx0O1xuXG4vKiBjb21wb25lbnRzIChjb25maWd1cmF0aW9uKSAqL1xuXG5leHBvcnRzLkluZGV4UmVkaXJlY3QgPSBfSW5kZXhSZWRpcmVjdDMuZGVmYXVsdDtcbmV4cG9ydHMuSW5kZXhSb3V0ZSA9IF9JbmRleFJvdXRlMy5kZWZhdWx0O1xuZXhwb3J0cy5SZWRpcmVjdCA9IF9SZWRpcmVjdDMuZGVmYXVsdDtcbmV4cG9ydHMuUm91dGUgPSBfUm91dGUzLmRlZmF1bHQ7XG5cbi8qIG1peGlucyAqL1xuXG5leHBvcnRzLkhpc3RvcnkgPSBfSGlzdG9yeTMuZGVmYXVsdDtcbmV4cG9ydHMuTGlmZWN5Y2xlID0gX0xpZmVjeWNsZTMuZGVmYXVsdDtcbmV4cG9ydHMuUm91dGVDb250ZXh0ID0gX1JvdXRlQ29udGV4dDMuZGVmYXVsdDtcblxuLyogdXRpbHMgKi9cblxuZXhwb3J0cy51c2VSb3V0ZXMgPSBfdXNlUm91dGVzMy5kZWZhdWx0O1xuZXhwb3J0cy5Sb3V0ZXJDb250ZXh0ID0gX1JvdXRlckNvbnRleHQzLmRlZmF1bHQ7XG5leHBvcnRzLlJvdXRpbmdDb250ZXh0ID0gX1JvdXRpbmdDb250ZXh0My5kZWZhdWx0O1xuZXhwb3J0cy5Qcm9wVHlwZXMgPSBfUHJvcFR5cGVzMy5kZWZhdWx0O1xuZXhwb3J0cy5tYXRjaCA9IF9tYXRjaDMuZGVmYXVsdDtcbmV4cG9ydHMudXNlUm91dGVySGlzdG9yeSA9IF91c2VSb3V0ZXJIaXN0b3J5My5kZWZhdWx0O1xuZXhwb3J0cy5hcHBseVJvdXRlck1pZGRsZXdhcmUgPSBfYXBwbHlSb3V0ZXJNaWRkbGV3YXJlMy5kZWZhdWx0O1xuXG4vKiBoaXN0b3JpZXMgKi9cblxuZXhwb3J0cy5icm93c2VySGlzdG9yeSA9IF9icm93c2VySGlzdG9yeTMuZGVmYXVsdDtcbmV4cG9ydHMuaGFzaEhpc3RvcnkgPSBfaGFzaEhpc3RvcnkzLmRlZmF1bHQ7XG5leHBvcnRzLmNyZWF0ZU1lbW9yeUhpc3RvcnkgPSBfY3JlYXRlTWVtb3J5SGlzdG9yeTMuZGVmYXVsdDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9pbmRleC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZXhwb3J0cy5pc1JlYWN0Q2hpbGRyZW4gPSBpc1JlYWN0Q2hpbGRyZW47XG5leHBvcnRzLmNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudCA9IGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudDtcbmV4cG9ydHMuY3JlYXRlUm91dGVzRnJvbVJlYWN0Q2hpbGRyZW4gPSBjcmVhdGVSb3V0ZXNGcm9tUmVhY3RDaGlsZHJlbjtcbmV4cG9ydHMuY3JlYXRlUm91dGVzID0gY3JlYXRlUm91dGVzO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGlzVmFsaWRDaGlsZChvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsIHx8IF9yZWFjdDIuZGVmYXVsdC5pc1ZhbGlkRWxlbWVudChvYmplY3QpO1xufVxuXG5mdW5jdGlvbiBpc1JlYWN0Q2hpbGRyZW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc1ZhbGlkQ2hpbGQob2JqZWN0KSB8fCBBcnJheS5pc0FycmF5KG9iamVjdCkgJiYgb2JqZWN0LmV2ZXJ5KGlzVmFsaWRDaGlsZCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlKGRlZmF1bHRQcm9wcywgcHJvcHMpIHtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBkZWZhdWx0UHJvcHMsIHByb3BzKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KGVsZW1lbnQpIHtcbiAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gIHZhciByb3V0ZSA9IGNyZWF0ZVJvdXRlKHR5cGUuZGVmYXVsdFByb3BzLCBlbGVtZW50LnByb3BzKTtcblxuICBpZiAocm91dGUuY2hpbGRyZW4pIHtcbiAgICB2YXIgY2hpbGRSb3V0ZXMgPSBjcmVhdGVSb3V0ZXNGcm9tUmVhY3RDaGlsZHJlbihyb3V0ZS5jaGlsZHJlbiwgcm91dGUpO1xuXG4gICAgaWYgKGNoaWxkUm91dGVzLmxlbmd0aCkgcm91dGUuY2hpbGRSb3V0ZXMgPSBjaGlsZFJvdXRlcztcblxuICAgIGRlbGV0ZSByb3V0ZS5jaGlsZHJlbjtcbiAgfVxuXG4gIHJldHVybiByb3V0ZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgcm91dGVzIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBSZWFjdENoaWxkcmVuLiBKU1hcbiAqIHByb3ZpZGVzIGEgY29udmVuaWVudCB3YXkgdG8gdmlzdWFsaXplIGhvdyByb3V0ZXMgaW4gdGhlIGhpZXJhcmNoeSBhcmVcbiAqIG5lc3RlZC5cbiAqXG4gKiAgIGltcG9ydCB7IFJvdXRlLCBjcmVhdGVSb3V0ZXNGcm9tUmVhY3RDaGlsZHJlbiB9IGZyb20gJ3JlYWN0LXJvdXRlcidcbiAqXG4gKiAgIGNvbnN0IHJvdXRlcyA9IGNyZWF0ZVJvdXRlc0Zyb21SZWFjdENoaWxkcmVuKFxuICogICAgIDxSb3V0ZSBjb21wb25lbnQ9e0FwcH0+XG4gKiAgICAgICA8Um91dGUgcGF0aD1cImhvbWVcIiBjb21wb25lbnQ9e0Rhc2hib2FyZH0vPlxuICogICAgICAgPFJvdXRlIHBhdGg9XCJuZXdzXCIgY29tcG9uZW50PXtOZXdzRmVlZH0vPlxuICogICAgIDwvUm91dGU+XG4gKiAgIClcbiAqXG4gKiBOb3RlOiBUaGlzIG1ldGhvZCBpcyBhdXRvbWF0aWNhbGx5IHVzZWQgd2hlbiB5b3UgcHJvdmlkZSA8Um91dGU+IGNoaWxkcmVuXG4gKiB0byBhIDxSb3V0ZXI+IGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUm91dGVzRnJvbVJlYWN0Q2hpbGRyZW4oY2hpbGRyZW4sIHBhcmVudFJvdXRlKSB7XG4gIHZhciByb3V0ZXMgPSBbXTtcblxuICBfcmVhY3QyLmRlZmF1bHQuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICBpZiAoX3JlYWN0Mi5kZWZhdWx0LmlzVmFsaWRFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICAvLyBDb21wb25lbnQgY2xhc3NlcyBtYXkgaGF2ZSBhIHN0YXRpYyBjcmVhdGUqIG1ldGhvZC5cbiAgICAgIGlmIChlbGVtZW50LnR5cGUuY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KSB7XG4gICAgICAgIHZhciByb3V0ZSA9IGVsZW1lbnQudHlwZS5jcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQoZWxlbWVudCwgcGFyZW50Um91dGUpO1xuXG4gICAgICAgIGlmIChyb3V0ZSkgcm91dGVzLnB1c2gocm91dGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm91dGVzLnB1c2goY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KGVsZW1lbnQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByb3V0ZXM7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiByb3V0ZXMgZnJvbSB0aGUgZ2l2ZW4gb2JqZWN0IHdoaWNoXG4gKiBtYXkgYmUgYSBKU1ggcm91dGUsIGEgcGxhaW4gb2JqZWN0IHJvdXRlLCBvciBhbiBhcnJheSBvZiBlaXRoZXIuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlcyhyb3V0ZXMpIHtcbiAgaWYgKGlzUmVhY3RDaGlsZHJlbihyb3V0ZXMpKSB7XG4gICAgcm91dGVzID0gY3JlYXRlUm91dGVzRnJvbVJlYWN0Q2hpbGRyZW4ocm91dGVzKTtcbiAgfSBlbHNlIGlmIChyb3V0ZXMgJiYgIUFycmF5LmlzQXJyYXkocm91dGVzKSkge1xuICAgIHJvdXRlcyA9IFtyb3V0ZXNdO1xuICB9XG5cbiAgcmV0dXJuIHJvdXRlcztcbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZVV0aWxzLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5yb3V0ZXIgPSBleHBvcnRzLnJvdXRlcyA9IGV4cG9ydHMucm91dGUgPSBleHBvcnRzLmNvbXBvbmVudHMgPSBleHBvcnRzLmNvbXBvbmVudCA9IGV4cG9ydHMubG9jYXRpb24gPSBleHBvcnRzLmhpc3RvcnkgPSBleHBvcnRzLmZhbHN5ID0gZXhwb3J0cy5sb2NhdGlvblNoYXBlID0gZXhwb3J0cy5yb3V0ZXJTaGFwZSA9IHVuZGVmaW5lZDtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyA9IHJlcXVpcmUoJy4vZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcycpO1xuXG52YXIgX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyk7XG5cbnZhciBfSW50ZXJuYWxQcm9wVHlwZXMgPSByZXF1aXJlKCcuL0ludGVybmFsUHJvcFR5cGVzJyk7XG5cbnZhciBJbnRlcm5hbFByb3BUeXBlcyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9JbnRlcm5hbFByb3BUeXBlcyk7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBmdW5jID0gX3JlYWN0LlByb3BUeXBlcy5mdW5jO1xudmFyIG9iamVjdCA9IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0O1xudmFyIHNoYXBlID0gX3JlYWN0LlByb3BUeXBlcy5zaGFwZTtcbnZhciBzdHJpbmcgPSBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZztcbnZhciByb3V0ZXJTaGFwZSA9IGV4cG9ydHMucm91dGVyU2hhcGUgPSBzaGFwZSh7XG4gIHB1c2g6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgcmVwbGFjZTogZnVuYy5pc1JlcXVpcmVkLFxuICBnbzogZnVuYy5pc1JlcXVpcmVkLFxuICBnb0JhY2s6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgZ29Gb3J3YXJkOiBmdW5jLmlzUmVxdWlyZWQsXG4gIHNldFJvdXRlTGVhdmVIb29rOiBmdW5jLmlzUmVxdWlyZWQsXG4gIGlzQWN0aXZlOiBmdW5jLmlzUmVxdWlyZWRcbn0pO1xuXG52YXIgbG9jYXRpb25TaGFwZSA9IGV4cG9ydHMubG9jYXRpb25TaGFwZSA9IHNoYXBlKHtcbiAgcGF0aG5hbWU6IHN0cmluZy5pc1JlcXVpcmVkLFxuICBzZWFyY2g6IHN0cmluZy5pc1JlcXVpcmVkLFxuICBzdGF0ZTogb2JqZWN0LFxuICBhY3Rpb246IHN0cmluZy5pc1JlcXVpcmVkLFxuICBrZXk6IHN0cmluZ1xufSk7XG5cbi8vIERlcHJlY2F0ZWQgc3R1ZmYgYmVsb3c6XG5cbnZhciBmYWxzeSA9IGV4cG9ydHMuZmFsc3kgPSBJbnRlcm5hbFByb3BUeXBlcy5mYWxzeTtcbnZhciBoaXN0b3J5ID0gZXhwb3J0cy5oaXN0b3J5ID0gSW50ZXJuYWxQcm9wVHlwZXMuaGlzdG9yeTtcbnZhciBsb2NhdGlvbiA9IGV4cG9ydHMubG9jYXRpb24gPSBsb2NhdGlvblNoYXBlO1xudmFyIGNvbXBvbmVudCA9IGV4cG9ydHMuY29tcG9uZW50ID0gSW50ZXJuYWxQcm9wVHlwZXMuY29tcG9uZW50O1xudmFyIGNvbXBvbmVudHMgPSBleHBvcnRzLmNvbXBvbmVudHMgPSBJbnRlcm5hbFByb3BUeXBlcy5jb21wb25lbnRzO1xudmFyIHJvdXRlID0gZXhwb3J0cy5yb3V0ZSA9IEludGVybmFsUHJvcFR5cGVzLnJvdXRlO1xudmFyIHJvdXRlcyA9IGV4cG9ydHMucm91dGVzID0gSW50ZXJuYWxQcm9wVHlwZXMucm91dGVzO1xudmFyIHJvdXRlciA9IGV4cG9ydHMucm91dGVyID0gcm91dGVyU2hhcGU7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRlcHJlY2F0ZVByb3BUeXBlID0gZnVuY3Rpb24gZGVwcmVjYXRlUHJvcFR5cGUocHJvcFR5cGUsIG1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCBtZXNzYWdlKSA6IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIHByb3BUeXBlLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBkZXByZWNhdGVJbnRlcm5hbFByb3BUeXBlID0gZnVuY3Rpb24gZGVwcmVjYXRlSW50ZXJuYWxQcm9wVHlwZShwcm9wVHlwZSkge1xuICAgICAgcmV0dXJuIGRlcHJlY2F0ZVByb3BUeXBlKHByb3BUeXBlLCAnVGhpcyBwcm9wIHR5cGUgaXMgbm90IGludGVuZGVkIGZvciBleHRlcm5hbCB1c2UsIGFuZCB3YXMgcHJldmlvdXNseSBleHBvcnRlZCBieSBtaXN0YWtlLiBUaGVzZSBpbnRlcm5hbCBwcm9wIHR5cGVzIGFyZSBkZXByZWNhdGVkIGZvciBleHRlcm5hbCB1c2UsIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBsYXRlciB2ZXJzaW9uLicpO1xuICAgIH07XG5cbiAgICB2YXIgZGVwcmVjYXRlUmVuYW1lZFByb3BUeXBlID0gZnVuY3Rpb24gZGVwcmVjYXRlUmVuYW1lZFByb3BUeXBlKHByb3BUeXBlLCBuYW1lKSB7XG4gICAgICByZXR1cm4gZGVwcmVjYXRlUHJvcFR5cGUocHJvcFR5cGUsICdUaGUgYCcgKyBuYW1lICsgJ2AgcHJvcCB0eXBlIGlzIG5vdyBleHBvcnRlZCBhcyBgJyArIG5hbWUgKyAnU2hhcGVgIHRvIGF2b2lkIG5hbWUgY29uZmxpY3RzLiBUaGlzIGV4cG9ydCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBsYXRlciB2ZXJzaW9uLicpO1xuICAgIH07XG5cbiAgICBleHBvcnRzLmZhbHN5ID0gZmFsc3kgPSBkZXByZWNhdGVJbnRlcm5hbFByb3BUeXBlKGZhbHN5KTtcbiAgICBleHBvcnRzLmhpc3RvcnkgPSBoaXN0b3J5ID0gZGVwcmVjYXRlSW50ZXJuYWxQcm9wVHlwZShoaXN0b3J5KTtcbiAgICBleHBvcnRzLmNvbXBvbmVudCA9IGNvbXBvbmVudCA9IGRlcHJlY2F0ZUludGVybmFsUHJvcFR5cGUoY29tcG9uZW50KTtcbiAgICBleHBvcnRzLmNvbXBvbmVudHMgPSBjb21wb25lbnRzID0gZGVwcmVjYXRlSW50ZXJuYWxQcm9wVHlwZShjb21wb25lbnRzKTtcbiAgICBleHBvcnRzLnJvdXRlID0gcm91dGUgPSBkZXByZWNhdGVJbnRlcm5hbFByb3BUeXBlKHJvdXRlKTtcbiAgICBleHBvcnRzLnJvdXRlcyA9IHJvdXRlcyA9IGRlcHJlY2F0ZUludGVybmFsUHJvcFR5cGUocm91dGVzKTtcblxuICAgIGV4cG9ydHMubG9jYXRpb24gPSBsb2NhdGlvbiA9IGRlcHJlY2F0ZVJlbmFtZWRQcm9wVHlwZShsb2NhdGlvbiwgJ2xvY2F0aW9uJyk7XG4gICAgZXhwb3J0cy5yb3V0ZXIgPSByb3V0ZXIgPSBkZXByZWNhdGVSZW5hbWVkUHJvcFR5cGUocm91dGVyLCAncm91dGVyJyk7XG4gIH0pKCk7XG59XG5cbnZhciBkZWZhdWx0RXhwb3J0ID0ge1xuICBmYWxzeTogZmFsc3ksXG4gIGhpc3Rvcnk6IGhpc3RvcnksXG4gIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgY29tcG9uZW50OiBjb21wb25lbnQsXG4gIGNvbXBvbmVudHM6IGNvbXBvbmVudHMsXG4gIHJvdXRlOiByb3V0ZSxcbiAgLy8gRm9yIHNvbWUgcmVhc29uLCByb3V0ZXMgd2FzIG5ldmVyIGhlcmUuXG4gIHJvdXRlcjogcm91dGVyXG59O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWZhdWx0RXhwb3J0ID0gKDAsIF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzMi5kZWZhdWx0KShkZWZhdWx0RXhwb3J0LCAnVGhlIGRlZmF1bHQgZXhwb3J0IGZyb20gYHJlYWN0LXJvdXRlci9saWIvUHJvcFR5cGVzYCBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRoZSBuYW1lZCBleHBvcnRzIGluc3RlYWQuJyk7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGRlZmF1bHRFeHBvcnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvUHJvcFR5cGVzLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5jYW5Vc2VNZW1icmFuZSA9IHVuZGVmaW5lZDtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGNhblVzZU1lbWJyYW5lID0gZXhwb3J0cy5jYW5Vc2VNZW1icmFuZSA9IGZhbHNlO1xuXG4vLyBOby1vcCBieSBkZWZhdWx0LlxudmFyIGRlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0O1xufTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdHJ5IHtcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAneCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KS54KSB7XG4gICAgICBleHBvcnRzLmNhblVzZU1lbWJyYW5lID0gY2FuVXNlTWVtYnJhbmUgPSB0cnVlO1xuICAgIH1cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1lbXB0eSAqL1xuICB9IGNhdGNoIChlKSB7fVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWVtcHR5ICovXG5cbiAgaWYgKGNhblVzZU1lbWJyYW5lKSB7XG4gICAgZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMob2JqZWN0LCBtZXNzYWdlKSB7XG4gICAgICAvLyBXcmFwIHRoZSBkZXByZWNhdGVkIG9iamVjdCBpbiBhIG1lbWJyYW5lIHRvIHdhcm4gb24gcHJvcGVydHkgYWNjZXNzLlxuICAgICAgdmFyIG1lbWJyYW5lID0ge307XG5cbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKHByb3ApIHtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wKSkge1xuICAgICAgICAgIHJldHVybiAnY29udGludWUnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3RbcHJvcF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBDYW4ndCB1c2UgZmF0IGFycm93IGhlcmUgYmVjYXVzZSBvZiB1c2Ugb2YgYXJndW1lbnRzIGJlbG93LlxuICAgICAgICAgIG1lbWJyYW5lW3Byb3BdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsIG1lc3NhZ2UpIDogdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdFtwcm9wXS5hcHBseShvYmplY3QsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gJ2NvbnRpbnVlJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZXNlIHByb3BlcnRpZXMgYXJlIG5vbi1lbnVtZXJhYmxlIHRvIHByZXZlbnQgUmVhY3QgZGV2IHRvb2xzIGZyb21cbiAgICAgICAgLy8gc2VlaW5nIHRoZW0gYW5kIGNhdXNpbmcgc3B1cmlvdXMgd2FybmluZ3Mgd2hlbiBhY2Nlc3NpbmcgdGhlbS4gSW5cbiAgICAgICAgLy8gcHJpbmNpcGxlIHRoaXMgY291bGQgYmUgZG9uZSB3aXRoIGEgcHJveHksIGJ1dCBzdXBwb3J0IGZvciB0aGVcbiAgICAgICAgLy8gb3duS2V5cyB0cmFwIG9uIHByb3hpZXMgaXMgbm90IHVuaXZlcnNhbCwgZXZlbiBhbW9uZyBicm93c2VycyB0aGF0XG4gICAgICAgIC8vIG90aGVyd2lzZSBzdXBwb3J0IHByb3hpZXMuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZW1icmFuZSwgcHJvcCwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsIG1lc3NhZ2UpIDogdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdFtwcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBvYmplY3QpIHtcbiAgICAgICAgdmFyIF9yZXQgPSBfbG9vcChwcm9wKTtcblxuICAgICAgICBpZiAoX3JldCA9PT0gJ2NvbnRpbnVlJykgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtZW1icmFuZTtcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGRlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXM7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcy5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IHJvdXRlcldhcm5pbmc7XG5leHBvcnRzLl9yZXNldFdhcm5lZCA9IF9yZXNldFdhcm5lZDtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciB3YXJuZWQgPSB7fTtcblxuZnVuY3Rpb24gcm91dGVyV2FybmluZyhmYWxzZVRvV2FybiwgbWVzc2FnZSkge1xuICAvLyBPbmx5IGlzc3VlIGRlcHJlY2F0aW9uIHdhcm5pbmdzIG9uY2UuXG4gIGlmIChtZXNzYWdlLmluZGV4T2YoJ2RlcHJlY2F0ZWQnKSAhPT0gLTEpIHtcbiAgICBpZiAod2FybmVkW21lc3NhZ2VdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkW21lc3NhZ2VdID0gdHJ1ZTtcbiAgfVxuXG4gIG1lc3NhZ2UgPSAnW3JlYWN0LXJvdXRlcl0gJyArIG1lc3NhZ2U7XG5cbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBfd2FybmluZzIuZGVmYXVsdC5hcHBseSh1bmRlZmluZWQsIFtmYWxzZVRvV2FybiwgbWVzc2FnZV0uY29uY2F0KGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gX3Jlc2V0V2FybmVkKCkge1xuICB3YXJuZWQgPSB7fTtcbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9yb3V0ZXJXYXJuaW5nLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHdhcm5pbmcgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYXJncykge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuID4gMiA/IGxlbiAtIDIgOiAwKTtcbiAgICBmb3IgKHZhciBrZXkgPSAyOyBrZXkgPCBsZW47IGtleSsrKSB7XG4gICAgICBhcmdzW2tleSAtIDJdID0gYXJndW1lbnRzW2tleV07XG4gICAgfVxuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArXG4gICAgICAgICdtZXNzYWdlIGFyZ3VtZW50J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0Lmxlbmd0aCA8IDEwIHx8ICgvXltzXFxXXSokLykudGVzdChmb3JtYXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdUaGUgd2FybmluZyBmb3JtYXQgc2hvdWxkIGJlIGFibGUgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyAnICtcbiAgICAgICAgJ3dhcm5pbmcuIFBsZWFzZSwgdXNlIGEgbW9yZSBkZXNjcmlwdGl2ZSBmb3JtYXQgdGhhbjogJyArIGZvcm1hdFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgK1xuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB9IGNhdGNoKHgpIHt9XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vd2FybmluZy9icm93c2VyLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5yb3V0ZXMgPSBleHBvcnRzLnJvdXRlID0gZXhwb3J0cy5jb21wb25lbnRzID0gZXhwb3J0cy5jb21wb25lbnQgPSBleHBvcnRzLmhpc3RvcnkgPSB1bmRlZmluZWQ7XG5leHBvcnRzLmZhbHN5ID0gZmFsc3k7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgZnVuYyA9IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYztcbnZhciBvYmplY3QgPSBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdDtcbnZhciBhcnJheU9mID0gX3JlYWN0LlByb3BUeXBlcy5hcnJheU9mO1xudmFyIG9uZU9mVHlwZSA9IF9yZWFjdC5Qcm9wVHlwZXMub25lT2ZUeXBlO1xudmFyIGVsZW1lbnQgPSBfcmVhY3QuUHJvcFR5cGVzLmVsZW1lbnQ7XG52YXIgc2hhcGUgPSBfcmVhY3QuUHJvcFR5cGVzLnNoYXBlO1xudmFyIHN0cmluZyA9IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nO1xuZnVuY3Rpb24gZmFsc3kocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gIGlmIChwcm9wc1twcm9wTmFtZV0pIHJldHVybiBuZXcgRXJyb3IoJzwnICsgY29tcG9uZW50TmFtZSArICc+IHNob3VsZCBub3QgaGF2ZSBhIFwiJyArIHByb3BOYW1lICsgJ1wiIHByb3AnKTtcbn1cblxudmFyIGhpc3RvcnkgPSBleHBvcnRzLmhpc3RvcnkgPSBzaGFwZSh7XG4gIGxpc3RlbjogZnVuYy5pc1JlcXVpcmVkLFxuICBwdXNoOiBmdW5jLmlzUmVxdWlyZWQsXG4gIHJlcGxhY2U6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgZ286IGZ1bmMuaXNSZXF1aXJlZCxcbiAgZ29CYWNrOiBmdW5jLmlzUmVxdWlyZWQsXG4gIGdvRm9yd2FyZDogZnVuYy5pc1JlcXVpcmVkXG59KTtcblxudmFyIGNvbXBvbmVudCA9IGV4cG9ydHMuY29tcG9uZW50ID0gb25lT2ZUeXBlKFtmdW5jLCBzdHJpbmddKTtcbnZhciBjb21wb25lbnRzID0gZXhwb3J0cy5jb21wb25lbnRzID0gb25lT2ZUeXBlKFtjb21wb25lbnQsIG9iamVjdF0pO1xudmFyIHJvdXRlID0gZXhwb3J0cy5yb3V0ZSA9IG9uZU9mVHlwZShbb2JqZWN0LCBlbGVtZW50XSk7XG52YXIgcm91dGVzID0gZXhwb3J0cy5yb3V0ZXMgPSBvbmVPZlR5cGUoW3JvdXRlLCBhcnJheU9mKHJvdXRlKV0pO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL0ludGVybmFsUHJvcFR5cGVzLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5jb21waWxlUGF0dGVybiA9IGNvbXBpbGVQYXR0ZXJuO1xuZXhwb3J0cy5tYXRjaFBhdHRlcm4gPSBtYXRjaFBhdHRlcm47XG5leHBvcnRzLmdldFBhcmFtTmFtZXMgPSBnZXRQYXJhbU5hbWVzO1xuZXhwb3J0cy5nZXRQYXJhbXMgPSBnZXRQYXJhbXM7XG5leHBvcnRzLmZvcm1hdFBhdHRlcm4gPSBmb3JtYXRQYXR0ZXJuO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKTtcbn1cblxuZnVuY3Rpb24gX2NvbXBpbGVQYXR0ZXJuKHBhdHRlcm4pIHtcbiAgdmFyIHJlZ2V4cFNvdXJjZSA9ICcnO1xuICB2YXIgcGFyYW1OYW1lcyA9IFtdO1xuICB2YXIgdG9rZW5zID0gW107XG5cbiAgdmFyIG1hdGNoID0gdm9pZCAwLFxuICAgICAgbGFzdEluZGV4ID0gMCxcbiAgICAgIG1hdGNoZXIgPSAvOihbYS16QS1aXyRdW2EtekEtWjAtOV8kXSopfFxcKlxcKnxcXCp8XFwofFxcKS9nO1xuICB3aGlsZSAobWF0Y2ggPSBtYXRjaGVyLmV4ZWMocGF0dGVybikpIHtcbiAgICBpZiAobWF0Y2guaW5kZXggIT09IGxhc3RJbmRleCkge1xuICAgICAgdG9rZW5zLnB1c2gocGF0dGVybi5zbGljZShsYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICByZWdleHBTb3VyY2UgKz0gZXNjYXBlUmVnRXhwKHBhdHRlcm4uc2xpY2UobGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgIH1cblxuICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgcmVnZXhwU291cmNlICs9ICcoW14vXSspJztcbiAgICAgIHBhcmFtTmFtZXMucHVzaChtYXRjaFsxXSk7XG4gICAgfSBlbHNlIGlmIChtYXRjaFswXSA9PT0gJyoqJykge1xuICAgICAgcmVnZXhwU291cmNlICs9ICcoLiopJztcbiAgICAgIHBhcmFtTmFtZXMucHVzaCgnc3BsYXQnKTtcbiAgICB9IGVsc2UgaWYgKG1hdGNoWzBdID09PSAnKicpIHtcbiAgICAgIHJlZ2V4cFNvdXJjZSArPSAnKC4qPyknO1xuICAgICAgcGFyYW1OYW1lcy5wdXNoKCdzcGxhdCcpO1xuICAgIH0gZWxzZSBpZiAobWF0Y2hbMF0gPT09ICcoJykge1xuICAgICAgcmVnZXhwU291cmNlICs9ICcoPzonO1xuICAgIH0gZWxzZSBpZiAobWF0Y2hbMF0gPT09ICcpJykge1xuICAgICAgcmVnZXhwU291cmNlICs9ICcpPyc7XG4gICAgfVxuXG4gICAgdG9rZW5zLnB1c2gobWF0Y2hbMF0pO1xuXG4gICAgbGFzdEluZGV4ID0gbWF0Y2hlci5sYXN0SW5kZXg7XG4gIH1cblxuICBpZiAobGFzdEluZGV4ICE9PSBwYXR0ZXJuLmxlbmd0aCkge1xuICAgIHRva2Vucy5wdXNoKHBhdHRlcm4uc2xpY2UobGFzdEluZGV4LCBwYXR0ZXJuLmxlbmd0aCkpO1xuICAgIHJlZ2V4cFNvdXJjZSArPSBlc2NhcGVSZWdFeHAocGF0dGVybi5zbGljZShsYXN0SW5kZXgsIHBhdHRlcm4ubGVuZ3RoKSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhdHRlcm46IHBhdHRlcm4sXG4gICAgcmVnZXhwU291cmNlOiByZWdleHBTb3VyY2UsXG4gICAgcGFyYW1OYW1lczogcGFyYW1OYW1lcyxcbiAgICB0b2tlbnM6IHRva2Vuc1xuICB9O1xufVxuXG52YXIgQ29tcGlsZWRQYXR0ZXJuc0NhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gY29tcGlsZVBhdHRlcm4ocGF0dGVybikge1xuICBpZiAoIUNvbXBpbGVkUGF0dGVybnNDYWNoZVtwYXR0ZXJuXSkgQ29tcGlsZWRQYXR0ZXJuc0NhY2hlW3BhdHRlcm5dID0gX2NvbXBpbGVQYXR0ZXJuKHBhdHRlcm4pO1xuXG4gIHJldHVybiBDb21waWxlZFBhdHRlcm5zQ2FjaGVbcGF0dGVybl07XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gbWF0Y2ggYSBwYXR0ZXJuIG9uIHRoZSBnaXZlbiBwYXRobmFtZS4gUGF0dGVybnMgbWF5IHVzZVxuICogdGhlIGZvbGxvd2luZyBzcGVjaWFsIGNoYXJhY3RlcnM6XG4gKlxuICogLSA6cGFyYW1OYW1lICAgICBNYXRjaGVzIGEgVVJMIHNlZ21lbnQgdXAgdG8gdGhlIG5leHQgLywgPywgb3IgIy4gVGhlXG4gKiAgICAgICAgICAgICAgICAgIGNhcHR1cmVkIHN0cmluZyBpcyBjb25zaWRlcmVkIGEgXCJwYXJhbVwiXG4gKiAtICgpICAgICAgICAgICAgIFdyYXBzIGEgc2VnbWVudCBvZiB0aGUgVVJMIHRoYXQgaXMgb3B0aW9uYWxcbiAqIC0gKiAgICAgICAgICAgICAgQ29uc3VtZXMgKG5vbi1ncmVlZHkpIGFsbCBjaGFyYWN0ZXJzIHVwIHRvIHRoZSBuZXh0XG4gKiAgICAgICAgICAgICAgICAgIGNoYXJhY3RlciBpbiB0aGUgcGF0dGVybiwgb3IgdG8gdGhlIGVuZCBvZiB0aGUgVVJMIGlmXG4gKiAgICAgICAgICAgICAgICAgIHRoZXJlIGlzIG5vbmVcbiAqIC0gKiogICAgICAgICAgICAgQ29uc3VtZXMgKGdyZWVkeSkgYWxsIGNoYXJhY3RlcnMgdXAgdG8gdGhlIG5leHQgY2hhcmFjdGVyXG4gKiAgICAgICAgICAgICAgICAgIGluIHRoZSBwYXR0ZXJuLCBvciB0byB0aGUgZW5kIG9mIHRoZSBVUkwgaWYgdGhlcmUgaXMgbm9uZVxuICpcbiAqICBUaGUgZnVuY3Rpb24gY2FsbHMgY2FsbGJhY2soZXJyb3IsIG1hdGNoZWQpIHdoZW4gZmluaXNoZWQuXG4gKiBUaGUgcmV0dXJuIHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAtIHJlbWFpbmluZ1BhdGhuYW1lXG4gKiAtIHBhcmFtTmFtZXNcbiAqIC0gcGFyYW1WYWx1ZXNcbiAqL1xuZnVuY3Rpb24gbWF0Y2hQYXR0ZXJuKHBhdHRlcm4sIHBhdGhuYW1lKSB7XG4gIC8vIEVuc3VyZSBwYXR0ZXJuIHN0YXJ0cyB3aXRoIGxlYWRpbmcgc2xhc2ggZm9yIGNvbnNpc3RlbmN5IHdpdGggcGF0aG5hbWUuXG4gIGlmIChwYXR0ZXJuLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgcGF0dGVybiA9ICcvJyArIHBhdHRlcm47XG4gIH1cblxuICB2YXIgX2NvbXBpbGVQYXR0ZXJuMiA9IGNvbXBpbGVQYXR0ZXJuKHBhdHRlcm4pO1xuXG4gIHZhciByZWdleHBTb3VyY2UgPSBfY29tcGlsZVBhdHRlcm4yLnJlZ2V4cFNvdXJjZTtcbiAgdmFyIHBhcmFtTmFtZXMgPSBfY29tcGlsZVBhdHRlcm4yLnBhcmFtTmFtZXM7XG4gIHZhciB0b2tlbnMgPSBfY29tcGlsZVBhdHRlcm4yLnRva2VucztcblxuXG4gIGlmIChwYXR0ZXJuLmNoYXJBdChwYXR0ZXJuLmxlbmd0aCAtIDEpICE9PSAnLycpIHtcbiAgICByZWdleHBTb3VyY2UgKz0gJy8/JzsgLy8gQWxsb3cgb3B0aW9uYWwgcGF0aCBzZXBhcmF0b3IgYXQgZW5kLlxuICB9XG5cbiAgLy8gU3BlY2lhbC1jYXNlIHBhdHRlcm5zIGxpa2UgJyonIGZvciBjYXRjaC1hbGwgcm91dGVzLlxuICBpZiAodG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG4gICAgcmVnZXhwU291cmNlICs9ICckJztcbiAgfVxuXG4gIHZhciBtYXRjaCA9IHBhdGhuYW1lLm1hdGNoKG5ldyBSZWdFeHAoJ14nICsgcmVnZXhwU291cmNlLCAnaScpKTtcbiAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXRjaGVkUGF0aCA9IG1hdGNoWzBdO1xuICB2YXIgcmVtYWluaW5nUGF0aG5hbWUgPSBwYXRobmFtZS5zdWJzdHIobWF0Y2hlZFBhdGgubGVuZ3RoKTtcblxuICBpZiAocmVtYWluaW5nUGF0aG5hbWUpIHtcbiAgICAvLyBSZXF1aXJlIHRoYXQgdGhlIG1hdGNoIGVuZHMgYXQgYSBwYXRoIHNlcGFyYXRvciwgaWYgd2UgZGlkbid0IG1hdGNoXG4gICAgLy8gdGhlIGZ1bGwgcGF0aCwgc28gYW55IHJlbWFpbmluZyBwYXRobmFtZSBpcyBhIG5ldyBwYXRoIHNlZ21lbnQuXG4gICAgaWYgKG1hdGNoZWRQYXRoLmNoYXJBdChtYXRjaGVkUGF0aC5sZW5ndGggLSAxKSAhPT0gJy8nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIHJlbWFpbmluZyBwYXRobmFtZSwgdHJlYXQgdGhlIHBhdGggc2VwYXJhdG9yIGFzIHBhcnQgb2ZcbiAgICAvLyB0aGUgcmVtYWluaW5nIHBhdGhuYW1lIGZvciBwcm9wZXJseSBjb250aW51aW5nIHRoZSBtYXRjaC5cbiAgICByZW1haW5pbmdQYXRobmFtZSA9ICcvJyArIHJlbWFpbmluZ1BhdGhuYW1lO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByZW1haW5pbmdQYXRobmFtZTogcmVtYWluaW5nUGF0aG5hbWUsXG4gICAgcGFyYW1OYW1lczogcGFyYW1OYW1lcyxcbiAgICBwYXJhbVZhbHVlczogbWF0Y2guc2xpY2UoMSkubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICByZXR1cm4gdiAmJiBkZWNvZGVVUklDb21wb25lbnQodik7XG4gICAgfSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UGFyYW1OYW1lcyhwYXR0ZXJuKSB7XG4gIHJldHVybiBjb21waWxlUGF0dGVybihwYXR0ZXJuKS5wYXJhbU5hbWVzO1xufVxuXG5mdW5jdGlvbiBnZXRQYXJhbXMocGF0dGVybiwgcGF0aG5hbWUpIHtcbiAgdmFyIG1hdGNoID0gbWF0Y2hQYXR0ZXJuKHBhdHRlcm4sIHBhdGhuYW1lKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHBhcmFtTmFtZXMgPSBtYXRjaC5wYXJhbU5hbWVzO1xuICB2YXIgcGFyYW1WYWx1ZXMgPSBtYXRjaC5wYXJhbVZhbHVlcztcblxuICB2YXIgcGFyYW1zID0ge307XG5cbiAgcGFyYW1OYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbU5hbWUsIGluZGV4KSB7XG4gICAgcGFyYW1zW3BhcmFtTmFtZV0gPSBwYXJhbVZhbHVlc1tpbmRleF07XG4gIH0pO1xuXG4gIHJldHVybiBwYXJhbXM7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHZlcnNpb24gb2YgdGhlIGdpdmVuIHBhdHRlcm4gd2l0aCBwYXJhbXMgaW50ZXJwb2xhdGVkLiBUaHJvd3NcbiAqIGlmIHRoZXJlIGlzIGEgZHluYW1pYyBzZWdtZW50IG9mIHRoZSBwYXR0ZXJuIGZvciB3aGljaCB0aGVyZSBpcyBubyBwYXJhbS5cbiAqL1xuZnVuY3Rpb24gZm9ybWF0UGF0dGVybihwYXR0ZXJuLCBwYXJhbXMpIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXG4gIHZhciBfY29tcGlsZVBhdHRlcm4zID0gY29tcGlsZVBhdHRlcm4ocGF0dGVybik7XG5cbiAgdmFyIHRva2VucyA9IF9jb21waWxlUGF0dGVybjMudG9rZW5zO1xuXG4gIHZhciBwYXJlbkNvdW50ID0gMCxcbiAgICAgIHBhdGhuYW1lID0gJycsXG4gICAgICBzcGxhdEluZGV4ID0gMDtcblxuICB2YXIgdG9rZW4gPSB2b2lkIDAsXG4gICAgICBwYXJhbU5hbWUgPSB2b2lkIDAsXG4gICAgICBwYXJhbVZhbHVlID0gdm9pZCAwO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdG9rZW5zLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICBpZiAodG9rZW4gPT09ICcqJyB8fCB0b2tlbiA9PT0gJyoqJykge1xuICAgICAgcGFyYW1WYWx1ZSA9IEFycmF5LmlzQXJyYXkocGFyYW1zLnNwbGF0KSA/IHBhcmFtcy5zcGxhdFtzcGxhdEluZGV4KytdIDogcGFyYW1zLnNwbGF0O1xuXG4gICAgICAhKHBhcmFtVmFsdWUgIT0gbnVsbCB8fCBwYXJlbkNvdW50ID4gMCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnTWlzc2luZyBzcGxhdCAjJXMgZm9yIHBhdGggXCIlc1wiJywgc3BsYXRJbmRleCwgcGF0dGVybikgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgICBpZiAocGFyYW1WYWx1ZSAhPSBudWxsKSBwYXRobmFtZSArPSBlbmNvZGVVUkkocGFyYW1WYWx1ZSk7XG4gICAgfSBlbHNlIGlmICh0b2tlbiA9PT0gJygnKSB7XG4gICAgICBwYXJlbkNvdW50ICs9IDE7XG4gICAgfSBlbHNlIGlmICh0b2tlbiA9PT0gJyknKSB7XG4gICAgICBwYXJlbkNvdW50IC09IDE7XG4gICAgfSBlbHNlIGlmICh0b2tlbi5jaGFyQXQoMCkgPT09ICc6Jykge1xuICAgICAgcGFyYW1OYW1lID0gdG9rZW4uc3Vic3RyaW5nKDEpO1xuICAgICAgcGFyYW1WYWx1ZSA9IHBhcmFtc1twYXJhbU5hbWVdO1xuXG4gICAgICAhKHBhcmFtVmFsdWUgIT0gbnVsbCB8fCBwYXJlbkNvdW50ID4gMCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnTWlzc2luZyBcIiVzXCIgcGFyYW1ldGVyIGZvciBwYXRoIFwiJXNcIicsIHBhcmFtTmFtZSwgcGF0dGVybikgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgICBpZiAocGFyYW1WYWx1ZSAhPSBudWxsKSBwYXRobmFtZSArPSBlbmNvZGVVUklDb21wb25lbnQocGFyYW1WYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGhuYW1lICs9IHRva2VuO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXRobmFtZS5yZXBsYWNlKC9cXC8rL2csICcvJyk7XG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvUGF0dGVyblV0aWxzLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgaW52YXJpYW50ID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAnTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArXG4gICAgICAgICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLidcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7IHJldHVybiBhcmdzW2FyZ0luZGV4KytdOyB9KVxuICAgICAgKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9pbnZhcmlhbnQvYnJvd3Nlci5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9jcmVhdGVIYXNoSGlzdG9yeSA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL2NyZWF0ZUhhc2hIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlSGFzaEhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlSGFzaEhpc3RvcnkpO1xuXG52YXIgX3VzZVF1ZXJpZXMgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi91c2VRdWVyaWVzJyk7XG5cbnZhciBfdXNlUXVlcmllczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VRdWVyaWVzKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyID0gcmVxdWlyZSgnLi9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcicpO1xuXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKTtcblxudmFyIF9JbnRlcm5hbFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vSW50ZXJuYWxQcm9wVHlwZXMnKTtcblxudmFyIF9Sb3V0ZXJDb250ZXh0ID0gcmVxdWlyZSgnLi9Sb3V0ZXJDb250ZXh0Jyk7XG5cbnZhciBfUm91dGVyQ29udGV4dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Sb3V0ZXJDb250ZXh0KTtcblxudmFyIF9Sb3V0ZVV0aWxzID0gcmVxdWlyZSgnLi9Sb3V0ZVV0aWxzJyk7XG5cbnZhciBfUm91dGVyVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlclV0aWxzJyk7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gaXNEZXByZWNhdGVkSGlzdG9yeShoaXN0b3J5KSB7XG4gIHJldHVybiAhaGlzdG9yeSB8fCAhaGlzdG9yeS5fX3YyX2NvbXBhdGlibGVfXztcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNhbml0eSBjaGVjayAqL1xuZnVuY3Rpb24gaXNVbnN1cHBvcnRlZEhpc3RvcnkoaGlzdG9yeSkge1xuICAvLyB2MyBoaXN0b3JpZXMgZXhwb3NlIGdldEN1cnJlbnRMb2NhdGlvbiwgYnV0IGFyZW4ndCBjdXJyZW50bHkgc3VwcG9ydGVkLlxuICByZXR1cm4gaGlzdG9yeSAmJiBoaXN0b3J5LmdldEN1cnJlbnRMb2NhdGlvbjtcbn1cblxudmFyIF9SZWFjdCRQcm9wVHlwZXMgPSBfcmVhY3QyLmRlZmF1bHQuUHJvcFR5cGVzO1xudmFyIGZ1bmMgPSBfUmVhY3QkUHJvcFR5cGVzLmZ1bmM7XG52YXIgb2JqZWN0ID0gX1JlYWN0JFByb3BUeXBlcy5vYmplY3Q7XG5cbi8qKlxuICogQSA8Um91dGVyPiBpcyBhIGhpZ2gtbGV2ZWwgQVBJIGZvciBhdXRvbWF0aWNhbGx5IHNldHRpbmcgdXBcbiAqIGEgcm91dGVyIHRoYXQgcmVuZGVycyBhIDxSb3V0ZXJDb250ZXh0PiB3aXRoIGFsbCB0aGUgcHJvcHNcbiAqIGl0IG5lZWRzIGVhY2ggdGltZSB0aGUgVVJMIGNoYW5nZXMuXG4gKi9cblxudmFyIFJvdXRlciA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUm91dGVyJyxcblxuXG4gIHByb3BUeXBlczoge1xuICAgIGhpc3Rvcnk6IG9iamVjdCxcbiAgICBjaGlsZHJlbjogX0ludGVybmFsUHJvcFR5cGVzLnJvdXRlcyxcbiAgICByb3V0ZXM6IF9JbnRlcm5hbFByb3BUeXBlcy5yb3V0ZXMsIC8vIGFsaWFzIGZvciBjaGlsZHJlblxuICAgIHJlbmRlcjogZnVuYyxcbiAgICBjcmVhdGVFbGVtZW50OiBmdW5jLFxuICAgIG9uRXJyb3I6IGZ1bmMsXG4gICAgb25VcGRhdGU6IGZ1bmMsXG5cbiAgICAvLyBEZXByZWNhdGVkOlxuICAgIHBhcnNlUXVlcnlTdHJpbmc6IGZ1bmMsXG4gICAgc3RyaW5naWZ5UXVlcnk6IGZ1bmMsXG5cbiAgICAvLyBQUklWQVRFOiBGb3IgY2xpZW50LXNpZGUgcmVoeWRyYXRpb24gb2Ygc2VydmVyIG1hdGNoLlxuICAgIG1hdGNoQ29udGV4dDogb2JqZWN0XG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiBnZXREZWZhdWx0UHJvcHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKHByb3BzKSB7XG4gICAgICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChfUm91dGVyQ29udGV4dDIuZGVmYXVsdCwgcHJvcHMpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsb2NhdGlvbjogbnVsbCxcbiAgICAgIHJvdXRlczogbnVsbCxcbiAgICAgIHBhcmFtczogbnVsbCxcbiAgICAgIGNvbXBvbmVudHM6IG51bGxcbiAgICB9O1xuICB9LFxuICBoYW5kbGVFcnJvcjogZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyb3IpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5vbkVycm9yKSB7XG4gICAgICB0aGlzLnByb3BzLm9uRXJyb3IuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRocm93IGVycm9ycyBieSBkZWZhdWx0IHNvIHdlIGRvbid0IHNpbGVudGx5IHN3YWxsb3cgdGhlbSFcbiAgICAgIHRocm93IGVycm9yOyAvLyBUaGlzIGVycm9yIHByb2JhYmx5IG9jY3VycmVkIGluIGdldENoaWxkUm91dGVzIG9yIGdldENvbXBvbmVudHMuXG4gICAgfVxuICB9LFxuICBjb21wb25lbnRXaWxsTW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHBhcnNlUXVlcnlTdHJpbmcgPSBfcHJvcHMucGFyc2VRdWVyeVN0cmluZztcbiAgICB2YXIgc3RyaW5naWZ5UXVlcnkgPSBfcHJvcHMuc3RyaW5naWZ5UXVlcnk7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KSghKHBhcnNlUXVlcnlTdHJpbmcgfHwgc3RyaW5naWZ5UXVlcnkpLCAnYHBhcnNlUXVlcnlTdHJpbmdgIGFuZCBgc3RyaW5naWZ5UXVlcnlgIGFyZSBkZXByZWNhdGVkLiBQbGVhc2UgY3JlYXRlIGEgY3VzdG9tIGhpc3RvcnkuIGh0dHA6Ly90aW55LmNjL3JvdXRlci1jdXN0b21xdWVyeXN0cmluZycpIDogdm9pZCAwO1xuXG4gICAgdmFyIF9jcmVhdGVSb3V0ZXJPYmplY3RzID0gdGhpcy5jcmVhdGVSb3V0ZXJPYmplY3RzKCk7XG5cbiAgICB2YXIgaGlzdG9yeSA9IF9jcmVhdGVSb3V0ZXJPYmplY3RzLmhpc3Rvcnk7XG4gICAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gX2NyZWF0ZVJvdXRlck9iamVjdHMudHJhbnNpdGlvbk1hbmFnZXI7XG4gICAgdmFyIHJvdXRlciA9IF9jcmVhdGVSb3V0ZXJPYmplY3RzLnJvdXRlcjtcblxuXG4gICAgdGhpcy5fdW5saXN0ZW4gPSB0cmFuc2l0aW9uTWFuYWdlci5saXN0ZW4oZnVuY3Rpb24gKGVycm9yLCBzdGF0ZSkge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIF90aGlzLmhhbmRsZUVycm9yKGVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLnNldFN0YXRlKHN0YXRlLCBfdGhpcy5wcm9wcy5vblVwZGF0ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmhpc3RvcnkgPSBoaXN0b3J5O1xuICAgIHRoaXMucm91dGVyID0gcm91dGVyO1xuICB9LFxuICBjcmVhdGVSb3V0ZXJPYmplY3RzOiBmdW5jdGlvbiBjcmVhdGVSb3V0ZXJPYmplY3RzKCkge1xuICAgIHZhciBtYXRjaENvbnRleHQgPSB0aGlzLnByb3BzLm1hdGNoQ29udGV4dDtcblxuICAgIGlmIChtYXRjaENvbnRleHQpIHtcbiAgICAgIHJldHVybiBtYXRjaENvbnRleHQ7XG4gICAgfVxuXG4gICAgdmFyIGhpc3RvcnkgPSB0aGlzLnByb3BzLmhpc3Rvcnk7XG4gICAgdmFyIF9wcm9wczIgPSB0aGlzLnByb3BzO1xuICAgIHZhciByb3V0ZXMgPSBfcHJvcHMyLnJvdXRlcztcbiAgICB2YXIgY2hpbGRyZW4gPSBfcHJvcHMyLmNoaWxkcmVuO1xuXG5cbiAgICAhIWlzVW5zdXBwb3J0ZWRIaXN0b3J5KGhpc3RvcnkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ1lvdSBoYXZlIHByb3ZpZGVkIGEgaGlzdG9yeSBvYmplY3QgY3JlYXRlZCB3aXRoIGhpc3RvcnkgdjMueC4gJyArICdUaGlzIHZlcnNpb24gb2YgUmVhY3QgUm91dGVyIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdjMgaGlzdG9yeSAnICsgJ29iamVjdHMuIFBsZWFzZSB1c2UgaGlzdG9yeSB2Mi54IGluc3RlYWQuJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgaWYgKGlzRGVwcmVjYXRlZEhpc3RvcnkoaGlzdG9yeSkpIHtcbiAgICAgIGhpc3RvcnkgPSB0aGlzLndyYXBEZXByZWNhdGVkSGlzdG9yeShoaXN0b3J5KTtcbiAgICB9XG5cbiAgICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSAoMCwgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMi5kZWZhdWx0KShoaXN0b3J5LCAoMCwgX1JvdXRlVXRpbHMuY3JlYXRlUm91dGVzKShyb3V0ZXMgfHwgY2hpbGRyZW4pKTtcbiAgICB2YXIgcm91dGVyID0gKDAsIF9Sb3V0ZXJVdGlscy5jcmVhdGVSb3V0ZXJPYmplY3QpKGhpc3RvcnksIHRyYW5zaXRpb25NYW5hZ2VyKTtcbiAgICB2YXIgcm91dGluZ0hpc3RvcnkgPSAoMCwgX1JvdXRlclV0aWxzLmNyZWF0ZVJvdXRpbmdIaXN0b3J5KShoaXN0b3J5LCB0cmFuc2l0aW9uTWFuYWdlcik7XG5cbiAgICByZXR1cm4geyBoaXN0b3J5OiByb3V0aW5nSGlzdG9yeSwgdHJhbnNpdGlvbk1hbmFnZXI6IHRyYW5zaXRpb25NYW5hZ2VyLCByb3V0ZXI6IHJvdXRlciB9O1xuICB9LFxuICB3cmFwRGVwcmVjYXRlZEhpc3Rvcnk6IGZ1bmN0aW9uIHdyYXBEZXByZWNhdGVkSGlzdG9yeShoaXN0b3J5KSB7XG4gICAgdmFyIF9wcm9wczMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBwYXJzZVF1ZXJ5U3RyaW5nID0gX3Byb3BzMy5wYXJzZVF1ZXJ5U3RyaW5nO1xuICAgIHZhciBzdHJpbmdpZnlRdWVyeSA9IF9wcm9wczMuc3RyaW5naWZ5UXVlcnk7XG5cblxuICAgIHZhciBjcmVhdGVIaXN0b3J5ID0gdm9pZCAwO1xuICAgIGlmIChoaXN0b3J5KSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ0l0IGFwcGVhcnMgeW91IGhhdmUgcHJvdmlkZWQgYSBkZXByZWNhdGVkIGhpc3Rvcnkgb2JqZWN0IHRvIGA8Um91dGVyLz5gLCBwbGVhc2UgdXNlIGEgaGlzdG9yeSBwcm92aWRlZCBieSAnICsgJ1JlYWN0IFJvdXRlciB3aXRoIGBpbXBvcnQgeyBicm93c2VySGlzdG9yeSB9IGZyb20gXFwncmVhY3Qtcm91dGVyXFwnYCBvciBgaW1wb3J0IHsgaGFzaEhpc3RvcnkgfSBmcm9tIFxcJ3JlYWN0LXJvdXRlclxcJ2AuICcgKyAnSWYgeW91IGFyZSB1c2luZyBhIGN1c3RvbSBoaXN0b3J5IHBsZWFzZSBjcmVhdGUgaXQgd2l0aCBgdXNlUm91dGVySGlzdG9yeWAsIHNlZSBodHRwOi8vdGlueS5jYy9yb3V0ZXItdXNpbmdoaXN0b3J5IGZvciBkZXRhaWxzLicpIDogdm9pZCAwO1xuICAgICAgY3JlYXRlSGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUhpc3RvcnkoKSB7XG4gICAgICAgIHJldHVybiBoaXN0b3J5O1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdgUm91dGVyYCBubyBsb25nZXIgZGVmYXVsdHMgdGhlIGhpc3RvcnkgcHJvcCB0byBoYXNoIGhpc3RvcnkuIFBsZWFzZSB1c2UgdGhlIGBoYXNoSGlzdG9yeWAgc2luZ2xldG9uIGluc3RlYWQuIGh0dHA6Ly90aW55LmNjL3JvdXRlci1kZWZhdWx0aGlzdG9yeScpIDogdm9pZCAwO1xuICAgICAgY3JlYXRlSGlzdG9yeSA9IF9jcmVhdGVIYXNoSGlzdG9yeTIuZGVmYXVsdDtcbiAgICB9XG5cbiAgICByZXR1cm4gKDAsIF91c2VRdWVyaWVzMi5kZWZhdWx0KShjcmVhdGVIaXN0b3J5KSh7IHBhcnNlUXVlcnlTdHJpbmc6IHBhcnNlUXVlcnlTdHJpbmcsIHN0cmluZ2lmeVF1ZXJ5OiBzdHJpbmdpZnlRdWVyeSB9KTtcbiAgfSxcblxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzYW5pdHkgY2hlY2sgKi9cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShuZXh0UHJvcHMuaGlzdG9yeSA9PT0gdGhpcy5wcm9wcy5oaXN0b3J5LCAnWW91IGNhbm5vdCBjaGFuZ2UgPFJvdXRlciBoaXN0b3J5PjsgaXQgd2lsbCBiZSBpZ25vcmVkJykgOiB2b2lkIDA7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KSgobmV4dFByb3BzLnJvdXRlcyB8fCBuZXh0UHJvcHMuY2hpbGRyZW4pID09PSAodGhpcy5wcm9wcy5yb3V0ZXMgfHwgdGhpcy5wcm9wcy5jaGlsZHJlbiksICdZb3UgY2Fubm90IGNoYW5nZSA8Um91dGVyIHJvdXRlcz47IGl0IHdpbGwgYmUgaWdub3JlZCcpIDogdm9pZCAwO1xuICB9LFxuICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuX3VubGlzdGVuKSB0aGlzLl91bmxpc3RlbigpO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3N0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgbG9jYXRpb24gPSBfc3RhdGUubG9jYXRpb247XG4gICAgdmFyIHJvdXRlcyA9IF9zdGF0ZS5yb3V0ZXM7XG4gICAgdmFyIHBhcmFtcyA9IF9zdGF0ZS5wYXJhbXM7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBfc3RhdGUuY29tcG9uZW50cztcbiAgICB2YXIgX3Byb3BzNCA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGNyZWF0ZUVsZW1lbnQgPSBfcHJvcHM0LmNyZWF0ZUVsZW1lbnQ7XG4gICAgdmFyIHJlbmRlciA9IF9wcm9wczQucmVuZGVyO1xuXG4gICAgdmFyIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wczQsIFsnY3JlYXRlRWxlbWVudCcsICdyZW5kZXInXSk7XG5cbiAgICBpZiAobG9jYXRpb24gPT0gbnVsbCkgcmV0dXJuIG51bGw7IC8vIEFzeW5jIG1hdGNoXG5cbiAgICAvLyBPbmx5IGZvcndhcmQgbm9uLVJvdXRlci1zcGVjaWZpYyBwcm9wcyB0byByb3V0aW5nIGNvbnRleHQsIGFzIHRob3NlIGFyZVxuICAgIC8vIHRoZSBvbmx5IG9uZXMgdGhhdCBtaWdodCBiZSBjdXN0b20gcm91dGluZyBjb250ZXh0IHByb3BzLlxuICAgIE9iamVjdC5rZXlzKFJvdXRlci5wcm9wVHlwZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3BUeXBlKSB7XG4gICAgICByZXR1cm4gZGVsZXRlIHByb3BzW3Byb3BUeXBlXTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZW5kZXIoX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICBoaXN0b3J5OiB0aGlzLmhpc3RvcnksXG4gICAgICByb3V0ZXI6IHRoaXMucm91dGVyLFxuICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgcm91dGVzOiByb3V0ZXMsXG4gICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHMsXG4gICAgICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50XG4gICAgfSkpO1xuICB9XG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUm91dGVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvUm91dGVyLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX0FjdGlvbnMgPSByZXF1aXJlKCcuL0FjdGlvbnMnKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG52YXIgX0V4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgX0RPTVV0aWxzID0gcmVxdWlyZSgnLi9ET01VdGlscycpO1xuXG52YXIgX0RPTVN0YXRlU3RvcmFnZSA9IHJlcXVpcmUoJy4vRE9NU3RhdGVTdG9yYWdlJyk7XG5cbnZhciBfY3JlYXRlRE9NSGlzdG9yeSA9IHJlcXVpcmUoJy4vY3JlYXRlRE9NSGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZURPTUhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlRE9NSGlzdG9yeSk7XG5cbmZ1bmN0aW9uIGlzQWJzb2x1dGVQYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJyAmJiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufVxuXG5mdW5jdGlvbiBlbnN1cmVTbGFzaCgpIHtcbiAgdmFyIHBhdGggPSBfRE9NVXRpbHMuZ2V0SGFzaFBhdGgoKTtcblxuICBpZiAoaXNBYnNvbHV0ZVBhdGgocGF0aCkpIHJldHVybiB0cnVlO1xuXG4gIF9ET01VdGlscy5yZXBsYWNlSGFzaFBhdGgoJy8nICsgcGF0aCk7XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBhZGRRdWVyeVN0cmluZ1ZhbHVlVG9QYXRoKHBhdGgsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHBhdGggKyAocGF0aC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIChrZXkgKyAnPScgKyB2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIHN0cmlwUXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoKHBhdGgsIGtleSkge1xuICByZXR1cm4gcGF0aC5yZXBsYWNlKG5ldyBSZWdFeHAoJ1s/Jl0/JyArIGtleSArICc9W2EtekEtWjAtOV0rJyksICcnKTtcbn1cblxuZnVuY3Rpb24gZ2V0UXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoKHBhdGgsIGtleSkge1xuICB2YXIgbWF0Y2ggPSBwYXRoLm1hdGNoKG5ldyBSZWdFeHAoJ1xcXFw/Lio/XFxcXGInICsga2V5ICsgJz0oLis/KVxcXFxiJykpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV07XG59XG5cbnZhciBEZWZhdWx0UXVlcnlLZXkgPSAnX2snO1xuXG5mdW5jdGlvbiBjcmVhdGVIYXNoSGlzdG9yeSgpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAhX0V4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlLCAnSGFzaCBoaXN0b3J5IG5lZWRzIGEgRE9NJykgOiBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICB2YXIgcXVlcnlLZXkgPSBvcHRpb25zLnF1ZXJ5S2V5O1xuXG4gIGlmIChxdWVyeUtleSA9PT0gdW5kZWZpbmVkIHx8ICEhcXVlcnlLZXkpIHF1ZXJ5S2V5ID0gdHlwZW9mIHF1ZXJ5S2V5ID09PSAnc3RyaW5nJyA/IHF1ZXJ5S2V5IDogRGVmYXVsdFF1ZXJ5S2V5O1xuXG4gIGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbigpIHtcbiAgICB2YXIgcGF0aCA9IF9ET01VdGlscy5nZXRIYXNoUGF0aCgpO1xuXG4gICAgdmFyIGtleSA9IHVuZGVmaW5lZCxcbiAgICAgICAgc3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHF1ZXJ5S2V5KSB7XG4gICAgICBrZXkgPSBnZXRRdWVyeVN0cmluZ1ZhbHVlRnJvbVBhdGgocGF0aCwgcXVlcnlLZXkpO1xuICAgICAgcGF0aCA9IHN0cmlwUXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoKHBhdGgsIHF1ZXJ5S2V5KTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBzdGF0ZSA9IF9ET01TdGF0ZVN0b3JhZ2UucmVhZFN0YXRlKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZSA9IG51bGw7XG4gICAgICAgIGtleSA9IGhpc3RvcnkuY3JlYXRlS2V5KCk7XG4gICAgICAgIF9ET01VdGlscy5yZXBsYWNlSGFzaFBhdGgoYWRkUXVlcnlTdHJpbmdWYWx1ZVRvUGF0aChwYXRoLCBxdWVyeUtleSwga2V5KSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IHN0YXRlID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbG9jYXRpb24gPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChwYXRoKTtcblxuICAgIHJldHVybiBoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uKF9leHRlbmRzKHt9LCBsb2NhdGlvbiwgeyBzdGF0ZTogc3RhdGUgfSksIHVuZGVmaW5lZCwga2V5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0SGFzaENoYW5nZUxpc3RlbmVyKF9yZWYpIHtcbiAgICB2YXIgdHJhbnNpdGlvblRvID0gX3JlZi50cmFuc2l0aW9uVG87XG5cbiAgICBmdW5jdGlvbiBoYXNoQ2hhbmdlTGlzdGVuZXIoKSB7XG4gICAgICBpZiAoIWVuc3VyZVNsYXNoKCkpIHJldHVybjsgLy8gQWx3YXlzIG1ha2Ugc3VyZSBoYXNoZXMgYXJlIHByZWNlZWRlZCB3aXRoIGEgLy5cblxuICAgICAgdHJhbnNpdGlvblRvKGdldEN1cnJlbnRMb2NhdGlvbigpKTtcbiAgICB9XG5cbiAgICBlbnN1cmVTbGFzaCgpO1xuICAgIF9ET01VdGlscy5hZGRFdmVudExpc3RlbmVyKHdpbmRvdywgJ2hhc2hjaGFuZ2UnLCBoYXNoQ2hhbmdlTGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIF9ET01VdGlscy5yZW1vdmVFdmVudExpc3RlbmVyKHdpbmRvdywgJ2hhc2hjaGFuZ2UnLCBoYXNoQ2hhbmdlTGlzdGVuZXIpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2hUcmFuc2l0aW9uKGxvY2F0aW9uKSB7XG4gICAgdmFyIGJhc2VuYW1lID0gbG9jYXRpb24uYmFzZW5hbWU7XG4gICAgdmFyIHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWU7XG4gICAgdmFyIHNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaDtcbiAgICB2YXIgc3RhdGUgPSBsb2NhdGlvbi5zdGF0ZTtcbiAgICB2YXIgYWN0aW9uID0gbG9jYXRpb24uYWN0aW9uO1xuICAgIHZhciBrZXkgPSBsb2NhdGlvbi5rZXk7XG5cbiAgICBpZiAoYWN0aW9uID09PSBfQWN0aW9ucy5QT1ApIHJldHVybjsgLy8gTm90aGluZyB0byBkby5cblxuICAgIHZhciBwYXRoID0gKGJhc2VuYW1lIHx8ICcnKSArIHBhdGhuYW1lICsgc2VhcmNoO1xuXG4gICAgaWYgKHF1ZXJ5S2V5KSB7XG4gICAgICBwYXRoID0gYWRkUXVlcnlTdHJpbmdWYWx1ZVRvUGF0aChwYXRoLCBxdWVyeUtleSwga2V5KTtcbiAgICAgIF9ET01TdGF0ZVN0b3JhZ2Uuc2F2ZVN0YXRlKGtleSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEcm9wIGtleSBhbmQgc3RhdGUuXG4gICAgICBsb2NhdGlvbi5rZXkgPSBsb2NhdGlvbi5zdGF0ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRIYXNoID0gX0RPTVV0aWxzLmdldEhhc2hQYXRoKCk7XG5cbiAgICBpZiAoYWN0aW9uID09PSBfQWN0aW9ucy5QVVNIKSB7XG4gICAgICBpZiAoY3VycmVudEhhc2ggIT09IHBhdGgpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBwYXRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKGZhbHNlLCAnWW91IGNhbm5vdCBQVVNIIHRoZSBzYW1lIHBhdGggdXNpbmcgaGFzaCBoaXN0b3J5JykgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjdXJyZW50SGFzaCAhPT0gcGF0aCkge1xuICAgICAgLy8gUkVQTEFDRVxuICAgICAgX0RPTVV0aWxzLnJlcGxhY2VIYXNoUGF0aChwYXRoKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaGlzdG9yeSA9IF9jcmVhdGVET01IaXN0b3J5MlsnZGVmYXVsdCddKF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgZ2V0Q3VycmVudExvY2F0aW9uOiBnZXRDdXJyZW50TG9jYXRpb24sXG4gICAgZmluaXNoVHJhbnNpdGlvbjogZmluaXNoVHJhbnNpdGlvbixcbiAgICBzYXZlU3RhdGU6IF9ET01TdGF0ZVN0b3JhZ2Uuc2F2ZVN0YXRlXG4gIH0pKTtcblxuICB2YXIgbGlzdGVuZXJDb3VudCA9IDAsXG4gICAgICBzdG9wSGFzaENoYW5nZUxpc3RlbmVyID0gdW5kZWZpbmVkO1xuXG4gIGZ1bmN0aW9uIGxpc3RlbkJlZm9yZShsaXN0ZW5lcikge1xuICAgIGlmICgrK2xpc3RlbmVyQ291bnQgPT09IDEpIHN0b3BIYXNoQ2hhbmdlTGlzdGVuZXIgPSBzdGFydEhhc2hDaGFuZ2VMaXN0ZW5lcihoaXN0b3J5KTtcblxuICAgIHZhciB1bmxpc3RlbiA9IGhpc3RvcnkubGlzdGVuQmVmb3JlKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB1bmxpc3RlbigpO1xuXG4gICAgICBpZiAoLS1saXN0ZW5lckNvdW50ID09PSAwKSBzdG9wSGFzaENoYW5nZUxpc3RlbmVyKCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIGlmICgrK2xpc3RlbmVyQ291bnQgPT09IDEpIHN0b3BIYXNoQ2hhbmdlTGlzdGVuZXIgPSBzdGFydEhhc2hDaGFuZ2VMaXN0ZW5lcihoaXN0b3J5KTtcblxuICAgIHZhciB1bmxpc3RlbiA9IGhpc3RvcnkubGlzdGVuKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB1bmxpc3RlbigpO1xuXG4gICAgICBpZiAoLS1saXN0ZW5lckNvdW50ID09PSAwKSBzdG9wSGFzaENoYW5nZUxpc3RlbmVyKCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2gobG9jYXRpb24pIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10ocXVlcnlLZXkgfHwgbG9jYXRpb24uc3RhdGUgPT0gbnVsbCwgJ1lvdSBjYW5ub3QgdXNlIHN0YXRlIHdpdGhvdXQgYSBxdWVyeUtleSBpdCB3aWxsIGJlIGRyb3BwZWQnKSA6IHVuZGVmaW5lZDtcblxuICAgIGhpc3RvcnkucHVzaChsb2NhdGlvbik7XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlKGxvY2F0aW9uKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKHF1ZXJ5S2V5IHx8IGxvY2F0aW9uLnN0YXRlID09IG51bGwsICdZb3UgY2Fubm90IHVzZSBzdGF0ZSB3aXRob3V0IGEgcXVlcnlLZXkgaXQgd2lsbCBiZSBkcm9wcGVkJykgOiB1bmRlZmluZWQ7XG5cbiAgICBoaXN0b3J5LnJlcGxhY2UobG9jYXRpb24pO1xuICB9XG5cbiAgdmFyIGdvSXNTdXBwb3J0ZWRXaXRob3V0UmVsb2FkID0gX0RPTVV0aWxzLnN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoKCk7XG5cbiAgZnVuY3Rpb24gZ28obikge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShnb0lzU3VwcG9ydGVkV2l0aG91dFJlbG9hZCwgJ0hhc2ggaGlzdG9yeSBnbyhuKSBjYXVzZXMgYSBmdWxsIHBhZ2UgcmVsb2FkIGluIHRoaXMgYnJvd3NlcicpIDogdW5kZWZpbmVkO1xuXG4gICAgaGlzdG9yeS5nbyhuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUhyZWYocGF0aCkge1xuICAgIHJldHVybiAnIycgKyBoaXN0b3J5LmNyZWF0ZUhyZWYocGF0aCk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyVHJhbnNpdGlvbkhvb2soaG9vaykge1xuICAgIGlmICgrK2xpc3RlbmVyQ291bnQgPT09IDEpIHN0b3BIYXNoQ2hhbmdlTGlzdGVuZXIgPSBzdGFydEhhc2hDaGFuZ2VMaXN0ZW5lcihoaXN0b3J5KTtcblxuICAgIGhpc3RvcnkucmVnaXN0ZXJUcmFuc2l0aW9uSG9vayhob29rKTtcbiAgfVxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgZnVuY3Rpb24gdW5yZWdpc3RlclRyYW5zaXRpb25Ib29rKGhvb2spIHtcbiAgICBoaXN0b3J5LnVucmVnaXN0ZXJUcmFuc2l0aW9uSG9vayhob29rKTtcblxuICAgIGlmICgtLWxpc3RlbmVyQ291bnQgPT09IDApIHN0b3BIYXNoQ2hhbmdlTGlzdGVuZXIoKTtcbiAgfVxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgZnVuY3Rpb24gcHVzaFN0YXRlKHN0YXRlLCBwYXRoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKHF1ZXJ5S2V5IHx8IHN0YXRlID09IG51bGwsICdZb3UgY2Fubm90IHVzZSBzdGF0ZSB3aXRob3V0IGEgcXVlcnlLZXkgaXQgd2lsbCBiZSBkcm9wcGVkJykgOiB1bmRlZmluZWQ7XG5cbiAgICBoaXN0b3J5LnB1c2hTdGF0ZShzdGF0ZSwgcGF0aCk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHJlcGxhY2VTdGF0ZShzdGF0ZSwgcGF0aCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShxdWVyeUtleSB8fCBzdGF0ZSA9PSBudWxsLCAnWW91IGNhbm5vdCB1c2Ugc3RhdGUgd2l0aG91dCBhIHF1ZXJ5S2V5IGl0IHdpbGwgYmUgZHJvcHBlZCcpIDogdW5kZWZpbmVkO1xuXG4gICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoc3RhdGUsIHBhdGgpO1xuICB9XG5cbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBoaXN0b3J5LCB7XG4gICAgbGlzdGVuQmVmb3JlOiBsaXN0ZW5CZWZvcmUsXG4gICAgbGlzdGVuOiBsaXN0ZW4sXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuXG4gICAgcmVnaXN0ZXJUcmFuc2l0aW9uSG9vazogcmVnaXN0ZXJUcmFuc2l0aW9uSG9vaywgLy8gZGVwcmVjYXRlZCAtIHdhcm5pbmcgaXMgaW4gY3JlYXRlSGlzdG9yeVxuICAgIHVucmVnaXN0ZXJUcmFuc2l0aW9uSG9vazogdW5yZWdpc3RlclRyYW5zaXRpb25Ib29rLCAvLyBkZXByZWNhdGVkIC0gd2FybmluZyBpcyBpbiBjcmVhdGVIaXN0b3J5XG4gICAgcHVzaFN0YXRlOiBwdXNoU3RhdGUsIC8vIGRlcHJlY2F0ZWQgLSB3YXJuaW5nIGlzIGluIGNyZWF0ZUhpc3RvcnlcbiAgICByZXBsYWNlU3RhdGU6IHJlcGxhY2VTdGF0ZSAvLyBkZXByZWNhdGVkIC0gd2FybmluZyBpcyBpbiBjcmVhdGVIaXN0b3J5XG4gIH0pO1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBjcmVhdGVIYXNoSGlzdG9yeTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9oaXN0b3J5L2xpYi9jcmVhdGVIYXNoSGlzdG9yeS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB3YXJuaW5nID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGFyZ3MpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiA+IDIgPyBsZW4gLSAyIDogMCk7XG4gICAgZm9yICh2YXIga2V5ID0gMjsga2V5IDwgbGVuOyBrZXkrKykge1xuICAgICAgYXJnc1trZXkgLSAyXSA9IGFyZ3VtZW50c1trZXldO1xuICAgIH1cbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgK1xuICAgICAgICAnbWVzc2FnZSBhcmd1bWVudCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdC5sZW5ndGggPCAxMCB8fCAoL15bc1xcV10qJC8pLnRlc3QoZm9ybWF0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVGhlIHdhcm5pbmcgZm9ybWF0IHNob3VsZCBiZSBhYmxlIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgJyArXG4gICAgICAgICd3YXJuaW5nLiBQbGVhc2UsIHVzZSBhIG1vcmUgZGVzY3JpcHRpdmUgZm9ybWF0IHRoYW46ICcgKyBmb3JtYXRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICtcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfSBjYXRjaCh4KSB7fVxuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2hpc3Rvcnkvfi93YXJuaW5nL2Jyb3dzZXIuanNcbiAqKi8iLCIvKipcbiAqIEluZGljYXRlcyB0aGF0IG5hdmlnYXRpb24gd2FzIGNhdXNlZCBieSBhIGNhbGwgdG8gaGlzdG9yeS5wdXNoLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgUFVTSCA9ICdQVVNIJztcblxuZXhwb3J0cy5QVVNIID0gUFVTSDtcbi8qKlxuICogSW5kaWNhdGVzIHRoYXQgbmF2aWdhdGlvbiB3YXMgY2F1c2VkIGJ5IGEgY2FsbCB0byBoaXN0b3J5LnJlcGxhY2UuXG4gKi9cbnZhciBSRVBMQUNFID0gJ1JFUExBQ0UnO1xuXG5leHBvcnRzLlJFUExBQ0UgPSBSRVBMQUNFO1xuLyoqXG4gKiBJbmRpY2F0ZXMgdGhhdCBuYXZpZ2F0aW9uIHdhcyBjYXVzZWQgYnkgc29tZSBvdGhlciBhY3Rpb24gc3VjaFxuICogYXMgdXNpbmcgYSBicm93c2VyJ3MgYmFjay9mb3J3YXJkIGJ1dHRvbnMgYW5kL29yIG1hbnVhbGx5IG1hbmlwdWxhdGluZ1xuICogdGhlIFVSTCBpbiBhIGJyb3dzZXIncyBsb2NhdGlvbiBiYXIuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXG4gKlxuICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3dFdmVudEhhbmRsZXJzL29ucG9wc3RhdGVcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICovXG52YXIgUE9QID0gJ1BPUCc7XG5cbmV4cG9ydHMuUE9QID0gUE9QO1xuZXhwb3J0c1snZGVmYXVsdCddID0ge1xuICBQVVNIOiBQVVNILFxuICBSRVBMQUNFOiBSRVBMQUNFLFxuICBQT1A6IFBPUFxufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vaGlzdG9yeS9saWIvQWN0aW9ucy5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZXh0cmFjdFBhdGggPSBleHRyYWN0UGF0aDtcbmV4cG9ydHMucGFyc2VQYXRoID0gcGFyc2VQYXRoO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBleHRyYWN0UGF0aChzdHJpbmcpIHtcbiAgdmFyIG1hdGNoID0gc3RyaW5nLm1hdGNoKC9eaHR0cHM/OlxcL1xcL1teXFwvXSovKTtcblxuICBpZiAobWF0Y2ggPT0gbnVsbCkgcmV0dXJuIHN0cmluZztcblxuICByZXR1cm4gc3RyaW5nLnN1YnN0cmluZyhtYXRjaFswXS5sZW5ndGgpO1xufVxuXG5mdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkge1xuICB2YXIgcGF0aG5hbWUgPSBleHRyYWN0UGF0aChwYXRoKTtcbiAgdmFyIHNlYXJjaCA9ICcnO1xuICB2YXIgaGFzaCA9ICcnO1xuXG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShwYXRoID09PSBwYXRobmFtZSwgJ0EgcGF0aCBtdXN0IGJlIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaCBvbmx5LCBub3QgYSBmdWxseSBxdWFsaWZpZWQgVVJMIGxpa2UgXCIlc1wiJywgcGF0aCkgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIGhhc2hJbmRleCA9IHBhdGhuYW1lLmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2hJbmRleCAhPT0gLTEpIHtcbiAgICBoYXNoID0gcGF0aG5hbWUuc3Vic3RyaW5nKGhhc2hJbmRleCk7XG4gICAgcGF0aG5hbWUgPSBwYXRobmFtZS5zdWJzdHJpbmcoMCwgaGFzaEluZGV4KTtcbiAgfVxuXG4gIHZhciBzZWFyY2hJbmRleCA9IHBhdGhuYW1lLmluZGV4T2YoJz8nKTtcbiAgaWYgKHNlYXJjaEluZGV4ICE9PSAtMSkge1xuICAgIHNlYXJjaCA9IHBhdGhuYW1lLnN1YnN0cmluZyhzZWFyY2hJbmRleCk7XG4gICAgcGF0aG5hbWUgPSBwYXRobmFtZS5zdWJzdHJpbmcoMCwgc2VhcmNoSW5kZXgpO1xuICB9XG5cbiAgaWYgKHBhdGhuYW1lID09PSAnJykgcGF0aG5hbWUgPSAnLyc7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZTogcGF0aG5hbWUsXG4gICAgc2VhcmNoOiBzZWFyY2gsXG4gICAgaGFzaDogaGFzaFxuICB9O1xufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9oaXN0b3J5L2xpYi9QYXRoVXRpbHMuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbmV4cG9ydHMuY2FuVXNlRE9NID0gY2FuVXNlRE9NO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9oaXN0b3J5L2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuYWRkRXZlbnRMaXN0ZW5lciA9IGFkZEV2ZW50TGlzdGVuZXI7XG5leHBvcnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSByZW1vdmVFdmVudExpc3RlbmVyO1xuZXhwb3J0cy5nZXRIYXNoUGF0aCA9IGdldEhhc2hQYXRoO1xuZXhwb3J0cy5yZXBsYWNlSGFzaFBhdGggPSByZXBsYWNlSGFzaFBhdGg7XG5leHBvcnRzLmdldFdpbmRvd1BhdGggPSBnZXRXaW5kb3dQYXRoO1xuZXhwb3J0cy5nbyA9IGdvO1xuZXhwb3J0cy5nZXRVc2VyQ29uZmlybWF0aW9uID0gZ2V0VXNlckNvbmZpcm1hdGlvbjtcbmV4cG9ydHMuc3VwcG9ydHNIaXN0b3J5ID0gc3VwcG9ydHNIaXN0b3J5O1xuZXhwb3J0cy5zdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCA9IHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoO1xuXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50LCBsaXN0ZW5lcikge1xuICBpZiAobm9kZS5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudCwgbGlzdGVuZXIpIHtcbiAgaWYgKG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgfSBlbHNlIHtcbiAgICBub2RlLmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEhhc2hQYXRoKCkge1xuICAvLyBXZSBjYW4ndCB1c2Ugd2luZG93LmxvY2F0aW9uLmhhc2ggaGVyZSBiZWNhdXNlIGl0J3Mgbm90XG4gIC8vIGNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzIC0gRmlyZWZveCB3aWxsIHByZS1kZWNvZGUgaXQhXG4gIHJldHVybiB3aW5kb3cubG9jYXRpb24uaHJlZi5zcGxpdCgnIycpWzFdIHx8ICcnO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlSGFzaFBhdGgocGF0aCkge1xuICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZSh3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoICsgJyMnICsgcGF0aCk7XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvd1BhdGgoKSB7XG4gIHJldHVybiB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoICsgd2luZG93LmxvY2F0aW9uLmhhc2g7XG59XG5cbmZ1bmN0aW9uIGdvKG4pIHtcbiAgaWYgKG4pIHdpbmRvdy5oaXN0b3J5LmdvKG4pO1xufVxuXG5mdW5jdGlvbiBnZXRVc2VyQ29uZmlybWF0aW9uKG1lc3NhZ2UsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrKHdpbmRvdy5jb25maXJtKG1lc3NhZ2UpKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIEhUTUw1IGhpc3RvcnkgQVBJIGlzIHN1cHBvcnRlZC4gVGFrZW4gZnJvbSBNb2Rlcm5penIuXG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2hpc3RvcnkuanNcbiAqIGNoYW5nZWQgdG8gYXZvaWQgZmFsc2UgbmVnYXRpdmVzIGZvciBXaW5kb3dzIFBob25lczogaHR0cHM6Ly9naXRodWIuY29tL3JhY2t0L3JlYWN0LXJvdXRlci9pc3N1ZXMvNTg2XG4gKi9cblxuZnVuY3Rpb24gc3VwcG9ydHNIaXN0b3J5KCkge1xuICB2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICBpZiAoKHVhLmluZGV4T2YoJ0FuZHJvaWQgMi4nKSAhPT0gLTEgfHwgdWEuaW5kZXhPZignQW5kcm9pZCA0LjAnKSAhPT0gLTEpICYmIHVhLmluZGV4T2YoJ01vYmlsZSBTYWZhcmknKSAhPT0gLTEgJiYgdWEuaW5kZXhPZignQ2hyb21lJykgPT09IC0xICYmIHVhLmluZGV4T2YoJ1dpbmRvd3MgUGhvbmUnKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5ICYmICdwdXNoU3RhdGUnIGluIHdpbmRvdy5oaXN0b3J5O1xufVxuXG4vKipcbiAqIFJldHVybnMgZmFsc2UgaWYgdXNpbmcgZ28obikgd2l0aCBoYXNoIGhpc3RvcnkgY2F1c2VzIGEgZnVsbCBwYWdlIHJlbG9hZC5cbiAqL1xuXG5mdW5jdGlvbiBzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCgpIHtcbiAgdmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgcmV0dXJuIHVhLmluZGV4T2YoJ0ZpcmVmb3gnKSA9PT0gLTE7XG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2hpc3RvcnkvbGliL0RPTVV0aWxzLmpzXG4gKiovIiwiLyplc2xpbnQtZGlzYWJsZSBuby1lbXB0eSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5zYXZlU3RhdGUgPSBzYXZlU3RhdGU7XG5leHBvcnRzLnJlYWRTdGF0ZSA9IHJlYWRTdGF0ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIEtleVByZWZpeCA9ICdAQEhpc3RvcnkvJztcbnZhciBRdW90YUV4Y2VlZGVkRXJyb3JzID0gWydRdW90YUV4Y2VlZGVkRXJyb3InLCAnUVVPVEFfRVhDRUVERURfRVJSJ107XG5cbnZhciBTZWN1cml0eUVycm9yID0gJ1NlY3VyaXR5RXJyb3InO1xuXG5mdW5jdGlvbiBjcmVhdGVLZXkoa2V5KSB7XG4gIHJldHVybiBLZXlQcmVmaXggKyBrZXk7XG59XG5cbmZ1bmN0aW9uIHNhdmVTdGF0ZShrZXksIHN0YXRlKSB7XG4gIHRyeSB7XG4gICAgaWYgKHN0YXRlID09IG51bGwpIHtcbiAgICAgIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKGNyZWF0ZUtleShrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oY3JlYXRlS2V5KGtleSksIEpTT04uc3RyaW5naWZ5KHN0YXRlKSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvci5uYW1lID09PSBTZWN1cml0eUVycm9yKSB7XG4gICAgICAvLyBCbG9ja2luZyBjb29raWVzIGluIENocm9tZS9GaXJlZm94L1NhZmFyaSB0aHJvd3MgU2VjdXJpdHlFcnJvciBvbiBhbnlcbiAgICAgIC8vIGF0dGVtcHQgdG8gYWNjZXNzIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgJ1toaXN0b3J5XSBVbmFibGUgdG8gc2F2ZSBzdGF0ZTsgc2Vzc2lvblN0b3JhZ2UgaXMgbm90IGF2YWlsYWJsZSBkdWUgdG8gc2VjdXJpdHkgc2V0dGluZ3MnKSA6IHVuZGVmaW5lZDtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChRdW90YUV4Y2VlZGVkRXJyb3JzLmluZGV4T2YoZXJyb3IubmFtZSkgPj0gMCAmJiB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBTYWZhcmkgXCJwcml2YXRlIG1vZGVcIiB0aHJvd3MgUXVvdGFFeGNlZWRlZEVycm9yLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKGZhbHNlLCAnW2hpc3RvcnldIFVuYWJsZSB0byBzYXZlIHN0YXRlOyBzZXNzaW9uU3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlIGluIFNhZmFyaSBwcml2YXRlIG1vZGUnKSA6IHVuZGVmaW5lZDtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlYWRTdGF0ZShrZXkpIHtcbiAgdmFyIGpzb24gPSB1bmRlZmluZWQ7XG4gIHRyeSB7XG4gICAganNvbiA9IHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKGNyZWF0ZUtleShrZXkpKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IubmFtZSA9PT0gU2VjdXJpdHlFcnJvcikge1xuICAgICAgLy8gQmxvY2tpbmcgY29va2llcyBpbiBDaHJvbWUvRmlyZWZveC9TYWZhcmkgdGhyb3dzIFNlY3VyaXR5RXJyb3Igb24gYW55XG4gICAgICAvLyBhdHRlbXB0IHRvIGFjY2VzcyB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10oZmFsc2UsICdbaGlzdG9yeV0gVW5hYmxlIHRvIHJlYWQgc3RhdGU7IHNlc3Npb25TdG9yYWdlIGlzIG5vdCBhdmFpbGFibGUgZHVlIHRvIHNlY3VyaXR5IHNldHRpbmdzJykgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGlmIChqc29uKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGpzb24pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBJZ25vcmUgaW52YWxpZCBKU09OLlxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9oaXN0b3J5L2xpYi9ET01TdGF0ZVN0b3JhZ2UuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9FeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIF9ET01VdGlscyA9IHJlcXVpcmUoJy4vRE9NVXRpbHMnKTtcblxudmFyIF9jcmVhdGVIaXN0b3J5ID0gcmVxdWlyZSgnLi9jcmVhdGVIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlSGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVIaXN0b3J5KTtcblxuZnVuY3Rpb24gY3JlYXRlRE9NSGlzdG9yeShvcHRpb25zKSB7XG4gIHZhciBoaXN0b3J5ID0gX2NyZWF0ZUhpc3RvcnkyWydkZWZhdWx0J10oX2V4dGVuZHMoe1xuICAgIGdldFVzZXJDb25maXJtYXRpb246IF9ET01VdGlscy5nZXRVc2VyQ29uZmlybWF0aW9uXG4gIH0sIG9wdGlvbnMsIHtcbiAgICBnbzogX0RPTVV0aWxzLmdvXG4gIH0pKTtcblxuICBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICAhX0V4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlLCAnRE9NIGhpc3RvcnkgbmVlZHMgYSBET00nKSA6IF9pbnZhcmlhbnQyWydkZWZhdWx0J10oZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIGhpc3RvcnkubGlzdGVuKGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwge1xuICAgIGxpc3RlbjogbGlzdGVuXG4gIH0pO1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBjcmVhdGVET01IaXN0b3J5O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2hpc3RvcnkvbGliL2NyZWF0ZURPTUhpc3RvcnkuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfZGVlcEVxdWFsID0gcmVxdWlyZSgnZGVlcC1lcXVhbCcpO1xuXG52YXIgX2RlZXBFcXVhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWVwRXF1YWwpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbnZhciBfQXN5bmNVdGlscyA9IHJlcXVpcmUoJy4vQXN5bmNVdGlscycpO1xuXG52YXIgX0FjdGlvbnMgPSByZXF1aXJlKCcuL0FjdGlvbnMnKTtcblxudmFyIF9jcmVhdGVMb2NhdGlvbjIgPSByZXF1aXJlKCcuL2NyZWF0ZUxvY2F0aW9uJyk7XG5cbnZhciBfY3JlYXRlTG9jYXRpb24zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlTG9jYXRpb24yKTtcblxudmFyIF9ydW5UcmFuc2l0aW9uSG9vayA9IHJlcXVpcmUoJy4vcnVuVHJhbnNpdGlvbkhvb2snKTtcblxudmFyIF9ydW5UcmFuc2l0aW9uSG9vazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ydW5UcmFuc2l0aW9uSG9vayk7XG5cbnZhciBfZGVwcmVjYXRlID0gcmVxdWlyZSgnLi9kZXByZWNhdGUnKTtcblxudmFyIF9kZXByZWNhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVwcmVjYXRlKTtcblxuZnVuY3Rpb24gY3JlYXRlUmFuZG9tS2V5KGxlbmd0aCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIGxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGxvY2F0aW9uc0FyZUVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEucGF0aG5hbWUgPT09IGIucGF0aG5hbWUgJiYgYS5zZWFyY2ggPT09IGIuc2VhcmNoICYmXG4gIC8vYS5hY3Rpb24gPT09IGIuYWN0aW9uICYmIC8vIERpZmZlcmVudCBhY3Rpb24gIT09IGxvY2F0aW9uIGNoYW5nZS5cbiAgYS5rZXkgPT09IGIua2V5ICYmIF9kZWVwRXF1YWwyWydkZWZhdWx0J10oYS5zdGF0ZSwgYi5zdGF0ZSk7XG59XG5cbnZhciBEZWZhdWx0S2V5TGVuZ3RoID0gNjtcblxuZnVuY3Rpb24gY3JlYXRlSGlzdG9yeSgpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcbiAgdmFyIGdldEN1cnJlbnRMb2NhdGlvbiA9IG9wdGlvbnMuZ2V0Q3VycmVudExvY2F0aW9uO1xuICB2YXIgZmluaXNoVHJhbnNpdGlvbiA9IG9wdGlvbnMuZmluaXNoVHJhbnNpdGlvbjtcbiAgdmFyIHNhdmVTdGF0ZSA9IG9wdGlvbnMuc2F2ZVN0YXRlO1xuICB2YXIgZ28gPSBvcHRpb25zLmdvO1xuICB2YXIgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IG9wdGlvbnMuZ2V0VXNlckNvbmZpcm1hdGlvbjtcbiAgdmFyIGtleUxlbmd0aCA9IG9wdGlvbnMua2V5TGVuZ3RoO1xuXG4gIGlmICh0eXBlb2Yga2V5TGVuZ3RoICE9PSAnbnVtYmVyJykga2V5TGVuZ3RoID0gRGVmYXVsdEtleUxlbmd0aDtcblxuICB2YXIgdHJhbnNpdGlvbkhvb2tzID0gW107XG5cbiAgZnVuY3Rpb24gbGlzdGVuQmVmb3JlKGhvb2spIHtcbiAgICB0cmFuc2l0aW9uSG9va3MucHVzaChob29rKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB0cmFuc2l0aW9uSG9va3MgPSB0cmFuc2l0aW9uSG9va3MuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtICE9PSBob29rO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBhbGxLZXlzID0gW107XG4gIHZhciBjaGFuZ2VMaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIGxvY2F0aW9uID0gdW5kZWZpbmVkO1xuXG4gIGZ1bmN0aW9uIGdldEN1cnJlbnQoKSB7XG4gICAgaWYgKHBlbmRpbmdMb2NhdGlvbiAmJiBwZW5kaW5nTG9jYXRpb24uYWN0aW9uID09PSBfQWN0aW9ucy5QT1ApIHtcbiAgICAgIHJldHVybiBhbGxLZXlzLmluZGV4T2YocGVuZGluZ0xvY2F0aW9uLmtleSk7XG4gICAgfSBlbHNlIGlmIChsb2NhdGlvbikge1xuICAgICAgcmV0dXJuIGFsbEtleXMuaW5kZXhPZihsb2NhdGlvbi5rZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTG9jYXRpb24obmV3TG9jYXRpb24pIHtcbiAgICB2YXIgY3VycmVudCA9IGdldEN1cnJlbnQoKTtcblxuICAgIGxvY2F0aW9uID0gbmV3TG9jYXRpb247XG5cbiAgICBpZiAobG9jYXRpb24uYWN0aW9uID09PSBfQWN0aW9ucy5QVVNIKSB7XG4gICAgICBhbGxLZXlzID0gW10uY29uY2F0KGFsbEtleXMuc2xpY2UoMCwgY3VycmVudCArIDEpLCBbbG9jYXRpb24ua2V5XSk7XG4gICAgfSBlbHNlIGlmIChsb2NhdGlvbi5hY3Rpb24gPT09IF9BY3Rpb25zLlJFUExBQ0UpIHtcbiAgICAgIGFsbEtleXNbY3VycmVudF0gPSBsb2NhdGlvbi5rZXk7XG4gICAgfVxuXG4gICAgY2hhbmdlTGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lcihsb2NhdGlvbik7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICBjaGFuZ2VMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgIGxpc3RlbmVyKGxvY2F0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9sb2NhdGlvbiA9IGdldEN1cnJlbnRMb2NhdGlvbigpO1xuICAgICAgYWxsS2V5cyA9IFtfbG9jYXRpb24ua2V5XTtcbiAgICAgIHVwZGF0ZUxvY2F0aW9uKF9sb2NhdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNoYW5nZUxpc3RlbmVycyA9IGNoYW5nZUxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IGxpc3RlbmVyO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgX0FzeW5jVXRpbHMubG9vcEFzeW5jKHRyYW5zaXRpb25Ib29rcy5sZW5ndGgsIGZ1bmN0aW9uIChpbmRleCwgbmV4dCwgZG9uZSkge1xuICAgICAgX3J1blRyYW5zaXRpb25Ib29rMlsnZGVmYXVsdCddKHRyYW5zaXRpb25Ib29rc1tpbmRleF0sIGxvY2F0aW9uLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICAgIGRvbmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICBpZiAoZ2V0VXNlckNvbmZpcm1hdGlvbiAmJiB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbihtZXNzYWdlLCBmdW5jdGlvbiAob2spIHtcbiAgICAgICAgICBjYWxsYmFjayhvayAhPT0gZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKG1lc3NhZ2UgIT09IGZhbHNlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBwZW5kaW5nTG9jYXRpb24gPSB1bmRlZmluZWQ7XG5cbiAgZnVuY3Rpb24gdHJhbnNpdGlvblRvKG5leHRMb2NhdGlvbikge1xuICAgIGlmIChsb2NhdGlvbiAmJiBsb2NhdGlvbnNBcmVFcXVhbChsb2NhdGlvbiwgbmV4dExvY2F0aW9uKSkgcmV0dXJuOyAvLyBOb3RoaW5nIHRvIGRvLlxuXG4gICAgcGVuZGluZ0xvY2F0aW9uID0gbmV4dExvY2F0aW9uO1xuXG4gICAgY29uZmlybVRyYW5zaXRpb25UbyhuZXh0TG9jYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKHBlbmRpbmdMb2NhdGlvbiAhPT0gbmV4dExvY2F0aW9uKSByZXR1cm47IC8vIFRyYW5zaXRpb24gd2FzIGludGVycnVwdGVkLlxuXG4gICAgICBpZiAob2spIHtcbiAgICAgICAgLy8gdHJlYXQgUFVTSCB0byBjdXJyZW50IHBhdGggbGlrZSBSRVBMQUNFIHRvIGJlIGNvbnNpc3RlbnQgd2l0aCBicm93c2Vyc1xuICAgICAgICBpZiAobmV4dExvY2F0aW9uLmFjdGlvbiA9PT0gX0FjdGlvbnMuUFVTSCkge1xuICAgICAgICAgIHZhciBwcmV2UGF0aCA9IGNyZWF0ZVBhdGgobG9jYXRpb24pO1xuICAgICAgICAgIHZhciBuZXh0UGF0aCA9IGNyZWF0ZVBhdGgobmV4dExvY2F0aW9uKTtcblxuICAgICAgICAgIGlmIChuZXh0UGF0aCA9PT0gcHJldlBhdGggJiYgX2RlZXBFcXVhbDJbJ2RlZmF1bHQnXShsb2NhdGlvbi5zdGF0ZSwgbmV4dExvY2F0aW9uLnN0YXRlKSkgbmV4dExvY2F0aW9uLmFjdGlvbiA9IF9BY3Rpb25zLlJFUExBQ0U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmluaXNoVHJhbnNpdGlvbihuZXh0TG9jYXRpb24pICE9PSBmYWxzZSkgdXBkYXRlTG9jYXRpb24obmV4dExvY2F0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAobG9jYXRpb24gJiYgbmV4dExvY2F0aW9uLmFjdGlvbiA9PT0gX0FjdGlvbnMuUE9QKSB7XG4gICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxLZXlzLmluZGV4T2YobG9jYXRpb24ua2V5KTtcbiAgICAgICAgdmFyIG5leHRJbmRleCA9IGFsbEtleXMuaW5kZXhPZihuZXh0TG9jYXRpb24ua2V5KTtcblxuICAgICAgICBpZiAocHJldkluZGV4ICE9PSAtMSAmJiBuZXh0SW5kZXggIT09IC0xKSBnbyhwcmV2SW5kZXggLSBuZXh0SW5kZXgpOyAvLyBSZXN0b3JlIHRoZSBVUkwuXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoKGxvY2F0aW9uKSB7XG4gICAgdHJhbnNpdGlvblRvKGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uLCBfQWN0aW9ucy5QVVNILCBjcmVhdGVLZXkoKSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZShsb2NhdGlvbikge1xuICAgIHRyYW5zaXRpb25UbyhjcmVhdGVMb2NhdGlvbihsb2NhdGlvbiwgX0FjdGlvbnMuUkVQTEFDRSwgY3JlYXRlS2V5KCkpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICBnbygtMSk7XG4gIH1cblxuICBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgZ28oMSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVJhbmRvbUtleShrZXlMZW5ndGgpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUGF0aChsb2NhdGlvbikge1xuICAgIGlmIChsb2NhdGlvbiA9PSBudWxsIHx8IHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycpIHJldHVybiBsb2NhdGlvbjtcblxuICAgIHZhciBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lO1xuICAgIHZhciBzZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2g7XG4gICAgdmFyIGhhc2ggPSBsb2NhdGlvbi5oYXNoO1xuXG4gICAgdmFyIHJlc3VsdCA9IHBhdGhuYW1lO1xuXG4gICAgaWYgKHNlYXJjaCkgcmVzdWx0ICs9IHNlYXJjaDtcblxuICAgIGlmIChoYXNoKSByZXN1bHQgKz0gaGFzaDtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVIcmVmKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVBhdGgobG9jYXRpb24pO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24obG9jYXRpb24sIGFjdGlvbikge1xuICAgIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBjcmVhdGVLZXkoKSA6IGFyZ3VtZW50c1syXTtcblxuICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSAnb2JqZWN0Jykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKGZhbHNlLCAnVGhlIHN0YXRlICgybmQpIGFyZ3VtZW50IHRvIGhpc3RvcnkuY3JlYXRlTG9jYXRpb24gaXMgZGVwcmVjYXRlZDsgdXNlIGEgJyArICdsb2NhdGlvbiBkZXNjcmlwdG9yIGluc3RlYWQnKSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycpIGxvY2F0aW9uID0gX1BhdGhVdGlscy5wYXJzZVBhdGgobG9jYXRpb24pO1xuXG4gICAgICBsb2NhdGlvbiA9IF9leHRlbmRzKHt9LCBsb2NhdGlvbiwgeyBzdGF0ZTogYWN0aW9uIH0pO1xuXG4gICAgICBhY3Rpb24gPSBrZXk7XG4gICAgICBrZXkgPSBhcmd1bWVudHNbM10gfHwgY3JlYXRlS2V5KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9jcmVhdGVMb2NhdGlvbjNbJ2RlZmF1bHQnXShsb2NhdGlvbiwgYWN0aW9uLCBrZXkpO1xuICB9XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBmdW5jdGlvbiBzZXRTdGF0ZShzdGF0ZSkge1xuICAgIGlmIChsb2NhdGlvbikge1xuICAgICAgdXBkYXRlTG9jYXRpb25TdGF0ZShsb2NhdGlvbiwgc3RhdGUpO1xuICAgICAgdXBkYXRlTG9jYXRpb24obG9jYXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGVMb2NhdGlvblN0YXRlKGdldEN1cnJlbnRMb2NhdGlvbigpLCBzdGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTG9jYXRpb25TdGF0ZShsb2NhdGlvbiwgc3RhdGUpIHtcbiAgICBsb2NhdGlvbi5zdGF0ZSA9IF9leHRlbmRzKHt9LCBsb2NhdGlvbi5zdGF0ZSwgc3RhdGUpO1xuICAgIHNhdmVTdGF0ZShsb2NhdGlvbi5rZXksIGxvY2F0aW9uLnN0YXRlKTtcbiAgfVxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgZnVuY3Rpb24gcmVnaXN0ZXJUcmFuc2l0aW9uSG9vayhob29rKSB7XG4gICAgaWYgKHRyYW5zaXRpb25Ib29rcy5pbmRleE9mKGhvb2spID09PSAtMSkgdHJhbnNpdGlvbkhvb2tzLnB1c2goaG9vayk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHVucmVnaXN0ZXJUcmFuc2l0aW9uSG9vayhob29rKSB7XG4gICAgdHJhbnNpdGlvbkhvb2tzID0gdHJhbnNpdGlvbkhvb2tzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0gIT09IGhvb2s7XG4gICAgfSk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHB1c2hTdGF0ZShzdGF0ZSwgcGF0aCkge1xuICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHBhdGggPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChwYXRoKTtcblxuICAgIHB1c2goX2V4dGVuZHMoeyBzdGF0ZTogc3RhdGUgfSwgcGF0aCkpO1xuICB9XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBmdW5jdGlvbiByZXBsYWNlU3RhdGUoc3RhdGUsIHBhdGgpIHtcbiAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSBwYXRoID0gX1BhdGhVdGlscy5wYXJzZVBhdGgocGF0aCk7XG5cbiAgICByZXBsYWNlKF9leHRlbmRzKHsgc3RhdGU6IHN0YXRlIH0sIHBhdGgpKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbGlzdGVuQmVmb3JlOiBsaXN0ZW5CZWZvcmUsXG4gICAgbGlzdGVuOiBsaXN0ZW4sXG4gICAgdHJhbnNpdGlvblRvOiB0cmFuc2l0aW9uVG8sXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBnb0JhY2s6IGdvQmFjayxcbiAgICBnb0ZvcndhcmQ6IGdvRm9yd2FyZCxcbiAgICBjcmVhdGVLZXk6IGNyZWF0ZUtleSxcbiAgICBjcmVhdGVQYXRoOiBjcmVhdGVQYXRoLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgY3JlYXRlTG9jYXRpb246IGNyZWF0ZUxvY2F0aW9uLFxuXG4gICAgc2V0U3RhdGU6IF9kZXByZWNhdGUyWydkZWZhdWx0J10oc2V0U3RhdGUsICdzZXRTdGF0ZSBpcyBkZXByZWNhdGVkOyB1c2UgbG9jYXRpb24ua2V5IHRvIHNhdmUgc3RhdGUgaW5zdGVhZCcpLFxuICAgIHJlZ2lzdGVyVHJhbnNpdGlvbkhvb2s6IF9kZXByZWNhdGUyWydkZWZhdWx0J10ocmVnaXN0ZXJUcmFuc2l0aW9uSG9vaywgJ3JlZ2lzdGVyVHJhbnNpdGlvbkhvb2sgaXMgZGVwcmVjYXRlZDsgdXNlIGxpc3RlbkJlZm9yZSBpbnN0ZWFkJyksXG4gICAgdW5yZWdpc3RlclRyYW5zaXRpb25Ib29rOiBfZGVwcmVjYXRlMlsnZGVmYXVsdCddKHVucmVnaXN0ZXJUcmFuc2l0aW9uSG9vaywgJ3VucmVnaXN0ZXJUcmFuc2l0aW9uSG9vayBpcyBkZXByZWNhdGVkOyB1c2UgdGhlIGNhbGxiYWNrIHJldHVybmVkIGZyb20gbGlzdGVuQmVmb3JlIGluc3RlYWQnKSxcbiAgICBwdXNoU3RhdGU6IF9kZXByZWNhdGUyWydkZWZhdWx0J10ocHVzaFN0YXRlLCAncHVzaFN0YXRlIGlzIGRlcHJlY2F0ZWQ7IHVzZSBwdXNoIGluc3RlYWQnKSxcbiAgICByZXBsYWNlU3RhdGU6IF9kZXByZWNhdGUyWydkZWZhdWx0J10ocmVwbGFjZVN0YXRlLCAncmVwbGFjZVN0YXRlIGlzIGRlcHJlY2F0ZWQ7IHVzZSByZXBsYWNlIGluc3RlYWQnKVxuICB9O1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBjcmVhdGVIaXN0b3J5O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2hpc3RvcnkvbGliL2NyZWF0ZUhpc3RvcnkuanNcbiAqKi8iLCJ2YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCcuL2xpYi9rZXlzLmpzJyk7XG52YXIgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2xpYi9pc19hcmd1bWVudHMuanMnKTtcblxudmFyIGRlZXBFcXVhbCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFjdHVhbCwgZXhwZWN0ZWQsIG9wdHMpIHtcbiAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gIC8vIDcuMS4gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LlxuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuXG4gIH0gZWxzZSBpZiAoYWN0dWFsIGluc3RhbmNlb2YgRGF0ZSAmJiBleHBlY3RlZCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIC8vIDcuMy4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCB8fCB0eXBlb2YgYWN0dWFsICE9ICdvYmplY3QnICYmIHR5cGVvZiBleHBlY3RlZCAhPSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBvcHRzLnN0cmljdCA/IGFjdHVhbCA9PT0gZXhwZWN0ZWQgOiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gNy40LiBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gIC8vIGRldGVybWluZWQgYnkgaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChhcyB2ZXJpZmllZFxuICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgLy8gY29ycmVzcG9uZGluZyBrZXksIGFuZCBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuIE5vdGU6IHRoaXNcbiAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQsIG9wdHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkT3JOdWxsKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAoeCkge1xuICBpZiAoIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnIHx8IHR5cGVvZiB4Lmxlbmd0aCAhPT0gJ251bWJlcicpIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiB4LmNvcHkgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHguc2xpY2UgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHgubGVuZ3RoID4gMCAmJiB0eXBlb2YgeFswXSAhPT0gJ251bWJlcicpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIsIG9wdHMpIHtcbiAgdmFyIGksIGtleTtcbiAgaWYgKGlzVW5kZWZpbmVkT3JOdWxsKGEpIHx8IGlzVW5kZWZpbmVkT3JOdWxsKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LlxuICBpZiAoYS5wcm90b3R5cGUgIT09IGIucHJvdG90eXBlKSByZXR1cm4gZmFsc2U7XG4gIC8vfn5+SSd2ZSBtYW5hZ2VkIHRvIGJyZWFrIE9iamVjdC5rZXlzIHRocm91Z2ggc2NyZXd5IGFyZ3VtZW50cyBwYXNzaW5nLlxuICAvLyAgIENvbnZlcnRpbmcgdG8gYXJyYXkgc29sdmVzIHRoZSBwcm9ibGVtLlxuICBpZiAoaXNBcmd1bWVudHMoYSkpIHtcbiAgICBpZiAoIWlzQXJndW1lbnRzKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIGRlZXBFcXVhbChhLCBiLCBvcHRzKTtcbiAgfVxuICBpZiAoaXNCdWZmZXIoYSkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIga2EgPSBvYmplY3RLZXlzKGEpLFxuICAgICAgICBrYiA9IG9iamVjdEtleXMoYik7XG4gIH0gY2F0Y2ggKGUpIHsvL2hhcHBlbnMgd2hlbiBvbmUgaXMgYSBzdHJpbmcgbGl0ZXJhbCBhbmQgdGhlIG90aGVyIGlzbid0XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIWRlZXBFcXVhbChhW2tleV0sIGJba2V5XSwgb3B0cykpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiO1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2RlZXAtZXF1YWwvaW5kZXguanNcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbidcbiAgPyBPYmplY3Qua2V5cyA6IHNoaW07XG5cbmV4cG9ydHMuc2hpbSA9IHNoaW07XG5mdW5jdGlvbiBzaGltIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gIHJldHVybiBrZXlzO1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2RlZXAtZXF1YWwvbGliL2tleXMuanNcbiAqKi8iLCJ2YXIgc3VwcG9ydHNBcmd1bWVudHNDbGFzcyA9IChmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZ3VtZW50cylcbn0pKCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHN1cHBvcnRzQXJndW1lbnRzQ2xhc3MgPyBzdXBwb3J0ZWQgOiB1bnN1cHBvcnRlZDtcblxuZXhwb3J0cy5zdXBwb3J0ZWQgPSBzdXBwb3J0ZWQ7XG5mdW5jdGlvbiBzdXBwb3J0ZWQob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn07XG5cbmV4cG9ydHMudW5zdXBwb3J0ZWQgPSB1bnN1cHBvcnRlZDtcbmZ1bmN0aW9uIHVuc3VwcG9ydGVkKG9iamVjdCl7XG4gIHJldHVybiBvYmplY3QgJiZcbiAgICB0eXBlb2Ygb2JqZWN0ID09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIG9iamVjdC5sZW5ndGggPT0gJ251bWJlcicgJiZcbiAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnY2FsbGVlJykgJiZcbiAgICAhT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgJ2NhbGxlZScpIHx8XG4gICAgZmFsc2U7XG59O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2RlZXAtZXF1YWwvbGliL2lzX2FyZ3VtZW50cy5qc1xuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIF9zbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbmV4cG9ydHMubG9vcEFzeW5jID0gbG9vcEFzeW5jO1xuXG5mdW5jdGlvbiBsb29wQXN5bmModHVybnMsIHdvcmssIGNhbGxiYWNrKSB7XG4gIHZhciBjdXJyZW50VHVybiA9IDAsXG4gICAgICBpc0RvbmUgPSBmYWxzZTtcbiAgdmFyIHN5bmMgPSBmYWxzZSxcbiAgICAgIGhhc05leHQgPSBmYWxzZSxcbiAgICAgIGRvbmVBcmdzID0gdW5kZWZpbmVkO1xuXG4gIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgaXNEb25lID0gdHJ1ZTtcbiAgICBpZiAoc3luYykge1xuICAgICAgLy8gSXRlcmF0ZSBpbnN0ZWFkIG9mIHJlY3Vyc2luZyBpZiBwb3NzaWJsZS5cbiAgICAgIGRvbmVBcmdzID0gW10uY29uY2F0KF9zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBuZXh0KCkge1xuICAgIGlmIChpc0RvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBoYXNOZXh0ID0gdHJ1ZTtcbiAgICBpZiAoc3luYykge1xuICAgICAgLy8gSXRlcmF0ZSBpbnN0ZWFkIG9mIHJlY3Vyc2luZyBpZiBwb3NzaWJsZS5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzeW5jID0gdHJ1ZTtcblxuICAgIHdoaWxlICghaXNEb25lICYmIGN1cnJlbnRUdXJuIDwgdHVybnMgJiYgaGFzTmV4dCkge1xuICAgICAgaGFzTmV4dCA9IGZhbHNlO1xuICAgICAgd29yay5jYWxsKHRoaXMsIGN1cnJlbnRUdXJuKyssIG5leHQsIGRvbmUpO1xuICAgIH1cblxuICAgIHN5bmMgPSBmYWxzZTtcblxuICAgIGlmIChpc0RvbmUpIHtcbiAgICAgIC8vIFRoaXMgbWVhbnMgdGhlIGxvb3AgZmluaXNoZWQgc3luY2hyb25vdXNseS5cbiAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGRvbmVBcmdzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudFR1cm4gPj0gdHVybnMgJiYgaGFzTmV4dCkge1xuICAgICAgaXNEb25lID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9XG5cbiAgbmV4dCgpO1xufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9oaXN0b3J5L2xpYi9Bc3luY1V0aWxzLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX0FjdGlvbnMgPSByZXF1aXJlKCcuL0FjdGlvbnMnKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG5mdW5jdGlvbiBjcmVhdGVMb2NhdGlvbigpIHtcbiAgdmFyIGxvY2F0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gJy8nIDogYXJndW1lbnRzWzBdO1xuICB2YXIgYWN0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gX0FjdGlvbnMuUE9QIDogYXJndW1lbnRzWzFdO1xuICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFyZ3VtZW50c1syXTtcblxuICB2YXIgX2ZvdXJ0aEFyZyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMyB8fCBhcmd1bWVudHNbM10gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBhcmd1bWVudHNbM107XG5cbiAgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycpIGxvY2F0aW9uID0gX1BhdGhVdGlscy5wYXJzZVBhdGgobG9jYXRpb24pO1xuXG4gIGlmICh0eXBlb2YgYWN0aW9uID09PSAnb2JqZWN0Jykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgJ1RoZSBzdGF0ZSAoMm5kKSBhcmd1bWVudCB0byBjcmVhdGVMb2NhdGlvbiBpcyBkZXByZWNhdGVkOyB1c2UgYSAnICsgJ2xvY2F0aW9uIGRlc2NyaXB0b3IgaW5zdGVhZCcpIDogdW5kZWZpbmVkO1xuXG4gICAgbG9jYXRpb24gPSBfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHsgc3RhdGU6IGFjdGlvbiB9KTtcblxuICAgIGFjdGlvbiA9IGtleSB8fCBfQWN0aW9ucy5QT1A7XG4gICAga2V5ID0gX2ZvdXJ0aEFyZztcbiAgfVxuXG4gIHZhciBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lIHx8ICcvJztcbiAgdmFyIHNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaCB8fCAnJztcbiAgdmFyIGhhc2ggPSBsb2NhdGlvbi5oYXNoIHx8ICcnO1xuICB2YXIgc3RhdGUgPSBsb2NhdGlvbi5zdGF0ZSB8fCBudWxsO1xuXG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxuICAgIHNlYXJjaDogc2VhcmNoLFxuICAgIGhhc2g6IGhhc2gsXG4gICAgc3RhdGU6IHN0YXRlLFxuICAgIGFjdGlvbjogYWN0aW9uLFxuICAgIGtleToga2V5XG4gIH07XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGNyZWF0ZUxvY2F0aW9uO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2hpc3RvcnkvbGliL2NyZWF0ZUxvY2F0aW9uLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBydW5UcmFuc2l0aW9uSG9vayhob29rLCBsb2NhdGlvbiwgY2FsbGJhY2spIHtcbiAgdmFyIHJlc3VsdCA9IGhvb2sobG9jYXRpb24sIGNhbGxiYWNrKTtcblxuICBpZiAoaG9vay5sZW5ndGggPCAyKSB7XG4gICAgLy8gQXNzdW1lIHRoZSBob29rIHJ1bnMgc3luY2hyb25vdXNseSBhbmQgYXV0b21hdGljYWxseVxuICAgIC8vIGNhbGwgdGhlIGNhbGxiYWNrIHdpdGggdGhlIHJldHVybiB2YWx1ZS5cbiAgICBjYWxsYmFjayhyZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShyZXN1bHQgPT09IHVuZGVmaW5lZCwgJ1lvdSBzaG91bGQgbm90IFwicmV0dXJuXCIgaW4gYSB0cmFuc2l0aW9uIGhvb2sgd2l0aCBhIGNhbGxiYWNrIGFyZ3VtZW50OyBjYWxsIHRoZSBjYWxsYmFjayBpbnN0ZWFkJykgOiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gcnVuVHJhbnNpdGlvbkhvb2s7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vaGlzdG9yeS9saWIvcnVuVHJhbnNpdGlvbkhvb2suanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZShmbiwgbWVzc2FnZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgJ1toaXN0b3J5XSAnICsgbWVzc2FnZSkgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGRlcHJlY2F0ZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9oaXN0b3J5L2xpYi9kZXByZWNhdGUuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfcXVlcnlTdHJpbmcgPSByZXF1aXJlKCdxdWVyeS1zdHJpbmcnKTtcblxudmFyIF9ydW5UcmFuc2l0aW9uSG9vayA9IHJlcXVpcmUoJy4vcnVuVHJhbnNpdGlvbkhvb2snKTtcblxudmFyIF9ydW5UcmFuc2l0aW9uSG9vazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ydW5UcmFuc2l0aW9uSG9vayk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9kZXByZWNhdGUgPSByZXF1aXJlKCcuL2RlcHJlY2F0ZScpO1xuXG52YXIgX2RlcHJlY2F0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZXByZWNhdGUpO1xuXG52YXIgU0VBUkNIX0JBU0VfS0VZID0gJyRzZWFyY2hCYXNlJztcblxuZnVuY3Rpb24gZGVmYXVsdFN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5KSB7XG4gIHJldHVybiBfcXVlcnlTdHJpbmcuc3RyaW5naWZ5KHF1ZXJ5KS5yZXBsYWNlKC8lMjAvZywgJysnKTtcbn1cblxudmFyIGRlZmF1bHRQYXJzZVF1ZXJ5U3RyaW5nID0gX3F1ZXJ5U3RyaW5nLnBhcnNlO1xuXG5mdW5jdGlvbiBpc05lc3RlZE9iamVjdChvYmplY3QpIHtcbiAgZm9yICh2YXIgcCBpbiBvYmplY3QpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcCkgJiYgdHlwZW9mIG9iamVjdFtwXSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkob2JqZWN0W3BdKSAmJiBvYmplY3RbcF0gIT09IG51bGwpIHJldHVybiB0cnVlO1xuICB9cmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgY3JlYXRlSGlzdG9yeSBmdW5jdGlvbiB0aGF0IG1heSBiZSB1c2VkIHRvIGNyZWF0ZVxuICogaGlzdG9yeSBvYmplY3RzIHRoYXQga25vdyBob3cgdG8gaGFuZGxlIFVSTCBxdWVyaWVzLlxuICovXG5mdW5jdGlvbiB1c2VRdWVyaWVzKGNyZWF0ZUhpc3RvcnkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICAgdmFyIGhpc3RvcnkgPSBjcmVhdGVIaXN0b3J5KG9wdGlvbnMpO1xuXG4gICAgdmFyIHN0cmluZ2lmeVF1ZXJ5ID0gb3B0aW9ucy5zdHJpbmdpZnlRdWVyeTtcbiAgICB2YXIgcGFyc2VRdWVyeVN0cmluZyA9IG9wdGlvbnMucGFyc2VRdWVyeVN0cmluZztcblxuICAgIGlmICh0eXBlb2Ygc3RyaW5naWZ5UXVlcnkgIT09ICdmdW5jdGlvbicpIHN0cmluZ2lmeVF1ZXJ5ID0gZGVmYXVsdFN0cmluZ2lmeVF1ZXJ5O1xuXG4gICAgaWYgKHR5cGVvZiBwYXJzZVF1ZXJ5U3RyaW5nICE9PSAnZnVuY3Rpb24nKSBwYXJzZVF1ZXJ5U3RyaW5nID0gZGVmYXVsdFBhcnNlUXVlcnlTdHJpbmc7XG5cbiAgICBmdW5jdGlvbiBhZGRRdWVyeShsb2NhdGlvbikge1xuICAgICAgaWYgKGxvY2F0aW9uLnF1ZXJ5ID09IG51bGwpIHtcbiAgICAgICAgdmFyIHNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaDtcblxuICAgICAgICBsb2NhdGlvbi5xdWVyeSA9IHBhcnNlUXVlcnlTdHJpbmcoc2VhcmNoLnN1YnN0cmluZygxKSk7XG4gICAgICAgIGxvY2F0aW9uW1NFQVJDSF9CQVNFX0tFWV0gPSB7IHNlYXJjaDogc2VhcmNoLCBzZWFyY2hCYXNlOiAnJyB9O1xuICAgICAgfVxuXG4gICAgICAvLyBUT0RPOiBJbnN0ZWFkIG9mIGFsbCB0aGUgYm9vay1rZWVwaW5nIGhlcmUsIHRoaXMgc2hvdWxkIGp1c3Qgc3RyaXAgdGhlXG4gICAgICAvLyBzdHJpbmdpZmllZCBxdWVyeSBmcm9tIHRoZSBzZWFyY2guXG5cbiAgICAgIHJldHVybiBsb2NhdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBlbmRRdWVyeShsb2NhdGlvbiwgcXVlcnkpIHtcbiAgICAgIHZhciBfZXh0ZW5kczI7XG5cbiAgICAgIHZhciBzZWFyY2hCYXNlU3BlYyA9IGxvY2F0aW9uW1NFQVJDSF9CQVNFX0tFWV07XG4gICAgICB2YXIgcXVlcnlTdHJpbmcgPSBxdWVyeSA/IHN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5KSA6ICcnO1xuICAgICAgaWYgKCFzZWFyY2hCYXNlU3BlYyAmJiAhcXVlcnlTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uO1xuICAgICAgfVxuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10oc3RyaW5naWZ5UXVlcnkgIT09IGRlZmF1bHRTdHJpbmdpZnlRdWVyeSB8fCAhaXNOZXN0ZWRPYmplY3QocXVlcnkpLCAndXNlUXVlcmllcyBkb2VzIG5vdCBzdHJpbmdpZnkgbmVzdGVkIHF1ZXJ5IG9iamVjdHMgYnkgZGVmYXVsdDsgJyArICd1c2UgYSBjdXN0b20gc3RyaW5naWZ5UXVlcnkgZnVuY3Rpb24nKSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycpIGxvY2F0aW9uID0gX1BhdGhVdGlscy5wYXJzZVBhdGgobG9jYXRpb24pO1xuXG4gICAgICB2YXIgc2VhcmNoQmFzZSA9IHVuZGVmaW5lZDtcbiAgICAgIGlmIChzZWFyY2hCYXNlU3BlYyAmJiBsb2NhdGlvbi5zZWFyY2ggPT09IHNlYXJjaEJhc2VTcGVjLnNlYXJjaCkge1xuICAgICAgICBzZWFyY2hCYXNlID0gc2VhcmNoQmFzZVNwZWMuc2VhcmNoQmFzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlYXJjaEJhc2UgPSBsb2NhdGlvbi5zZWFyY2ggfHwgJyc7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWFyY2ggPSBzZWFyY2hCYXNlO1xuICAgICAgaWYgKHF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHNlYXJjaCArPSAoc2VhcmNoID8gJyYnIDogJz8nKSArIHF1ZXJ5U3RyaW5nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGxvY2F0aW9uLCAoX2V4dGVuZHMyID0ge1xuICAgICAgICBzZWFyY2g6IHNlYXJjaFxuICAgICAgfSwgX2V4dGVuZHMyW1NFQVJDSF9CQVNFX0tFWV0gPSB7IHNlYXJjaDogc2VhcmNoLCBzZWFyY2hCYXNlOiBzZWFyY2hCYXNlIH0sIF9leHRlbmRzMikpO1xuICAgIH1cblxuICAgIC8vIE92ZXJyaWRlIGFsbCByZWFkIG1ldGhvZHMgd2l0aCBxdWVyeS1hd2FyZSB2ZXJzaW9ucy5cbiAgICBmdW5jdGlvbiBsaXN0ZW5CZWZvcmUoaG9vaykge1xuICAgICAgcmV0dXJuIGhpc3RvcnkubGlzdGVuQmVmb3JlKGZ1bmN0aW9uIChsb2NhdGlvbiwgY2FsbGJhY2spIHtcbiAgICAgICAgX3J1blRyYW5zaXRpb25Ib29rMlsnZGVmYXVsdCddKGhvb2ssIGFkZFF1ZXJ5KGxvY2F0aW9uKSwgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeS5saXN0ZW4oZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICAgIGxpc3RlbmVyKGFkZFF1ZXJ5KGxvY2F0aW9uKSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBPdmVycmlkZSBhbGwgd3JpdGUgbWV0aG9kcyB3aXRoIHF1ZXJ5LWF3YXJlIHZlcnNpb25zLlxuICAgIGZ1bmN0aW9uIHB1c2gobG9jYXRpb24pIHtcbiAgICAgIGhpc3RvcnkucHVzaChhcHBlbmRRdWVyeShsb2NhdGlvbiwgbG9jYXRpb24ucXVlcnkpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlKGxvY2F0aW9uKSB7XG4gICAgICBoaXN0b3J5LnJlcGxhY2UoYXBwZW5kUXVlcnkobG9jYXRpb24sIGxvY2F0aW9uLnF1ZXJ5KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlUGF0aChsb2NhdGlvbiwgcXVlcnkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXSghcXVlcnksICd0aGUgcXVlcnkgYXJndW1lbnQgdG8gY3JlYXRlUGF0aCBpcyBkZXByZWNhdGVkOyB1c2UgYSBsb2NhdGlvbiBkZXNjcmlwdG9yIGluc3RlYWQnKSA6IHVuZGVmaW5lZDtcblxuICAgICAgcmV0dXJuIGhpc3RvcnkuY3JlYXRlUGF0aChhcHBlbmRRdWVyeShsb2NhdGlvbiwgcXVlcnkgfHwgbG9jYXRpb24ucXVlcnkpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVIcmVmKGxvY2F0aW9uLCBxdWVyeSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKCFxdWVyeSwgJ3RoZSBxdWVyeSBhcmd1bWVudCB0byBjcmVhdGVIcmVmIGlzIGRlcHJlY2F0ZWQ7IHVzZSBhIGxvY2F0aW9uIGRlc2NyaXB0b3IgaW5zdGVhZCcpIDogdW5kZWZpbmVkO1xuXG4gICAgICByZXR1cm4gaGlzdG9yeS5jcmVhdGVIcmVmKGFwcGVuZFF1ZXJ5KGxvY2F0aW9uLCBxdWVyeSB8fCBsb2NhdGlvbi5xdWVyeSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHZhciBmdWxsTG9jYXRpb24gPSBoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uLmFwcGx5KGhpc3RvcnksIFthcHBlbmRRdWVyeShsb2NhdGlvbiwgbG9jYXRpb24ucXVlcnkpXS5jb25jYXQoYXJncykpO1xuICAgICAgaWYgKGxvY2F0aW9uLnF1ZXJ5KSB7XG4gICAgICAgIGZ1bGxMb2NhdGlvbi5xdWVyeSA9IGxvY2F0aW9uLnF1ZXJ5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFkZFF1ZXJ5KGZ1bGxMb2NhdGlvbik7XG4gICAgfVxuXG4gICAgLy8gZGVwcmVjYXRlZFxuICAgIGZ1bmN0aW9uIHB1c2hTdGF0ZShzdGF0ZSwgcGF0aCwgcXVlcnkpIHtcbiAgICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHBhdGggPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChwYXRoKTtcblxuICAgICAgcHVzaChfZXh0ZW5kcyh7IHN0YXRlOiBzdGF0ZSB9LCBwYXRoLCB7IHF1ZXJ5OiBxdWVyeSB9KSk7XG4gICAgfVxuXG4gICAgLy8gZGVwcmVjYXRlZFxuICAgIGZ1bmN0aW9uIHJlcGxhY2VTdGF0ZShzdGF0ZSwgcGF0aCwgcXVlcnkpIHtcbiAgICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHBhdGggPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChwYXRoKTtcblxuICAgICAgcmVwbGFjZShfZXh0ZW5kcyh7IHN0YXRlOiBzdGF0ZSB9LCBwYXRoLCB7IHF1ZXJ5OiBxdWVyeSB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBoaXN0b3J5LCB7XG4gICAgICBsaXN0ZW5CZWZvcmU6IGxpc3RlbkJlZm9yZSxcbiAgICAgIGxpc3RlbjogbGlzdGVuLFxuICAgICAgcHVzaDogcHVzaCxcbiAgICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgICBjcmVhdGVQYXRoOiBjcmVhdGVQYXRoLFxuICAgICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICAgIGNyZWF0ZUxvY2F0aW9uOiBjcmVhdGVMb2NhdGlvbixcblxuICAgICAgcHVzaFN0YXRlOiBfZGVwcmVjYXRlMlsnZGVmYXVsdCddKHB1c2hTdGF0ZSwgJ3B1c2hTdGF0ZSBpcyBkZXByZWNhdGVkOyB1c2UgcHVzaCBpbnN0ZWFkJyksXG4gICAgICByZXBsYWNlU3RhdGU6IF9kZXByZWNhdGUyWydkZWZhdWx0J10ocmVwbGFjZVN0YXRlLCAncmVwbGFjZVN0YXRlIGlzIGRlcHJlY2F0ZWQ7IHVzZSByZXBsYWNlIGluc3RlYWQnKVxuICAgIH0pO1xuICB9O1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSB1c2VRdWVyaWVzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2hpc3RvcnkvbGliL3VzZVF1ZXJpZXMuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgc3RyaWN0VXJpRW5jb2RlID0gcmVxdWlyZSgnc3RyaWN0LXVyaS1lbmNvZGUnKTtcblxuZXhwb3J0cy5leHRyYWN0ID0gZnVuY3Rpb24gKHN0cikge1xuXHRyZXR1cm4gc3RyLnNwbGl0KCc/JylbMV0gfHwgJyc7XG59O1xuXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHN0cikge1xuXHRpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm4ge307XG5cdH1cblxuXHRzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoL14oXFw/fCN8JikvLCAnJyk7XG5cblx0aWYgKCFzdHIpIHtcblx0XHRyZXR1cm4ge307XG5cdH1cblxuXHRyZXR1cm4gc3RyLnNwbGl0KCcmJykucmVkdWNlKGZ1bmN0aW9uIChyZXQsIHBhcmFtKSB7XG5cdFx0dmFyIHBhcnRzID0gcGFyYW0ucmVwbGFjZSgvXFwrL2csICcgJykuc3BsaXQoJz0nKTtcblx0XHQvLyBGaXJlZm94IChwcmUgNDApIGRlY29kZXMgYCUzRGAgdG8gYD1gXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9xdWVyeS1zdHJpbmcvcHVsbC8zN1xuXHRcdHZhciBrZXkgPSBwYXJ0cy5zaGlmdCgpO1xuXHRcdHZhciB2YWwgPSBwYXJ0cy5sZW5ndGggPiAwID8gcGFydHMuam9pbignPScpIDogdW5kZWZpbmVkO1xuXG5cdFx0a2V5ID0gZGVjb2RlVVJJQ29tcG9uZW50KGtleSk7XG5cblx0XHQvLyBtaXNzaW5nIGA9YCBzaG91bGQgYmUgYG51bGxgOlxuXHRcdC8vIGh0dHA6Ly93My5vcmcvVFIvMjAxMi9XRC11cmwtMjAxMjA1MjQvI2NvbGxlY3QtdXJsLXBhcmFtZXRlcnNcblx0XHR2YWwgPSB2YWwgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZWNvZGVVUklDb21wb25lbnQodmFsKTtcblxuXHRcdGlmICghcmV0Lmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdHJldFtrZXldID0gdmFsO1xuXHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXRba2V5XSkpIHtcblx0XHRcdHJldFtrZXldLnB1c2godmFsKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0W2tleV0gPSBbcmV0W2tleV0sIHZhbF07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSwge30pO1xufTtcblxuZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAob2JqKSB7XG5cdHJldHVybiBvYmogPyBPYmplY3Qua2V5cyhvYmopLnNvcnQoKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciB2YWwgPSBvYmpba2V5XTtcblxuXHRcdGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH1cblxuXHRcdGlmICh2YWwgPT09IG51bGwpIHtcblx0XHRcdHJldHVybiBrZXk7XG5cdFx0fVxuXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuXHRcdFx0cmV0dXJuIHZhbC5zbGljZSgpLnNvcnQoKS5tYXAoZnVuY3Rpb24gKHZhbDIpIHtcblx0XHRcdFx0cmV0dXJuIHN0cmljdFVyaUVuY29kZShrZXkpICsgJz0nICsgc3RyaWN0VXJpRW5jb2RlKHZhbDIpO1xuXHRcdFx0fSkuam9pbignJicpO1xuXHRcdH1cblxuXHRcdHJldHVybiBzdHJpY3RVcmlFbmNvZGUoa2V5KSArICc9JyArIHN0cmljdFVyaUVuY29kZSh2YWwpO1xuXHR9KS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcblx0XHRyZXR1cm4geC5sZW5ndGggPiAwO1xuXHR9KS5qb2luKCcmJykgOiAnJztcbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcXVlcnktc3RyaW5nL2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKS5yZXBsYWNlKC9bIScoKSpdL2csIGZ1bmN0aW9uIChjKSB7XG5cdFx0cmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblx0fSk7XG59O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3N0cmljdC11cmktZW5jb2RlL2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxudmFyIF9jb21wdXRlQ2hhbmdlZFJvdXRlczIgPSByZXF1aXJlKCcuL2NvbXB1dGVDaGFuZ2VkUm91dGVzJyk7XG5cbnZhciBfY29tcHV0ZUNoYW5nZWRSb3V0ZXMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcHV0ZUNoYW5nZWRSb3V0ZXMyKTtcblxudmFyIF9UcmFuc2l0aW9uVXRpbHMgPSByZXF1aXJlKCcuL1RyYW5zaXRpb25VdGlscycpO1xuXG52YXIgX2lzQWN0aXZlMiA9IHJlcXVpcmUoJy4vaXNBY3RpdmUnKTtcblxudmFyIF9pc0FjdGl2ZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0FjdGl2ZTIpO1xuXG52YXIgX2dldENvbXBvbmVudHMgPSByZXF1aXJlKCcuL2dldENvbXBvbmVudHMnKTtcblxudmFyIF9nZXRDb21wb25lbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldENvbXBvbmVudHMpO1xuXG52YXIgX21hdGNoUm91dGVzID0gcmVxdWlyZSgnLi9tYXRjaFJvdXRlcycpO1xuXG52YXIgX21hdGNoUm91dGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21hdGNoUm91dGVzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaGFzQW55UHJvcGVydGllcyhvYmplY3QpIHtcbiAgZm9yICh2YXIgcCBpbiBvYmplY3QpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcCkpIHJldHVybiB0cnVlO1xuICB9cmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcihoaXN0b3J5LCByb3V0ZXMpIHtcbiAgdmFyIHN0YXRlID0ge307XG5cbiAgLy8gU2lnbmF0dXJlIHNob3VsZCBiZSAobG9jYXRpb24sIGluZGV4T25seSksIGJ1dCBuZWVkcyB0byBzdXBwb3J0IChwYXRoLFxuICAvLyBxdWVyeSwgaW5kZXhPbmx5KVxuICBmdW5jdGlvbiBpc0FjdGl2ZShsb2NhdGlvbikge1xuICAgIHZhciBpbmRleE9ubHlPckRlcHJlY2F0ZWRRdWVyeSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYXJndW1lbnRzWzFdO1xuICAgIHZhciBkZXByZWNhdGVkSW5kZXhPbmx5ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFyZ3VtZW50c1syXTtcblxuICAgIHZhciBpbmRleE9ubHkgPSB2b2lkIDA7XG4gICAgaWYgKGluZGV4T25seU9yRGVwcmVjYXRlZFF1ZXJ5ICYmIGluZGV4T25seU9yRGVwcmVjYXRlZFF1ZXJ5ICE9PSB0cnVlIHx8IGRlcHJlY2F0ZWRJbmRleE9ubHkgIT09IG51bGwpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnYGlzQWN0aXZlKHBhdGhuYW1lLCBxdWVyeSwgaW5kZXhPbmx5KSBpcyBkZXByZWNhdGVkOyB1c2UgYGlzQWN0aXZlKGxvY2F0aW9uLCBpbmRleE9ubHkpYCB3aXRoIGEgbG9jYXRpb24gZGVzY3JpcHRvciBpbnN0ZWFkLiBodHRwOi8vdGlueS5jYy9yb3V0ZXItaXNBY3RpdmVkZXByZWNhdGVkJykgOiB2b2lkIDA7XG4gICAgICBsb2NhdGlvbiA9IHsgcGF0aG5hbWU6IGxvY2F0aW9uLCBxdWVyeTogaW5kZXhPbmx5T3JEZXByZWNhdGVkUXVlcnkgfTtcbiAgICAgIGluZGV4T25seSA9IGRlcHJlY2F0ZWRJbmRleE9ubHkgfHwgZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvY2F0aW9uID0gaGlzdG9yeS5jcmVhdGVMb2NhdGlvbihsb2NhdGlvbik7XG4gICAgICBpbmRleE9ubHkgPSBpbmRleE9ubHlPckRlcHJlY2F0ZWRRdWVyeTtcbiAgICB9XG5cbiAgICByZXR1cm4gKDAsIF9pc0FjdGl2ZTMuZGVmYXVsdCkobG9jYXRpb24sIGluZGV4T25seSwgc3RhdGUubG9jYXRpb24sIHN0YXRlLnJvdXRlcywgc3RhdGUucGFyYW1zKTtcbiAgfVxuXG4gIHZhciBwYXJ0aWFsTmV4dFN0YXRlID0gdm9pZCAwO1xuXG4gIGZ1bmN0aW9uIG1hdGNoKGxvY2F0aW9uLCBjYWxsYmFjaykge1xuICAgIGlmIChwYXJ0aWFsTmV4dFN0YXRlICYmIHBhcnRpYWxOZXh0U3RhdGUubG9jYXRpb24gPT09IGxvY2F0aW9uKSB7XG4gICAgICAvLyBDb250aW51ZSBmcm9tIHdoZXJlIHdlIGxlZnQgb2ZmLlxuICAgICAgZmluaXNoTWF0Y2gocGFydGlhbE5leHRTdGF0ZSwgY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAoMCwgX21hdGNoUm91dGVzMi5kZWZhdWx0KShyb3V0ZXMsIGxvY2F0aW9uLCBmdW5jdGlvbiAoZXJyb3IsIG5leHRTdGF0ZSkge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAobmV4dFN0YXRlKSB7XG4gICAgICAgICAgZmluaXNoTWF0Y2goX2V4dGVuZHMoe30sIG5leHRTdGF0ZSwgeyBsb2NhdGlvbjogbG9jYXRpb24gfSksIGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2hNYXRjaChuZXh0U3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF9jb21wdXRlQ2hhbmdlZFJvdXRlcyA9ICgwLCBfY29tcHV0ZUNoYW5nZWRSb3V0ZXMzLmRlZmF1bHQpKHN0YXRlLCBuZXh0U3RhdGUpO1xuXG4gICAgdmFyIGxlYXZlUm91dGVzID0gX2NvbXB1dGVDaGFuZ2VkUm91dGVzLmxlYXZlUm91dGVzO1xuICAgIHZhciBjaGFuZ2VSb3V0ZXMgPSBfY29tcHV0ZUNoYW5nZWRSb3V0ZXMuY2hhbmdlUm91dGVzO1xuICAgIHZhciBlbnRlclJvdXRlcyA9IF9jb21wdXRlQ2hhbmdlZFJvdXRlcy5lbnRlclJvdXRlcztcblxuXG4gICAgKDAsIF9UcmFuc2l0aW9uVXRpbHMucnVuTGVhdmVIb29rcykobGVhdmVSb3V0ZXMsIHN0YXRlKTtcblxuICAgIC8vIFRlYXIgZG93biBjb25maXJtYXRpb24gaG9va3MgZm9yIGxlZnQgcm91dGVzXG4gICAgbGVhdmVSb3V0ZXMuZmlsdGVyKGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgcmV0dXJuIGVudGVyUm91dGVzLmluZGV4T2Yocm91dGUpID09PSAtMTtcbiAgICB9KS5mb3JFYWNoKHJlbW92ZUxpc3RlbkJlZm9yZUhvb2tzRm9yUm91dGUpO1xuXG4gICAgLy8gY2hhbmdlIGFuZCBlbnRlciBob29rcyBhcmUgcnVuIGluIHNlcmllc1xuICAgICgwLCBfVHJhbnNpdGlvblV0aWxzLnJ1bkNoYW5nZUhvb2tzKShjaGFuZ2VSb3V0ZXMsIHN0YXRlLCBuZXh0U3RhdGUsIGZ1bmN0aW9uIChlcnJvciwgcmVkaXJlY3RJbmZvKSB7XG4gICAgICBpZiAoZXJyb3IgfHwgcmVkaXJlY3RJbmZvKSByZXR1cm4gaGFuZGxlRXJyb3JPclJlZGlyZWN0KGVycm9yLCByZWRpcmVjdEluZm8pO1xuXG4gICAgICAoMCwgX1RyYW5zaXRpb25VdGlscy5ydW5FbnRlckhvb2tzKShlbnRlclJvdXRlcywgbmV4dFN0YXRlLCBmaW5pc2hFbnRlckhvb2tzKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGZpbmlzaEVudGVySG9va3MoZXJyb3IsIHJlZGlyZWN0SW5mbykge1xuICAgICAgaWYgKGVycm9yIHx8IHJlZGlyZWN0SW5mbykgcmV0dXJuIGhhbmRsZUVycm9yT3JSZWRpcmVjdChlcnJvciwgcmVkaXJlY3RJbmZvKTtcblxuICAgICAgLy8gVE9ETzogRmV0Y2ggY29tcG9uZW50cyBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICAgICAgKDAsIF9nZXRDb21wb25lbnRzMi5kZWZhdWx0KShuZXh0U3RhdGUsIGZ1bmN0aW9uIChlcnJvciwgY29tcG9uZW50cykge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVE9ETzogTWFrZSBtYXRjaCBhIHB1cmUgZnVuY3Rpb24gYW5kIGhhdmUgc29tZSBvdGhlciBBUElcbiAgICAgICAgICAvLyBmb3IgXCJtYXRjaCBhbmQgdXBkYXRlIHN0YXRlXCIuXG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwgbnVsbCwgc3RhdGUgPSBfZXh0ZW5kcyh7fSwgbmV4dFN0YXRlLCB7IGNvbXBvbmVudHM6IGNvbXBvbmVudHMgfSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVFcnJvck9yUmVkaXJlY3QoZXJyb3IsIHJlZGlyZWN0SW5mbykge1xuICAgICAgaWYgKGVycm9yKSBjYWxsYmFjayhlcnJvcik7ZWxzZSBjYWxsYmFjayhudWxsLCByZWRpcmVjdEluZm8pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBSb3V0ZUd1aWQgPSAxO1xuXG4gIGZ1bmN0aW9uIGdldFJvdXRlSUQocm91dGUpIHtcbiAgICB2YXIgY3JlYXRlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFyZ3VtZW50c1sxXTtcblxuICAgIHJldHVybiByb3V0ZS5fX2lkX18gfHwgY3JlYXRlICYmIChyb3V0ZS5fX2lkX18gPSBSb3V0ZUd1aWQrKyk7XG4gIH1cblxuICB2YXIgUm91dGVIb29rcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgZnVuY3Rpb24gZ2V0Um91dGVIb29rc0ZvclJvdXRlcyhyb3V0ZXMpIHtcbiAgICByZXR1cm4gcm91dGVzLnJlZHVjZShmdW5jdGlvbiAoaG9va3MsIHJvdXRlKSB7XG4gICAgICBob29rcy5wdXNoLmFwcGx5KGhvb2tzLCBSb3V0ZUhvb2tzW2dldFJvdXRlSUQocm91dGUpXSk7XG4gICAgICByZXR1cm4gaG9va3M7XG4gICAgfSwgW10pO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNpdGlvbkhvb2sobG9jYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgKDAsIF9tYXRjaFJvdXRlczIuZGVmYXVsdCkocm91dGVzLCBsb2NhdGlvbiwgZnVuY3Rpb24gKGVycm9yLCBuZXh0U3RhdGUpIHtcbiAgICAgIGlmIChuZXh0U3RhdGUgPT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBXZSBkaWRuJ3QgYWN0dWFsbHkgbWF0Y2ggYW55dGhpbmcsIGJ1dCBoYW5nXG4gICAgICAgIC8vIG9udG8gZXJyb3IvbmV4dFN0YXRlIHNvIHdlIGRvbid0IGhhdmUgdG8gbWF0Y2hSb3V0ZXNcbiAgICAgICAgLy8gYWdhaW4gaW4gdGhlIGxpc3RlbiBjYWxsYmFjay5cbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBDYWNoZSBzb21lIHN0YXRlIGhlcmUgc28gd2UgZG9uJ3QgaGF2ZSB0b1xuICAgICAgLy8gbWF0Y2hSb3V0ZXMoKSBhZ2FpbiBpbiB0aGUgbGlzdGVuIGNhbGxiYWNrLlxuICAgICAgcGFydGlhbE5leHRTdGF0ZSA9IF9leHRlbmRzKHt9LCBuZXh0U3RhdGUsIHsgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuXG4gICAgICB2YXIgaG9va3MgPSBnZXRSb3V0ZUhvb2tzRm9yUm91dGVzKCgwLCBfY29tcHV0ZUNoYW5nZWRSb3V0ZXMzLmRlZmF1bHQpKHN0YXRlLCBwYXJ0aWFsTmV4dFN0YXRlKS5sZWF2ZVJvdXRlcyk7XG5cbiAgICAgIHZhciByZXN1bHQgPSB2b2lkIDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaG9va3MubGVuZ3RoOyByZXN1bHQgPT0gbnVsbCAmJiBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgLy8gUGFzc2luZyB0aGUgbG9jYXRpb24gYXJnIGhlcmUgaW5kaWNhdGVzIHRvXG4gICAgICAgIC8vIHRoZSB1c2VyIHRoYXQgdGhpcyBpcyBhIHRyYW5zaXRpb24gaG9vay5cbiAgICAgICAgcmVzdWx0ID0gaG9va3NbaV0obG9jYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgIH0pO1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHVudGVzdGFibGUgd2l0aCBLYXJtYSAqL1xuICBmdW5jdGlvbiBiZWZvcmVVbmxvYWRIb29rKCkge1xuICAgIC8vIFN5bmNocm9ub3VzbHkgY2hlY2sgdG8gc2VlIGlmIGFueSByb3V0ZSBob29rcyB3YW50XG4gICAgLy8gdG8gcHJldmVudCB0aGUgY3VycmVudCB3aW5kb3cvdGFiIGZyb20gY2xvc2luZy5cbiAgICBpZiAoc3RhdGUucm91dGVzKSB7XG4gICAgICB2YXIgaG9va3MgPSBnZXRSb3V0ZUhvb2tzRm9yUm91dGVzKHN0YXRlLnJvdXRlcyk7XG5cbiAgICAgIHZhciBtZXNzYWdlID0gdm9pZCAwO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGhvb2tzLmxlbmd0aDsgdHlwZW9mIG1lc3NhZ2UgIT09ICdzdHJpbmcnICYmIGkgPCBsZW47ICsraSkge1xuICAgICAgICAvLyBQYXNzaW5nIG5vIGFyZ3MgaW5kaWNhdGVzIHRvIHRoZSB1c2VyIHRoYXQgdGhpcyBpcyBhXG4gICAgICAgIC8vIGJlZm9yZXVubG9hZCBob29rLiBXZSBkb24ndCBrbm93IHRoZSBuZXh0IGxvY2F0aW9uLlxuICAgICAgICBtZXNzYWdlID0gaG9va3NbaV0oKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVubGlzdGVuQmVmb3JlID0gdm9pZCAwLFxuICAgICAgdW5saXN0ZW5CZWZvcmVVbmxvYWQgPSB2b2lkIDA7XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuQmVmb3JlSG9va3NGb3JSb3V0ZShyb3V0ZSkge1xuICAgIHZhciByb3V0ZUlEID0gZ2V0Um91dGVJRChyb3V0ZSwgZmFsc2UpO1xuICAgIGlmICghcm91dGVJRCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRlbGV0ZSBSb3V0ZUhvb2tzW3JvdXRlSURdO1xuXG4gICAgaWYgKCFoYXNBbnlQcm9wZXJ0aWVzKFJvdXRlSG9va3MpKSB7XG4gICAgICAvLyB0ZWFyZG93biB0cmFuc2l0aW9uICYgYmVmb3JldW5sb2FkIGhvb2tzXG4gICAgICBpZiAodW5saXN0ZW5CZWZvcmUpIHtcbiAgICAgICAgdW5saXN0ZW5CZWZvcmUoKTtcbiAgICAgICAgdW5saXN0ZW5CZWZvcmUgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodW5saXN0ZW5CZWZvcmVVbmxvYWQpIHtcbiAgICAgICAgdW5saXN0ZW5CZWZvcmVVbmxvYWQoKTtcbiAgICAgICAgdW5saXN0ZW5CZWZvcmVVbmxvYWQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgdGhlIGdpdmVuIGhvb2sgZnVuY3Rpb24gdG8gcnVuIGJlZm9yZSBsZWF2aW5nIHRoZSBnaXZlbiByb3V0ZS5cbiAgICpcbiAgICogRHVyaW5nIGEgbm9ybWFsIHRyYW5zaXRpb24sIHRoZSBob29rIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSBuZXh0IGxvY2F0aW9uXG4gICAqIGFzIGl0cyBvbmx5IGFyZ3VtZW50IGFuZCBjYW4gcmV0dXJuIGVpdGhlciBhIHByb21wdCBtZXNzYWdlIChzdHJpbmcpIHRvIHNob3cgdGhlIHVzZXIsXG4gICAqIHRvIG1ha2Ugc3VyZSB0aGV5IHdhbnQgdG8gbGVhdmUgdGhlIHBhZ2U7IG9yIGBmYWxzZWAsIHRvIHByZXZlbnQgdGhlIHRyYW5zaXRpb24uXG4gICAqIEFueSBvdGhlciByZXR1cm4gdmFsdWUgd2lsbCBoYXZlIG5vIGVmZmVjdC5cbiAgICpcbiAgICogRHVyaW5nIHRoZSBiZWZvcmV1bmxvYWQgZXZlbnQgKGluIGJyb3dzZXJzKSB0aGUgaG9vayByZWNlaXZlcyBubyBhcmd1bWVudHMuXG4gICAqIEluIHRoaXMgY2FzZSBpdCBtdXN0IHJldHVybiBhIHByb21wdCBtZXNzYWdlIHRvIHByZXZlbnQgdGhlIHRyYW5zaXRpb24uXG4gICAqXG4gICAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IG1heSBiZSB1c2VkIHRvIHVuYmluZCB0aGUgbGlzdGVuZXIuXG4gICAqL1xuICBmdW5jdGlvbiBsaXN0ZW5CZWZvcmVMZWF2aW5nUm91dGUocm91dGUsIGhvb2spIHtcbiAgICAvLyBUT0RPOiBXYXJuIGlmIHRoZXkgcmVnaXN0ZXIgZm9yIGEgcm91dGUgdGhhdCBpc24ndCBjdXJyZW50bHlcbiAgICAvLyBhY3RpdmUuIFRoZXkncmUgcHJvYmFibHkgZG9pbmcgc29tZXRoaW5nIHdyb25nLCBsaWtlIHJlLWNyZWF0aW5nXG4gICAgLy8gcm91dGUgb2JqZWN0cyBvbiBldmVyeSBsb2NhdGlvbiBjaGFuZ2UuXG4gICAgdmFyIHJvdXRlSUQgPSBnZXRSb3V0ZUlEKHJvdXRlKTtcbiAgICB2YXIgaG9va3MgPSBSb3V0ZUhvb2tzW3JvdXRlSURdO1xuXG4gICAgaWYgKCFob29rcykge1xuICAgICAgdmFyIHRoZXJlV2VyZU5vUm91dGVIb29rcyA9ICFoYXNBbnlQcm9wZXJ0aWVzKFJvdXRlSG9va3MpO1xuXG4gICAgICBSb3V0ZUhvb2tzW3JvdXRlSURdID0gW2hvb2tdO1xuXG4gICAgICBpZiAodGhlcmVXZXJlTm9Sb3V0ZUhvb2tzKSB7XG4gICAgICAgIC8vIHNldHVwIHRyYW5zaXRpb24gJiBiZWZvcmV1bmxvYWQgaG9va3NcbiAgICAgICAgdW5saXN0ZW5CZWZvcmUgPSBoaXN0b3J5Lmxpc3RlbkJlZm9yZSh0cmFuc2l0aW9uSG9vayk7XG5cbiAgICAgICAgaWYgKGhpc3RvcnkubGlzdGVuQmVmb3JlVW5sb2FkKSB1bmxpc3RlbkJlZm9yZVVubG9hZCA9IGhpc3RvcnkubGlzdGVuQmVmb3JlVW5sb2FkKGJlZm9yZVVubG9hZEhvb2spO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaG9va3MuaW5kZXhPZihob29rKSA9PT0gLTEpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdhZGRpbmcgbXVsdGlwbGUgbGVhdmUgaG9va3MgZm9yIHRoZSBzYW1lIHJvdXRlIGlzIGRlcHJlY2F0ZWQ7IG1hbmFnZSBtdWx0aXBsZSBjb25maXJtYXRpb25zIGluIHlvdXIgb3duIGNvZGUgaW5zdGVhZCcpIDogdm9pZCAwO1xuXG4gICAgICAgIGhvb2tzLnB1c2goaG9vayk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBob29rcyA9IFJvdXRlSG9va3Nbcm91dGVJRF07XG5cbiAgICAgIGlmIChob29rcykge1xuICAgICAgICB2YXIgbmV3SG9va3MgPSBob29rcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gaXRlbSAhPT0gaG9vaztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG5ld0hvb2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJlbW92ZUxpc3RlbkJlZm9yZUhvb2tzRm9yUm91dGUocm91dGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFJvdXRlSG9va3Nbcm91dGVJRF0gPSBuZXdIb29rcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyB0aGUgQVBJIGZvciBzdGF0ZWZ1bCBlbnZpcm9ubWVudHMuIEFzIHRoZSBsb2NhdGlvblxuICAgKiBjaGFuZ2VzLCB3ZSB1cGRhdGUgc3RhdGUgYW5kIGNhbGwgdGhlIGxpc3RlbmVyLiBXZSBjYW4gYWxzb1xuICAgKiBncmFjZWZ1bGx5IGhhbmRsZSBlcnJvcnMgYW5kIHJlZGlyZWN0cy5cbiAgICovXG4gIGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIC8vIFRPRE86IE9ubHkgdXNlIGEgc2luZ2xlIGhpc3RvcnkgbGlzdGVuZXIuIE90aGVyd2lzZSB3ZSdsbFxuICAgIC8vIGVuZCB1cCB3aXRoIG11bHRpcGxlIGNvbmN1cnJlbnQgY2FsbHMgdG8gbWF0Y2guXG4gICAgcmV0dXJuIGhpc3RvcnkubGlzdGVuKGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgaWYgKHN0YXRlLmxvY2F0aW9uID09PSBsb2NhdGlvbikge1xuICAgICAgICBsaXN0ZW5lcihudWxsLCBzdGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXRjaChsb2NhdGlvbiwgZnVuY3Rpb24gKGVycm9yLCByZWRpcmVjdExvY2F0aW9uLCBuZXh0U3RhdGUpIHtcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyKGVycm9yKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlZGlyZWN0TG9jYXRpb24pIHtcbiAgICAgICAgICAgIGhpc3RvcnkucmVwbGFjZShyZWRpcmVjdExvY2F0aW9uKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5leHRTdGF0ZSkge1xuICAgICAgICAgICAgbGlzdGVuZXIobnVsbCwgbmV4dFN0YXRlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdMb2NhdGlvbiBcIiVzXCIgZGlkIG5vdCBtYXRjaCBhbnkgcm91dGVzJywgbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2ggKyBsb2NhdGlvbi5oYXNoKSA6IHZvaWQgMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBpc0FjdGl2ZTogaXNBY3RpdmUsXG4gICAgbWF0Y2g6IG1hdGNoLFxuICAgIGxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZTogbGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlLFxuICAgIGxpc3RlbjogbGlzdGVuXG4gIH07XG59XG5cbi8vZXhwb3J0IGRlZmF1bHQgdXNlUm91dGVzXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX1BhdHRlcm5VdGlscyA9IHJlcXVpcmUoJy4vUGF0dGVyblV0aWxzJyk7XG5cbmZ1bmN0aW9uIHJvdXRlUGFyYW1zQ2hhbmdlZChyb3V0ZSwgcHJldlN0YXRlLCBuZXh0U3RhdGUpIHtcbiAgaWYgKCFyb3V0ZS5wYXRoKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIHBhcmFtTmFtZXMgPSAoMCwgX1BhdHRlcm5VdGlscy5nZXRQYXJhbU5hbWVzKShyb3V0ZS5wYXRoKTtcblxuICByZXR1cm4gcGFyYW1OYW1lcy5zb21lKGZ1bmN0aW9uIChwYXJhbU5hbWUpIHtcbiAgICByZXR1cm4gcHJldlN0YXRlLnBhcmFtc1twYXJhbU5hbWVdICE9PSBuZXh0U3RhdGUucGFyYW1zW3BhcmFtTmFtZV07XG4gIH0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IG9mIHsgbGVhdmVSb3V0ZXMsIGNoYW5nZVJvdXRlcywgZW50ZXJSb3V0ZXMgfSBkZXRlcm1pbmVkIGJ5XG4gKiB0aGUgY2hhbmdlIGZyb20gcHJldlN0YXRlIHRvIG5leHRTdGF0ZS4gV2UgbGVhdmUgcm91dGVzIGlmIGVpdGhlclxuICogMSkgdGhleSBhcmUgbm90IGluIHRoZSBuZXh0IHN0YXRlIG9yIDIpIHRoZXkgYXJlIGluIHRoZSBuZXh0IHN0YXRlXG4gKiBidXQgdGhlaXIgcGFyYW1zIGhhdmUgY2hhbmdlZCAoaS5lLiAvdXNlcnMvMTIzID0+IC91c2Vycy80NTYpLlxuICpcbiAqIGxlYXZlUm91dGVzIGFyZSBvcmRlcmVkIHN0YXJ0aW5nIGF0IHRoZSBsZWFmIHJvdXRlIG9mIHRoZSB0cmVlXG4gKiB3ZSdyZSBsZWF2aW5nIHVwIHRvIHRoZSBjb21tb24gcGFyZW50IHJvdXRlLiBlbnRlclJvdXRlcyBhcmUgb3JkZXJlZFxuICogZnJvbSB0aGUgdG9wIG9mIHRoZSB0cmVlIHdlJ3JlIGVudGVyaW5nIGRvd24gdG8gdGhlIGxlYWYgcm91dGUuXG4gKlxuICogY2hhbmdlUm91dGVzIGFyZSBhbnkgcm91dGVzIHRoYXQgZGlkbid0IGxlYXZlIG9yIGVudGVyIGR1cmluZ1xuICogdGhlIHRyYW5zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVDaGFuZ2VkUm91dGVzKHByZXZTdGF0ZSwgbmV4dFN0YXRlKSB7XG4gIHZhciBwcmV2Um91dGVzID0gcHJldlN0YXRlICYmIHByZXZTdGF0ZS5yb3V0ZXM7XG4gIHZhciBuZXh0Um91dGVzID0gbmV4dFN0YXRlLnJvdXRlcztcblxuICB2YXIgbGVhdmVSb3V0ZXMgPSB2b2lkIDAsXG4gICAgICBjaGFuZ2VSb3V0ZXMgPSB2b2lkIDAsXG4gICAgICBlbnRlclJvdXRlcyA9IHZvaWQgMDtcbiAgaWYgKHByZXZSb3V0ZXMpIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcmVudElzTGVhdmluZyA9IGZhbHNlO1xuICAgICAgbGVhdmVSb3V0ZXMgPSBwcmV2Um91dGVzLmZpbHRlcihmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgICAgaWYgKHBhcmVudElzTGVhdmluZykge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBpc0xlYXZpbmcgPSBuZXh0Um91dGVzLmluZGV4T2Yocm91dGUpID09PSAtMSB8fCByb3V0ZVBhcmFtc0NoYW5nZWQocm91dGUsIHByZXZTdGF0ZSwgbmV4dFN0YXRlKTtcbiAgICAgICAgICBpZiAoaXNMZWF2aW5nKSBwYXJlbnRJc0xlYXZpbmcgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBpc0xlYXZpbmc7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBvbkxlYXZlIGhvb2tzIHN0YXJ0IGF0IHRoZSBsZWFmIHJvdXRlLlxuICAgICAgbGVhdmVSb3V0ZXMucmV2ZXJzZSgpO1xuXG4gICAgICBlbnRlclJvdXRlcyA9IFtdO1xuICAgICAgY2hhbmdlUm91dGVzID0gW107XG5cbiAgICAgIG5leHRSb3V0ZXMuZm9yRWFjaChmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgICAgdmFyIGlzTmV3ID0gcHJldlJvdXRlcy5pbmRleE9mKHJvdXRlKSA9PT0gLTE7XG4gICAgICAgIHZhciBwYXJhbXNDaGFuZ2VkID0gbGVhdmVSb3V0ZXMuaW5kZXhPZihyb3V0ZSkgIT09IC0xO1xuXG4gICAgICAgIGlmIChpc05ldyB8fCBwYXJhbXNDaGFuZ2VkKSBlbnRlclJvdXRlcy5wdXNoKHJvdXRlKTtlbHNlIGNoYW5nZVJvdXRlcy5wdXNoKHJvdXRlKTtcbiAgICAgIH0pO1xuICAgIH0pKCk7XG4gIH0gZWxzZSB7XG4gICAgbGVhdmVSb3V0ZXMgPSBbXTtcbiAgICBjaGFuZ2VSb3V0ZXMgPSBbXTtcbiAgICBlbnRlclJvdXRlcyA9IG5leHRSb3V0ZXM7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxlYXZlUm91dGVzOiBsZWF2ZVJvdXRlcyxcbiAgICBjaGFuZ2VSb3V0ZXM6IGNoYW5nZVJvdXRlcyxcbiAgICBlbnRlclJvdXRlczogZW50ZXJSb3V0ZXNcbiAgfTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gY29tcHV0ZUNoYW5nZWRSb3V0ZXM7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9jb21wdXRlQ2hhbmdlZFJvdXRlcy5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMucnVuRW50ZXJIb29rcyA9IHJ1bkVudGVySG9va3M7XG5leHBvcnRzLnJ1bkNoYW5nZUhvb2tzID0gcnVuQ2hhbmdlSG9va3M7XG5leHBvcnRzLnJ1bkxlYXZlSG9va3MgPSBydW5MZWF2ZUhvb2tzO1xuXG52YXIgX0FzeW5jVXRpbHMgPSByZXF1aXJlKCcuL0FzeW5jVXRpbHMnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gY3JlYXRlVHJhbnNpdGlvbkhvb2soaG9vaywgcm91dGUsIGFzeW5jQXJpdHkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBob29rLmFwcGx5KHJvdXRlLCBhcmdzKTtcblxuICAgIGlmIChob29rLmxlbmd0aCA8IGFzeW5jQXJpdHkpIHtcbiAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICAgIC8vIEFzc3VtZSBob29rIGV4ZWN1dGVzIHN5bmNocm9ub3VzbHkgYW5kXG4gICAgICAvLyBhdXRvbWF0aWNhbGx5IGNhbGwgdGhlIGNhbGxiYWNrLlxuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEVudGVySG9va3Mocm91dGVzKSB7XG4gIHJldHVybiByb3V0ZXMucmVkdWNlKGZ1bmN0aW9uIChob29rcywgcm91dGUpIHtcbiAgICBpZiAocm91dGUub25FbnRlcikgaG9va3MucHVzaChjcmVhdGVUcmFuc2l0aW9uSG9vayhyb3V0ZS5vbkVudGVyLCByb3V0ZSwgMykpO1xuXG4gICAgcmV0dXJuIGhvb2tzO1xuICB9LCBbXSk7XG59XG5cbmZ1bmN0aW9uIGdldENoYW5nZUhvb2tzKHJvdXRlcykge1xuICByZXR1cm4gcm91dGVzLnJlZHVjZShmdW5jdGlvbiAoaG9va3MsIHJvdXRlKSB7XG4gICAgaWYgKHJvdXRlLm9uQ2hhbmdlKSBob29rcy5wdXNoKGNyZWF0ZVRyYW5zaXRpb25Ib29rKHJvdXRlLm9uQ2hhbmdlLCByb3V0ZSwgNCkpO1xuICAgIHJldHVybiBob29rcztcbiAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiBydW5UcmFuc2l0aW9uSG9va3MobGVuZ3RoLCBpdGVyLCBjYWxsYmFjaykge1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGNhbGxiYWNrKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHJlZGlyZWN0SW5mbyA9IHZvaWQgMDtcbiAgZnVuY3Rpb24gcmVwbGFjZShsb2NhdGlvbiwgZGVwcmVjYXRlZFBhdGhuYW1lLCBkZXByZWNhdGVkUXVlcnkpIHtcbiAgICBpZiAoZGVwcmVjYXRlZFBhdGhuYW1lKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ2ByZXBsYWNlU3RhdGUoc3RhdGUsIHBhdGhuYW1lLCBxdWVyeSkgaXMgZGVwcmVjYXRlZDsgdXNlIGByZXBsYWNlKGxvY2F0aW9uKWAgd2l0aCBhIGxvY2F0aW9uIGRlc2NyaXB0b3IgaW5zdGVhZC4gaHR0cDovL3RpbnkuY2Mvcm91dGVyLWlzQWN0aXZlZGVwcmVjYXRlZCcpIDogdm9pZCAwO1xuICAgICAgcmVkaXJlY3RJbmZvID0ge1xuICAgICAgICBwYXRobmFtZTogZGVwcmVjYXRlZFBhdGhuYW1lLFxuICAgICAgICBxdWVyeTogZGVwcmVjYXRlZFF1ZXJ5LFxuICAgICAgICBzdGF0ZTogbG9jYXRpb25cbiAgICAgIH07XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZWRpcmVjdEluZm8gPSBsb2NhdGlvbjtcbiAgfVxuXG4gICgwLCBfQXN5bmNVdGlscy5sb29wQXN5bmMpKGxlbmd0aCwgZnVuY3Rpb24gKGluZGV4LCBuZXh0LCBkb25lKSB7XG4gICAgaXRlcihpbmRleCwgcmVwbGFjZSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgfHwgcmVkaXJlY3RJbmZvKSB7XG4gICAgICAgIGRvbmUoZXJyb3IsIHJlZGlyZWN0SW5mbyk7IC8vIE5vIG5lZWQgdG8gY29udGludWUuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBSdW5zIGFsbCBvbkVudGVyIGhvb2tzIGluIHRoZSBnaXZlbiBhcnJheSBvZiByb3V0ZXMgaW4gb3JkZXJcbiAqIHdpdGggb25FbnRlcihuZXh0U3RhdGUsIHJlcGxhY2UsIGNhbGxiYWNrKSBhbmQgY2FsbHNcbiAqIGNhbGxiYWNrKGVycm9yLCByZWRpcmVjdEluZm8pIHdoZW4gZmluaXNoZWQuIFRoZSBmaXJzdCBob29rXG4gKiB0byB1c2UgcmVwbGFjZSBzaG9ydC1jaXJjdWl0cyB0aGUgbG9vcC5cbiAqXG4gKiBJZiBhIGhvb2sgbmVlZHMgdG8gcnVuIGFzeW5jaHJvbm91c2x5LCBpdCBtYXkgdXNlIHRoZSBjYWxsYmFja1xuICogZnVuY3Rpb24uIEhvd2V2ZXIsIGRvaW5nIHNvIHdpbGwgY2F1c2UgdGhlIHRyYW5zaXRpb24gdG8gcGF1c2UsXG4gKiB3aGljaCBjb3VsZCBsZWFkIHRvIGEgbm9uLXJlc3BvbnNpdmUgVUkgaWYgdGhlIGhvb2sgaXMgc2xvdy5cbiAqL1xuZnVuY3Rpb24gcnVuRW50ZXJIb29rcyhyb3V0ZXMsIG5leHRTdGF0ZSwgY2FsbGJhY2spIHtcbiAgdmFyIGhvb2tzID0gZ2V0RW50ZXJIb29rcyhyb3V0ZXMpO1xuICByZXR1cm4gcnVuVHJhbnNpdGlvbkhvb2tzKGhvb2tzLmxlbmd0aCwgZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlLCBuZXh0KSB7XG4gICAgaG9va3NbaW5kZXhdKG5leHRTdGF0ZSwgcmVwbGFjZSwgbmV4dCk7XG4gIH0sIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBSdW5zIGFsbCBvbkNoYW5nZSBob29rcyBpbiB0aGUgZ2l2ZW4gYXJyYXkgb2Ygcm91dGVzIGluIG9yZGVyXG4gKiB3aXRoIG9uQ2hhbmdlKHByZXZTdGF0ZSwgbmV4dFN0YXRlLCByZXBsYWNlLCBjYWxsYmFjaykgYW5kIGNhbGxzXG4gKiBjYWxsYmFjayhlcnJvciwgcmVkaXJlY3RJbmZvKSB3aGVuIGZpbmlzaGVkLiBUaGUgZmlyc3QgaG9va1xuICogdG8gdXNlIHJlcGxhY2Ugc2hvcnQtY2lyY3VpdHMgdGhlIGxvb3AuXG4gKlxuICogSWYgYSBob29rIG5lZWRzIHRvIHJ1biBhc3luY2hyb25vdXNseSwgaXQgbWF5IHVzZSB0aGUgY2FsbGJhY2tcbiAqIGZ1bmN0aW9uLiBIb3dldmVyLCBkb2luZyBzbyB3aWxsIGNhdXNlIHRoZSB0cmFuc2l0aW9uIHRvIHBhdXNlLFxuICogd2hpY2ggY291bGQgbGVhZCB0byBhIG5vbi1yZXNwb25zaXZlIFVJIGlmIHRoZSBob29rIGlzIHNsb3cuXG4gKi9cbmZ1bmN0aW9uIHJ1bkNoYW5nZUhvb2tzKHJvdXRlcywgc3RhdGUsIG5leHRTdGF0ZSwgY2FsbGJhY2spIHtcbiAgdmFyIGhvb2tzID0gZ2V0Q2hhbmdlSG9va3Mocm91dGVzKTtcbiAgcmV0dXJuIHJ1blRyYW5zaXRpb25Ib29rcyhob29rcy5sZW5ndGgsIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZSwgbmV4dCkge1xuICAgIGhvb2tzW2luZGV4XShzdGF0ZSwgbmV4dFN0YXRlLCByZXBsYWNlLCBuZXh0KTtcbiAgfSwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIFJ1bnMgYWxsIG9uTGVhdmUgaG9va3MgaW4gdGhlIGdpdmVuIGFycmF5IG9mIHJvdXRlcyBpbiBvcmRlci5cbiAqL1xuZnVuY3Rpb24gcnVuTGVhdmVIb29rcyhyb3V0ZXMsIHByZXZTdGF0ZSkge1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcm91dGVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHJvdXRlc1tpXS5vbkxlYXZlKSByb3V0ZXNbaV0ub25MZWF2ZS5jYWxsKHJvdXRlc1tpXSwgcHJldlN0YXRlKTtcbiAgfVxufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL1RyYW5zaXRpb25VdGlscy5qc1xuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5sb29wQXN5bmMgPSBsb29wQXN5bmM7XG5leHBvcnRzLm1hcEFzeW5jID0gbWFwQXN5bmM7XG5mdW5jdGlvbiBsb29wQXN5bmModHVybnMsIHdvcmssIGNhbGxiYWNrKSB7XG4gIHZhciBjdXJyZW50VHVybiA9IDAsXG4gICAgICBpc0RvbmUgPSBmYWxzZTtcbiAgdmFyIHN5bmMgPSBmYWxzZSxcbiAgICAgIGhhc05leHQgPSBmYWxzZSxcbiAgICAgIGRvbmVBcmdzID0gdm9pZCAwO1xuXG4gIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgaXNEb25lID0gdHJ1ZTtcbiAgICBpZiAoc3luYykge1xuICAgICAgLy8gSXRlcmF0ZSBpbnN0ZWFkIG9mIHJlY3Vyc2luZyBpZiBwb3NzaWJsZS5cbiAgICAgIGRvbmVBcmdzID0gW10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBuZXh0KCkge1xuICAgIGlmIChpc0RvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBoYXNOZXh0ID0gdHJ1ZTtcbiAgICBpZiAoc3luYykge1xuICAgICAgLy8gSXRlcmF0ZSBpbnN0ZWFkIG9mIHJlY3Vyc2luZyBpZiBwb3NzaWJsZS5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzeW5jID0gdHJ1ZTtcblxuICAgIHdoaWxlICghaXNEb25lICYmIGN1cnJlbnRUdXJuIDwgdHVybnMgJiYgaGFzTmV4dCkge1xuICAgICAgaGFzTmV4dCA9IGZhbHNlO1xuICAgICAgd29yay5jYWxsKHRoaXMsIGN1cnJlbnRUdXJuKyssIG5leHQsIGRvbmUpO1xuICAgIH1cblxuICAgIHN5bmMgPSBmYWxzZTtcblxuICAgIGlmIChpc0RvbmUpIHtcbiAgICAgIC8vIFRoaXMgbWVhbnMgdGhlIGxvb3AgZmluaXNoZWQgc3luY2hyb25vdXNseS5cbiAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGRvbmVBcmdzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudFR1cm4gPj0gdHVybnMgJiYgaGFzTmV4dCkge1xuICAgICAgaXNEb25lID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9XG5cbiAgbmV4dCgpO1xufVxuXG5mdW5jdGlvbiBtYXBBc3luYyhhcnJheSwgd29yaywgY2FsbGJhY2spIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgdmFyIHZhbHVlcyA9IFtdO1xuXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiBjYWxsYmFjayhudWxsLCB2YWx1ZXMpO1xuXG4gIHZhciBpc0RvbmUgPSBmYWxzZSxcbiAgICAgIGRvbmVDb3VudCA9IDA7XG5cbiAgZnVuY3Rpb24gZG9uZShpbmRleCwgZXJyb3IsIHZhbHVlKSB7XG4gICAgaWYgKGlzRG9uZSkgcmV0dXJuO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBpc0RvbmUgPSB0cnVlO1xuICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG5cbiAgICAgIGlzRG9uZSA9ICsrZG9uZUNvdW50ID09PSBsZW5ndGg7XG5cbiAgICAgIGlmIChpc0RvbmUpIGNhbGxiYWNrKG51bGwsIHZhbHVlcyk7XG4gICAgfVxuICB9XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICB3b3JrKGl0ZW0sIGluZGV4LCBmdW5jdGlvbiAoZXJyb3IsIHZhbHVlKSB7XG4gICAgICBkb25lKGluZGV4LCBlcnJvciwgdmFsdWUpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9Bc3luY1V0aWxzLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gaXNBY3RpdmU7XG5cbnZhciBfUGF0dGVyblV0aWxzID0gcmVxdWlyZSgnLi9QYXR0ZXJuVXRpbHMnKTtcblxuZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT0gYikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGIpICYmIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgcmV0dXJuIGRlZXBFcXVhbChpdGVtLCBiW2luZGV4XSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoKHR5cGVvZiBhID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihhKSkgPT09ICdvYmplY3QnKSB7XG4gICAgZm9yICh2YXIgcCBpbiBhKSB7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLCBwKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFbcF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYltwXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICghZGVlcEVxdWFsKGFbcF0sIGJbcF0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQgcGF0aG5hbWUgbWF0Y2hlcyB0aGUgc3VwcGxpZWQgb25lLCBuZXQgb2ZcbiAqIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoIG5vcm1hbGl6YXRpb24uIFRoaXMgaXMgc3VmZmljaWVudCBmb3IgYW5cbiAqIGluZGV4T25seSByb3V0ZSBtYXRjaC5cbiAqL1xuZnVuY3Rpb24gcGF0aElzQWN0aXZlKHBhdGhuYW1lLCBjdXJyZW50UGF0aG5hbWUpIHtcbiAgLy8gTm9ybWFsaXplIGxlYWRpbmcgc2xhc2ggZm9yIGNvbnNpc3RlbmN5LiBMZWFkaW5nIHNsYXNoIG9uIHBhdGhuYW1lIGhhc1xuICAvLyBhbHJlYWR5IGJlZW4gbm9ybWFsaXplZCBpbiBpc0FjdGl2ZS4gU2VlIGNhdmVhdCB0aGVyZS5cbiAgaWYgKGN1cnJlbnRQYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgIGN1cnJlbnRQYXRobmFtZSA9ICcvJyArIGN1cnJlbnRQYXRobmFtZTtcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgZW5kIG9mIGJvdGggcGF0aCBuYW1lcyB0b28uIE1heWJlIGAvZm9vL2Agc2hvdWxkbid0IHNob3dcbiAgLy8gYC9mb29gIGFzIGFjdGl2ZSwgYnV0IGluIHRoaXMgY2FzZSwgd2Ugd291bGQgYWxyZWFkeSBoYXZlIGZhaWxlZCB0aGVcbiAgLy8gbWF0Y2guXG4gIGlmIChwYXRobmFtZS5jaGFyQXQocGF0aG5hbWUubGVuZ3RoIC0gMSkgIT09ICcvJykge1xuICAgIHBhdGhuYW1lICs9ICcvJztcbiAgfVxuICBpZiAoY3VycmVudFBhdGhuYW1lLmNoYXJBdChjdXJyZW50UGF0aG5hbWUubGVuZ3RoIC0gMSkgIT09ICcvJykge1xuICAgIGN1cnJlbnRQYXRobmFtZSArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gY3VycmVudFBhdGhuYW1lID09PSBwYXRobmFtZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHBhdGhuYW1lIG1hdGNoZXMgdGhlIGFjdGl2ZSByb3V0ZXMgYW5kIHBhcmFtcy5cbiAqL1xuZnVuY3Rpb24gcm91dGVJc0FjdGl2ZShwYXRobmFtZSwgcm91dGVzLCBwYXJhbXMpIHtcbiAgdmFyIHJlbWFpbmluZ1BhdGhuYW1lID0gcGF0aG5hbWUsXG4gICAgICBwYXJhbU5hbWVzID0gW10sXG4gICAgICBwYXJhbVZhbHVlcyA9IFtdO1xuXG4gIC8vIGZvci4uLm9mIHdvdWxkIHdvcmsgaGVyZSBidXQgaXQncyBwcm9iYWJseSBzbG93ZXIgcG9zdC10cmFuc3BpbGF0aW9uLlxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcm91dGVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHJvdXRlID0gcm91dGVzW2ldO1xuICAgIHZhciBwYXR0ZXJuID0gcm91dGUucGF0aCB8fCAnJztcblxuICAgIGlmIChwYXR0ZXJuLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgICByZW1haW5pbmdQYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgcGFyYW1OYW1lcyA9IFtdO1xuICAgICAgcGFyYW1WYWx1ZXMgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAocmVtYWluaW5nUGF0aG5hbWUgIT09IG51bGwgJiYgcGF0dGVybikge1xuICAgICAgdmFyIG1hdGNoZWQgPSAoMCwgX1BhdHRlcm5VdGlscy5tYXRjaFBhdHRlcm4pKHBhdHRlcm4sIHJlbWFpbmluZ1BhdGhuYW1lKTtcbiAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gbWF0Y2hlZC5yZW1haW5pbmdQYXRobmFtZTtcbiAgICAgICAgcGFyYW1OYW1lcyA9IFtdLmNvbmNhdChwYXJhbU5hbWVzLCBtYXRjaGVkLnBhcmFtTmFtZXMpO1xuICAgICAgICBwYXJhbVZhbHVlcyA9IFtdLmNvbmNhdChwYXJhbVZhbHVlcywgbWF0Y2hlZC5wYXJhbVZhbHVlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1haW5pbmdQYXRobmFtZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZW1haW5pbmdQYXRobmFtZSA9PT0gJycpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBhbiBleGFjdCBtYXRjaCBvbiB0aGUgcm91dGUuIEp1c3QgY2hlY2sgdGhhdCBhbGwgdGhlIHBhcmFtc1xuICAgICAgICAvLyBtYXRjaC5cbiAgICAgICAgLy8gRklYTUU6IFRoaXMgZG9lc24ndCB3b3JrIG9uIHJlcGVhdGVkIHBhcmFtcy5cbiAgICAgICAgcmV0dXJuIHBhcmFtTmFtZXMuZXZlcnkoZnVuY3Rpb24gKHBhcmFtTmFtZSwgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHBhcmFtVmFsdWVzW2luZGV4XSkgPT09IFN0cmluZyhwYXJhbXNbcGFyYW1OYW1lXSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYWxsIGtleS92YWx1ZSBwYWlycyBpbiB0aGUgZ2l2ZW4gcXVlcnkgYXJlXG4gKiBjdXJyZW50bHkgYWN0aXZlLlxuICovXG5mdW5jdGlvbiBxdWVyeUlzQWN0aXZlKHF1ZXJ5LCBhY3RpdmVRdWVyeSkge1xuICBpZiAoYWN0aXZlUXVlcnkgPT0gbnVsbCkgcmV0dXJuIHF1ZXJ5ID09IG51bGw7XG5cbiAgaWYgKHF1ZXJ5ID09IG51bGwpIHJldHVybiB0cnVlO1xuXG4gIHJldHVybiBkZWVwRXF1YWwocXVlcnksIGFjdGl2ZVF1ZXJ5KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYSA8TGluaz4gdG8gdGhlIGdpdmVuIHBhdGhuYW1lL3F1ZXJ5IGNvbWJpbmF0aW9uIGlzXG4gKiBjdXJyZW50bHkgYWN0aXZlLlxuICovXG5mdW5jdGlvbiBpc0FjdGl2ZShfcmVmLCBpbmRleE9ubHksIGN1cnJlbnRMb2NhdGlvbiwgcm91dGVzLCBwYXJhbXMpIHtcbiAgdmFyIHBhdGhuYW1lID0gX3JlZi5wYXRobmFtZTtcbiAgdmFyIHF1ZXJ5ID0gX3JlZi5xdWVyeTtcblxuICBpZiAoY3VycmVudExvY2F0aW9uID09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICAvLyBUT0RPOiBUaGlzIGlzIGEgYml0IHVnbHkuIEl0IGtlZXBzIGFyb3VuZCBzdXBwb3J0IGZvciB0cmVhdGluZyBwYXRobmFtZXNcbiAgLy8gd2l0aG91dCBwcmVjZWRpbmcgc2xhc2hlcyBhcyBhYnNvbHV0ZSBwYXRocywgYnV0IHBvc3NpYmx5IGFsc28gd29ya3NcbiAgLy8gYXJvdW5kIHRoZSBzYW1lIHF1aXJrcyB3aXRoIGJhc2VuYW1lcyBhcyBpbiBtYXRjaFJvdXRlcy5cbiAgaWYgKHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfVxuXG4gIGlmICghcGF0aElzQWN0aXZlKHBhdGhuYW1lLCBjdXJyZW50TG9jYXRpb24ucGF0aG5hbWUpKSB7XG4gICAgLy8gVGhlIHBhdGggY2hlY2sgaXMgbmVjZXNzYXJ5IGFuZCBzdWZmaWNpZW50IGZvciBpbmRleE9ubHksIGJ1dCBvdGhlcndpc2VcbiAgICAvLyB3ZSBzdGlsbCBuZWVkIHRvIGNoZWNrIHRoZSByb3V0ZXMuXG4gICAgaWYgKGluZGV4T25seSB8fCAhcm91dGVJc0FjdGl2ZShwYXRobmFtZSwgcm91dGVzLCBwYXJhbXMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHF1ZXJ5SXNBY3RpdmUocXVlcnksIGN1cnJlbnRMb2NhdGlvbi5xdWVyeSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9pc0FjdGl2ZS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9Bc3luY1V0aWxzID0gcmVxdWlyZSgnLi9Bc3luY1V0aWxzJyk7XG5cbnZhciBfbWFrZVN0YXRlV2l0aExvY2F0aW9uID0gcmVxdWlyZSgnLi9tYWtlU3RhdGVXaXRoTG9jYXRpb24nKTtcblxudmFyIF9tYWtlU3RhdGVXaXRoTG9jYXRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWFrZVN0YXRlV2l0aExvY2F0aW9uKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50c0ZvclJvdXRlKG5leHRTdGF0ZSwgcm91dGUsIGNhbGxiYWNrKSB7XG4gIGlmIChyb3V0ZS5jb21wb25lbnQgfHwgcm91dGUuY29tcG9uZW50cykge1xuICAgIGNhbGxiYWNrKG51bGwsIHJvdXRlLmNvbXBvbmVudCB8fCByb3V0ZS5jb21wb25lbnRzKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZ2V0Q29tcG9uZW50ID0gcm91dGUuZ2V0Q29tcG9uZW50IHx8IHJvdXRlLmdldENvbXBvbmVudHM7XG4gIGlmICghZ2V0Q29tcG9uZW50KSB7XG4gICAgY2FsbGJhY2soKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbG9jYXRpb24gPSBuZXh0U3RhdGUubG9jYXRpb247XG5cbiAgdmFyIG5leHRTdGF0ZVdpdGhMb2NhdGlvbiA9ICgwLCBfbWFrZVN0YXRlV2l0aExvY2F0aW9uMi5kZWZhdWx0KShuZXh0U3RhdGUsIGxvY2F0aW9uKTtcblxuICBnZXRDb21wb25lbnQuY2FsbChyb3V0ZSwgbmV4dFN0YXRlV2l0aExvY2F0aW9uLCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgZmV0Y2hlcyBhbGwgY29tcG9uZW50cyBuZWVkZWQgZm9yIHRoZSBnaXZlbiByb3V0ZXJcbiAqIHN0YXRlIGFuZCBjYWxscyBjYWxsYmFjayhlcnJvciwgY29tcG9uZW50cykgd2hlbiBmaW5pc2hlZC5cbiAqXG4gKiBOb3RlOiBUaGlzIG9wZXJhdGlvbiBtYXkgZmluaXNoIHN5bmNocm9ub3VzbHkgaWYgbm8gcm91dGVzIGhhdmUgYW5cbiAqIGFzeW5jaHJvbm91cyBnZXRDb21wb25lbnRzIG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50cyhuZXh0U3RhdGUsIGNhbGxiYWNrKSB7XG4gICgwLCBfQXN5bmNVdGlscy5tYXBBc3luYykobmV4dFN0YXRlLnJvdXRlcywgZnVuY3Rpb24gKHJvdXRlLCBpbmRleCwgY2FsbGJhY2spIHtcbiAgICBnZXRDb21wb25lbnRzRm9yUm91dGUobmV4dFN0YXRlLCByb3V0ZSwgY2FsbGJhY2spO1xuICB9LCBjYWxsYmFjayk7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGdldENvbXBvbmVudHM7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9nZXRDb21wb25lbnRzLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBtYWtlU3RhdGVXaXRoTG9jYXRpb247XG5cbnZhciBfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyA9IHJlcXVpcmUoJy4vZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBtYWtlU3RhdGVXaXRoTG9jYXRpb24oc3RhdGUsIGxvY2F0aW9uKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzLmNhblVzZU1lbWJyYW5lKSB7XG4gICAgdmFyIHN0YXRlV2l0aExvY2F0aW9uID0gX2V4dGVuZHMoe30sIHN0YXRlKTtcblxuICAgIC8vIEkgZG9uJ3QgdXNlIGRlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMgaGVyZSBiZWNhdXNlIEkgd2FudCB0byBrZWVwIHRoZVxuICAgIC8vIHNhbWUgY29kZSBwYXRoIGJldHdlZW4gZGV2ZWxvcG1lbnQgYW5kIHByb2R1Y3Rpb24sIGluIHRoYXQgd2UganVzdFxuICAgIC8vIGFzc2lnbiBleHRyYSBwcm9wZXJ0aWVzIHRvIHRoZSBjb3B5IG9mIHRoZSBzdGF0ZSBvYmplY3QgaW4gYm90aCBjYXNlcy5cblxuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKHByb3ApIHtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGxvY2F0aW9uLCBwcm9wKSkge1xuICAgICAgICByZXR1cm4gJ2NvbnRpbnVlJztcbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN0YXRlV2l0aExvY2F0aW9uLCBwcm9wLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnQWNjZXNzaW5nIGxvY2F0aW9uIHByb3BlcnRpZXMgZGlyZWN0bHkgZnJvbSB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYGdldENvbXBvbmVudGAsIGBnZXRDb21wb25lbnRzYCwgYGdldENoaWxkUm91dGVzYCwgYW5kIGBnZXRJbmRleFJvdXRlYCBpcyBkZXByZWNhdGVkLiBUaGF0IGFyZ3VtZW50IGlzIG5vdyB0aGUgcm91dGVyIHN0YXRlIChgbmV4dFN0YXRlYCBvciBgcGFydGlhbE5leHRTdGF0ZWApIHJhdGhlciB0aGFuIHRoZSBsb2NhdGlvbi4gVG8gYWNjZXNzIHRoZSBsb2NhdGlvbiwgdXNlIGBuZXh0U3RhdGUubG9jYXRpb25gIG9yIGBwYXJ0aWFsTmV4dFN0YXRlLmxvY2F0aW9uYC4nKSA6IHZvaWQgMDtcbiAgICAgICAgICByZXR1cm4gbG9jYXRpb25bcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmb3IgKHZhciBwcm9wIGluIGxvY2F0aW9uKSB7XG4gICAgICB2YXIgX3JldCA9IF9sb29wKHByb3ApO1xuXG4gICAgICBpZiAoX3JldCA9PT0gJ2NvbnRpbnVlJykgY29udGludWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXRlV2l0aExvY2F0aW9uO1xuICB9XG5cbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwgbG9jYXRpb24pO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvbWFrZVN0YXRlV2l0aExvY2F0aW9uLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gbWF0Y2hSb3V0ZXM7XG5cbnZhciBfQXN5bmNVdGlscyA9IHJlcXVpcmUoJy4vQXN5bmNVdGlscycpO1xuXG52YXIgX21ha2VTdGF0ZVdpdGhMb2NhdGlvbiA9IHJlcXVpcmUoJy4vbWFrZVN0YXRlV2l0aExvY2F0aW9uJyk7XG5cbnZhciBfbWFrZVN0YXRlV2l0aExvY2F0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21ha2VTdGF0ZVdpdGhMb2NhdGlvbik7XG5cbnZhciBfUGF0dGVyblV0aWxzID0gcmVxdWlyZSgnLi9QYXR0ZXJuVXRpbHMnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxudmFyIF9Sb3V0ZVV0aWxzID0gcmVxdWlyZSgnLi9Sb3V0ZVV0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGdldENoaWxkUm91dGVzKHJvdXRlLCBsb2NhdGlvbiwgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMsIGNhbGxiYWNrKSB7XG4gIGlmIChyb3V0ZS5jaGlsZFJvdXRlcykge1xuICAgIHJldHVybiBbbnVsbCwgcm91dGUuY2hpbGRSb3V0ZXNdO1xuICB9XG4gIGlmICghcm91dGUuZ2V0Q2hpbGRSb3V0ZXMpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgc3luYyA9IHRydWUsXG4gICAgICByZXN1bHQgPSB2b2lkIDA7XG5cbiAgdmFyIHBhcnRpYWxOZXh0U3RhdGUgPSB7XG4gICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgIHBhcmFtczogY3JlYXRlUGFyYW1zKHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzKVxuICB9O1xuXG4gIHZhciBwYXJ0aWFsTmV4dFN0YXRlV2l0aExvY2F0aW9uID0gKDAsIF9tYWtlU3RhdGVXaXRoTG9jYXRpb24yLmRlZmF1bHQpKHBhcnRpYWxOZXh0U3RhdGUsIGxvY2F0aW9uKTtcblxuICByb3V0ZS5nZXRDaGlsZFJvdXRlcyhwYXJ0aWFsTmV4dFN0YXRlV2l0aExvY2F0aW9uLCBmdW5jdGlvbiAoZXJyb3IsIGNoaWxkUm91dGVzKSB7XG4gICAgY2hpbGRSb3V0ZXMgPSAhZXJyb3IgJiYgKDAsIF9Sb3V0ZVV0aWxzLmNyZWF0ZVJvdXRlcykoY2hpbGRSb3V0ZXMpO1xuICAgIGlmIChzeW5jKSB7XG4gICAgICByZXN1bHQgPSBbZXJyb3IsIGNoaWxkUm91dGVzXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYWxsYmFjayhlcnJvciwgY2hpbGRSb3V0ZXMpO1xuICB9KTtcblxuICBzeW5jID0gZmFsc2U7XG4gIHJldHVybiByZXN1bHQ7IC8vIE1pZ2h0IGJlIHVuZGVmaW5lZC5cbn1cblxuZnVuY3Rpb24gZ2V0SW5kZXhSb3V0ZShyb3V0ZSwgbG9jYXRpb24sIHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzLCBjYWxsYmFjaykge1xuICBpZiAocm91dGUuaW5kZXhSb3V0ZSkge1xuICAgIGNhbGxiYWNrKG51bGwsIHJvdXRlLmluZGV4Um91dGUpO1xuICB9IGVsc2UgaWYgKHJvdXRlLmdldEluZGV4Um91dGUpIHtcbiAgICB2YXIgcGFydGlhbE5leHRTdGF0ZSA9IHtcbiAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgIHBhcmFtczogY3JlYXRlUGFyYW1zKHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzKVxuICAgIH07XG5cbiAgICB2YXIgcGFydGlhbE5leHRTdGF0ZVdpdGhMb2NhdGlvbiA9ICgwLCBfbWFrZVN0YXRlV2l0aExvY2F0aW9uMi5kZWZhdWx0KShwYXJ0aWFsTmV4dFN0YXRlLCBsb2NhdGlvbik7XG5cbiAgICByb3V0ZS5nZXRJbmRleFJvdXRlKHBhcnRpYWxOZXh0U3RhdGVXaXRoTG9jYXRpb24sIGZ1bmN0aW9uIChlcnJvciwgaW5kZXhSb3V0ZSkge1xuICAgICAgY2FsbGJhY2soZXJyb3IsICFlcnJvciAmJiAoMCwgX1JvdXRlVXRpbHMuY3JlYXRlUm91dGVzKShpbmRleFJvdXRlKVswXSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAocm91dGUuY2hpbGRSb3V0ZXMpIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhdGhsZXNzID0gcm91dGUuY2hpbGRSb3V0ZXMuZmlsdGVyKGZ1bmN0aW9uIChjaGlsZFJvdXRlKSB7XG4gICAgICAgIHJldHVybiAhY2hpbGRSb3V0ZS5wYXRoO1xuICAgICAgfSk7XG5cbiAgICAgICgwLCBfQXN5bmNVdGlscy5sb29wQXN5bmMpKHBhdGhsZXNzLmxlbmd0aCwgZnVuY3Rpb24gKGluZGV4LCBuZXh0LCBkb25lKSB7XG4gICAgICAgIGdldEluZGV4Um91dGUocGF0aGxlc3NbaW5kZXhdLCBsb2NhdGlvbiwgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMsIGZ1bmN0aW9uIChlcnJvciwgaW5kZXhSb3V0ZSkge1xuICAgICAgICAgIGlmIChlcnJvciB8fCBpbmRleFJvdXRlKSB7XG4gICAgICAgICAgICB2YXIgcm91dGVzID0gW3BhdGhsZXNzW2luZGV4XV0uY29uY2F0KEFycmF5LmlzQXJyYXkoaW5kZXhSb3V0ZSkgPyBpbmRleFJvdXRlIDogW2luZGV4Um91dGVdKTtcbiAgICAgICAgICAgIGRvbmUoZXJyb3IsIHJvdXRlcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSwgZnVuY3Rpb24gKGVyciwgcm91dGVzKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHJvdXRlcyk7XG4gICAgICB9KTtcbiAgICB9KSgpO1xuICB9IGVsc2Uge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzaWduUGFyYW1zKHBhcmFtcywgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMpIHtcbiAgcmV0dXJuIHBhcmFtTmFtZXMucmVkdWNlKGZ1bmN0aW9uIChwYXJhbXMsIHBhcmFtTmFtZSwgaW5kZXgpIHtcbiAgICB2YXIgcGFyYW1WYWx1ZSA9IHBhcmFtVmFsdWVzICYmIHBhcmFtVmFsdWVzW2luZGV4XTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtc1twYXJhbU5hbWVdKSkge1xuICAgICAgcGFyYW1zW3BhcmFtTmFtZV0ucHVzaChwYXJhbVZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHBhcmFtTmFtZSBpbiBwYXJhbXMpIHtcbiAgICAgIHBhcmFtc1twYXJhbU5hbWVdID0gW3BhcmFtc1twYXJhbU5hbWVdLCBwYXJhbVZhbHVlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyYW1zW3BhcmFtTmFtZV0gPSBwYXJhbVZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH0sIHBhcmFtcyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhcmFtcyhwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcykge1xuICByZXR1cm4gYXNzaWduUGFyYW1zKHt9LCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcyk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoUm91dGVEZWVwKHJvdXRlLCBsb2NhdGlvbiwgcmVtYWluaW5nUGF0aG5hbWUsIHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzLCBjYWxsYmFjaykge1xuICB2YXIgcGF0dGVybiA9IHJvdXRlLnBhdGggfHwgJyc7XG5cbiAgaWYgKHBhdHRlcm4uY2hhckF0KDApID09PSAnLycpIHtcbiAgICByZW1haW5pbmdQYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lO1xuICAgIHBhcmFtTmFtZXMgPSBbXTtcbiAgICBwYXJhbVZhbHVlcyA9IFtdO1xuICB9XG5cbiAgLy8gT25seSB0cnkgdG8gbWF0Y2ggdGhlIHBhdGggaWYgdGhlIHJvdXRlIGFjdHVhbGx5IGhhcyBhIHBhdHRlcm4sIGFuZCBpZlxuICAvLyB3ZSdyZSBub3QganVzdCBzZWFyY2hpbmcgZm9yIHBvdGVudGlhbCBuZXN0ZWQgYWJzb2x1dGUgcGF0aHMuXG4gIGlmIChyZW1haW5pbmdQYXRobmFtZSAhPT0gbnVsbCAmJiBwYXR0ZXJuKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBtYXRjaGVkID0gKDAsIF9QYXR0ZXJuVXRpbHMubWF0Y2hQYXR0ZXJuKShwYXR0ZXJuLCByZW1haW5pbmdQYXRobmFtZSk7XG4gICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICByZW1haW5pbmdQYXRobmFtZSA9IG1hdGNoZWQucmVtYWluaW5nUGF0aG5hbWU7XG4gICAgICAgIHBhcmFtTmFtZXMgPSBbXS5jb25jYXQocGFyYW1OYW1lcywgbWF0Y2hlZC5wYXJhbU5hbWVzKTtcbiAgICAgICAgcGFyYW1WYWx1ZXMgPSBbXS5jb25jYXQocGFyYW1WYWx1ZXMsIG1hdGNoZWQucGFyYW1WYWx1ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtYWluaW5nUGF0aG5hbWUgPSBudWxsO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgfVxuXG4gICAgLy8gQnkgYXNzdW1wdGlvbiwgcGF0dGVybiBpcyBub24tZW1wdHkgaGVyZSwgd2hpY2ggaXMgdGhlIHByZXJlcXVpc2l0ZSBmb3JcbiAgICAvLyBhY3R1YWxseSB0ZXJtaW5hdGluZyBhIG1hdGNoLlxuICAgIGlmIChyZW1haW5pbmdQYXRobmFtZSA9PT0gJycpIHtcbiAgICAgIHZhciBfcmV0MiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0ge1xuICAgICAgICAgIHJvdXRlczogW3JvdXRlXSxcbiAgICAgICAgICBwYXJhbXM6IGNyZWF0ZVBhcmFtcyhwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcylcbiAgICAgICAgfTtcblxuICAgICAgICBnZXRJbmRleFJvdXRlKHJvdXRlLCBsb2NhdGlvbiwgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMsIGZ1bmN0aW9uIChlcnJvciwgaW5kZXhSb3V0ZSkge1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbmRleFJvdXRlKSkge1xuICAgICAgICAgICAgICB2YXIgX21hdGNoJHJvdXRlcztcblxuICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShpbmRleFJvdXRlLmV2ZXJ5KGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhcm91dGUucGF0aDtcbiAgICAgICAgICAgICAgfSksICdJbmRleCByb3V0ZXMgc2hvdWxkIG5vdCBoYXZlIHBhdGhzJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIChfbWF0Y2gkcm91dGVzID0gbWF0Y2gucm91dGVzKS5wdXNoLmFwcGx5KF9tYXRjaCRyb3V0ZXMsIGluZGV4Um91dGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleFJvdXRlKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKCFpbmRleFJvdXRlLnBhdGgsICdJbmRleCByb3V0ZXMgc2hvdWxkIG5vdCBoYXZlIHBhdGhzJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIG1hdGNoLnJvdXRlcy5wdXNoKGluZGV4Um91dGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBtYXRjaCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHY6IHZvaWQgMFxuICAgICAgICB9O1xuICAgICAgfSgpO1xuXG4gICAgICBpZiAoKHR5cGVvZiBfcmV0MiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoX3JldDIpKSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIF9yZXQyLnY7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJlbWFpbmluZ1BhdGhuYW1lICE9IG51bGwgfHwgcm91dGUuY2hpbGRSb3V0ZXMpIHtcbiAgICAvLyBFaXRoZXIgYSkgdGhpcyByb3V0ZSBtYXRjaGVkIGF0IGxlYXN0IHNvbWUgb2YgdGhlIHBhdGggb3IgYilcbiAgICAvLyB3ZSBkb24ndCBoYXZlIHRvIGxvYWQgdGhpcyByb3V0ZSdzIGNoaWxkcmVuIGFzeW5jaHJvbm91c2x5LiBJblxuICAgIC8vIGVpdGhlciBjYXNlIGNvbnRpbnVlIGNoZWNraW5nIGZvciBtYXRjaGVzIGluIHRoZSBzdWJ0cmVlLlxuICAgIHZhciBvbkNoaWxkUm91dGVzID0gZnVuY3Rpb24gb25DaGlsZFJvdXRlcyhlcnJvciwgY2hpbGRSb3V0ZXMpIHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkUm91dGVzKSB7XG4gICAgICAgIC8vIENoZWNrIHRoZSBjaGlsZCByb3V0ZXMgdG8gc2VlIGlmIGFueSBvZiB0aGVtIG1hdGNoLlxuICAgICAgICBtYXRjaFJvdXRlcyhjaGlsZFJvdXRlcywgbG9jYXRpb24sIGZ1bmN0aW9uIChlcnJvciwgbWF0Y2gpIHtcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAvLyBBIGNoaWxkIHJvdXRlIG1hdGNoZWQhIEF1Z21lbnQgdGhlIG1hdGNoIGFuZCBwYXNzIGl0IHVwIHRoZSBzdGFjay5cbiAgICAgICAgICAgIG1hdGNoLnJvdXRlcy51bnNoaWZ0KHJvdXRlKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG1hdGNoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHJlbWFpbmluZ1BhdGhuYW1lLCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmVzdWx0ID0gZ2V0Q2hpbGRSb3V0ZXMocm91dGUsIGxvY2F0aW9uLCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcywgb25DaGlsZFJvdXRlcyk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgb25DaGlsZFJvdXRlcy5hcHBseSh1bmRlZmluZWQsIHJlc3VsdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSBtYXRjaGVzIHRoZSBnaXZlbiBsb2NhdGlvbiB0byBhIHNldCBvZiByb3V0ZXMgYW5kIGNhbGxzXG4gKiBjYWxsYmFjayhlcnJvciwgc3RhdGUpIHdoZW4gZmluaXNoZWQuIFRoZSBzdGF0ZSBvYmplY3Qgd2lsbCBoYXZlIHRoZVxuICogZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogLSByb3V0ZXMgICAgICAgQW4gYXJyYXkgb2Ygcm91dGVzIHRoYXQgbWF0Y2hlZCwgaW4gaGllcmFyY2hpY2FsIG9yZGVyXG4gKiAtIHBhcmFtcyAgICAgICBBbiBvYmplY3Qgb2YgVVJMIHBhcmFtZXRlcnNcbiAqXG4gKiBOb3RlOiBUaGlzIG9wZXJhdGlvbiBtYXkgZmluaXNoIHN5bmNocm9ub3VzbHkgaWYgbm8gcm91dGVzIGhhdmUgYW5cbiAqIGFzeW5jaHJvbm91cyBnZXRDaGlsZFJvdXRlcyBtZXRob2QuXG4gKi9cbmZ1bmN0aW9uIG1hdGNoUm91dGVzKHJvdXRlcywgbG9jYXRpb24sIGNhbGxiYWNrLCByZW1haW5pbmdQYXRobmFtZSkge1xuICB2YXIgcGFyYW1OYW1lcyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gNCB8fCBhcmd1bWVudHNbNF0gPT09IHVuZGVmaW5lZCA/IFtdIDogYXJndW1lbnRzWzRdO1xuICB2YXIgcGFyYW1WYWx1ZXMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDUgfHwgYXJndW1lbnRzWzVdID09PSB1bmRlZmluZWQgPyBbXSA6IGFyZ3VtZW50c1s1XTtcblxuICBpZiAocmVtYWluaW5nUGF0aG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFRPRE86IFRoaXMgaXMgYSBsaXR0bGUgYml0IHVnbHksIGJ1dCBpdCB3b3JrcyBhcm91bmQgYSBxdWlyayBpbiBoaXN0b3J5XG4gICAgLy8gdGhhdCBzdHJpcHMgdGhlIGxlYWRpbmcgc2xhc2ggZnJvbSBwYXRobmFtZXMgd2hlbiB1c2luZyBiYXNlbmFtZXMgd2l0aFxuICAgIC8vIHRyYWlsaW5nIHNsYXNoZXMuXG4gICAgaWYgKGxvY2F0aW9uLnBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgICBsb2NhdGlvbiA9IF9leHRlbmRzKHt9LCBsb2NhdGlvbiwge1xuICAgICAgICBwYXRobmFtZTogJy8nICsgbG9jYXRpb24ucGF0aG5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZW1haW5pbmdQYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lO1xuICB9XG5cbiAgKDAsIF9Bc3luY1V0aWxzLmxvb3BBc3luYykocm91dGVzLmxlbmd0aCwgZnVuY3Rpb24gKGluZGV4LCBuZXh0LCBkb25lKSB7XG4gICAgbWF0Y2hSb3V0ZURlZXAocm91dGVzW2luZGV4XSwgbG9jYXRpb24sIHJlbWFpbmluZ1BhdGhuYW1lLCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcywgZnVuY3Rpb24gKGVycm9yLCBtYXRjaCkge1xuICAgICAgaWYgKGVycm9yIHx8IG1hdGNoKSB7XG4gICAgICAgIGRvbmUoZXJyb3IsIG1hdGNoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgY2FsbGJhY2spO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvbWF0Y2hSb3V0ZXMuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyA9IHJlcXVpcmUoJy4vZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcycpO1xuXG52YXIgX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyk7XG5cbnZhciBfZ2V0Um91dGVQYXJhbXMgPSByZXF1aXJlKCcuL2dldFJvdXRlUGFyYW1zJyk7XG5cbnZhciBfZ2V0Um91dGVQYXJhbXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0Um91dGVQYXJhbXMpO1xuXG52YXIgX1JvdXRlVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlVXRpbHMnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIF9SZWFjdCRQcm9wVHlwZXMgPSBfcmVhY3QyLmRlZmF1bHQuUHJvcFR5cGVzO1xudmFyIGFycmF5ID0gX1JlYWN0JFByb3BUeXBlcy5hcnJheTtcbnZhciBmdW5jID0gX1JlYWN0JFByb3BUeXBlcy5mdW5jO1xudmFyIG9iamVjdCA9IF9SZWFjdCRQcm9wVHlwZXMub2JqZWN0O1xuXG4vKipcbiAqIEEgPFJvdXRlckNvbnRleHQ+IHJlbmRlcnMgdGhlIGNvbXBvbmVudCB0cmVlIGZvciBhIGdpdmVuIHJvdXRlciBzdGF0ZVxuICogYW5kIHNldHMgdGhlIGhpc3Rvcnkgb2JqZWN0IGFuZCB0aGUgY3VycmVudCBsb2NhdGlvbiBpbiBjb250ZXh0LlxuICovXG5cbnZhciBSb3V0ZXJDb250ZXh0ID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdSb3V0ZXJDb250ZXh0JyxcblxuXG4gIHByb3BUeXBlczoge1xuICAgIGhpc3Rvcnk6IG9iamVjdCxcbiAgICByb3V0ZXI6IG9iamVjdC5pc1JlcXVpcmVkLFxuICAgIGxvY2F0aW9uOiBvYmplY3QuaXNSZXF1aXJlZCxcbiAgICByb3V0ZXM6IGFycmF5LmlzUmVxdWlyZWQsXG4gICAgcGFyYW1zOiBvYmplY3QuaXNSZXF1aXJlZCxcbiAgICBjb21wb25lbnRzOiBhcnJheS5pc1JlcXVpcmVkLFxuICAgIGNyZWF0ZUVsZW1lbnQ6IGZ1bmMuaXNSZXF1aXJlZFxuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjcmVhdGVFbGVtZW50OiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudFxuICAgIH07XG4gIH0sXG5cblxuICBjaGlsZENvbnRleHRUeXBlczoge1xuICAgIGhpc3Rvcnk6IG9iamVjdCxcbiAgICBsb2NhdGlvbjogb2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgcm91dGVyOiBvYmplY3QuaXNSZXF1aXJlZFxuICB9LFxuXG4gIGdldENoaWxkQ29udGV4dDogZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciByb3V0ZXIgPSBfcHJvcHMucm91dGVyO1xuICAgIHZhciBoaXN0b3J5ID0gX3Byb3BzLmhpc3Rvcnk7XG4gICAgdmFyIGxvY2F0aW9uID0gX3Byb3BzLmxvY2F0aW9uO1xuXG4gICAgaWYgKCFyb3V0ZXIpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnYDxSb3V0ZXJDb250ZXh0PmAgZXhwZWN0cyBhIGByb3V0ZXJgIHJhdGhlciB0aGFuIGEgYGhpc3RvcnlgJykgOiB2b2lkIDA7XG5cbiAgICAgIHJvdXRlciA9IF9leHRlbmRzKHt9LCBoaXN0b3J5LCB7XG4gICAgICAgIHNldFJvdXRlTGVhdmVIb29rOiBoaXN0b3J5Lmxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZVxuICAgICAgfSk7XG4gICAgICBkZWxldGUgcm91dGVyLmxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgbG9jYXRpb24gPSAoMCwgX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMyLmRlZmF1bHQpKGxvY2F0aW9uLCAnYGNvbnRleHQubG9jYXRpb25gIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgYSByb3V0ZSBjb21wb25lbnRcXCdzIGBwcm9wcy5sb2NhdGlvbmAgaW5zdGVhZC4gaHR0cDovL3RpbnkuY2Mvcm91dGVyLWFjY2Vzc2luZ2xvY2F0aW9uJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgaGlzdG9yeTogaGlzdG9yeSwgbG9jYXRpb246IGxvY2F0aW9uLCByb3V0ZXI6IHJvdXRlciB9O1xuICB9LFxuICBjcmVhdGVFbGVtZW50OiBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KGNvbXBvbmVudCwgcHJvcHMpIHtcbiAgICByZXR1cm4gY29tcG9uZW50ID09IG51bGwgPyBudWxsIDogdGhpcy5wcm9wcy5jcmVhdGVFbGVtZW50KGNvbXBvbmVudCwgcHJvcHMpO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIF9wcm9wczIgPSB0aGlzLnByb3BzO1xuICAgIHZhciBoaXN0b3J5ID0gX3Byb3BzMi5oaXN0b3J5O1xuICAgIHZhciBsb2NhdGlvbiA9IF9wcm9wczIubG9jYXRpb247XG4gICAgdmFyIHJvdXRlcyA9IF9wcm9wczIucm91dGVzO1xuICAgIHZhciBwYXJhbXMgPSBfcHJvcHMyLnBhcmFtcztcbiAgICB2YXIgY29tcG9uZW50cyA9IF9wcm9wczIuY29tcG9uZW50cztcblxuICAgIHZhciBlbGVtZW50ID0gbnVsbDtcblxuICAgIGlmIChjb21wb25lbnRzKSB7XG4gICAgICBlbGVtZW50ID0gY29tcG9uZW50cy5yZWR1Y2VSaWdodChmdW5jdGlvbiAoZWxlbWVudCwgY29tcG9uZW50cywgaW5kZXgpIHtcbiAgICAgICAgaWYgKGNvbXBvbmVudHMgPT0gbnVsbCkgcmV0dXJuIGVsZW1lbnQ7IC8vIERvbid0IGNyZWF0ZSBuZXcgY2hpbGRyZW47IHVzZSB0aGUgZ3JhbmRjaGlsZHJlbi5cblxuICAgICAgICB2YXIgcm91dGUgPSByb3V0ZXNbaW5kZXhdO1xuICAgICAgICB2YXIgcm91dGVQYXJhbXMgPSAoMCwgX2dldFJvdXRlUGFyYW1zMi5kZWZhdWx0KShyb3V0ZSwgcGFyYW1zKTtcbiAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgIGhpc3Rvcnk6IGhpc3RvcnksXG4gICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgIHJvdXRlOiByb3V0ZSxcbiAgICAgICAgICByb3V0ZVBhcmFtczogcm91dGVQYXJhbXMsXG4gICAgICAgICAgcm91dGVzOiByb3V0ZXNcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoKDAsIF9Sb3V0ZVV0aWxzLmlzUmVhY3RDaGlsZHJlbikoZWxlbWVudCkpIHtcbiAgICAgICAgICBwcm9wcy5jaGlsZHJlbiA9IGVsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCkge1xuICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gZWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlbGVtZW50LCBwcm9wKSkgcHJvcHNbcHJvcF0gPSBlbGVtZW50W3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgodHlwZW9mIGNvbXBvbmVudHMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGNvbXBvbmVudHMpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB2YXIgZWxlbWVudHMgPSB7fTtcblxuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBjb21wb25lbnRzKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbXBvbmVudHMsIGtleSkpIHtcbiAgICAgICAgICAgICAgLy8gUGFzcyB0aHJvdWdoIHRoZSBrZXkgYXMgYSBwcm9wIHRvIGNyZWF0ZUVsZW1lbnQgdG8gYWxsb3dcbiAgICAgICAgICAgICAgLy8gY3VzdG9tIGNyZWF0ZUVsZW1lbnQgZnVuY3Rpb25zIHRvIGtub3cgd2hpY2ggbmFtZWQgY29tcG9uZW50XG4gICAgICAgICAgICAgIC8vIHRoZXkncmUgcmVuZGVyaW5nLCBmb3IgZS5nLiBtYXRjaGluZyB1cCB0byBmZXRjaGVkIGRhdGEuXG4gICAgICAgICAgICAgIGVsZW1lbnRzW2tleV0gPSBfdGhpcy5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHNba2V5XSwgX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgIGtleToga2V5IH0sIHByb3BzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF90aGlzLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50cywgcHJvcHMpO1xuICAgICAgfSwgZWxlbWVudCk7XG4gICAgfVxuXG4gICAgIShlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IGZhbHNlIHx8IF9yZWFjdDIuZGVmYXVsdC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnVGhlIHJvb3Qgcm91dGUgbXVzdCByZW5kZXIgYSBzaW5nbGUgZWxlbWVudCcpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUm91dGVyQ29udGV4dDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlckNvbnRleHQuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfUGF0dGVyblV0aWxzID0gcmVxdWlyZSgnLi9QYXR0ZXJuVXRpbHMnKTtcblxuLyoqXG4gKiBFeHRyYWN0cyBhbiBvYmplY3Qgb2YgcGFyYW1zIHRoZSBnaXZlbiByb3V0ZSBjYXJlcyBhYm91dCBmcm9tXG4gKiB0aGUgZ2l2ZW4gcGFyYW1zIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZ2V0Um91dGVQYXJhbXMocm91dGUsIHBhcmFtcykge1xuICB2YXIgcm91dGVQYXJhbXMgPSB7fTtcblxuICBpZiAoIXJvdXRlLnBhdGgpIHJldHVybiByb3V0ZVBhcmFtcztcblxuICAoMCwgX1BhdHRlcm5VdGlscy5nZXRQYXJhbU5hbWVzKShyb3V0ZS5wYXRoKS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwYXJhbXMsIHApKSB7XG4gICAgICByb3V0ZVBhcmFtc1twXSA9IHBhcmFtc1twXTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByb3V0ZVBhcmFtcztcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0Um91dGVQYXJhbXM7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9nZXRSb3V0ZVBhcmFtcy5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZXhwb3J0cy5jcmVhdGVSb3V0ZXJPYmplY3QgPSBjcmVhdGVSb3V0ZXJPYmplY3Q7XG5leHBvcnRzLmNyZWF0ZVJvdXRpbmdIaXN0b3J5ID0gY3JlYXRlUm91dGluZ0hpc3Rvcnk7XG5cbnZhciBfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyA9IHJlcXVpcmUoJy4vZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcycpO1xuXG52YXIgX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlck9iamVjdChoaXN0b3J5LCB0cmFuc2l0aW9uTWFuYWdlcikge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIGhpc3RvcnksIHtcbiAgICBzZXRSb3V0ZUxlYXZlSG9vazogdHJhbnNpdGlvbk1hbmFnZXIubGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlLFxuICAgIGlzQWN0aXZlOiB0cmFuc2l0aW9uTWFuYWdlci5pc0FjdGl2ZVxuICB9KTtcbn1cblxuLy8gZGVwcmVjYXRlZFxuZnVuY3Rpb24gY3JlYXRlUm91dGluZ0hpc3RvcnkoaGlzdG9yeSwgdHJhbnNpdGlvbk1hbmFnZXIpIHtcbiAgaGlzdG9yeSA9IF9leHRlbmRzKHt9LCBoaXN0b3J5LCB0cmFuc2l0aW9uTWFuYWdlcik7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBoaXN0b3J5ID0gKDAsIF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzMi5kZWZhdWx0KShoaXN0b3J5LCAnYHByb3BzLmhpc3RvcnlgIGFuZCBgY29udGV4dC5oaXN0b3J5YCBhcmUgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBgY29udGV4dC5yb3V0ZXJgLiBodHRwOi8vdGlueS5jYy9yb3V0ZXItY29udGV4dGNoYW5nZXMnKTtcbiAgfVxuXG4gIHJldHVybiBoaXN0b3J5O1xufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlclV0aWxzLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9Qcm9wVHlwZXMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgX1JlYWN0JFByb3BUeXBlcyA9IF9yZWFjdDIuZGVmYXVsdC5Qcm9wVHlwZXM7XG52YXIgYm9vbCA9IF9SZWFjdCRQcm9wVHlwZXMuYm9vbDtcbnZhciBvYmplY3QgPSBfUmVhY3QkUHJvcFR5cGVzLm9iamVjdDtcbnZhciBzdHJpbmcgPSBfUmVhY3QkUHJvcFR5cGVzLnN0cmluZztcbnZhciBmdW5jID0gX1JlYWN0JFByb3BUeXBlcy5mdW5jO1xudmFyIG9uZU9mVHlwZSA9IF9SZWFjdCRQcm9wVHlwZXMub25lT2ZUeXBlO1xuXG5cbmZ1bmN0aW9uIGlzTGVmdENsaWNrRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LmJ1dHRvbiA9PT0gMDtcbn1cblxuZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiAhIShldmVudC5tZXRhS2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50LnNoaWZ0S2V5KTtcbn1cblxuLy8gVE9ETzogRGUtZHVwbGljYXRlIGFnYWluc3QgaGFzQW55UHJvcGVydGllcyBpbiBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlci5cbmZ1bmN0aW9uIGlzRW1wdHlPYmplY3Qob2JqZWN0KSB7XG4gIGZvciAodmFyIHAgaW4gb2JqZWN0KSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHApKSByZXR1cm4gZmFsc2U7XG4gIH1yZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTG9jYXRpb25EZXNjcmlwdG9yKHRvLCBfcmVmKSB7XG4gIHZhciBxdWVyeSA9IF9yZWYucXVlcnk7XG4gIHZhciBoYXNoID0gX3JlZi5oYXNoO1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlO1xuXG4gIGlmIChxdWVyeSB8fCBoYXNoIHx8IHN0YXRlKSB7XG4gICAgcmV0dXJuIHsgcGF0aG5hbWU6IHRvLCBxdWVyeTogcXVlcnksIGhhc2g6IGhhc2gsIHN0YXRlOiBzdGF0ZSB9O1xuICB9XG5cbiAgcmV0dXJuIHRvO1xufVxuXG4vKipcbiAqIEEgPExpbms+IGlzIHVzZWQgdG8gY3JlYXRlIGFuIDxhPiBlbGVtZW50IHRoYXQgbGlua3MgdG8gYSByb3V0ZS5cbiAqIFdoZW4gdGhhdCByb3V0ZSBpcyBhY3RpdmUsIHRoZSBsaW5rIGdldHMgdGhlIHZhbHVlIG9mIGl0c1xuICogYWN0aXZlQ2xhc3NOYW1lIHByb3AuXG4gKlxuICogRm9yIGV4YW1wbGUsIGFzc3VtaW5nIHlvdSBoYXZlIHRoZSBmb2xsb3dpbmcgcm91dGU6XG4gKlxuICogICA8Um91dGUgcGF0aD1cIi9wb3N0cy86cG9zdElEXCIgY29tcG9uZW50PXtQb3N0fSAvPlxuICpcbiAqIFlvdSBjb3VsZCB1c2UgdGhlIGZvbGxvd2luZyBjb21wb25lbnQgdG8gbGluayB0byB0aGF0IHJvdXRlOlxuICpcbiAqICAgPExpbmsgdG89e2AvcG9zdHMvJHtwb3N0LmlkfWB9IC8+XG4gKlxuICogTGlua3MgbWF5IHBhc3MgYWxvbmcgbG9jYXRpb24gc3RhdGUgYW5kL29yIHF1ZXJ5IHN0cmluZyBwYXJhbWV0ZXJzXG4gKiBpbiB0aGUgc3RhdGUvcXVlcnkgcHJvcHMsIHJlc3BlY3RpdmVseS5cbiAqXG4gKiAgIDxMaW5rIC4uLiBxdWVyeT17eyBzaG93OiB0cnVlIH19IHN0YXRlPXt7IHRoZTogJ3N0YXRlJyB9fSAvPlxuICovXG52YXIgTGluayA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnTGluaycsXG5cblxuICBjb250ZXh0VHlwZXM6IHtcbiAgICByb3V0ZXI6IF9Qcm9wVHlwZXMucm91dGVyU2hhcGVcbiAgfSxcblxuICBwcm9wVHlwZXM6IHtcbiAgICB0bzogb25lT2ZUeXBlKFtzdHJpbmcsIG9iamVjdF0pLFxuICAgIHF1ZXJ5OiBvYmplY3QsXG4gICAgaGFzaDogc3RyaW5nLFxuICAgIHN0YXRlOiBvYmplY3QsXG4gICAgYWN0aXZlU3R5bGU6IG9iamVjdCxcbiAgICBhY3RpdmVDbGFzc05hbWU6IHN0cmluZyxcbiAgICBvbmx5QWN0aXZlT25JbmRleDogYm9vbC5pc1JlcXVpcmVkLFxuICAgIG9uQ2xpY2s6IGZ1bmMsXG4gICAgdGFyZ2V0OiBzdHJpbmdcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb25seUFjdGl2ZU9uSW5kZXg6IGZhbHNlLFxuICAgICAgc3R5bGU6IHt9XG4gICAgfTtcbiAgfSxcbiAgaGFuZGxlQ2xpY2s6IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMucHJvcHMub25DbGljaykgdGhpcy5wcm9wcy5vbkNsaWNrKGV2ZW50KTtcblxuICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG5cbiAgICAhdGhpcy5jb250ZXh0LnJvdXRlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICc8TGluaz5zIHJlbmRlcmVkIG91dHNpZGUgb2YgYSByb3V0ZXIgY29udGV4dCBjYW5ub3QgbmF2aWdhdGUuJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgaWYgKGlzTW9kaWZpZWRFdmVudChldmVudCkgfHwgIWlzTGVmdENsaWNrRXZlbnQoZXZlbnQpKSByZXR1cm47XG5cbiAgICAvLyBJZiB0YXJnZXQgcHJvcCBpcyBzZXQgKGUuZy4gdG8gXCJfYmxhbmtcIiksIGxldCBicm93c2VyIGhhbmRsZSBsaW5rLlxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZjogdW50ZXN0YWJsZSB3aXRoIEthcm1hICovXG4gICAgaWYgKHRoaXMucHJvcHMudGFyZ2V0KSByZXR1cm47XG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHRvID0gX3Byb3BzLnRvO1xuICAgIHZhciBxdWVyeSA9IF9wcm9wcy5xdWVyeTtcbiAgICB2YXIgaGFzaCA9IF9wcm9wcy5oYXNoO1xuICAgIHZhciBzdGF0ZSA9IF9wcm9wcy5zdGF0ZTtcblxuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uRGVzY3JpcHRvcih0bywgeyBxdWVyeTogcXVlcnksIGhhc2g6IGhhc2gsIHN0YXRlOiBzdGF0ZSB9KTtcblxuICAgIHRoaXMuY29udGV4dC5yb3V0ZXIucHVzaChsb2NhdGlvbik7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfcHJvcHMyID0gdGhpcy5wcm9wcztcbiAgICB2YXIgdG8gPSBfcHJvcHMyLnRvO1xuICAgIHZhciBxdWVyeSA9IF9wcm9wczIucXVlcnk7XG4gICAgdmFyIGhhc2ggPSBfcHJvcHMyLmhhc2g7XG4gICAgdmFyIHN0YXRlID0gX3Byb3BzMi5zdGF0ZTtcbiAgICB2YXIgYWN0aXZlQ2xhc3NOYW1lID0gX3Byb3BzMi5hY3RpdmVDbGFzc05hbWU7XG4gICAgdmFyIGFjdGl2ZVN0eWxlID0gX3Byb3BzMi5hY3RpdmVTdHlsZTtcbiAgICB2YXIgb25seUFjdGl2ZU9uSW5kZXggPSBfcHJvcHMyLm9ubHlBY3RpdmVPbkluZGV4O1xuXG4gICAgdmFyIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wczIsIFsndG8nLCAncXVlcnknLCAnaGFzaCcsICdzdGF0ZScsICdhY3RpdmVDbGFzc05hbWUnLCAnYWN0aXZlU3R5bGUnLCAnb25seUFjdGl2ZU9uSW5kZXgnXSk7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KSghKHF1ZXJ5IHx8IGhhc2ggfHwgc3RhdGUpLCAndGhlIGBxdWVyeWAsIGBoYXNoYCwgYW5kIGBzdGF0ZWAgcHJvcHMgb24gYDxMaW5rPmAgYXJlIGRlcHJlY2F0ZWQsIHVzZSBgPExpbmsgdG89e3sgcGF0aG5hbWUsIHF1ZXJ5LCBoYXNoLCBzdGF0ZSB9fS8+LiBodHRwOi8vdGlueS5jYy9yb3V0ZXItaXNBY3RpdmVkZXByZWNhdGVkJykgOiB2b2lkIDA7XG5cbiAgICAvLyBJZ25vcmUgaWYgcmVuZGVyZWQgb3V0c2lkZSB0aGUgY29udGV4dCBvZiByb3V0ZXIsIHNpbXBsaWZpZXMgdW5pdCB0ZXN0aW5nLlxuICAgIHZhciByb3V0ZXIgPSB0aGlzLmNvbnRleHQucm91dGVyO1xuXG5cbiAgICBpZiAocm91dGVyKSB7XG4gICAgICAvLyBJZiB1c2VyIGRvZXMgbm90IHNwZWNpZnkgYSBgdG9gIHByb3AsIHJldHVybiBhbiBlbXB0eSBhbmNob3IgdGFnLlxuICAgICAgaWYgKHRvID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KCdhJywgcHJvcHMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbkRlc2NyaXB0b3IodG8sIHsgcXVlcnk6IHF1ZXJ5LCBoYXNoOiBoYXNoLCBzdGF0ZTogc3RhdGUgfSk7XG4gICAgICBwcm9wcy5ocmVmID0gcm91dGVyLmNyZWF0ZUhyZWYobG9jYXRpb24pO1xuXG4gICAgICBpZiAoYWN0aXZlQ2xhc3NOYW1lIHx8IGFjdGl2ZVN0eWxlICE9IG51bGwgJiYgIWlzRW1wdHlPYmplY3QoYWN0aXZlU3R5bGUpKSB7XG4gICAgICAgIGlmIChyb3V0ZXIuaXNBY3RpdmUobG9jYXRpb24sIG9ubHlBY3RpdmVPbkluZGV4KSkge1xuICAgICAgICAgIGlmIChhY3RpdmVDbGFzc05hbWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9wcy5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgcHJvcHMuY2xhc3NOYW1lICs9ICcgJyArIGFjdGl2ZUNsYXNzTmFtZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHByb3BzLmNsYXNzTmFtZSA9IGFjdGl2ZUNsYXNzTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYWN0aXZlU3R5bGUpIHByb3BzLnN0eWxlID0gX2V4dGVuZHMoe30sIHByb3BzLnN0eWxlLCBhY3RpdmVTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoJ2EnLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHsgb25DbGljazogdGhpcy5oYW5kbGVDbGljayB9KSk7XG4gIH1cbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBMaW5rO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvTGluay5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX0xpbmsgPSByZXF1aXJlKCcuL0xpbmsnKTtcblxudmFyIF9MaW5rMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0xpbmspO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIEFuIDxJbmRleExpbms+IGlzIHVzZWQgdG8gbGluayB0byBhbiA8SW5kZXhSb3V0ZT4uXG4gKi9cbnZhciBJbmRleExpbmsgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ0luZGV4TGluaycsXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChfTGluazIuZGVmYXVsdCwgX2V4dGVuZHMoe30sIHRoaXMucHJvcHMsIHsgb25seUFjdGl2ZU9uSW5kZXg6IHRydWUgfSkpO1xuICB9XG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gSW5kZXhMaW5rO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvSW5kZXhMaW5rLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzLmRlZmF1bHQgPSB3aXRoUm91dGVyO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfaG9pc3ROb25SZWFjdFN0YXRpY3MgPSByZXF1aXJlKCdob2lzdC1ub24tcmVhY3Qtc3RhdGljcycpO1xuXG52YXIgX2hvaXN0Tm9uUmVhY3RTdGF0aWNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hvaXN0Tm9uUmVhY3RTdGF0aWNzKTtcblxudmFyIF9Qcm9wVHlwZXMgPSByZXF1aXJlKCcuL1Byb3BUeXBlcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBnZXREaXNwbGF5TmFtZShXcmFwcGVkQ29tcG9uZW50KSB7XG4gIHJldHVybiBXcmFwcGVkQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IFdyYXBwZWRDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50Jztcbn1cblxuZnVuY3Rpb24gd2l0aFJvdXRlcihXcmFwcGVkQ29tcG9uZW50LCBvcHRpb25zKSB7XG4gIHZhciB3aXRoUmVmID0gb3B0aW9ucyAmJiBvcHRpb25zLndpdGhSZWY7XG5cbiAgdmFyIFdpdGhSb3V0ZXIgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICAgIGRpc3BsYXlOYW1lOiAnV2l0aFJvdXRlcicsXG5cbiAgICBjb250ZXh0VHlwZXM6IHsgcm91dGVyOiBfUHJvcFR5cGVzLnJvdXRlclNoYXBlIH0sXG4gICAgcHJvcFR5cGVzOiB7IHJvdXRlcjogX1Byb3BUeXBlcy5yb3V0ZXJTaGFwZSB9LFxuXG4gICAgZ2V0V3JhcHBlZEluc3RhbmNlOiBmdW5jdGlvbiBnZXRXcmFwcGVkSW5zdGFuY2UoKSB7XG4gICAgICAhd2l0aFJlZiA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdUbyBhY2Nlc3MgdGhlIHdyYXBwZWQgaW5zdGFuY2UsIHlvdSBuZWVkIHRvIHNwZWNpZnkgJyArICdgeyB3aXRoUmVmOiB0cnVlIH1gIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgb2YgdGhlIHdpdGhSb3V0ZXIoKSBjYWxsLicpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcblxuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZEluc3RhbmNlO1xuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgcm91dGVyID0gdGhpcy5wcm9wcy5yb3V0ZXIgfHwgdGhpcy5jb250ZXh0LnJvdXRlcjtcbiAgICAgIHZhciBwcm9wcyA9IF9leHRlbmRzKHt9LCB0aGlzLnByb3BzLCB7IHJvdXRlcjogcm91dGVyIH0pO1xuXG4gICAgICBpZiAod2l0aFJlZikge1xuICAgICAgICBwcm9wcy5yZWYgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICAgIF90aGlzLndyYXBwZWRJbnN0YW5jZSA9IGM7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChXcmFwcGVkQ29tcG9uZW50LCBwcm9wcyk7XG4gICAgfVxuICB9KTtcblxuICBXaXRoUm91dGVyLmRpc3BsYXlOYW1lID0gJ3dpdGhSb3V0ZXIoJyArIGdldERpc3BsYXlOYW1lKFdyYXBwZWRDb21wb25lbnQpICsgJyknO1xuICBXaXRoUm91dGVyLldyYXBwZWRDb21wb25lbnQgPSBXcmFwcGVkQ29tcG9uZW50O1xuXG4gIHJldHVybiAoMCwgX2hvaXN0Tm9uUmVhY3RTdGF0aWNzMi5kZWZhdWx0KShXaXRoUm91dGVyLCBXcmFwcGVkQ29tcG9uZW50KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL3dpdGhSb3V0ZXIuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LCBZYWhvbyEgSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSRUFDVF9TVEFUSUNTID0ge1xuICAgIGNoaWxkQ29udGV4dFR5cGVzOiB0cnVlLFxuICAgIGNvbnRleHRUeXBlczogdHJ1ZSxcbiAgICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gICAgZGlzcGxheU5hbWU6IHRydWUsXG4gICAgZ2V0RGVmYXVsdFByb3BzOiB0cnVlLFxuICAgIG1peGluczogdHJ1ZSxcbiAgICBwcm9wVHlwZXM6IHRydWUsXG4gICAgdHlwZTogdHJ1ZVxufTtcblxudmFyIEtOT1dOX1NUQVRJQ1MgPSB7XG4gICAgbmFtZTogdHJ1ZSxcbiAgICBsZW5ndGg6IHRydWUsXG4gICAgcHJvdG90eXBlOiB0cnVlLFxuICAgIGNhbGxlcjogdHJ1ZSxcbiAgICBhcmd1bWVudHM6IHRydWUsXG4gICAgYXJpdHk6IHRydWVcbn07XG5cbnZhciBpc0dldE93blByb3BlcnR5U3ltYm9sc0F2YWlsYWJsZSA9IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgc291cmNlQ29tcG9uZW50LCBjdXN0b21TdGF0aWNzKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2VDb21wb25lbnQgIT09ICdzdHJpbmcnKSB7IC8vIGRvbid0IGhvaXN0IG92ZXIgc3RyaW5nIChodG1sKSBjb21wb25lbnRzXG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc291cmNlQ29tcG9uZW50KTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoaXNHZXRPd25Qcm9wZXJ0eVN5bWJvbHNBdmFpbGFibGUpIHtcbiAgICAgICAgICAgIGtleXMgPSBrZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZUNvbXBvbmVudCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIVJFQUNUX1NUQVRJQ1Nba2V5c1tpXV0gJiYgIUtOT1dOX1NUQVRJQ1Nba2V5c1tpXV0gJiYgKCFjdXN0b21TdGF0aWNzIHx8ICFjdXN0b21TdGF0aWNzW2tleXNbaV1dKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldENvbXBvbmVudFtrZXlzW2ldXSA9IHNvdXJjZUNvbXBvbmVudFtrZXlzW2ldXTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9SZWRpcmVjdCA9IHJlcXVpcmUoJy4vUmVkaXJlY3QnKTtcblxudmFyIF9SZWRpcmVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SZWRpcmVjdCk7XG5cbnZhciBfSW50ZXJuYWxQcm9wVHlwZXMgPSByZXF1aXJlKCcuL0ludGVybmFsUHJvcFR5cGVzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBfUmVhY3QkUHJvcFR5cGVzID0gX3JlYWN0Mi5kZWZhdWx0LlByb3BUeXBlcztcbnZhciBzdHJpbmcgPSBfUmVhY3QkUHJvcFR5cGVzLnN0cmluZztcbnZhciBvYmplY3QgPSBfUmVhY3QkUHJvcFR5cGVzLm9iamVjdDtcblxuLyoqXG4gKiBBbiA8SW5kZXhSZWRpcmVjdD4gaXMgdXNlZCB0byByZWRpcmVjdCBmcm9tIGFuIGluZGV4Um91dGUuXG4gKi9cblxudmFyIEluZGV4UmVkaXJlY3QgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ0luZGV4UmVkaXJlY3QnLFxuXG5cbiAgc3RhdGljczoge1xuICAgIGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudDogZnVuY3Rpb24gY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KGVsZW1lbnQsIHBhcmVudFJvdXRlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogc2FuaXR5IGNoZWNrICovXG4gICAgICBpZiAocGFyZW50Um91dGUpIHtcbiAgICAgICAgcGFyZW50Um91dGUuaW5kZXhSb3V0ZSA9IF9SZWRpcmVjdDIuZGVmYXVsdC5jcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQoZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ0FuIDxJbmRleFJlZGlyZWN0PiBkb2VzIG5vdCBtYWtlIHNlbnNlIGF0IHRoZSByb290IG9mIHlvdXIgcm91dGUgY29uZmlnJykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHByb3BUeXBlczoge1xuICAgIHRvOiBzdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBxdWVyeTogb2JqZWN0LFxuICAgIHN0YXRlOiBvYmplY3QsXG4gICAgb25FbnRlcjogX0ludGVybmFsUHJvcFR5cGVzLmZhbHN5LFxuICAgIGNoaWxkcmVuOiBfSW50ZXJuYWxQcm9wVHlwZXMuZmFsc3lcbiAgfSxcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2FuaXR5IGNoZWNrICovXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICc8SW5kZXhSZWRpcmVjdD4gZWxlbWVudHMgYXJlIGZvciByb3V0ZXIgY29uZmlndXJhdGlvbiBvbmx5IGFuZCBzaG91bGQgbm90IGJlIHJlbmRlcmVkJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuICB9XG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gSW5kZXhSZWRpcmVjdDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL0luZGV4UmVkaXJlY3QuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9Sb3V0ZVV0aWxzID0gcmVxdWlyZSgnLi9Sb3V0ZVV0aWxzJyk7XG5cbnZhciBfUGF0dGVyblV0aWxzID0gcmVxdWlyZSgnLi9QYXR0ZXJuVXRpbHMnKTtcblxudmFyIF9JbnRlcm5hbFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vSW50ZXJuYWxQcm9wVHlwZXMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIF9SZWFjdCRQcm9wVHlwZXMgPSBfcmVhY3QyLmRlZmF1bHQuUHJvcFR5cGVzO1xudmFyIHN0cmluZyA9IF9SZWFjdCRQcm9wVHlwZXMuc3RyaW5nO1xudmFyIG9iamVjdCA9IF9SZWFjdCRQcm9wVHlwZXMub2JqZWN0O1xuXG4vKipcbiAqIEEgPFJlZGlyZWN0PiBpcyB1c2VkIHRvIGRlY2xhcmUgYW5vdGhlciBVUkwgcGF0aCBhIGNsaWVudCBzaG91bGRcbiAqIGJlIHNlbnQgdG8gd2hlbiB0aGV5IHJlcXVlc3QgYSBnaXZlbiBVUkwuXG4gKlxuICogUmVkaXJlY3RzIGFyZSBwbGFjZWQgYWxvbmdzaWRlIHJvdXRlcyBpbiB0aGUgcm91dGUgY29uZmlndXJhdGlvblxuICogYW5kIGFyZSB0cmF2ZXJzZWQgaW4gdGhlIHNhbWUgbWFubmVyLlxuICovXG5cbnZhciBSZWRpcmVjdCA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUmVkaXJlY3QnLFxuXG5cbiAgc3RhdGljczoge1xuICAgIGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudDogZnVuY3Rpb24gY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgIHZhciByb3V0ZSA9ICgwLCBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQpKGVsZW1lbnQpO1xuXG4gICAgICBpZiAocm91dGUuZnJvbSkgcm91dGUucGF0aCA9IHJvdXRlLmZyb207XG5cbiAgICAgIHJvdXRlLm9uRW50ZXIgPSBmdW5jdGlvbiAobmV4dFN0YXRlLCByZXBsYWNlKSB7XG4gICAgICAgIHZhciBsb2NhdGlvbiA9IG5leHRTdGF0ZS5sb2NhdGlvbjtcbiAgICAgICAgdmFyIHBhcmFtcyA9IG5leHRTdGF0ZS5wYXJhbXM7XG5cblxuICAgICAgICB2YXIgcGF0aG5hbWUgPSB2b2lkIDA7XG4gICAgICAgIGlmIChyb3V0ZS50by5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgICAgICAgIHBhdGhuYW1lID0gKDAsIF9QYXR0ZXJuVXRpbHMuZm9ybWF0UGF0dGVybikocm91dGUudG8sIHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXJvdXRlLnRvKSB7XG4gICAgICAgICAgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcm91dGVJbmRleCA9IG5leHRTdGF0ZS5yb3V0ZXMuaW5kZXhPZihyb3V0ZSk7XG4gICAgICAgICAgdmFyIHBhcmVudFBhdHRlcm4gPSBSZWRpcmVjdC5nZXRSb3V0ZVBhdHRlcm4obmV4dFN0YXRlLnJvdXRlcywgcm91dGVJbmRleCAtIDEpO1xuICAgICAgICAgIHZhciBwYXR0ZXJuID0gcGFyZW50UGF0dGVybi5yZXBsYWNlKC9cXC8qJC8sICcvJykgKyByb3V0ZS50bztcbiAgICAgICAgICBwYXRobmFtZSA9ICgwLCBfUGF0dGVyblV0aWxzLmZvcm1hdFBhdHRlcm4pKHBhdHRlcm4sIHBhcmFtcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXBsYWNlKHtcbiAgICAgICAgICBwYXRobmFtZTogcGF0aG5hbWUsXG4gICAgICAgICAgcXVlcnk6IHJvdXRlLnF1ZXJ5IHx8IGxvY2F0aW9uLnF1ZXJ5LFxuICAgICAgICAgIHN0YXRlOiByb3V0ZS5zdGF0ZSB8fCBsb2NhdGlvbi5zdGF0ZVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiByb3V0ZTtcbiAgICB9LFxuICAgIGdldFJvdXRlUGF0dGVybjogZnVuY3Rpb24gZ2V0Um91dGVQYXR0ZXJuKHJvdXRlcywgcm91dGVJbmRleCkge1xuICAgICAgdmFyIHBhcmVudFBhdHRlcm4gPSAnJztcblxuICAgICAgZm9yICh2YXIgaSA9IHJvdXRlSW5kZXg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciByb3V0ZSA9IHJvdXRlc1tpXTtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSByb3V0ZS5wYXRoIHx8ICcnO1xuXG4gICAgICAgIHBhcmVudFBhdHRlcm4gPSBwYXR0ZXJuLnJlcGxhY2UoL1xcLyokLywgJy8nKSArIHBhcmVudFBhdHRlcm47XG5cbiAgICAgICAgaWYgKHBhdHRlcm4uaW5kZXhPZignLycpID09PSAwKSBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICcvJyArIHBhcmVudFBhdHRlcm47XG4gICAgfVxuICB9LFxuXG4gIHByb3BUeXBlczoge1xuICAgIHBhdGg6IHN0cmluZyxcbiAgICBmcm9tOiBzdHJpbmcsIC8vIEFsaWFzIGZvciBwYXRoXG4gICAgdG86IHN0cmluZy5pc1JlcXVpcmVkLFxuICAgIHF1ZXJ5OiBvYmplY3QsXG4gICAgc3RhdGU6IG9iamVjdCxcbiAgICBvbkVudGVyOiBfSW50ZXJuYWxQcm9wVHlwZXMuZmFsc3ksXG4gICAgY2hpbGRyZW46IF9JbnRlcm5hbFByb3BUeXBlcy5mYWxzeVxuICB9LFxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzYW5pdHkgY2hlY2sgKi9cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJzxSZWRpcmVjdD4gZWxlbWVudHMgYXJlIGZvciByb3V0ZXIgY29uZmlndXJhdGlvbiBvbmx5IGFuZCBzaG91bGQgbm90IGJlIHJlbmRlcmVkJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuICB9XG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUmVkaXJlY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9SZWRpcmVjdC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX1JvdXRlVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlVXRpbHMnKTtcblxudmFyIF9JbnRlcm5hbFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vSW50ZXJuYWxQcm9wVHlwZXMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGZ1bmMgPSBfcmVhY3QyLmRlZmF1bHQuUHJvcFR5cGVzLmZ1bmM7XG5cbi8qKlxuICogQW4gPEluZGV4Um91dGU+IGlzIHVzZWQgdG8gc3BlY2lmeSBpdHMgcGFyZW50J3MgPFJvdXRlIGluZGV4Um91dGU+IGluXG4gKiBhIEpTWCByb3V0ZSBjb25maWcuXG4gKi9cblxudmFyIEluZGV4Um91dGUgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ0luZGV4Um91dGUnLFxuXG5cbiAgc3RhdGljczoge1xuICAgIGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudDogZnVuY3Rpb24gY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KGVsZW1lbnQsIHBhcmVudFJvdXRlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogc2FuaXR5IGNoZWNrICovXG4gICAgICBpZiAocGFyZW50Um91dGUpIHtcbiAgICAgICAgcGFyZW50Um91dGUuaW5kZXhSb3V0ZSA9ICgwLCBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQpKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdBbiA8SW5kZXhSb3V0ZT4gZG9lcyBub3QgbWFrZSBzZW5zZSBhdCB0aGUgcm9vdCBvZiB5b3VyIHJvdXRlIGNvbmZpZycpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBwYXRoOiBfSW50ZXJuYWxQcm9wVHlwZXMuZmFsc3ksXG4gICAgY29tcG9uZW50OiBfSW50ZXJuYWxQcm9wVHlwZXMuY29tcG9uZW50LFxuICAgIGNvbXBvbmVudHM6IF9JbnRlcm5hbFByb3BUeXBlcy5jb21wb25lbnRzLFxuICAgIGdldENvbXBvbmVudDogZnVuYyxcbiAgICBnZXRDb21wb25lbnRzOiBmdW5jXG4gIH0sXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNhbml0eSBjaGVjayAqL1xuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnPEluZGV4Um91dGU+IGVsZW1lbnRzIGFyZSBmb3Igcm91dGVyIGNvbmZpZ3VyYXRpb24gb25seSBhbmQgc2hvdWxkIG5vdCBiZSByZW5kZXJlZCcpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcbiAgfVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEluZGV4Um91dGU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9JbmRleFJvdXRlLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfUm91dGVVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVVdGlscycpO1xuXG52YXIgX0ludGVybmFsUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9JbnRlcm5hbFByb3BUeXBlcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgX1JlYWN0JFByb3BUeXBlcyA9IF9yZWFjdDIuZGVmYXVsdC5Qcm9wVHlwZXM7XG52YXIgc3RyaW5nID0gX1JlYWN0JFByb3BUeXBlcy5zdHJpbmc7XG52YXIgZnVuYyA9IF9SZWFjdCRQcm9wVHlwZXMuZnVuYztcblxuLyoqXG4gKiBBIDxSb3V0ZT4gaXMgdXNlZCB0byBkZWNsYXJlIHdoaWNoIGNvbXBvbmVudHMgYXJlIHJlbmRlcmVkIHRvIHRoZVxuICogcGFnZSB3aGVuIHRoZSBVUkwgbWF0Y2hlcyBhIGdpdmVuIHBhdHRlcm4uXG4gKlxuICogUm91dGVzIGFyZSBhcnJhbmdlZCBpbiBhIG5lc3RlZCB0cmVlIHN0cnVjdHVyZS4gV2hlbiBhIG5ldyBVUkwgaXNcbiAqIHJlcXVlc3RlZCwgdGhlIHRyZWUgaXMgc2VhcmNoZWQgZGVwdGgtZmlyc3QgdG8gZmluZCBhIHJvdXRlIHdob3NlXG4gKiBwYXRoIG1hdGNoZXMgdGhlIFVSTC4gIFdoZW4gb25lIGlzIGZvdW5kLCBhbGwgcm91dGVzIGluIHRoZSB0cmVlXG4gKiB0aGF0IGxlYWQgdG8gaXQgYXJlIGNvbnNpZGVyZWQgXCJhY3RpdmVcIiBhbmQgdGhlaXIgY29tcG9uZW50cyBhcmVcbiAqIHJlbmRlcmVkIGludG8gdGhlIERPTSwgbmVzdGVkIGluIHRoZSBzYW1lIG9yZGVyIGFzIGluIHRoZSB0cmVlLlxuICovXG5cbnZhciBSb3V0ZSA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUm91dGUnLFxuXG5cbiAgc3RhdGljczoge1xuICAgIGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudDogX1JvdXRlVXRpbHMuY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50XG4gIH0sXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgcGF0aDogc3RyaW5nLFxuICAgIGNvbXBvbmVudDogX0ludGVybmFsUHJvcFR5cGVzLmNvbXBvbmVudCxcbiAgICBjb21wb25lbnRzOiBfSW50ZXJuYWxQcm9wVHlwZXMuY29tcG9uZW50cyxcbiAgICBnZXRDb21wb25lbnQ6IGZ1bmMsXG4gICAgZ2V0Q29tcG9uZW50czogZnVuY1xuICB9LFxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzYW5pdHkgY2hlY2sgKi9cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJzxSb3V0ZT4gZWxlbWVudHMgYXJlIGZvciByb3V0ZXIgY29uZmlndXJhdGlvbiBvbmx5IGFuZCBzaG91bGQgbm90IGJlIHJlbmRlcmVkJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuICB9XG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUm91dGU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxudmFyIF9JbnRlcm5hbFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vSW50ZXJuYWxQcm9wVHlwZXMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBBIG1peGluIHRoYXQgYWRkcyB0aGUgXCJoaXN0b3J5XCIgaW5zdGFuY2UgdmFyaWFibGUgdG8gY29tcG9uZW50cy5cbiAqL1xudmFyIEhpc3RvcnkgPSB7XG5cbiAgY29udGV4dFR5cGVzOiB7XG4gICAgaGlzdG9yeTogX0ludGVybmFsUHJvcFR5cGVzLmhpc3RvcnlcbiAgfSxcblxuICBjb21wb25lbnRXaWxsTW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ3RoZSBgSGlzdG9yeWAgbWl4aW4gaXMgZGVwcmVjYXRlZCwgcGxlYXNlIGFjY2VzcyBgY29udGV4dC5yb3V0ZXJgIHdpdGggeW91ciBvd24gYGNvbnRleHRUeXBlc2AuIGh0dHA6Ly90aW55LmNjL3JvdXRlci1oaXN0b3J5bWl4aW4nKSA6IHZvaWQgMDtcbiAgICB0aGlzLmhpc3RvcnkgPSB0aGlzLmNvbnRleHQuaGlzdG9yeTtcbiAgfVxufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gSGlzdG9yeTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL0hpc3RvcnkuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIG9iamVjdCA9IF9yZWFjdDIuZGVmYXVsdC5Qcm9wVHlwZXMub2JqZWN0O1xuXG4vKipcbiAqIFRoZSBMaWZlY3ljbGUgbWl4aW4gYWRkcyB0aGUgcm91dGVyV2lsbExlYXZlIGxpZmVjeWNsZSBtZXRob2QgdG8gYVxuICogY29tcG9uZW50IHRoYXQgbWF5IGJlIHVzZWQgdG8gY2FuY2VsIGEgdHJhbnNpdGlvbiBvciBwcm9tcHQgdGhlIHVzZXJcbiAqIGZvciBjb25maXJtYXRpb24uXG4gKlxuICogT24gc3RhbmRhcmQgdHJhbnNpdGlvbnMsIHJvdXRlcldpbGxMZWF2ZSByZWNlaXZlcyBhIHNpbmdsZSBhcmd1bWVudDogdGhlXG4gKiBsb2NhdGlvbiB3ZSdyZSB0cmFuc2l0aW9uaW5nIHRvLiBUbyBjYW5jZWwgdGhlIHRyYW5zaXRpb24sIHJldHVybiBmYWxzZS5cbiAqIFRvIHByb21wdCB0aGUgdXNlciBmb3IgY29uZmlybWF0aW9uLCByZXR1cm4gYSBwcm9tcHQgbWVzc2FnZSAoc3RyaW5nKS5cbiAqXG4gKiBEdXJpbmcgdGhlIGJlZm9yZXVubG9hZCBldmVudCAoYXNzdW1pbmcgeW91J3JlIHVzaW5nIHRoZSB1c2VCZWZvcmVVbmxvYWRcbiAqIGhpc3RvcnkgZW5oYW5jZXIpLCByb3V0ZXJXaWxsTGVhdmUgZG9lcyBub3QgcmVjZWl2ZSBhIGxvY2F0aW9uIG9iamVjdFxuICogYmVjYXVzZSBpdCBpc24ndCBwb3NzaWJsZSBmb3IgdXMgdG8ga25vdyB0aGUgbG9jYXRpb24gd2UncmUgdHJhbnNpdGlvbmluZ1xuICogdG8uIEluIHRoaXMgY2FzZSByb3V0ZXJXaWxsTGVhdmUgbXVzdCByZXR1cm4gYSBwcm9tcHQgbWVzc2FnZSB0byBwcmV2ZW50XG4gKiB0aGUgdXNlciBmcm9tIGNsb3NpbmcgdGhlIHdpbmRvdy90YWIuXG4gKi9cblxudmFyIExpZmVjeWNsZSA9IHtcblxuICBjb250ZXh0VHlwZXM6IHtcbiAgICBoaXN0b3J5OiBvYmplY3QuaXNSZXF1aXJlZCxcbiAgICAvLyBOZXN0ZWQgY2hpbGRyZW4gcmVjZWl2ZSB0aGUgcm91dGUgYXMgY29udGV4dCwgZWl0aGVyXG4gICAgLy8gc2V0IGJ5IHRoZSByb3V0ZSBjb21wb25lbnQgdXNpbmcgdGhlIFJvdXRlQ29udGV4dCBtaXhpblxuICAgIC8vIG9yIGJ5IHNvbWUgb3RoZXIgYW5jZXN0b3IuXG4gICAgcm91dGU6IG9iamVjdFxuICB9LFxuXG4gIHByb3BUeXBlczoge1xuICAgIC8vIFJvdXRlIGNvbXBvbmVudHMgcmVjZWl2ZSB0aGUgcm91dGUgb2JqZWN0IGFzIGEgcHJvcC5cbiAgICByb3V0ZTogb2JqZWN0XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAndGhlIGBMaWZlY3ljbGVgIG1peGluIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgYGNvbnRleHQucm91dGVyLnNldFJvdXRlTGVhdmVIb29rKHJvdXRlLCBob29rKWAuIGh0dHA6Ly90aW55LmNjL3JvdXRlci1saWZlY3ljbGVtaXhpbicpIDogdm9pZCAwO1xuICAgICF0aGlzLnJvdXRlcldpbGxMZWF2ZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdUaGUgTGlmZWN5Y2xlIG1peGluIHJlcXVpcmVzIHlvdSB0byBkZWZpbmUgYSByb3V0ZXJXaWxsTGVhdmUgbWV0aG9kJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgdmFyIHJvdXRlID0gdGhpcy5wcm9wcy5yb3V0ZSB8fCB0aGlzLmNvbnRleHQucm91dGU7XG5cbiAgICAhcm91dGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnVGhlIExpZmVjeWNsZSBtaXhpbiBtdXN0IGJlIHVzZWQgb24gZWl0aGVyIGEpIGEgPFJvdXRlIGNvbXBvbmVudD4gb3IgJyArICdiKSBhIGRlc2NlbmRhbnQgb2YgYSA8Um91dGUgY29tcG9uZW50PiB0aGF0IHVzZXMgdGhlIFJvdXRlQ29udGV4dCBtaXhpbicpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIHRoaXMuX3VubGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlID0gdGhpcy5jb250ZXh0Lmhpc3RvcnkubGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlKHJvdXRlLCB0aGlzLnJvdXRlcldpbGxMZWF2ZSk7XG4gIH0sXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAodGhpcy5fdW5saXN0ZW5CZWZvcmVMZWF2aW5nUm91dGUpIHRoaXMuX3VubGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlKCk7XG4gIH1cbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IExpZmVjeWNsZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL0xpZmVjeWNsZS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgb2JqZWN0ID0gX3JlYWN0Mi5kZWZhdWx0LlByb3BUeXBlcy5vYmplY3Q7XG5cbi8qKlxuICogVGhlIFJvdXRlQ29udGV4dCBtaXhpbiBwcm92aWRlcyBhIGNvbnZlbmllbnQgd2F5IGZvciByb3V0ZVxuICogY29tcG9uZW50cyB0byBzZXQgdGhlIHJvdXRlIGluIGNvbnRleHQuIFRoaXMgaXMgbmVlZGVkIGZvclxuICogcm91dGVzIHRoYXQgcmVuZGVyIGVsZW1lbnRzIHRoYXQgd2FudCB0byB1c2UgdGhlIExpZmVjeWNsZVxuICogbWl4aW4gdG8gcHJldmVudCB0cmFuc2l0aW9ucy5cbiAqL1xuXG52YXIgUm91dGVDb250ZXh0ID0ge1xuXG4gIHByb3BUeXBlczoge1xuICAgIHJvdXRlOiBvYmplY3QuaXNSZXF1aXJlZFxuICB9LFxuXG4gIGNoaWxkQ29udGV4dFR5cGVzOiB7XG4gICAgcm91dGU6IG9iamVjdC5pc1JlcXVpcmVkXG4gIH0sXG5cbiAgZ2V0Q2hpbGRDb250ZXh0OiBmdW5jdGlvbiBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvdXRlOiB0aGlzLnByb3BzLnJvdXRlXG4gICAgfTtcbiAgfSxcbiAgY29tcG9uZW50V2lsbE1vdW50OiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdUaGUgYFJvdXRlQ29udGV4dGAgbWl4aW4gaXMgZGVwcmVjYXRlZC4gWW91IGNhbiBwcm92aWRlIGB0aGlzLnByb3BzLnJvdXRlYCBvbiBjb250ZXh0IHdpdGggeW91ciBvd24gYGNvbnRleHRUeXBlc2AuIGh0dHA6Ly90aW55LmNjL3JvdXRlci1yb3V0ZWNvbnRleHRtaXhpbicpIDogdm9pZCAwO1xuICB9XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSb3V0ZUNvbnRleHQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZUNvbnRleHQuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfdXNlUXVlcmllcyA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL3VzZVF1ZXJpZXMnKTtcblxudmFyIF91c2VRdWVyaWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3VzZVF1ZXJpZXMpO1xuXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyID0gcmVxdWlyZSgnLi9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcicpO1xuXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgY3JlYXRlSGlzdG9yeSBmdW5jdGlvbiB0aGF0IG1heSBiZSB1c2VkIHRvIGNyZWF0ZVxuICogaGlzdG9yeSBvYmplY3RzIHRoYXQga25vdyBhYm91dCByb3V0aW5nLlxuICpcbiAqIEVuaGFuY2VzIGhpc3Rvcnkgb2JqZWN0cyB3aXRoIHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcbiAqXG4gKiAtIGxpc3RlbigoZXJyb3IsIG5leHRTdGF0ZSkgPT4ge30pXG4gKiAtIGxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZShyb3V0ZSwgKG5leHRMb2NhdGlvbikgPT4ge30pXG4gKiAtIG1hdGNoKGxvY2F0aW9uLCAoZXJyb3IsIHJlZGlyZWN0TG9jYXRpb24sIG5leHRTdGF0ZSkgPT4ge30pXG4gKiAtIGlzQWN0aXZlKHBhdGhuYW1lLCBxdWVyeSwgaW5kZXhPbmx5PWZhbHNlKVxuICovXG5mdW5jdGlvbiB1c2VSb3V0ZXMoY3JlYXRlSGlzdG9yeSkge1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ2B1c2VSb3V0ZXNgIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgYGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyYCBpbnN0ZWFkLicpIDogdm9pZCAwO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgIHZhciByb3V0ZXMgPSBfcmVmLnJvdXRlcztcblxuICAgIHZhciBvcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsncm91dGVzJ10pO1xuXG4gICAgdmFyIGhpc3RvcnkgPSAoMCwgX3VzZVF1ZXJpZXMyLmRlZmF1bHQpKGNyZWF0ZUhpc3RvcnkpKG9wdGlvbnMpO1xuICAgIHZhciB0cmFuc2l0aW9uTWFuYWdlciA9ICgwLCBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyLmRlZmF1bHQpKGhpc3RvcnksIHJvdXRlcyk7XG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBoaXN0b3J5LCB0cmFuc2l0aW9uTWFuYWdlcik7XG4gIH07XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHVzZVJvdXRlcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL3VzZVJvdXRlcy5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX1JvdXRlckNvbnRleHQgPSByZXF1aXJlKCcuL1JvdXRlckNvbnRleHQnKTtcblxudmFyIF9Sb3V0ZXJDb250ZXh0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JvdXRlckNvbnRleHQpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgUm91dGluZ0NvbnRleHQgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1JvdXRpbmdDb250ZXh0JyxcbiAgY29tcG9uZW50V2lsbE1vdW50OiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdgUm91dGluZ0NvbnRleHRgIGhhcyBiZWVuIHJlbmFtZWQgdG8gYFJvdXRlckNvbnRleHRgLiBQbGVhc2UgdXNlIGBpbXBvcnQgeyBSb3V0ZXJDb250ZXh0IH0gZnJvbSBcXCdyZWFjdC1yb3V0ZXJcXCdgLiBodHRwOi8vdGlueS5jYy9yb3V0ZXItcm91dGVyY29udGV4dCcpIDogdm9pZCAwO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX1JvdXRlckNvbnRleHQyLmRlZmF1bHQsIHRoaXMucHJvcHMpO1xuICB9XG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUm91dGluZ0NvbnRleHQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0aW5nQ29udGV4dC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9BY3Rpb25zID0gcmVxdWlyZSgnaGlzdG9yeS9saWIvQWN0aW9ucycpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX2NyZWF0ZU1lbW9yeUhpc3RvcnkgPSByZXF1aXJlKCcuL2NyZWF0ZU1lbW9yeUhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVNZW1vcnlIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZU1lbW9yeUhpc3RvcnkpO1xuXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyID0gcmVxdWlyZSgnLi9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcicpO1xuXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKTtcblxudmFyIF9Sb3V0ZVV0aWxzID0gcmVxdWlyZSgnLi9Sb3V0ZVV0aWxzJyk7XG5cbnZhciBfUm91dGVyVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlclV0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuLyoqXG4gKiBBIGhpZ2gtbGV2ZWwgQVBJIHRvIGJlIHVzZWQgZm9yIHNlcnZlci1zaWRlIHJlbmRlcmluZy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIG1hdGNoZXMgYSBsb2NhdGlvbiB0byBhIHNldCBvZiByb3V0ZXMgYW5kIGNhbGxzXG4gKiBjYWxsYmFjayhlcnJvciwgcmVkaXJlY3RMb2NhdGlvbiwgcmVuZGVyUHJvcHMpIHdoZW4gZmluaXNoZWQuXG4gKlxuICogTm90ZTogWW91IHByb2JhYmx5IGRvbid0IHdhbnQgdG8gdXNlIHRoaXMgaW4gYSBicm93c2VyIHVubGVzcyB5b3UncmUgdXNpbmdcbiAqIHNlcnZlci1zaWRlIHJlbmRlcmluZyB3aXRoIGFzeW5jIHJvdXRlcy5cbiAqL1xuZnVuY3Rpb24gbWF0Y2goX3JlZiwgY2FsbGJhY2spIHtcbiAgdmFyIGhpc3RvcnkgPSBfcmVmLmhpc3Rvcnk7XG4gIHZhciByb3V0ZXMgPSBfcmVmLnJvdXRlcztcbiAgdmFyIGxvY2F0aW9uID0gX3JlZi5sb2NhdGlvbjtcblxuICB2YXIgb3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2hpc3RvcnknLCAncm91dGVzJywgJ2xvY2F0aW9uJ10pO1xuXG4gICEoaGlzdG9yeSB8fCBsb2NhdGlvbikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnbWF0Y2ggbmVlZHMgYSBoaXN0b3J5IG9yIGEgbG9jYXRpb24nKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgaGlzdG9yeSA9IGhpc3RvcnkgPyBoaXN0b3J5IDogKDAsIF9jcmVhdGVNZW1vcnlIaXN0b3J5Mi5kZWZhdWx0KShvcHRpb25zKTtcbiAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gKDAsIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIuZGVmYXVsdCkoaGlzdG9yeSwgKDAsIF9Sb3V0ZVV0aWxzLmNyZWF0ZVJvdXRlcykocm91dGVzKSk7XG5cbiAgdmFyIHVubGlzdGVuID0gdm9pZCAwO1xuXG4gIGlmIChsb2NhdGlvbikge1xuICAgIC8vIEFsbG93IG1hdGNoKHsgbG9jYXRpb246ICcvdGhlL3BhdGgnLCAuLi4gfSlcbiAgICBsb2NhdGlvbiA9IGhpc3RvcnkuY3JlYXRlTG9jYXRpb24obG9jYXRpb24pO1xuICB9IGVsc2Uge1xuICAgIC8vIFBpY2sgdXAgdGhlIGxvY2F0aW9uIGZyb20gdGhlIGhpc3RvcnkgdmlhIHN5bmNocm9ub3VzIGhpc3RvcnkubGlzdGVuXG4gICAgLy8gY2FsbCBpZiBuZWVkZWQuXG4gICAgdW5saXN0ZW4gPSBoaXN0b3J5Lmxpc3RlbihmdW5jdGlvbiAoaGlzdG9yeUxvY2F0aW9uKSB7XG4gICAgICBsb2NhdGlvbiA9IGhpc3RvcnlMb2NhdGlvbjtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciByb3V0ZXIgPSAoMCwgX1JvdXRlclV0aWxzLmNyZWF0ZVJvdXRlck9iamVjdCkoaGlzdG9yeSwgdHJhbnNpdGlvbk1hbmFnZXIpO1xuICBoaXN0b3J5ID0gKDAsIF9Sb3V0ZXJVdGlscy5jcmVhdGVSb3V0aW5nSGlzdG9yeSkoaGlzdG9yeSwgdHJhbnNpdGlvbk1hbmFnZXIpO1xuXG4gIHRyYW5zaXRpb25NYW5hZ2VyLm1hdGNoKGxvY2F0aW9uLCBmdW5jdGlvbiAoZXJyb3IsIHJlZGlyZWN0TG9jYXRpb24sIG5leHRTdGF0ZSkge1xuICAgIGNhbGxiYWNrKGVycm9yLCByZWRpcmVjdExvY2F0aW9uICYmIHJvdXRlci5jcmVhdGVMb2NhdGlvbihyZWRpcmVjdExvY2F0aW9uLCBfQWN0aW9ucy5SRVBMQUNFKSwgbmV4dFN0YXRlICYmIF9leHRlbmRzKHt9LCBuZXh0U3RhdGUsIHtcbiAgICAgIGhpc3Rvcnk6IGhpc3RvcnksXG4gICAgICByb3V0ZXI6IHJvdXRlcixcbiAgICAgIG1hdGNoQ29udGV4dDogeyBoaXN0b3J5OiBoaXN0b3J5LCB0cmFuc2l0aW9uTWFuYWdlcjogdHJhbnNpdGlvbk1hbmFnZXIsIHJvdXRlcjogcm91dGVyIH1cbiAgICB9KSk7XG5cbiAgICAvLyBEZWZlciByZW1vdmluZyB0aGUgbGlzdGVuZXIgdG8gaGVyZSB0byBwcmV2ZW50IERPTSBoaXN0b3JpZXMgZnJvbSBoYXZpbmdcbiAgICAvLyB0byB1bndpbmQgRE9NIGV2ZW50IGxpc3RlbmVycyB1bm5lY2Vzc2FyaWx5LCBpbiBjYXNlIGNhbGxiYWNrIHJlbmRlcnMgYVxuICAgIC8vIDxSb3V0ZXI+IGFuZCBhdHRhY2hlcyBhbm90aGVyIGhpc3RvcnkgbGlzdGVuZXIuXG4gICAgaWYgKHVubGlzdGVuKSB7XG4gICAgICB1bmxpc3RlbigpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG1hdGNoO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvbWF0Y2guanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVNZW1vcnlIaXN0b3J5O1xuXG52YXIgX3VzZVF1ZXJpZXMgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi91c2VRdWVyaWVzJyk7XG5cbnZhciBfdXNlUXVlcmllczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VRdWVyaWVzKTtcblxudmFyIF91c2VCYXNlbmFtZSA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL3VzZUJhc2VuYW1lJyk7XG5cbnZhciBfdXNlQmFzZW5hbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXNlQmFzZW5hbWUpO1xuXG52YXIgX2NyZWF0ZU1lbW9yeUhpc3RvcnkgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi9jcmVhdGVNZW1vcnlIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlTWVtb3J5SGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVNZW1vcnlIaXN0b3J5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeShvcHRpb25zKSB7XG4gIC8vIHNpZ25hdHVyZXMgYW5kIHR5cGUgY2hlY2tpbmcgZGlmZmVyIGJldHdlZW4gYHVzZVJvdXRlc2AgYW5kXG4gIC8vIGBjcmVhdGVNZW1vcnlIaXN0b3J5YCwgaGF2ZSB0byBjcmVhdGUgYG1lbW9yeUhpc3RvcnlgIGZpcnN0IGJlY2F1c2VcbiAgLy8gYHVzZVF1ZXJpZXNgIGRvZXNuJ3QgdW5kZXJzdGFuZCB0aGUgc2lnbmF0dXJlXG4gIHZhciBtZW1vcnlIaXN0b3J5ID0gKDAsIF9jcmVhdGVNZW1vcnlIaXN0b3J5Mi5kZWZhdWx0KShvcHRpb25zKTtcbiAgdmFyIGNyZWF0ZUhpc3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVIaXN0b3J5KCkge1xuICAgIHJldHVybiBtZW1vcnlIaXN0b3J5O1xuICB9O1xuICB2YXIgaGlzdG9yeSA9ICgwLCBfdXNlUXVlcmllczIuZGVmYXVsdCkoKDAsIF91c2VCYXNlbmFtZTIuZGVmYXVsdCkoY3JlYXRlSGlzdG9yeSkpKG9wdGlvbnMpO1xuICBoaXN0b3J5Ll9fdjJfY29tcGF0aWJsZV9fID0gdHJ1ZTtcbiAgcmV0dXJuIGhpc3Rvcnk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9jcmVhdGVNZW1vcnlIaXN0b3J5LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX0V4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbnZhciBfcnVuVHJhbnNpdGlvbkhvb2sgPSByZXF1aXJlKCcuL3J1blRyYW5zaXRpb25Ib29rJyk7XG5cbnZhciBfcnVuVHJhbnNpdGlvbkhvb2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcnVuVHJhbnNpdGlvbkhvb2spO1xuXG52YXIgX2RlcHJlY2F0ZSA9IHJlcXVpcmUoJy4vZGVwcmVjYXRlJyk7XG5cbnZhciBfZGVwcmVjYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlcHJlY2F0ZSk7XG5cbmZ1bmN0aW9uIHVzZUJhc2VuYW1lKGNyZWF0ZUhpc3RvcnkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICAgdmFyIGhpc3RvcnkgPSBjcmVhdGVIaXN0b3J5KG9wdGlvbnMpO1xuXG4gICAgdmFyIGJhc2VuYW1lID0gb3B0aW9ucy5iYXNlbmFtZTtcblxuICAgIHZhciBjaGVja2VkQmFzZUhyZWYgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIGNoZWNrQmFzZUhyZWYoKSB7XG4gICAgICBpZiAoY2hlY2tlZEJhc2VIcmVmKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQXV0b21hdGljYWxseSB1c2UgdGhlIHZhbHVlIG9mIDxiYXNlIGhyZWY+IGluIEhUTUxcbiAgICAgIC8vIGRvY3VtZW50cyBhcyBiYXNlbmFtZSBpZiBpdCdzIG5vdCBleHBsaWNpdGx5IGdpdmVuLlxuICAgICAgaWYgKGJhc2VuYW1lID09IG51bGwgJiYgX0V4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAgICAgICB2YXIgYmFzZSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdiYXNlJylbMF07XG4gICAgICAgIHZhciBiYXNlSHJlZiA9IGJhc2UgJiYgYmFzZS5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcblxuICAgICAgICBpZiAoYmFzZUhyZWYgIT0gbnVsbCkge1xuICAgICAgICAgIGJhc2VuYW1lID0gYmFzZUhyZWY7XG5cbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10oZmFsc2UsICdBdXRvbWF0aWNhbGx5IHNldHRpbmcgYmFzZW5hbWUgdXNpbmcgPGJhc2UgaHJlZj4gaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCAnICsgJ2JlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS4gVGhlIHNlbWFudGljcyBvZiA8YmFzZSBocmVmPiBhcmUgJyArICdzdWJ0bHkgZGlmZmVyZW50IGZyb20gYmFzZW5hbWUuIFBsZWFzZSBwYXNzIHRoZSBiYXNlbmFtZSBleHBsaWNpdGx5IGluICcgKyAndGhlIG9wdGlvbnMgdG8gY3JlYXRlSGlzdG9yeScpIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNoZWNrZWRCYXNlSHJlZiA9IHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkQmFzZW5hbWUobG9jYXRpb24pIHtcbiAgICAgIGNoZWNrQmFzZUhyZWYoKTtcblxuICAgICAgaWYgKGJhc2VuYW1lICYmIGxvY2F0aW9uLmJhc2VuYW1lID09IG51bGwpIHtcbiAgICAgICAgaWYgKGxvY2F0aW9uLnBhdGhuYW1lLmluZGV4T2YoYmFzZW5hbWUpID09PSAwKSB7XG4gICAgICAgICAgbG9jYXRpb24ucGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZS5zdWJzdHJpbmcoYmFzZW5hbWUubGVuZ3RoKTtcbiAgICAgICAgICBsb2NhdGlvbi5iYXNlbmFtZSA9IGJhc2VuYW1lO1xuXG4gICAgICAgICAgaWYgKGxvY2F0aW9uLnBhdGhuYW1lID09PSAnJykgbG9jYXRpb24ucGF0aG5hbWUgPSAnLyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9jYXRpb24uYmFzZW5hbWUgPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbG9jYXRpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcGVuZEJhc2VuYW1lKGxvY2F0aW9uKSB7XG4gICAgICBjaGVja0Jhc2VIcmVmKCk7XG5cbiAgICAgIGlmICghYmFzZW5hbWUpIHJldHVybiBsb2NhdGlvbjtcblxuICAgICAgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycpIGxvY2F0aW9uID0gX1BhdGhVdGlscy5wYXJzZVBhdGgobG9jYXRpb24pO1xuXG4gICAgICB2YXIgcG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZTtcbiAgICAgIHZhciBub3JtYWxpemVkQmFzZW5hbWUgPSBiYXNlbmFtZS5zbGljZSgtMSkgPT09ICcvJyA/IGJhc2VuYW1lIDogYmFzZW5hbWUgKyAnLyc7XG4gICAgICB2YXIgbm9ybWFsaXplZFBhdGhuYW1lID0gcG5hbWUuY2hhckF0KDApID09PSAnLycgPyBwbmFtZS5zbGljZSgxKSA6IHBuYW1lO1xuICAgICAgdmFyIHBhdGhuYW1lID0gbm9ybWFsaXplZEJhc2VuYW1lICsgbm9ybWFsaXplZFBhdGhuYW1lO1xuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGxvY2F0aW9uLCB7XG4gICAgICAgIHBhdGhuYW1lOiBwYXRobmFtZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gT3ZlcnJpZGUgYWxsIHJlYWQgbWV0aG9kcyB3aXRoIGJhc2VuYW1lLWF3YXJlIHZlcnNpb25zLlxuICAgIGZ1bmN0aW9uIGxpc3RlbkJlZm9yZShob29rKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeS5saXN0ZW5CZWZvcmUoZnVuY3Rpb24gKGxvY2F0aW9uLCBjYWxsYmFjaykge1xuICAgICAgICBfcnVuVHJhbnNpdGlvbkhvb2syWydkZWZhdWx0J10oaG9vaywgYWRkQmFzZW5hbWUobG9jYXRpb24pLCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBoaXN0b3J5Lmxpc3RlbihmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgICAgbGlzdGVuZXIoYWRkQmFzZW5hbWUobG9jYXRpb24pKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIE92ZXJyaWRlIGFsbCB3cml0ZSBtZXRob2RzIHdpdGggYmFzZW5hbWUtYXdhcmUgdmVyc2lvbnMuXG4gICAgZnVuY3Rpb24gcHVzaChsb2NhdGlvbikge1xuICAgICAgaGlzdG9yeS5wdXNoKHByZXBlbmRCYXNlbmFtZShsb2NhdGlvbikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlcGxhY2UobG9jYXRpb24pIHtcbiAgICAgIGhpc3RvcnkucmVwbGFjZShwcmVwZW5kQmFzZW5hbWUobG9jYXRpb24pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXRoKGxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeS5jcmVhdGVQYXRoKHByZXBlbmRCYXNlbmFtZShsb2NhdGlvbikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24pIHtcbiAgICAgIHJldHVybiBoaXN0b3J5LmNyZWF0ZUhyZWYocHJlcGVuZEJhc2VuYW1lKGxvY2F0aW9uKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24obG9jYXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFkZEJhc2VuYW1lKGhpc3RvcnkuY3JlYXRlTG9jYXRpb24uYXBwbHkoaGlzdG9yeSwgW3ByZXBlbmRCYXNlbmFtZShsb2NhdGlvbildLmNvbmNhdChhcmdzKSkpO1xuICAgIH1cblxuICAgIC8vIGRlcHJlY2F0ZWRcbiAgICBmdW5jdGlvbiBwdXNoU3RhdGUoc3RhdGUsIHBhdGgpIHtcbiAgICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHBhdGggPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChwYXRoKTtcblxuICAgICAgcHVzaChfZXh0ZW5kcyh7IHN0YXRlOiBzdGF0ZSB9LCBwYXRoKSk7XG4gICAgfVxuXG4gICAgLy8gZGVwcmVjYXRlZFxuICAgIGZ1bmN0aW9uIHJlcGxhY2VTdGF0ZShzdGF0ZSwgcGF0aCkge1xuICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykgcGF0aCA9IF9QYXRoVXRpbHMucGFyc2VQYXRoKHBhdGgpO1xuXG4gICAgICByZXBsYWNlKF9leHRlbmRzKHsgc3RhdGU6IHN0YXRlIH0sIHBhdGgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGhpc3RvcnksIHtcbiAgICAgIGxpc3RlbkJlZm9yZTogbGlzdGVuQmVmb3JlLFxuICAgICAgbGlzdGVuOiBsaXN0ZW4sXG4gICAgICBwdXNoOiBwdXNoLFxuICAgICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICAgIGNyZWF0ZVBhdGg6IGNyZWF0ZVBhdGgsXG4gICAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgICAgY3JlYXRlTG9jYXRpb246IGNyZWF0ZUxvY2F0aW9uLFxuXG4gICAgICBwdXNoU3RhdGU6IF9kZXByZWNhdGUyWydkZWZhdWx0J10ocHVzaFN0YXRlLCAncHVzaFN0YXRlIGlzIGRlcHJlY2F0ZWQ7IHVzZSBwdXNoIGluc3RlYWQnKSxcbiAgICAgIHJlcGxhY2VTdGF0ZTogX2RlcHJlY2F0ZTJbJ2RlZmF1bHQnXShyZXBsYWNlU3RhdGUsICdyZXBsYWNlU3RhdGUgaXMgZGVwcmVjYXRlZDsgdXNlIHJlcGxhY2UgaW5zdGVhZCcpXG4gICAgfSk7XG4gIH07XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHVzZUJhc2VuYW1lO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2hpc3RvcnkvbGliL3VzZUJhc2VuYW1lLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbnZhciBfQWN0aW9ucyA9IHJlcXVpcmUoJy4vQWN0aW9ucycpO1xuXG52YXIgX2NyZWF0ZUhpc3RvcnkgPSByZXF1aXJlKCcuL2NyZWF0ZUhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUhpc3RvcnkpO1xuXG5mdW5jdGlvbiBjcmVhdGVTdGF0ZVN0b3JhZ2UoZW50cmllcykge1xuICByZXR1cm4gZW50cmllcy5maWx0ZXIoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgcmV0dXJuIGVudHJ5LnN0YXRlO1xuICB9KS5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIGVudHJ5KSB7XG4gICAgbWVtb1tlbnRyeS5rZXldID0gZW50cnkuc3RhdGU7XG4gICAgcmV0dXJuIG1lbW87XG4gIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeSgpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgIG9wdGlvbnMgPSB7IGVudHJpZXM6IG9wdGlvbnMgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICBvcHRpb25zID0geyBlbnRyaWVzOiBbb3B0aW9uc10gfTtcbiAgfVxuXG4gIHZhciBoaXN0b3J5ID0gX2NyZWF0ZUhpc3RvcnkyWydkZWZhdWx0J10oX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICBnZXRDdXJyZW50TG9jYXRpb246IGdldEN1cnJlbnRMb2NhdGlvbixcbiAgICBmaW5pc2hUcmFuc2l0aW9uOiBmaW5pc2hUcmFuc2l0aW9uLFxuICAgIHNhdmVTdGF0ZTogc2F2ZVN0YXRlLFxuICAgIGdvOiBnb1xuICB9KSk7XG5cbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucztcbiAgdmFyIGVudHJpZXMgPSBfb3B0aW9ucy5lbnRyaWVzO1xuICB2YXIgY3VycmVudCA9IF9vcHRpb25zLmN1cnJlbnQ7XG5cbiAgaWYgKHR5cGVvZiBlbnRyaWVzID09PSAnc3RyaW5nJykge1xuICAgIGVudHJpZXMgPSBbZW50cmllc107XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoZW50cmllcykpIHtcbiAgICBlbnRyaWVzID0gWycvJ107XG4gIH1cblxuICBlbnRyaWVzID0gZW50cmllcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgdmFyIGtleSA9IGhpc3RvcnkuY3JlYXRlS2V5KCk7XG5cbiAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJykgcmV0dXJuIHsgcGF0aG5hbWU6IGVudHJ5LCBrZXk6IGtleSB9O1xuXG4gICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ29iamVjdCcgJiYgZW50cnkpIHJldHVybiBfZXh0ZW5kcyh7fSwgZW50cnksIHsga2V5OiBrZXkgfSk7XG5cbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX2ludmFyaWFudDJbJ2RlZmF1bHQnXShmYWxzZSwgJ1VuYWJsZSB0byBjcmVhdGUgaGlzdG9yeSBlbnRyeSBmcm9tICVzJywgZW50cnkpIDogX2ludmFyaWFudDJbJ2RlZmF1bHQnXShmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIH0pO1xuXG4gIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICBjdXJyZW50ID0gZW50cmllcy5sZW5ndGggLSAxO1xuICB9IGVsc2Uge1xuICAgICEoY3VycmVudCA+PSAwICYmIGN1cnJlbnQgPCBlbnRyaWVzLmxlbmd0aCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX2ludmFyaWFudDJbJ2RlZmF1bHQnXShmYWxzZSwgJ0N1cnJlbnQgaW5kZXggbXVzdCBiZSA+PSAwIGFuZCA8ICVzLCB3YXMgJXMnLCBlbnRyaWVzLmxlbmd0aCwgY3VycmVudCkgOiBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciBzdG9yYWdlID0gY3JlYXRlU3RhdGVTdG9yYWdlKGVudHJpZXMpO1xuXG4gIGZ1bmN0aW9uIHNhdmVTdGF0ZShrZXksIHN0YXRlKSB7XG4gICAgc3RvcmFnZVtrZXldID0gc3RhdGU7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkU3RhdGUoa2V5KSB7XG4gICAgcmV0dXJuIHN0b3JhZ2Vba2V5XTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbigpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2N1cnJlbnRdO1xuICAgIHZhciBiYXNlbmFtZSA9IGVudHJ5LmJhc2VuYW1lO1xuICAgIHZhciBwYXRobmFtZSA9IGVudHJ5LnBhdGhuYW1lO1xuICAgIHZhciBzZWFyY2ggPSBlbnRyeS5zZWFyY2g7XG5cbiAgICB2YXIgcGF0aCA9IChiYXNlbmFtZSB8fCAnJykgKyBwYXRobmFtZSArIChzZWFyY2ggfHwgJycpO1xuXG4gICAgdmFyIGtleSA9IHVuZGVmaW5lZCxcbiAgICAgICAgc3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGVudHJ5LmtleSkge1xuICAgICAga2V5ID0gZW50cnkua2V5O1xuICAgICAgc3RhdGUgPSByZWFkU3RhdGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5ID0gaGlzdG9yeS5jcmVhdGVLZXkoKTtcbiAgICAgIHN0YXRlID0gbnVsbDtcbiAgICAgIGVudHJ5LmtleSA9IGtleTtcbiAgICB9XG5cbiAgICB2YXIgbG9jYXRpb24gPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChwYXRoKTtcblxuICAgIHJldHVybiBoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uKF9leHRlbmRzKHt9LCBsb2NhdGlvbiwgeyBzdGF0ZTogc3RhdGUgfSksIHVuZGVmaW5lZCwga2V5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbkdvKG4pIHtcbiAgICB2YXIgaW5kZXggPSBjdXJyZW50ICsgbjtcbiAgICByZXR1cm4gaW5kZXggPj0gMCAmJiBpbmRleCA8IGVudHJpZXMubGVuZ3RoO1xuICB9XG5cbiAgZnVuY3Rpb24gZ28obikge1xuICAgIGlmIChuKSB7XG4gICAgICBpZiAoIWNhbkdvKG4pKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgJ0Nhbm5vdCBnbyglcykgdGhlcmUgaXMgbm90IGVub3VnaCBoaXN0b3J5JywgbikgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY3VycmVudCArPSBuO1xuXG4gICAgICB2YXIgY3VycmVudExvY2F0aW9uID0gZ2V0Q3VycmVudExvY2F0aW9uKCk7XG5cbiAgICAgIC8vIGNoYW5nZSBhY3Rpb24gdG8gUE9QXG4gICAgICBoaXN0b3J5LnRyYW5zaXRpb25UbyhfZXh0ZW5kcyh7fSwgY3VycmVudExvY2F0aW9uLCB7IGFjdGlvbjogX0FjdGlvbnMuUE9QIH0pKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2hUcmFuc2l0aW9uKGxvY2F0aW9uKSB7XG4gICAgc3dpdGNoIChsb2NhdGlvbi5hY3Rpb24pIHtcbiAgICAgIGNhc2UgX0FjdGlvbnMuUFVTSDpcbiAgICAgICAgY3VycmVudCArPSAxO1xuXG4gICAgICAgIC8vIGlmIHdlIGFyZSBub3Qgb24gdGhlIHRvcCBvZiBzdGFja1xuICAgICAgICAvLyByZW1vdmUgcmVzdCBhbmQgcHVzaCBuZXdcbiAgICAgICAgaWYgKGN1cnJlbnQgPCBlbnRyaWVzLmxlbmd0aCkgZW50cmllcy5zcGxpY2UoY3VycmVudCk7XG5cbiAgICAgICAgZW50cmllcy5wdXNoKGxvY2F0aW9uKTtcbiAgICAgICAgc2F2ZVN0YXRlKGxvY2F0aW9uLmtleSwgbG9jYXRpb24uc3RhdGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX0FjdGlvbnMuUkVQTEFDRTpcbiAgICAgICAgZW50cmllc1tjdXJyZW50XSA9IGxvY2F0aW9uO1xuICAgICAgICBzYXZlU3RhdGUobG9jYXRpb24ua2V5LCBsb2NhdGlvbi5zdGF0ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBoaXN0b3J5O1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBjcmVhdGVNZW1vcnlIaXN0b3J5O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2hpc3RvcnkvbGliL2NyZWF0ZU1lbW9yeUhpc3RvcnkuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSB1c2VSb3V0ZXJIaXN0b3J5O1xuXG52YXIgX3VzZVF1ZXJpZXMgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi91c2VRdWVyaWVzJyk7XG5cbnZhciBfdXNlUXVlcmllczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VRdWVyaWVzKTtcblxudmFyIF91c2VCYXNlbmFtZSA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL3VzZUJhc2VuYW1lJyk7XG5cbnZhciBfdXNlQmFzZW5hbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXNlQmFzZW5hbWUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB1c2VSb3V0ZXJIaXN0b3J5KGNyZWF0ZUhpc3RvcnkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIGhpc3RvcnkgPSAoMCwgX3VzZVF1ZXJpZXMyLmRlZmF1bHQpKCgwLCBfdXNlQmFzZW5hbWUyLmRlZmF1bHQpKGNyZWF0ZUhpc3RvcnkpKShvcHRpb25zKTtcbiAgICBoaXN0b3J5Ll9fdjJfY29tcGF0aWJsZV9fID0gdHJ1ZTtcbiAgICByZXR1cm4gaGlzdG9yeTtcbiAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL3VzZVJvdXRlckhpc3RvcnkuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9Sb3V0ZXJDb250ZXh0ID0gcmVxdWlyZSgnLi9Sb3V0ZXJDb250ZXh0Jyk7XG5cbnZhciBfUm91dGVyQ29udGV4dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Sb3V0ZXJDb250ZXh0KTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbWlkZGxld2FyZXMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBtaWRkbGV3YXJlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgbWlkZGxld2FyZXMuZm9yRWFjaChmdW5jdGlvbiAobWlkZGxld2FyZSwgaW5kZXgpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKG1pZGRsZXdhcmUucmVuZGVyUm91dGVyQ29udGV4dCB8fCBtaWRkbGV3YXJlLnJlbmRlclJvdXRlQ29tcG9uZW50LCAnVGhlIG1pZGRsZXdhcmUgc3BlY2lmaWVkIGF0IGluZGV4ICcgKyBpbmRleCArICcgZG9lcyBub3QgYXBwZWFyIHRvIGJlICcgKyAnYSB2YWxpZCBSZWFjdCBSb3V0ZXIgbWlkZGxld2FyZS4nKSA6IHZvaWQgMDtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciB3aXRoQ29udGV4dCA9IG1pZGRsZXdhcmVzLm1hcChmdW5jdGlvbiAobWlkZGxld2FyZSkge1xuICAgIHJldHVybiBtaWRkbGV3YXJlLnJlbmRlclJvdXRlckNvbnRleHQ7XG4gIH0pLmZpbHRlcihCb29sZWFuKTtcbiAgdmFyIHdpdGhDb21wb25lbnQgPSBtaWRkbGV3YXJlcy5tYXAoZnVuY3Rpb24gKG1pZGRsZXdhcmUpIHtcbiAgICByZXR1cm4gbWlkZGxld2FyZS5yZW5kZXJSb3V0ZUNvbXBvbmVudDtcbiAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuXG4gIHZhciBtYWtlQ3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIG1ha2VDcmVhdGVFbGVtZW50KCkge1xuICAgIHZhciBiYXNlQ3JlYXRlRWxlbWVudCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IF9yZWFjdC5jcmVhdGVFbGVtZW50IDogYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiBmdW5jdGlvbiAoQ29tcG9uZW50LCBwcm9wcykge1xuICAgICAgcmV0dXJuIHdpdGhDb21wb25lbnQucmVkdWNlUmlnaHQoZnVuY3Rpb24gKHByZXZpb3VzLCByZW5kZXJSb3V0ZUNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gcmVuZGVyUm91dGVDb21wb25lbnQocHJldmlvdXMsIHByb3BzKTtcbiAgICAgIH0sIGJhc2VDcmVhdGVFbGVtZW50KENvbXBvbmVudCwgcHJvcHMpKTtcbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbiAocmVuZGVyUHJvcHMpIHtcbiAgICByZXR1cm4gd2l0aENvbnRleHQucmVkdWNlUmlnaHQoZnVuY3Rpb24gKHByZXZpb3VzLCByZW5kZXJSb3V0ZXJDb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVuZGVyUm91dGVyQ29udGV4dChwcmV2aW91cywgcmVuZGVyUHJvcHMpO1xuICAgIH0sIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9Sb3V0ZXJDb250ZXh0Mi5kZWZhdWx0LCBfZXh0ZW5kcyh7fSwgcmVuZGVyUHJvcHMsIHtcbiAgICAgIGNyZWF0ZUVsZW1lbnQ6IG1ha2VDcmVhdGVFbGVtZW50KHJlbmRlclByb3BzLmNyZWF0ZUVsZW1lbnQpXG4gICAgfSkpKTtcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL2FwcGx5Um91dGVyTWlkZGxld2FyZS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9jcmVhdGVCcm93c2VySGlzdG9yeSA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL2NyZWF0ZUJyb3dzZXJIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlQnJvd3Nlckhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQnJvd3Nlckhpc3RvcnkpO1xuXG52YXIgX2NyZWF0ZVJvdXRlckhpc3RvcnkgPSByZXF1aXJlKCcuL2NyZWF0ZVJvdXRlckhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVSb3V0ZXJIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVJvdXRlckhpc3RvcnkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSAoMCwgX2NyZWF0ZVJvdXRlckhpc3RvcnkyLmRlZmF1bHQpKF9jcmVhdGVCcm93c2VySGlzdG9yeTIuZGVmYXVsdCk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9icm93c2VySGlzdG9yeS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX0FjdGlvbnMgPSByZXF1aXJlKCcuL0FjdGlvbnMnKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG52YXIgX0V4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgX0RPTVV0aWxzID0gcmVxdWlyZSgnLi9ET01VdGlscycpO1xuXG52YXIgX0RPTVN0YXRlU3RvcmFnZSA9IHJlcXVpcmUoJy4vRE9NU3RhdGVTdG9yYWdlJyk7XG5cbnZhciBfY3JlYXRlRE9NSGlzdG9yeSA9IHJlcXVpcmUoJy4vY3JlYXRlRE9NSGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZURPTUhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlRE9NSGlzdG9yeSk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGhpc3Rvcnkgb2JqZWN0IHRoYXQgdXNlcyBIVE1MNSdzIGhpc3RvcnkgQVBJXG4gKiAocHVzaFN0YXRlLCByZXBsYWNlU3RhdGUsIGFuZCB0aGUgcG9wc3RhdGUgZXZlbnQpIHRvIG1hbmFnZSBoaXN0b3J5LlxuICogVGhpcyBpcyB0aGUgcmVjb21tZW5kZWQgbWV0aG9kIG9mIG1hbmFnaW5nIGhpc3RvcnkgaW4gYnJvd3NlcnMgYmVjYXVzZVxuICogaXQgcHJvdmlkZXMgdGhlIGNsZWFuZXN0IFVSTHMuXG4gKlxuICogTm90ZTogSW4gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCB0aGUgSFRNTDUgaGlzdG9yeSBBUEkgZnVsbFxuICogcGFnZSByZWxvYWRzIHdpbGwgYmUgdXNlZCB0byBwcmVzZXJ2ZSBVUkxzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCcm93c2VySGlzdG9yeSgpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAhX0V4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlLCAnQnJvd3NlciBoaXN0b3J5IG5lZWRzIGEgRE9NJykgOiBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICB2YXIgZm9yY2VSZWZyZXNoID0gb3B0aW9ucy5mb3JjZVJlZnJlc2g7XG5cbiAgdmFyIGlzU3VwcG9ydGVkID0gX0RPTVV0aWxzLnN1cHBvcnRzSGlzdG9yeSgpO1xuICB2YXIgdXNlUmVmcmVzaCA9ICFpc1N1cHBvcnRlZCB8fCBmb3JjZVJlZnJlc2g7XG5cbiAgZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uKGhpc3RvcnlTdGF0ZSkge1xuICAgIHRyeSB7XG4gICAgICBoaXN0b3J5U3RhdGUgPSBoaXN0b3J5U3RhdGUgfHwgd2luZG93Lmhpc3Rvcnkuc3RhdGUgfHwge307XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGlzdG9yeVN0YXRlID0ge307XG4gICAgfVxuXG4gICAgdmFyIHBhdGggPSBfRE9NVXRpbHMuZ2V0V2luZG93UGF0aCgpO1xuICAgIHZhciBfaGlzdG9yeVN0YXRlID0gaGlzdG9yeVN0YXRlO1xuICAgIHZhciBrZXkgPSBfaGlzdG9yeVN0YXRlLmtleTtcblxuICAgIHZhciBzdGF0ZSA9IHVuZGVmaW5lZDtcbiAgICBpZiAoa2V5KSB7XG4gICAgICBzdGF0ZSA9IF9ET01TdGF0ZVN0b3JhZ2UucmVhZFN0YXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlID0gbnVsbDtcbiAgICAgIGtleSA9IGhpc3RvcnkuY3JlYXRlS2V5KCk7XG5cbiAgICAgIGlmIChpc1N1cHBvcnRlZCkgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKF9leHRlbmRzKHt9LCBoaXN0b3J5U3RhdGUsIHsga2V5OiBrZXkgfSksIG51bGwpO1xuICAgIH1cblxuICAgIHZhciBsb2NhdGlvbiA9IF9QYXRoVXRpbHMucGFyc2VQYXRoKHBhdGgpO1xuXG4gICAgcmV0dXJuIGhpc3RvcnkuY3JlYXRlTG9jYXRpb24oX2V4dGVuZHMoe30sIGxvY2F0aW9uLCB7IHN0YXRlOiBzdGF0ZSB9KSwgdW5kZWZpbmVkLCBrZXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnRQb3BTdGF0ZUxpc3RlbmVyKF9yZWYpIHtcbiAgICB2YXIgdHJhbnNpdGlvblRvID0gX3JlZi50cmFuc2l0aW9uVG87XG5cbiAgICBmdW5jdGlvbiBwb3BTdGF0ZUxpc3RlbmVyKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQuc3RhdGUgPT09IHVuZGVmaW5lZCkgcmV0dXJuOyAvLyBJZ25vcmUgZXh0cmFuZW91cyBwb3BzdGF0ZSBldmVudHMgaW4gV2ViS2l0LlxuXG4gICAgICB0cmFuc2l0aW9uVG8oZ2V0Q3VycmVudExvY2F0aW9uKGV2ZW50LnN0YXRlKSk7XG4gICAgfVxuXG4gICAgX0RPTVV0aWxzLmFkZEV2ZW50TGlzdGVuZXIod2luZG93LCAncG9wc3RhdGUnLCBwb3BTdGF0ZUxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBfRE9NVXRpbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcih3aW5kb3csICdwb3BzdGF0ZScsIHBvcFN0YXRlTGlzdGVuZXIpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2hUcmFuc2l0aW9uKGxvY2F0aW9uKSB7XG4gICAgdmFyIGJhc2VuYW1lID0gbG9jYXRpb24uYmFzZW5hbWU7XG4gICAgdmFyIHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWU7XG4gICAgdmFyIHNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaDtcbiAgICB2YXIgaGFzaCA9IGxvY2F0aW9uLmhhc2g7XG4gICAgdmFyIHN0YXRlID0gbG9jYXRpb24uc3RhdGU7XG4gICAgdmFyIGFjdGlvbiA9IGxvY2F0aW9uLmFjdGlvbjtcbiAgICB2YXIga2V5ID0gbG9jYXRpb24ua2V5O1xuXG4gICAgaWYgKGFjdGlvbiA9PT0gX0FjdGlvbnMuUE9QKSByZXR1cm47IC8vIE5vdGhpbmcgdG8gZG8uXG5cbiAgICBfRE9NU3RhdGVTdG9yYWdlLnNhdmVTdGF0ZShrZXksIHN0YXRlKTtcblxuICAgIHZhciBwYXRoID0gKGJhc2VuYW1lIHx8ICcnKSArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbiAgICB2YXIgaGlzdG9yeVN0YXRlID0ge1xuICAgICAga2V5OiBrZXlcbiAgICB9O1xuXG4gICAgaWYgKGFjdGlvbiA9PT0gX0FjdGlvbnMuUFVTSCkge1xuICAgICAgaWYgKHVzZVJlZnJlc2gpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBwYXRoO1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIFByZXZlbnQgbG9jYXRpb24gdXBkYXRlLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoaGlzdG9yeVN0YXRlLCBudWxsLCBwYXRoKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSRVBMQUNFXG4gICAgICBpZiAodXNlUmVmcmVzaCkge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShwYXRoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBQcmV2ZW50IGxvY2F0aW9uIHVwZGF0ZS5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKGhpc3RvcnlTdGF0ZSwgbnVsbCwgcGF0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgaGlzdG9yeSA9IF9jcmVhdGVET01IaXN0b3J5MlsnZGVmYXVsdCddKF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgZ2V0Q3VycmVudExvY2F0aW9uOiBnZXRDdXJyZW50TG9jYXRpb24sXG4gICAgZmluaXNoVHJhbnNpdGlvbjogZmluaXNoVHJhbnNpdGlvbixcbiAgICBzYXZlU3RhdGU6IF9ET01TdGF0ZVN0b3JhZ2Uuc2F2ZVN0YXRlXG4gIH0pKTtcblxuICB2YXIgbGlzdGVuZXJDb3VudCA9IDAsXG4gICAgICBzdG9wUG9wU3RhdGVMaXN0ZW5lciA9IHVuZGVmaW5lZDtcblxuICBmdW5jdGlvbiBsaXN0ZW5CZWZvcmUobGlzdGVuZXIpIHtcbiAgICBpZiAoKytsaXN0ZW5lckNvdW50ID09PSAxKSBzdG9wUG9wU3RhdGVMaXN0ZW5lciA9IHN0YXJ0UG9wU3RhdGVMaXN0ZW5lcihoaXN0b3J5KTtcblxuICAgIHZhciB1bmxpc3RlbiA9IGhpc3RvcnkubGlzdGVuQmVmb3JlKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB1bmxpc3RlbigpO1xuXG4gICAgICBpZiAoLS1saXN0ZW5lckNvdW50ID09PSAwKSBzdG9wUG9wU3RhdGVMaXN0ZW5lcigpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICBpZiAoKytsaXN0ZW5lckNvdW50ID09PSAxKSBzdG9wUG9wU3RhdGVMaXN0ZW5lciA9IHN0YXJ0UG9wU3RhdGVMaXN0ZW5lcihoaXN0b3J5KTtcblxuICAgIHZhciB1bmxpc3RlbiA9IGhpc3RvcnkubGlzdGVuKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB1bmxpc3RlbigpO1xuXG4gICAgICBpZiAoLS1saXN0ZW5lckNvdW50ID09PSAwKSBzdG9wUG9wU3RhdGVMaXN0ZW5lcigpO1xuICAgIH07XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyVHJhbnNpdGlvbkhvb2soaG9vaykge1xuICAgIGlmICgrK2xpc3RlbmVyQ291bnQgPT09IDEpIHN0b3BQb3BTdGF0ZUxpc3RlbmVyID0gc3RhcnRQb3BTdGF0ZUxpc3RlbmVyKGhpc3RvcnkpO1xuXG4gICAgaGlzdG9yeS5yZWdpc3RlclRyYW5zaXRpb25Ib29rKGhvb2spO1xuICB9XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBmdW5jdGlvbiB1bnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2soaG9vaykge1xuICAgIGhpc3RvcnkudW5yZWdpc3RlclRyYW5zaXRpb25Ib29rKGhvb2spO1xuXG4gICAgaWYgKC0tbGlzdGVuZXJDb3VudCA9PT0gMCkgc3RvcFBvcFN0YXRlTGlzdGVuZXIoKTtcbiAgfVxuXG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwge1xuICAgIGxpc3RlbkJlZm9yZTogbGlzdGVuQmVmb3JlLFxuICAgIGxpc3RlbjogbGlzdGVuLFxuICAgIHJlZ2lzdGVyVHJhbnNpdGlvbkhvb2s6IHJlZ2lzdGVyVHJhbnNpdGlvbkhvb2ssXG4gICAgdW5yZWdpc3RlclRyYW5zaXRpb25Ib29rOiB1bnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2tcbiAgfSk7XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGNyZWF0ZUJyb3dzZXJIaXN0b3J5O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2hpc3RvcnkvbGliL2NyZWF0ZUJyb3dzZXJIaXN0b3J5LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoY3JlYXRlSGlzdG9yeSkge1xuICB2YXIgaGlzdG9yeSA9IHZvaWQgMDtcbiAgaWYgKGNhblVzZURPTSkgaGlzdG9yeSA9ICgwLCBfdXNlUm91dGVySGlzdG9yeTIuZGVmYXVsdCkoY3JlYXRlSGlzdG9yeSkoKTtcbiAgcmV0dXJuIGhpc3Rvcnk7XG59O1xuXG52YXIgX3VzZVJvdXRlckhpc3RvcnkgPSByZXF1aXJlKCcuL3VzZVJvdXRlckhpc3RvcnknKTtcblxudmFyIF91c2VSb3V0ZXJIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3VzZVJvdXRlckhpc3RvcnkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvY3JlYXRlUm91dGVySGlzdG9yeS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9jcmVhdGVIYXNoSGlzdG9yeSA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL2NyZWF0ZUhhc2hIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlSGFzaEhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlSGFzaEhpc3RvcnkpO1xuXG52YXIgX2NyZWF0ZVJvdXRlckhpc3RvcnkgPSByZXF1aXJlKCcuL2NyZWF0ZVJvdXRlckhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVSb3V0ZXJIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVJvdXRlckhpc3RvcnkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSAoMCwgX2NyZWF0ZVJvdXRlckhpc3RvcnkyLmRlZmF1bHQpKF9jcmVhdGVIYXNoSGlzdG9yeTIuZGVmYXVsdCk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9oYXNoSGlzdG9yeS5qc1xuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2luZGV4LmpzIS4vYXBwLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2luZGV4LmpzIS4vYXBwLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvaW5kZXguanMhLi9hcHAuc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc3R5bGUtbG9hZGVyIS4vfi9jc3MtbG9hZGVyIS4vfi9zYXNzLWxvYWRlciEuL2FwcC9zdHlsZXMvYXBwLnNjc3NcbiAqKiBtb2R1bGUgaWQgPSAyMjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiQGNoYXJzZXQgXFxcIlVURi04XFxcIjtcXG4vKipcXG4gKiBGb3VuZGF0aW9uIGZvciBTaXRlcyBieSBaVVJCXFxuICogVmVyc2lvbiA2LjIuM1xcbiAqIGZvdW5kYXRpb24uenVyYi5jb21cXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgT3BlbiBTb3VyY2VcXG4gKi9cXG4vKiEgbm9ybWFsaXplLmNzcyB2My4wLjMgfCBNSVQgTGljZW5zZSB8IGdpdGh1Yi5jb20vbmVjb2xhcy9ub3JtYWxpemUuY3NzICovXFxuLyoqXFxuICAgKiAxLiBTZXQgZGVmYXVsdCBmb250IGZhbWlseSB0byBzYW5zLXNlcmlmLlxcbiAgICogMi4gUHJldmVudCBpT1MgYW5kIElFIHRleHQgc2l6ZSBhZGp1c3QgYWZ0ZXIgZGV2aWNlIG9yaWVudGF0aW9uIGNoYW5nZSxcXG4gICAqICAgIHdpdGhvdXQgZGlzYWJsaW5nIHVzZXIgem9vbS5cXG4gICAqL1xcbmh0bWwge1xcbiAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XFxuICAvKiAxICovXFxuICAtbXMtdGV4dC1zaXplLWFkanVzdDogMTAwJTtcXG4gIC8qIDIgKi9cXG4gIC13ZWJraXQtdGV4dC1zaXplLWFkanVzdDogMTAwJTtcXG4gIC8qIDIgKi8gfVxcblxcbi8qKlxcbiAgICogUmVtb3ZlIGRlZmF1bHQgbWFyZ2luLlxcbiAgICovXFxuYm9keSB7XFxuICBtYXJnaW46IDA7IH1cXG5cXG4vKiBIVE1MNSBkaXNwbGF5IGRlZmluaXRpb25zXFxuICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcbi8qKlxcbiAgICogQ29ycmVjdCBgYmxvY2tgIGRpc3BsYXkgbm90IGRlZmluZWQgZm9yIGFueSBIVE1MNSBlbGVtZW50IGluIElFIDgvOS5cXG4gICAqIENvcnJlY3QgYGJsb2NrYCBkaXNwbGF5IG5vdCBkZWZpbmVkIGZvciBgZGV0YWlsc2Agb3IgYHN1bW1hcnlgIGluIElFIDEwLzExXFxuICAgKiBhbmQgRmlyZWZveC5cXG4gICAqIENvcnJlY3QgYGJsb2NrYCBkaXNwbGF5IG5vdCBkZWZpbmVkIGZvciBgbWFpbmAgaW4gSUUgMTEuXFxuICAgKi9cXG5hcnRpY2xlLFxcbmFzaWRlLFxcbmRldGFpbHMsXFxuZmlnY2FwdGlvbixcXG5maWd1cmUsXFxuZm9vdGVyLFxcbmhlYWRlcixcXG5oZ3JvdXAsXFxubWFpbixcXG5tZW51LFxcbm5hdixcXG5zZWN0aW9uLFxcbnN1bW1hcnkge1xcbiAgZGlzcGxheTogYmxvY2s7IH1cXG5cXG4vKipcXG4gICAqIDEuIENvcnJlY3QgYGlubGluZS1ibG9ja2AgZGlzcGxheSBub3QgZGVmaW5lZCBpbiBJRSA4LzkuXFxuICAgKiAyLiBOb3JtYWxpemUgdmVydGljYWwgYWxpZ25tZW50IG9mIGBwcm9ncmVzc2AgaW4gQ2hyb21lLCBGaXJlZm94LCBhbmQgT3BlcmEuXFxuICAgKi9cXG5hdWRpbyxcXG5jYW52YXMsXFxucHJvZ3Jlc3MsXFxudmlkZW8ge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgLyogMSAqL1xcbiAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xcbiAgLyogMiAqLyB9XFxuXFxuLyoqXFxuICAgKiBQcmV2ZW50IG1vZGVybiBicm93c2VycyBmcm9tIGRpc3BsYXlpbmcgYGF1ZGlvYCB3aXRob3V0IGNvbnRyb2xzLlxcbiAgICogUmVtb3ZlIGV4Y2VzcyBoZWlnaHQgaW4gaU9TIDUgZGV2aWNlcy5cXG4gICAqL1xcbmF1ZGlvOm5vdChbY29udHJvbHNdKSB7XFxuICBkaXNwbGF5OiBub25lO1xcbiAgaGVpZ2h0OiAwOyB9XFxuXFxuLyoqXFxuICAgKiBBZGRyZXNzIGBbaGlkZGVuXWAgc3R5bGluZyBub3QgcHJlc2VudCBpbiBJRSA4LzkvMTAuXFxuICAgKiBIaWRlIHRoZSBgdGVtcGxhdGVgIGVsZW1lbnQgaW4gSUUgOC85LzEwLzExLCBTYWZhcmksIGFuZCBGaXJlZm94IDwgMjIuXFxuICAgKi9cXG5baGlkZGVuXSxcXG50ZW1wbGF0ZSB7XFxuICBkaXNwbGF5OiBub25lOyB9XFxuXFxuLyogTGlua3NcXG4gICAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuLyoqXFxuICAgKiBSZW1vdmUgdGhlIGdyYXkgYmFja2dyb3VuZCBjb2xvciBmcm9tIGFjdGl2ZSBsaW5rcyBpbiBJRSAxMC5cXG4gICAqL1xcbmEge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7IH1cXG5cXG4vKipcXG4gICAqIEltcHJvdmUgcmVhZGFiaWxpdHkgb2YgZm9jdXNlZCBlbGVtZW50cyB3aGVuIHRoZXkgYXJlIGFsc28gaW4gYW5cXG4gICAqIGFjdGl2ZS9ob3ZlciBzdGF0ZS5cXG4gICAqL1xcbmE6YWN0aXZlLFxcbmE6aG92ZXIge1xcbiAgb3V0bGluZTogMDsgfVxcblxcbi8qIFRleHQtbGV2ZWwgc2VtYW50aWNzXFxuICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcbi8qKlxcbiAgICogQWRkcmVzcyBzdHlsaW5nIG5vdCBwcmVzZW50IGluIElFIDgvOS8xMC8xMSwgU2FmYXJpLCBhbmQgQ2hyb21lLlxcbiAgICovXFxuYWJiclt0aXRsZV0ge1xcbiAgYm9yZGVyLWJvdHRvbTogMXB4IGRvdHRlZDsgfVxcblxcbi8qKlxcbiAgICogQWRkcmVzcyBzdHlsZSBzZXQgdG8gYGJvbGRlcmAgaW4gRmlyZWZveCA0KywgU2FmYXJpLCBhbmQgQ2hyb21lLlxcbiAgICovXFxuYixcXG5zdHJvbmcge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7IH1cXG5cXG4vKipcXG4gICAqIEFkZHJlc3Mgc3R5bGluZyBub3QgcHJlc2VudCBpbiBTYWZhcmkgYW5kIENocm9tZS5cXG4gICAqL1xcbmRmbiB7XFxuICBmb250LXN0eWxlOiBpdGFsaWM7IH1cXG5cXG4vKipcXG4gICAqIEFkZHJlc3MgdmFyaWFibGUgYGgxYCBmb250LXNpemUgYW5kIG1hcmdpbiB3aXRoaW4gYHNlY3Rpb25gIGFuZCBgYXJ0aWNsZWBcXG4gICAqIGNvbnRleHRzIGluIEZpcmVmb3ggNCssIFNhZmFyaSwgYW5kIENocm9tZS5cXG4gICAqL1xcbmgxIHtcXG4gIGZvbnQtc2l6ZTogMmVtO1xcbiAgbWFyZ2luOiAwLjY3ZW0gMDsgfVxcblxcbi8qKlxcbiAgICogQWRkcmVzcyBzdHlsaW5nIG5vdCBwcmVzZW50IGluIElFIDgvOS5cXG4gICAqL1xcbm1hcmsge1xcbiAgYmFja2dyb3VuZDogI2ZmMDtcXG4gIGNvbG9yOiAjMDAwOyB9XFxuXFxuLyoqXFxuICAgKiBBZGRyZXNzIGluY29uc2lzdGVudCBhbmQgdmFyaWFibGUgZm9udCBzaXplIGluIGFsbCBicm93c2Vycy5cXG4gICAqL1xcbnNtYWxsIHtcXG4gIGZvbnQtc2l6ZTogODAlOyB9XFxuXFxuLyoqXFxuICAgKiBQcmV2ZW50IGBzdWJgIGFuZCBgc3VwYCBhZmZlY3RpbmcgYGxpbmUtaGVpZ2h0YCBpbiBhbGwgYnJvd3NlcnMuXFxuICAgKi9cXG5zdWIsXFxuc3VwIHtcXG4gIGZvbnQtc2l6ZTogNzUlO1xcbiAgbGluZS1oZWlnaHQ6IDA7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7IH1cXG5cXG5zdXAge1xcbiAgdG9wOiAtMC41ZW07IH1cXG5cXG5zdWIge1xcbiAgYm90dG9tOiAtMC4yNWVtOyB9XFxuXFxuLyogRW1iZWRkZWQgY29udGVudFxcbiAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG4vKipcXG4gICAqIFJlbW92ZSBib3JkZXIgd2hlbiBpbnNpZGUgYGFgIGVsZW1lbnQgaW4gSUUgOC85LzEwLlxcbiAgICovXFxuaW1nIHtcXG4gIGJvcmRlcjogMDsgfVxcblxcbi8qKlxcbiAgICogQ29ycmVjdCBvdmVyZmxvdyBub3QgaGlkZGVuIGluIElFIDkvMTAvMTEuXFxuICAgKi9cXG5zdmc6bm90KDpyb290KSB7XFxuICBvdmVyZmxvdzogaGlkZGVuOyB9XFxuXFxuLyogR3JvdXBpbmcgY29udGVudFxcbiAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG4vKipcXG4gICAqIEFkZHJlc3MgbWFyZ2luIG5vdCBwcmVzZW50IGluIElFIDgvOSBhbmQgU2FmYXJpLlxcbiAgICovXFxuZmlndXJlIHtcXG4gIG1hcmdpbjogMWVtIDQwcHg7IH1cXG5cXG4vKipcXG4gICAqIEFkZHJlc3MgZGlmZmVyZW5jZXMgYmV0d2VlbiBGaXJlZm94IGFuZCBvdGhlciBicm93c2Vycy5cXG4gICAqL1xcbmhyIHtcXG4gIGJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xcbiAgaGVpZ2h0OiAwOyB9XFxuXFxuLyoqXFxuICAgKiBDb250YWluIG92ZXJmbG93IGluIGFsbCBicm93c2Vycy5cXG4gICAqL1xcbnByZSB7XFxuICBvdmVyZmxvdzogYXV0bzsgfVxcblxcbi8qKlxcbiAgICogQWRkcmVzcyBvZGQgYGVtYC11bml0IGZvbnQgc2l6ZSByZW5kZXJpbmcgaW4gYWxsIGJyb3dzZXJzLlxcbiAgICovXFxuY29kZSxcXG5rYmQsXFxucHJlLFxcbnNhbXAge1xcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZSwgbW9ub3NwYWNlO1xcbiAgZm9udC1zaXplOiAxZW07IH1cXG5cXG4vKiBGb3Jtc1xcbiAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG4vKipcXG4gICAqIEtub3duIGxpbWl0YXRpb246IGJ5IGRlZmF1bHQsIENocm9tZSBhbmQgU2FmYXJpIG9uIE9TIFggYWxsb3cgdmVyeSBsaW1pdGVkXFxuICAgKiBzdHlsaW5nIG9mIGBzZWxlY3RgLCB1bmxlc3MgYSBgYm9yZGVyYCBwcm9wZXJ0eSBpcyBzZXQuXFxuICAgKi9cXG4vKipcXG4gICAqIDEuIENvcnJlY3QgY29sb3Igbm90IGJlaW5nIGluaGVyaXRlZC5cXG4gICAqICAgIEtub3duIGlzc3VlOiBhZmZlY3RzIGNvbG9yIG9mIGRpc2FibGVkIGVsZW1lbnRzLlxcbiAgICogMi4gQ29ycmVjdCBmb250IHByb3BlcnRpZXMgbm90IGJlaW5nIGluaGVyaXRlZC5cXG4gICAqIDMuIEFkZHJlc3MgbWFyZ2lucyBzZXQgZGlmZmVyZW50bHkgaW4gRmlyZWZveCA0KywgU2FmYXJpLCBhbmQgQ2hyb21lLlxcbiAgICovXFxuYnV0dG9uLFxcbmlucHV0LFxcbm9wdGdyb3VwLFxcbnNlbGVjdCxcXG50ZXh0YXJlYSB7XFxuICBjb2xvcjogaW5oZXJpdDtcXG4gIC8qIDEgKi9cXG4gIGZvbnQ6IGluaGVyaXQ7XFxuICAvKiAyICovXFxuICBtYXJnaW46IDA7XFxuICAvKiAzICovIH1cXG5cXG4vKipcXG4gICAqIEFkZHJlc3MgYG92ZXJmbG93YCBzZXQgdG8gYGhpZGRlbmAgaW4gSUUgOC85LzEwLzExLlxcbiAgICovXFxuYnV0dG9uIHtcXG4gIG92ZXJmbG93OiB2aXNpYmxlOyB9XFxuXFxuLyoqXFxuICAgKiBBZGRyZXNzIGluY29uc2lzdGVudCBgdGV4dC10cmFuc2Zvcm1gIGluaGVyaXRhbmNlIGZvciBgYnV0dG9uYCBhbmQgYHNlbGVjdGAuXFxuICAgKiBBbGwgb3RoZXIgZm9ybSBjb250cm9sIGVsZW1lbnRzIGRvIG5vdCBpbmhlcml0IGB0ZXh0LXRyYW5zZm9ybWAgdmFsdWVzLlxcbiAgICogQ29ycmVjdCBgYnV0dG9uYCBzdHlsZSBpbmhlcml0YW5jZSBpbiBGaXJlZm94LCBJRSA4LzkvMTAvMTEsIGFuZCBPcGVyYS5cXG4gICAqIENvcnJlY3QgYHNlbGVjdGAgc3R5bGUgaW5oZXJpdGFuY2UgaW4gRmlyZWZveC5cXG4gICAqL1xcbmJ1dHRvbixcXG5zZWxlY3Qge1xcbiAgdGV4dC10cmFuc2Zvcm06IG5vbmU7IH1cXG5cXG4vKipcXG4gICAqIDEuIEF2b2lkIHRoZSBXZWJLaXQgYnVnIGluIEFuZHJvaWQgNC4wLiogd2hlcmUgKDIpIGRlc3Ryb3lzIG5hdGl2ZSBgYXVkaW9gXFxuICAgKiAgICBhbmQgYHZpZGVvYCBjb250cm9scy5cXG4gICAqIDIuIENvcnJlY3QgaW5hYmlsaXR5IHRvIHN0eWxlIGNsaWNrYWJsZSBgaW5wdXRgIHR5cGVzIGluIGlPUy5cXG4gICAqIDMuIEltcHJvdmUgdXNhYmlsaXR5IGFuZCBjb25zaXN0ZW5jeSBvZiBjdXJzb3Igc3R5bGUgYmV0d2VlbiBpbWFnZS10eXBlXFxuICAgKiAgICBgaW5wdXRgIGFuZCBvdGhlcnMuXFxuICAgKi9cXG5idXR0b24sXFxuaHRtbCBpbnB1dFt0eXBlPVxcXCJidXR0b25cXFwiXSxcXG5pbnB1dFt0eXBlPVxcXCJyZXNldFxcXCJdLFxcbmlucHV0W3R5cGU9XFxcInN1Ym1pdFxcXCJdIHtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogYnV0dG9uO1xcbiAgLyogMiAqL1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgLyogMyAqLyB9XFxuXFxuLyoqXFxuICAgKiBSZS1zZXQgZGVmYXVsdCBjdXJzb3IgZm9yIGRpc2FibGVkIGVsZW1lbnRzLlxcbiAgICovXFxuYnV0dG9uW2Rpc2FibGVkXSxcXG5odG1sIGlucHV0W2Rpc2FibGVkXSB7XFxuICBjdXJzb3I6IG5vdC1hbGxvd2VkOyB9XFxuXFxuLyoqXFxuICAgKiBSZW1vdmUgaW5uZXIgcGFkZGluZyBhbmQgYm9yZGVyIGluIEZpcmVmb3ggNCsuXFxuICAgKi9cXG5idXR0b246Oi1tb3otZm9jdXMtaW5uZXIsXFxuaW5wdXQ6Oi1tb3otZm9jdXMtaW5uZXIge1xcbiAgYm9yZGVyOiAwO1xcbiAgcGFkZGluZzogMDsgfVxcblxcbi8qKlxcbiAgICogQWRkcmVzcyBGaXJlZm94IDQrIHNldHRpbmcgYGxpbmUtaGVpZ2h0YCBvbiBgaW5wdXRgIHVzaW5nIGAhaW1wb3J0YW50YCBpblxcbiAgICogdGhlIFVBIHN0eWxlc2hlZXQuXFxuICAgKi9cXG5pbnB1dCB7XFxuICBsaW5lLWhlaWdodDogbm9ybWFsOyB9XFxuXFxuLyoqXFxuICAgKiBJdCdzIHJlY29tbWVuZGVkIHRoYXQgeW91IGRvbid0IGF0dGVtcHQgdG8gc3R5bGUgdGhlc2UgZWxlbWVudHMuXFxuICAgKiBGaXJlZm94J3MgaW1wbGVtZW50YXRpb24gZG9lc24ndCByZXNwZWN0IGJveC1zaXppbmcsIHBhZGRpbmcsIG9yIHdpZHRoLlxcbiAgICpcXG4gICAqIDEuIEFkZHJlc3MgYm94IHNpemluZyBzZXQgdG8gYGNvbnRlbnQtYm94YCBpbiBJRSA4LzkvMTAuXFxuICAgKiAyLiBSZW1vdmUgZXhjZXNzIHBhZGRpbmcgaW4gSUUgOC85LzEwLlxcbiAgICovXFxuaW5wdXRbdHlwZT1cXFwiY2hlY2tib3hcXFwiXSxcXG5pbnB1dFt0eXBlPVxcXCJyYWRpb1xcXCJdIHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAvKiAxICovXFxuICBwYWRkaW5nOiAwO1xcbiAgLyogMiAqLyB9XFxuXFxuLyoqXFxuICAgKiBGaXggdGhlIGN1cnNvciBzdHlsZSBmb3IgQ2hyb21lJ3MgaW5jcmVtZW50L2RlY3JlbWVudCBidXR0b25zLiBGb3IgY2VydGFpblxcbiAgICogYGZvbnQtc2l6ZWAgdmFsdWVzIG9mIHRoZSBgaW5wdXRgLCBpdCBjYXVzZXMgdGhlIGN1cnNvciBzdHlsZSBvZiB0aGVcXG4gICAqIGRlY3JlbWVudCBidXR0b24gdG8gY2hhbmdlIGZyb20gYGRlZmF1bHRgIHRvIGB0ZXh0YC5cXG4gICAqL1xcbmlucHV0W3R5cGU9XFxcIm51bWJlclxcXCJdOjotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uLFxcbmlucHV0W3R5cGU9XFxcIm51bWJlclxcXCJdOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uIHtcXG4gIGhlaWdodDogYXV0bzsgfVxcblxcbi8qKlxcbiAgICogMS4gQWRkcmVzcyBgYXBwZWFyYW5jZWAgc2V0IHRvIGBzZWFyY2hmaWVsZGAgaW4gU2FmYXJpIGFuZCBDaHJvbWUuXFxuICAgKiAyLiBBZGRyZXNzIGBib3gtc2l6aW5nYCBzZXQgdG8gYGJvcmRlci1ib3hgIGluIFNhZmFyaSBhbmQgQ2hyb21lLlxcbiAgICovXFxuaW5wdXRbdHlwZT1cXFwic2VhcmNoXFxcIl0ge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiB0ZXh0ZmllbGQ7XFxuICAvKiAxICovXFxuICBib3gtc2l6aW5nOiBjb250ZW50LWJveDtcXG4gIC8qIDIgKi8gfVxcblxcbi8qKlxcbiAgICogUmVtb3ZlIGlubmVyIHBhZGRpbmcgYW5kIHNlYXJjaCBjYW5jZWwgYnV0dG9uIGluIFNhZmFyaSBhbmQgQ2hyb21lIG9uIE9TIFguXFxuICAgKiBTYWZhcmkgKGJ1dCBub3QgQ2hyb21lKSBjbGlwcyB0aGUgY2FuY2VsIGJ1dHRvbiB3aGVuIHRoZSBzZWFyY2ggaW5wdXQgaGFzXFxuICAgKiBwYWRkaW5nIChhbmQgYHRleHRmaWVsZGAgYXBwZWFyYW5jZSkuXFxuICAgKi9cXG5pbnB1dFt0eXBlPVxcXCJzZWFyY2hcXFwiXTo6LXdlYmtpdC1zZWFyY2gtY2FuY2VsLWJ1dHRvbixcXG5pbnB1dFt0eXBlPVxcXCJzZWFyY2hcXFwiXTo6LXdlYmtpdC1zZWFyY2gtZGVjb3JhdGlvbiB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7IH1cXG5cXG4vKipcXG4gICAqIERlZmluZSBjb25zaXN0ZW50IGJvcmRlciwgbWFyZ2luLCBhbmQgcGFkZGluZy5cXG4gICAqIFtOT1RFXSBXZSBkb24ndCBlbmFibGUgdGhpcyBydWxlc2V0IGluIEZvdW5kYXRpb24sIGJlY2F1c2Ugd2Ugd2FudCB0aGUgPGZpZWxkc2V0PiBlbGVtZW50IHRvIGhhdmUgcGxhaW4gc3R5bGluZy5cXG4gICAqL1xcbi8qIGZpZWxkc2V0IHtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgI2MwYzBjMDtcXG4gICAgbWFyZ2luOiAwIDJweDtcXG4gICAgcGFkZGluZzogMC4zNWVtIDAuNjI1ZW0gMC43NWVtO1xcbiAgfSAqL1xcbi8qKlxcbiAgICogMS4gQ29ycmVjdCBgY29sb3JgIG5vdCBiZWluZyBpbmhlcml0ZWQgaW4gSUUgOC85LzEwLzExLlxcbiAgICogMi4gUmVtb3ZlIHBhZGRpbmcgc28gcGVvcGxlIGFyZW4ndCBjYXVnaHQgb3V0IGlmIHRoZXkgemVybyBvdXQgZmllbGRzZXRzLlxcbiAgICovXFxubGVnZW5kIHtcXG4gIGJvcmRlcjogMDtcXG4gIC8qIDEgKi9cXG4gIHBhZGRpbmc6IDA7XFxuICAvKiAyICovIH1cXG5cXG4vKipcXG4gICAqIFJlbW92ZSBkZWZhdWx0IHZlcnRpY2FsIHNjcm9sbGJhciBpbiBJRSA4LzkvMTAvMTEuXFxuICAgKi9cXG50ZXh0YXJlYSB7XFxuICBvdmVyZmxvdzogYXV0bzsgfVxcblxcbi8qKlxcbiAgICogRG9uJ3QgaW5oZXJpdCB0aGUgYGZvbnQtd2VpZ2h0YCAoYXBwbGllZCBieSBhIHJ1bGUgYWJvdmUpLlxcbiAgICogTk9URTogdGhlIGRlZmF1bHQgY2Fubm90IHNhZmVseSBiZSBjaGFuZ2VkIGluIENocm9tZSBhbmQgU2FmYXJpIG9uIE9TIFguXFxuICAgKi9cXG5vcHRncm91cCB7XFxuICBmb250LXdlaWdodDogYm9sZDsgfVxcblxcbi8qIFRhYmxlc1xcbiAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG4vKipcXG4gICAqIFJlbW92ZSBtb3N0IHNwYWNpbmcgYmV0d2VlbiB0YWJsZSBjZWxscy5cXG4gICAqL1xcbnRhYmxlIHtcXG4gIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxuICBib3JkZXItc3BhY2luZzogMDsgfVxcblxcbnRkLFxcbnRoIHtcXG4gIHBhZGRpbmc6IDA7IH1cXG5cXG4uZm91bmRhdGlvbi1tcSB7XFxuICBmb250LWZhbWlseTogXFxcInNtYWxsPTBlbSZtZWRpdW09NDBlbSZsYXJnZT02NGVtJnhsYXJnZT03NWVtJnh4bGFyZ2U9OTBlbVxcXCI7IH1cXG5cXG5odG1sIHtcXG4gIGZvbnQtc2l6ZTogMTAwJTtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IH1cXG5cXG4qLFxcbio6OmJlZm9yZSxcXG4qOjphZnRlciB7XFxuICBib3gtc2l6aW5nOiBpbmhlcml0OyB9XFxuXFxuYm9keSB7XFxuICBwYWRkaW5nOiAwO1xcbiAgbWFyZ2luOiAwO1xcbiAgZm9udC1mYW1pbHk6IFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsIEhlbHZldGljYSwgUm9ib3RvLCBBcmlhbCwgc2Fucy1zZXJpZjtcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxuICBsaW5lLWhlaWdodDogMS41O1xcbiAgY29sb3I6ICMwYTBhMGE7XFxuICBiYWNrZ3JvdW5kOiAjZmVmZWZlO1xcbiAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XFxuICAtbW96LW9zeC1mb250LXNtb290aGluZzogZ3JheXNjYWxlOyB9XFxuXFxuaW1nIHtcXG4gIG1heC13aWR0aDogMTAwJTtcXG4gIGhlaWdodDogYXV0bztcXG4gIC1tcy1pbnRlcnBvbGF0aW9uLW1vZGU6IGJpY3ViaWM7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOyB9XFxuXFxudGV4dGFyZWEge1xcbiAgaGVpZ2h0OiBhdXRvO1xcbiAgbWluLWhlaWdodDogNTBweDtcXG4gIGJvcmRlci1yYWRpdXM6IDA7IH1cXG5cXG5zZWxlY3Qge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBib3JkZXItcmFkaXVzOiAwOyB9XFxuXFxuI21hcF9jYW52YXMgaW1nLFxcbiNtYXBfY2FudmFzIGVtYmVkLFxcbiNtYXBfY2FudmFzIG9iamVjdCxcXG4ubWFwX2NhbnZhcyBpbWcsXFxuLm1hcF9jYW52YXMgZW1iZWQsXFxuLm1hcF9jYW52YXMgb2JqZWN0LFxcbi5tcWEtZGlzcGxheSBpbWcsXFxuLm1xYS1kaXNwbGF5IGVtYmVkLFxcbi5tcWEtZGlzcGxheSBvYmplY3Qge1xcbiAgbWF4LXdpZHRoOiBub25lICFpbXBvcnRhbnQ7IH1cXG5cXG5idXR0b24ge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcbiAgLW1vei1hcHBlYXJhbmNlOiBub25lO1xcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxuICBwYWRkaW5nOiAwO1xcbiAgYm9yZGVyOiAwO1xcbiAgYm9yZGVyLXJhZGl1czogMDtcXG4gIGxpbmUtaGVpZ2h0OiAxOyB9XFxuICBbZGF0YS13aGF0aW5wdXQ9J21vdXNlJ10gYnV0dG9uIHtcXG4gICAgb3V0bGluZTogMDsgfVxcblxcbi5pcy12aXNpYmxlIHtcXG4gIGRpc3BsYXk6IGJsb2NrICFpbXBvcnRhbnQ7IH1cXG5cXG4uaXMtaGlkZGVuIHtcXG4gIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDsgfVxcblxcbi5yb3cge1xcbiAgbWF4LXdpZHRoOiA3NXJlbTtcXG4gIG1hcmdpbi1sZWZ0OiBhdXRvO1xcbiAgbWFyZ2luLXJpZ2h0OiBhdXRvOyB9XFxuICAucm93OjpiZWZvcmUsIC5yb3c6OmFmdGVyIHtcXG4gICAgY29udGVudDogJyAnO1xcbiAgICBkaXNwbGF5OiB0YWJsZTsgfVxcbiAgLnJvdzo6YWZ0ZXIge1xcbiAgICBjbGVhcjogYm90aDsgfVxcbiAgLnJvdy5jb2xsYXBzZSA+IC5jb2x1bW4sIC5yb3cuY29sbGFwc2UgPiAuY29sdW1ucyB7XFxuICAgIHBhZGRpbmctbGVmdDogMDtcXG4gICAgcGFkZGluZy1yaWdodDogMDsgfVxcbiAgLnJvdyAucm93IHtcXG4gICAgbWF4LXdpZHRoOiBub25lO1xcbiAgICBtYXJnaW4tbGVmdDogLTAuNjI1cmVtO1xcbiAgICBtYXJnaW4tcmlnaHQ6IC0wLjYyNXJlbTsgfVxcbiAgICBAbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA0MGVtKSB7XFxuICAgICAgLnJvdyAucm93IHtcXG4gICAgICAgIG1hcmdpbi1sZWZ0OiAtMC45Mzc1cmVtO1xcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAtMC45Mzc1cmVtOyB9IH1cXG4gICAgLnJvdyAucm93LmNvbGxhcHNlIHtcXG4gICAgICBtYXJnaW4tbGVmdDogMDtcXG4gICAgICBtYXJnaW4tcmlnaHQ6IDA7IH1cXG4gIC5yb3cuZXhwYW5kZWQge1xcbiAgICBtYXgtd2lkdGg6IG5vbmU7IH1cXG4gICAgLnJvdy5leHBhbmRlZCAucm93IHtcXG4gICAgICBtYXJnaW4tbGVmdDogYXV0bztcXG4gICAgICBtYXJnaW4tcmlnaHQ6IGF1dG87IH1cXG5cXG4uY29sdW1uLCAuY29sdW1ucyB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgcGFkZGluZy1sZWZ0OiAwLjYyNXJlbTtcXG4gIHBhZGRpbmctcmlnaHQ6IDAuNjI1cmVtOyB9XFxuICBAbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA0MGVtKSB7XFxuICAgIC5jb2x1bW4sIC5jb2x1bW5zIHtcXG4gICAgICBwYWRkaW5nLWxlZnQ6IDAuOTM3NXJlbTtcXG4gICAgICBwYWRkaW5nLXJpZ2h0OiAwLjkzNzVyZW07IH0gfVxcbiAgLmNvbHVtbjpsYXN0LWNoaWxkOm5vdCg6Zmlyc3QtY2hpbGQpLCAuY29sdW1uczpsYXN0LWNoaWxkOm5vdCg6Zmlyc3QtY2hpbGQpIHtcXG4gICAgZmxvYXQ6IHJpZ2h0OyB9XFxuICAuY29sdW1uLmVuZDpsYXN0LWNoaWxkOmxhc3QtY2hpbGQsIC5lbmQuY29sdW1uczpsYXN0LWNoaWxkOmxhc3QtY2hpbGQge1xcbiAgICBmbG9hdDogbGVmdDsgfVxcblxcbi5jb2x1bW4ucm93LnJvdywgLnJvdy5yb3cuY29sdW1ucyB7XFxuICBmbG9hdDogbm9uZTsgfVxcbiAgLnJvdyAuY29sdW1uLnJvdy5yb3csIC5yb3cgLnJvdy5yb3cuY29sdW1ucyB7XFxuICAgIHBhZGRpbmctbGVmdDogMDtcXG4gICAgcGFkZGluZy1yaWdodDogMDtcXG4gICAgbWFyZ2luLWxlZnQ6IDA7XFxuICAgIG1hcmdpbi1yaWdodDogMDsgfVxcblxcbi5zbWFsbC0xIHtcXG4gIHdpZHRoOiA4LjMzMzMzJTsgfVxcblxcbi5zbWFsbC1wdXNoLTEge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgbGVmdDogOC4zMzMzMyU7IH1cXG5cXG4uc21hbGwtcHVsbC0xIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGxlZnQ6IC04LjMzMzMzJTsgfVxcblxcbi5zbWFsbC1vZmZzZXQtMCB7XFxuICBtYXJnaW4tbGVmdDogMCU7IH1cXG5cXG4uc21hbGwtMiB7XFxuICB3aWR0aDogMTYuNjY2NjclOyB9XFxuXFxuLnNtYWxsLXB1c2gtMiB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBsZWZ0OiAxNi42NjY2NyU7IH1cXG5cXG4uc21hbGwtcHVsbC0yIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGxlZnQ6IC0xNi42NjY2NyU7IH1cXG5cXG4uc21hbGwtb2Zmc2V0LTEge1xcbiAgbWFyZ2luLWxlZnQ6IDguMzMzMzMlOyB9XFxuXFxuLnNtYWxsLTMge1xcbiAgd2lkdGg6IDI1JTsgfVxcblxcbi5zbWFsbC1wdXNoLTMge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgbGVmdDogMjUlOyB9XFxuXFxuLnNtYWxsLXB1bGwtMyB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBsZWZ0OiAtMjUlOyB9XFxuXFxuLnNtYWxsLW9mZnNldC0yIHtcXG4gIG1hcmdpbi1sZWZ0OiAxNi42NjY2NyU7IH1cXG5cXG4uc21hbGwtNCB7XFxuICB3aWR0aDogMzMuMzMzMzMlOyB9XFxuXFxuLnNtYWxsLXB1c2gtNCB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBsZWZ0OiAzMy4zMzMzMyU7IH1cXG5cXG4uc21hbGwtcHVsbC00IHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGxlZnQ6IC0zMy4zMzMzMyU7IH1cXG5cXG4uc21hbGwtb2Zmc2V0LTMge1xcbiAgbWFyZ2luLWxlZnQ6IDI1JTsgfVxcblxcbi5zbWFsbC01IHtcXG4gIHdpZHRoOiA0MS42NjY2NyU7IH1cXG5cXG4uc21hbGwtcHVzaC01IHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGxlZnQ6IDQxLjY2NjY3JTsgfVxcblxcbi5zbWFsbC1wdWxsLTUge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgbGVmdDogLTQxLjY2NjY3JTsgfVxcblxcbi5zbWFsbC1vZmZzZXQtNCB7XFxuICBtYXJnaW4tbGVmdDogMzMuMzMzMzMlOyB9XFxuXFxuLnNtYWxsLTYge1xcbiAgd2lkdGg6IDUwJTsgfVxcblxcbi5zbWFsbC1wdXNoLTYge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgbGVmdDogNTAlOyB9XFxuXFxuLnNtYWxsLXB1bGwtNiB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBsZWZ0OiAtNTAlOyB9XFxuXFxuLnNtYWxsLW9mZnNldC01IHtcXG4gIG1hcmdpbi1sZWZ0OiA0MS42NjY2NyU7IH1cXG5cXG4uc21hbGwtNyB7XFxuICB3aWR0aDogNTguMzMzMzMlOyB9XFxuXFxuLnNtYWxsLXB1c2gtNyB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBsZWZ0OiA1OC4zMzMzMyU7IH1cXG5cXG4uc21hbGwtcHVsbC03IHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGxlZnQ6IC01OC4zMzMzMyU7IH1cXG5cXG4uc21hbGwtb2Zmc2V0LTYge1xcbiAgbWFyZ2luLWxlZnQ6IDUwJTsgfVxcblxcbi5zbWFsbC04IHtcXG4gIHdpZHRoOiA2Ni42NjY2NyU7IH1cXG5cXG4uc21hbGwtcHVzaC04IHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGxlZnQ6IDY2LjY2NjY3JTsgfVxcblxcbi5zbWFsbC1wdWxsLTgge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgbGVmdDogLTY2LjY2NjY3JTsgfVxcblxcbi5zbWFsbC1vZmZzZXQtNyB7XFxuICBtYXJnaW4tbGVmdDogNTguMzMzMzMlOyB9XFxuXFxuLnNtYWxsLTkge1xcbiAgd2lkdGg6IDc1JTsgfVxcblxcbi5zbWFsbC1wdXNoLTkge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgbGVmdDogNzUlOyB9XFxuXFxuLnNtYWxsLXB1bGwtOSB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBsZWZ0OiAtNzUlOyB9XFxuXFxuLnNtYWxsLW9mZnNldC04IHtcXG4gIG1hcmdpbi1sZWZ0OiA2Ni42NjY2NyU7IH1cXG5cXG4uc21hbGwtMTAge1xcbiAgd2lkdGg6IDgzLjMzMzMzJTsgfVxcblxcbi5zbWFsbC1wdXNoLTEwIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGxlZnQ6IDgzLjMzMzMzJTsgfVxcblxcbi5zbWFsbC1wdWxsLTEwIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGxlZnQ6IC04My4zMzMzMyU7IH1cXG5cXG4uc21hbGwtb2Zmc2V0LTkge1xcbiAgbWFyZ2luLWxlZnQ6IDc1JTsgfVxcblxcbi5zbWFsbC0xMSB7XFxuICB3aWR0aDogOTEuNjY2NjclOyB9XFxuXFxuLnNtYWxsLXB1c2gtMTEge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgbGVmdDogOTEuNjY2NjclOyB9XFxuXFxuLnNtYWxsLXB1bGwtMTEge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgbGVmdDogLTkxLjY2NjY3JTsgfVxcblxcbi5zbWFsbC1vZmZzZXQtMTAge1xcbiAgbWFyZ2luLWxlZnQ6IDgzLjMzMzMzJTsgfVxcblxcbi5zbWFsbC0xMiB7XFxuICB3aWR0aDogMTAwJTsgfVxcblxcbi5zbWFsbC1vZmZzZXQtMTEge1xcbiAgbWFyZ2luLWxlZnQ6IDkxLjY2NjY3JTsgfVxcblxcbi5zbWFsbC11cC0xID4gLmNvbHVtbiwgLnNtYWxsLXVwLTEgPiAuY29sdW1ucyB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGZsb2F0OiBsZWZ0OyB9XFxuICAuc21hbGwtdXAtMSA+IC5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLCAuc21hbGwtdXAtMSA+IC5jb2x1bW5zOm50aC1vZi10eXBlKDFuKSB7XFxuICAgIGNsZWFyOiBub25lOyB9XFxuICAuc21hbGwtdXAtMSA+IC5jb2x1bW46bnRoLW9mLXR5cGUoMW4rMSksIC5zbWFsbC11cC0xID4gLmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4rMSkge1xcbiAgICBjbGVhcjogYm90aDsgfVxcbiAgLnNtYWxsLXVwLTEgPiAuY29sdW1uOmxhc3QtY2hpbGQsIC5zbWFsbC11cC0xID4gLmNvbHVtbnM6bGFzdC1jaGlsZCB7XFxuICAgIGZsb2F0OiBsZWZ0OyB9XFxuXFxuLnNtYWxsLXVwLTIgPiAuY29sdW1uLCAuc21hbGwtdXAtMiA+IC5jb2x1bW5zIHtcXG4gIHdpZHRoOiA1MCU7XFxuICBmbG9hdDogbGVmdDsgfVxcbiAgLnNtYWxsLXVwLTIgPiAuY29sdW1uOm50aC1vZi10eXBlKDFuKSwgLnNtYWxsLXVwLTIgPiAuY29sdW1uczpudGgtb2YtdHlwZSgxbikge1xcbiAgICBjbGVhcjogbm9uZTsgfVxcbiAgLnNtYWxsLXVwLTIgPiAuY29sdW1uOm50aC1vZi10eXBlKDJuKzEpLCAuc21hbGwtdXAtMiA+IC5jb2x1bW5zOm50aC1vZi10eXBlKDJuKzEpIHtcXG4gICAgY2xlYXI6IGJvdGg7IH1cXG4gIC5zbWFsbC11cC0yID4gLmNvbHVtbjpsYXN0LWNoaWxkLCAuc21hbGwtdXAtMiA+IC5jb2x1bW5zOmxhc3QtY2hpbGQge1xcbiAgICBmbG9hdDogbGVmdDsgfVxcblxcbi5zbWFsbC11cC0zID4gLmNvbHVtbiwgLnNtYWxsLXVwLTMgPiAuY29sdW1ucyB7XFxuICB3aWR0aDogMzMuMzMzMzMlO1xcbiAgZmxvYXQ6IGxlZnQ7IH1cXG4gIC5zbWFsbC11cC0zID4gLmNvbHVtbjpudGgtb2YtdHlwZSgxbiksIC5zbWFsbC11cC0zID4gLmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pIHtcXG4gICAgY2xlYXI6IG5vbmU7IH1cXG4gIC5zbWFsbC11cC0zID4gLmNvbHVtbjpudGgtb2YtdHlwZSgzbisxKSwgLnNtYWxsLXVwLTMgPiAuY29sdW1uczpudGgtb2YtdHlwZSgzbisxKSB7XFxuICAgIGNsZWFyOiBib3RoOyB9XFxuICAuc21hbGwtdXAtMyA+IC5jb2x1bW46bGFzdC1jaGlsZCwgLnNtYWxsLXVwLTMgPiAuY29sdW1uczpsYXN0LWNoaWxkIHtcXG4gICAgZmxvYXQ6IGxlZnQ7IH1cXG5cXG4uc21hbGwtdXAtNCA+IC5jb2x1bW4sIC5zbWFsbC11cC00ID4gLmNvbHVtbnMge1xcbiAgd2lkdGg6IDI1JTtcXG4gIGZsb2F0OiBsZWZ0OyB9XFxuICAuc21hbGwtdXAtNCA+IC5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLCAuc21hbGwtdXAtNCA+IC5jb2x1bW5zOm50aC1vZi10eXBlKDFuKSB7XFxuICAgIGNsZWFyOiBub25lOyB9XFxuICAuc21hbGwtdXAtNCA+IC5jb2x1bW46bnRoLW9mLXR5cGUoNG4rMSksIC5zbWFsbC11cC00ID4gLmNvbHVtbnM6bnRoLW9mLXR5cGUoNG4rMSkge1xcbiAgICBjbGVhcjogYm90aDsgfVxcbiAgLnNtYWxsLXVwLTQgPiAuY29sdW1uOmxhc3QtY2hpbGQsIC5zbWFsbC11cC00ID4gLmNvbHVtbnM6bGFzdC1jaGlsZCB7XFxuICAgIGZsb2F0OiBsZWZ0OyB9XFxuXFxuLnNtYWxsLXVwLTUgPiAuY29sdW1uLCAuc21hbGwtdXAtNSA+IC5jb2x1bW5zIHtcXG4gIHdpZHRoOiAyMCU7XFxuICBmbG9hdDogbGVmdDsgfVxcbiAgLnNtYWxsLXVwLTUgPiAuY29sdW1uOm50aC1vZi10eXBlKDFuKSwgLnNtYWxsLXVwLTUgPiAuY29sdW1uczpudGgtb2YtdHlwZSgxbikge1xcbiAgICBjbGVhcjogbm9uZTsgfVxcbiAgLnNtYWxsLXVwLTUgPiAuY29sdW1uOm50aC1vZi10eXBlKDVuKzEpLCAuc21hbGwtdXAtNSA+IC5jb2x1bW5zOm50aC1vZi10eXBlKDVuKzEpIHtcXG4gICAgY2xlYXI6IGJvdGg7IH1cXG4gIC5zbWFsbC11cC01ID4gLmNvbHVtbjpsYXN0LWNoaWxkLCAuc21hbGwtdXAtNSA+IC5jb2x1bW5zOmxhc3QtY2hpbGQge1xcbiAgICBmbG9hdDogbGVmdDsgfVxcblxcbi5zbWFsbC11cC02ID4gLmNvbHVtbiwgLnNtYWxsLXVwLTYgPiAuY29sdW1ucyB7XFxuICB3aWR0aDogMTYuNjY2NjclO1xcbiAgZmxvYXQ6IGxlZnQ7IH1cXG4gIC5zbWFsbC11cC02ID4gLmNvbHVtbjpudGgtb2YtdHlwZSgxbiksIC5zbWFsbC11cC02ID4gLmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pIHtcXG4gICAgY2xlYXI6IG5vbmU7IH1cXG4gIC5zbWFsbC11cC02ID4gLmNvbHVtbjpudGgtb2YtdHlwZSg2bisxKSwgLnNtYWxsLXVwLTYgPiAuY29sdW1uczpudGgtb2YtdHlwZSg2bisxKSB7XFxuICAgIGNsZWFyOiBib3RoOyB9XFxuICAuc21hbGwtdXAtNiA+IC5jb2x1bW46bGFzdC1jaGlsZCwgLnNtYWxsLXVwLTYgPiAuY29sdW1uczpsYXN0LWNoaWxkIHtcXG4gICAgZmxvYXQ6IGxlZnQ7IH1cXG5cXG4uc21hbGwtdXAtNyA+IC5jb2x1bW4sIC5zbWFsbC11cC03ID4gLmNvbHVtbnMge1xcbiAgd2lkdGg6IDE0LjI4NTcxJTtcXG4gIGZsb2F0OiBsZWZ0OyB9XFxuICAuc21hbGwtdXAtNyA+IC5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLCAuc21hbGwtdXAtNyA+IC5jb2x1bW5zOm50aC1vZi10eXBlKDFuKSB7XFxuICAgIGNsZWFyOiBub25lOyB9XFxuICAuc21hbGwtdXAtNyA+IC5jb2x1bW46bnRoLW9mLXR5cGUoN24rMSksIC5zbWFsbC11cC03ID4gLmNvbHVtbnM6bnRoLW9mLXR5cGUoN24rMSkge1xcbiAgICBjbGVhcjogYm90aDsgfVxcbiAgLnNtYWxsLXVwLTcgPiAuY29sdW1uOmxhc3QtY2hpbGQsIC5zbWFsbC11cC03ID4gLmNvbHVtbnM6bGFzdC1jaGlsZCB7XFxuICAgIGZsb2F0OiBsZWZ0OyB9XFxuXFxuLnNtYWxsLXVwLTggPiAuY29sdW1uLCAuc21hbGwtdXAtOCA+IC5jb2x1bW5zIHtcXG4gIHdpZHRoOiAxMi41JTtcXG4gIGZsb2F0OiBsZWZ0OyB9XFxuICAuc21hbGwtdXAtOCA+IC5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLCAuc21hbGwtdXAtOCA+IC5jb2x1bW5zOm50aC1vZi10eXBlKDFuKSB7XFxuICAgIGNsZWFyOiBub25lOyB9XFxuICAuc21hbGwtdXAtOCA+IC5jb2x1bW46bnRoLW9mLXR5cGUoOG4rMSksIC5zbWFsbC11cC04ID4gLmNvbHVtbnM6bnRoLW9mLXR5cGUoOG4rMSkge1xcbiAgICBjbGVhcjogYm90aDsgfVxcbiAgLnNtYWxsLXVwLTggPiAuY29sdW1uOmxhc3QtY2hpbGQsIC5zbWFsbC11cC04ID4gLmNvbHVtbnM6bGFzdC1jaGlsZCB7XFxuICAgIGZsb2F0OiBsZWZ0OyB9XFxuXFxuLnNtYWxsLWNvbGxhcHNlID4gLmNvbHVtbiwgLnNtYWxsLWNvbGxhcHNlID4gLmNvbHVtbnMge1xcbiAgcGFkZGluZy1sZWZ0OiAwO1xcbiAgcGFkZGluZy1yaWdodDogMDsgfVxcblxcbi5zbWFsbC1jb2xsYXBzZSAucm93LFxcbi5leHBhbmRlZC5yb3cgLnNtYWxsLWNvbGxhcHNlLnJvdyB7XFxuICBtYXJnaW4tbGVmdDogMDtcXG4gIG1hcmdpbi1yaWdodDogMDsgfVxcblxcbi5zbWFsbC11bmNvbGxhcHNlID4gLmNvbHVtbiwgLnNtYWxsLXVuY29sbGFwc2UgPiAuY29sdW1ucyB7XFxuICBwYWRkaW5nLWxlZnQ6IDAuNjI1cmVtO1xcbiAgcGFkZGluZy1yaWdodDogMC42MjVyZW07IH1cXG5cXG4uc21hbGwtY2VudGVyZWQge1xcbiAgZmxvYXQ6IG5vbmU7XFxuICBtYXJnaW4tbGVmdDogYXV0bztcXG4gIG1hcmdpbi1yaWdodDogYXV0bzsgfVxcblxcbi5zbWFsbC11bmNlbnRlcmVkLFxcbi5zbWFsbC1wdXNoLTAsXFxuLnNtYWxsLXB1bGwtMCB7XFxuICBwb3NpdGlvbjogc3RhdGljO1xcbiAgbWFyZ2luLWxlZnQ6IDA7XFxuICBtYXJnaW4tcmlnaHQ6IDA7XFxuICBmbG9hdDogbGVmdDsgfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDQwZW0pIHtcXG4gIC5tZWRpdW0tMSB7XFxuICAgIHdpZHRoOiA4LjMzMzMzJTsgfVxcbiAgLm1lZGl1bS1wdXNoLTEge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGxlZnQ6IDguMzMzMzMlOyB9XFxuICAubWVkaXVtLXB1bGwtMSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgbGVmdDogLTguMzMzMzMlOyB9XFxuICAubWVkaXVtLW9mZnNldC0wIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDAlOyB9XFxuICAubWVkaXVtLTIge1xcbiAgICB3aWR0aDogMTYuNjY2NjclOyB9XFxuICAubWVkaXVtLXB1c2gtMiB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgbGVmdDogMTYuNjY2NjclOyB9XFxuICAubWVkaXVtLXB1bGwtMiB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgbGVmdDogLTE2LjY2NjY3JTsgfVxcbiAgLm1lZGl1bS1vZmZzZXQtMSB7XFxuICAgIG1hcmdpbi1sZWZ0OiA4LjMzMzMzJTsgfVxcbiAgLm1lZGl1bS0zIHtcXG4gICAgd2lkdGg6IDI1JTsgfVxcbiAgLm1lZGl1bS1wdXNoLTMge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGxlZnQ6IDI1JTsgfVxcbiAgLm1lZGl1bS1wdWxsLTMge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGxlZnQ6IC0yNSU7IH1cXG4gIC5tZWRpdW0tb2Zmc2V0LTIge1xcbiAgICBtYXJnaW4tbGVmdDogMTYuNjY2NjclOyB9XFxuICAubWVkaXVtLTQge1xcbiAgICB3aWR0aDogMzMuMzMzMzMlOyB9XFxuICAubWVkaXVtLXB1c2gtNCB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgbGVmdDogMzMuMzMzMzMlOyB9XFxuICAubWVkaXVtLXB1bGwtNCB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgbGVmdDogLTMzLjMzMzMzJTsgfVxcbiAgLm1lZGl1bS1vZmZzZXQtMyB7XFxuICAgIG1hcmdpbi1sZWZ0OiAyNSU7IH1cXG4gIC5tZWRpdW0tNSB7XFxuICAgIHdpZHRoOiA0MS42NjY2NyU7IH1cXG4gIC5tZWRpdW0tcHVzaC01IHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBsZWZ0OiA0MS42NjY2NyU7IH1cXG4gIC5tZWRpdW0tcHVsbC01IHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBsZWZ0OiAtNDEuNjY2NjclOyB9XFxuICAubWVkaXVtLW9mZnNldC00IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDMzLjMzMzMzJTsgfVxcbiAgLm1lZGl1bS02IHtcXG4gICAgd2lkdGg6IDUwJTsgfVxcbiAgLm1lZGl1bS1wdXNoLTYge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGxlZnQ6IDUwJTsgfVxcbiAgLm1lZGl1bS1wdWxsLTYge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGxlZnQ6IC01MCU7IH1cXG4gIC5tZWRpdW0tb2Zmc2V0LTUge1xcbiAgICBtYXJnaW4tbGVmdDogNDEuNjY2NjclOyB9XFxuICAubWVkaXVtLTcge1xcbiAgICB3aWR0aDogNTguMzMzMzMlOyB9XFxuICAubWVkaXVtLXB1c2gtNyB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgbGVmdDogNTguMzMzMzMlOyB9XFxuICAubWVkaXVtLXB1bGwtNyB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgbGVmdDogLTU4LjMzMzMzJTsgfVxcbiAgLm1lZGl1bS1vZmZzZXQtNiB7XFxuICAgIG1hcmdpbi1sZWZ0OiA1MCU7IH1cXG4gIC5tZWRpdW0tOCB7XFxuICAgIHdpZHRoOiA2Ni42NjY2NyU7IH1cXG4gIC5tZWRpdW0tcHVzaC04IHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBsZWZ0OiA2Ni42NjY2NyU7IH1cXG4gIC5tZWRpdW0tcHVsbC04IHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBsZWZ0OiAtNjYuNjY2NjclOyB9XFxuICAubWVkaXVtLW9mZnNldC03IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDU4LjMzMzMzJTsgfVxcbiAgLm1lZGl1bS05IHtcXG4gICAgd2lkdGg6IDc1JTsgfVxcbiAgLm1lZGl1bS1wdXNoLTkge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGxlZnQ6IDc1JTsgfVxcbiAgLm1lZGl1bS1wdWxsLTkge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGxlZnQ6IC03NSU7IH1cXG4gIC5tZWRpdW0tb2Zmc2V0LTgge1xcbiAgICBtYXJnaW4tbGVmdDogNjYuNjY2NjclOyB9XFxuICAubWVkaXVtLTEwIHtcXG4gICAgd2lkdGg6IDgzLjMzMzMzJTsgfVxcbiAgLm1lZGl1bS1wdXNoLTEwIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBsZWZ0OiA4My4zMzMzMyU7IH1cXG4gIC5tZWRpdW0tcHVsbC0xMCB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgbGVmdDogLTgzLjMzMzMzJTsgfVxcbiAgLm1lZGl1bS1vZmZzZXQtOSB7XFxuICAgIG1hcmdpbi1sZWZ0OiA3NSU7IH1cXG4gIC5tZWRpdW0tMTEge1xcbiAgICB3aWR0aDogOTEuNjY2NjclOyB9XFxuICAubWVkaXVtLXB1c2gtMTEge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGxlZnQ6IDkxLjY2NjY3JTsgfVxcbiAgLm1lZGl1bS1wdWxsLTExIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBsZWZ0OiAtOTEuNjY2NjclOyB9XFxuICAubWVkaXVtLW9mZnNldC0xMCB7XFxuICAgIG1hcmdpbi1sZWZ0OiA4My4zMzMzMyU7IH1cXG4gIC5tZWRpdW0tMTIge1xcbiAgICB3aWR0aDogMTAwJTsgfVxcbiAgLm1lZGl1bS1vZmZzZXQtMTEge1xcbiAgICBtYXJnaW4tbGVmdDogOTEuNjY2NjclOyB9XFxuICAubWVkaXVtLXVwLTEgPiAuY29sdW1uLCAubWVkaXVtLXVwLTEgPiAuY29sdW1ucyB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBmbG9hdDogbGVmdDsgfVxcbiAgICAubWVkaXVtLXVwLTEgPiAuY29sdW1uOm50aC1vZi10eXBlKDFuKSwgLm1lZGl1bS11cC0xID4gLmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pIHtcXG4gICAgICBjbGVhcjogbm9uZTsgfVxcbiAgICAubWVkaXVtLXVwLTEgPiAuY29sdW1uOm50aC1vZi10eXBlKDFuKzEpLCAubWVkaXVtLXVwLTEgPiAuY29sdW1uczpudGgtb2YtdHlwZSgxbisxKSB7XFxuICAgICAgY2xlYXI6IGJvdGg7IH1cXG4gICAgLm1lZGl1bS11cC0xID4gLmNvbHVtbjpsYXN0LWNoaWxkLCAubWVkaXVtLXVwLTEgPiAuY29sdW1uczpsYXN0LWNoaWxkIHtcXG4gICAgICBmbG9hdDogbGVmdDsgfVxcbiAgLm1lZGl1bS11cC0yID4gLmNvbHVtbiwgLm1lZGl1bS11cC0yID4gLmNvbHVtbnMge1xcbiAgICB3aWR0aDogNTAlO1xcbiAgICBmbG9hdDogbGVmdDsgfVxcbiAgICAubWVkaXVtLXVwLTIgPiAuY29sdW1uOm50aC1vZi10eXBlKDFuKSwgLm1lZGl1bS11cC0yID4gLmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pIHtcXG4gICAgICBjbGVhcjogbm9uZTsgfVxcbiAgICAubWVkaXVtLXVwLTIgPiAuY29sdW1uOm50aC1vZi10eXBlKDJuKzEpLCAubWVkaXVtLXVwLTIgPiAuY29sdW1uczpudGgtb2YtdHlwZSgybisxKSB7XFxuICAgICAgY2xlYXI6IGJvdGg7IH1cXG4gICAgLm1lZGl1bS11cC0yID4gLmNvbHVtbjpsYXN0LWNoaWxkLCAubWVkaXVtLXVwLTIgPiAuY29sdW1uczpsYXN0LWNoaWxkIHtcXG4gICAgICBmbG9hdDogbGVmdDsgfVxcbiAgLm1lZGl1bS11cC0zID4gLmNvbHVtbiwgLm1lZGl1bS11cC0zID4gLmNvbHVtbnMge1xcbiAgICB3aWR0aDogMzMuMzMzMzMlO1xcbiAgICBmbG9hdDogbGVmdDsgfVxcbiAgICAubWVkaXVtLXVwLTMgPiAuY29sdW1uOm50aC1vZi10eXBlKDFuKSwgLm1lZGl1bS11cC0zID4gLmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pIHtcXG4gICAgICBjbGVhcjogbm9uZTsgfVxcbiAgICAubWVkaXVtLXVwLTMgPiAuY29sdW1uOm50aC1vZi10eXBlKDNuKzEpLCAubWVkaXVtLXVwLTMgPiAuY29sdW1uczpudGgtb2YtdHlwZSgzbisxKSB7XFxuICAgICAgY2xlYXI6IGJvdGg7IH1cXG4gICAgLm1lZGl1bS11cC0zID4gLmNvbHVtbjpsYXN0LWNoaWxkLCAubWVkaXVtLXVwLTMgPiAuY29sdW1uczpsYXN0LWNoaWxkIHtcXG4gICAgICBmbG9hdDogbGVmdDsgfVxcbiAgLm1lZGl1bS11cC00ID4gLmNvbHVtbiwgLm1lZGl1bS11cC00ID4gLmNvbHVtbnMge1xcbiAgICB3aWR0aDogMjUlO1xcbiAgICBmbG9hdDogbGVmdDsgfVxcbiAgICAubWVkaXVtLXVwLTQgPiAuY29sdW1uOm50aC1vZi10eXBlKDFuKSwgLm1lZGl1bS11cC00ID4gLmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pIHtcXG4gICAgICBjbGVhcjogbm9uZTsgfVxcbiAgICAubWVkaXVtLXVwLTQgPiAuY29sdW1uOm50aC1vZi10eXBlKDRuKzEpLCAubWVkaXVtLXVwLTQgPiAuY29sdW1uczpudGgtb2YtdHlwZSg0bisxKSB7XFxuICAgICAgY2xlYXI6IGJvdGg7IH1cXG4gICAgLm1lZGl1bS11cC00ID4gLmNvbHVtbjpsYXN0LWNoaWxkLCAubWVkaXVtLXVwLTQgPiAuY29sdW1uczpsYXN0LWNoaWxkIHtcXG4gICAgICBmbG9hdDogbGVmdDsgfVxcbiAgLm1lZGl1bS11cC01ID4gLmNvbHVtbiwgLm1lZGl1bS11cC01ID4gLmNvbHVtbnMge1xcbiAgICB3aWR0aDogMjAlO1xcbiAgICBmbG9hdDogbGVmdDsgfVxcbiAgICAubWVkaXVtLXVwLTUgPiAuY29sdW1uOm50aC1vZi10eXBlKDFuKSwgLm1lZGl1bS11cC01ID4gLmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pIHtcXG4gICAgICBjbGVhcjogbm9uZTsgfVxcbiAgICAubWVkaXVtLXVwLTUgPiAuY29sdW1uOm50aC1vZi10eXBlKDVuKzEpLCAubWVkaXVtLXVwLTUgPiAuY29sdW1uczpudGgtb2YtdHlwZSg1bisxKSB7XFxuICAgICAgY2xlYXI6IGJvdGg7IH1cXG4gICAgLm1lZGl1bS11cC01ID4gLmNvbHVtbjpsYXN0LWNoaWxkLCAubWVkaXVtLXVwLTUgPiAuY29sdW1uczpsYXN0LWNoaWxkIHtcXG4gICAgICBmbG9hdDogbGVmdDsgfVxcbiAgLm1lZGl1bS11cC02ID4gLmNvbHVtbiwgLm1lZGl1bS11cC02ID4gLmNvbHVtbnMge1xcbiAgICB3aWR0aDogMTYuNjY2NjclO1xcbiAgICBmbG9hdDogbGVmdDsgfVxcbiAgICAubWVkaXVtLXVwLTYgPiAuY29sdW1uOm50aC1vZi10eXBlKDFuKSwgLm1lZGl1bS11cC02ID4gLmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pIHtcXG4gICAgICBjbGVhcjogbm9uZTsgfVxcbiAgICAubWVkaXVtLXVwLTYgPiAuY29sdW1uOm50aC1vZi10eXBlKDZuKzEpLCAubWVkaXVtLXVwLTYgPiAuY29sdW1uczpudGgtb2YtdHlwZSg2bisxKSB7XFxuICAgICAgY2xlYXI6IGJvdGg7IH1cXG4gICAgLm1lZGl1bS11cC02ID4gLmNvbHVtbjpsYXN0LWNoaWxkLCAubWVkaXVtLXVwLTYgPiAuY29sdW1uczpsYXN0LWNoaWxkIHtcXG4gICAgICBmbG9hdDogbGVmdDsgfVxcbiAgLm1lZGl1bS11cC03ID4gLmNvbHVtbiwgLm1lZGl1bS11cC03ID4gLmNvbHVtbnMge1xcbiAgICB3aWR0aDogMTQuMjg1NzElO1xcbiAgICBmbG9hdDogbGVmdDsgfVxcbiAgICAubWVkaXVtLXVwLTcgPiAuY29sdW1uOm50aC1vZi10eXBlKDFuKSwgLm1lZGl1bS11cC03ID4gLmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pIHtcXG4gICAgICBjbGVhcjogbm9uZTsgfVxcbiAgICAubWVkaXVtLXVwLTcgPiAuY29sdW1uOm50aC1vZi10eXBlKDduKzEpLCAubWVkaXVtLXVwLTcgPiAuY29sdW1uczpudGgtb2YtdHlwZSg3bisxKSB7XFxuICAgICAgY2xlYXI6IGJvdGg7IH1cXG4gICAgLm1lZGl1bS11cC03ID4gLmNvbHVtbjpsYXN0LWNoaWxkLCAubWVkaXVtLXVwLTcgPiAuY29sdW1uczpsYXN0LWNoaWxkIHtcXG4gICAgICBmbG9hdDogbGVmdDsgfVxcbiAgLm1lZGl1bS11cC04ID4gLmNvbHVtbiwgLm1lZGl1bS11cC04ID4gLmNvbHVtbnMge1xcbiAgICB3aWR0aDogMTIuNSU7XFxuICAgIGZsb2F0OiBsZWZ0OyB9XFxuICAgIC5tZWRpdW0tdXAtOCA+IC5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLCAubWVkaXVtLXVwLTggPiAuY29sdW1uczpudGgtb2YtdHlwZSgxbikge1xcbiAgICAgIGNsZWFyOiBub25lOyB9XFxuICAgIC5tZWRpdW0tdXAtOCA+IC5jb2x1bW46bnRoLW9mLXR5cGUoOG4rMSksIC5tZWRpdW0tdXAtOCA+IC5jb2x1bW5zOm50aC1vZi10eXBlKDhuKzEpIHtcXG4gICAgICBjbGVhcjogYm90aDsgfVxcbiAgICAubWVkaXVtLXVwLTggPiAuY29sdW1uOmxhc3QtY2hpbGQsIC5tZWRpdW0tdXAtOCA+IC5jb2x1bW5zOmxhc3QtY2hpbGQge1xcbiAgICAgIGZsb2F0OiBsZWZ0OyB9XFxuICAubWVkaXVtLWNvbGxhcHNlID4gLmNvbHVtbiwgLm1lZGl1bS1jb2xsYXBzZSA+IC5jb2x1bW5zIHtcXG4gICAgcGFkZGluZy1sZWZ0OiAwO1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAwOyB9XFxuICAubWVkaXVtLWNvbGxhcHNlIC5yb3csXFxuICAuZXhwYW5kZWQucm93IC5tZWRpdW0tY29sbGFwc2Uucm93IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDA7XFxuICAgIG1hcmdpbi1yaWdodDogMDsgfVxcbiAgLm1lZGl1bS11bmNvbGxhcHNlID4gLmNvbHVtbiwgLm1lZGl1bS11bmNvbGxhcHNlID4gLmNvbHVtbnMge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDAuOTM3NXJlbTtcXG4gICAgcGFkZGluZy1yaWdodDogMC45Mzc1cmVtOyB9XFxuICAubWVkaXVtLWNlbnRlcmVkIHtcXG4gICAgZmxvYXQ6IG5vbmU7XFxuICAgIG1hcmdpbi1sZWZ0OiBhdXRvO1xcbiAgICBtYXJnaW4tcmlnaHQ6IGF1dG87IH1cXG4gIC5tZWRpdW0tdW5jZW50ZXJlZCxcXG4gIC5tZWRpdW0tcHVzaC0wLFxcbiAgLm1lZGl1bS1wdWxsLTAge1xcbiAgICBwb3NpdGlvbjogc3RhdGljO1xcbiAgICBtYXJnaW4tbGVmdDogMDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAwO1xcbiAgICBmbG9hdDogbGVmdDsgfSB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNjRlbSkge1xcbiAgLmxhcmdlLTEge1xcbiAgICB3aWR0aDogOC4zMzMzMyU7IH1cXG4gIC5sYXJnZS1wdXNoLTEge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGxlZnQ6IDguMzMzMzMlOyB9XFxuICAubGFyZ2UtcHVsbC0xIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBsZWZ0OiAtOC4zMzMzMyU7IH1cXG4gIC5sYXJnZS1vZmZzZXQtMCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAwJTsgfVxcbiAgLmxhcmdlLTIge1xcbiAgICB3aWR0aDogMTYuNjY2NjclOyB9XFxuICAubGFyZ2UtcHVzaC0yIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBsZWZ0OiAxNi42NjY2NyU7IH1cXG4gIC5sYXJnZS1wdWxsLTIge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGxlZnQ6IC0xNi42NjY2NyU7IH1cXG4gIC5sYXJnZS1vZmZzZXQtMSB7XFxuICAgIG1hcmdpbi1sZWZ0OiA4LjMzMzMzJTsgfVxcbiAgLmxhcmdlLTMge1xcbiAgICB3aWR0aDogMjUlOyB9XFxuICAubGFyZ2UtcHVzaC0zIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBsZWZ0OiAyNSU7IH1cXG4gIC5sYXJnZS1wdWxsLTMge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGxlZnQ6IC0yNSU7IH1cXG4gIC5sYXJnZS1vZmZzZXQtMiB7XFxuICAgIG1hcmdpbi1sZWZ0OiAxNi42NjY2NyU7IH1cXG4gIC5sYXJnZS00IHtcXG4gICAgd2lkdGg6IDMzLjMzMzMzJTsgfVxcbiAgLmxhcmdlLXB1c2gtNCB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgbGVmdDogMzMuMzMzMzMlOyB9XFxuICAubGFyZ2UtcHVsbC00IHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBsZWZ0OiAtMzMuMzMzMzMlOyB9XFxuICAubGFyZ2Utb2Zmc2V0LTMge1xcbiAgICBtYXJnaW4tbGVmdDogMjUlOyB9XFxuICAubGFyZ2UtNSB7XFxuICAgIHdpZHRoOiA0MS42NjY2NyU7IH1cXG4gIC5sYXJnZS1wdXNoLTUge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGxlZnQ6IDQxLjY2NjY3JTsgfVxcbiAgLmxhcmdlLXB1bGwtNSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgbGVmdDogLTQxLjY2NjY3JTsgfVxcbiAgLmxhcmdlLW9mZnNldC00IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDMzLjMzMzMzJTsgfVxcbiAgLmxhcmdlLTYge1xcbiAgICB3aWR0aDogNTAlOyB9XFxuICAubGFyZ2UtcHVzaC02IHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBsZWZ0OiA1MCU7IH1cXG4gIC5sYXJnZS1wdWxsLTYge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGxlZnQ6IC01MCU7IH1cXG4gIC5sYXJnZS1vZmZzZXQtNSB7XFxuICAgIG1hcmdpbi1sZWZ0OiA0MS42NjY2NyU7IH1cXG4gIC5sYXJnZS03IHtcXG4gICAgd2lkdGg6IDU4LjMzMzMzJTsgfVxcbiAgLmxhcmdlLXB1c2gtNyB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgbGVmdDogNTguMzMzMzMlOyB9XFxuICAubGFyZ2UtcHVsbC03IHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBsZWZ0OiAtNTguMzMzMzMlOyB9XFxuICAubGFyZ2Utb2Zmc2V0LTYge1xcbiAgICBtYXJnaW4tbGVmdDogNTAlOyB9XFxuICAubGFyZ2UtOCB7XFxuICAgIHdpZHRoOiA2Ni42NjY2NyU7IH1cXG4gIC5sYXJnZS1wdXNoLTgge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGxlZnQ6IDY2LjY2NjY3JTsgfVxcbiAgLmxhcmdlLXB1bGwtOCB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgbGVmdDogLTY2LjY2NjY3JTsgfVxcbiAgLmxhcmdlLW9mZnNldC03IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDU4LjMzMzMzJTsgfVxcbiAgLmxhcmdlLTkge1xcbiAgICB3aWR0aDogNzUlOyB9XFxuICAubGFyZ2UtcHVzaC05IHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBsZWZ0OiA3NSU7IH1cXG4gIC5sYXJnZS1wdWxsLTkge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGxlZnQ6IC03NSU7IH1cXG4gIC5sYXJnZS1vZmZzZXQtOCB7XFxuICAgIG1hcmdpbi1sZWZ0OiA2Ni42NjY2NyU7IH1cXG4gIC5sYXJnZS0xMCB7XFxuICAgIHdpZHRoOiA4My4zMzMzMyU7IH1cXG4gIC5sYXJnZS1wdXNoLTEwIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBsZWZ0OiA4My4zMzMzMyU7IH1cXG4gIC5sYXJnZS1wdWxsLTEwIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBsZWZ0OiAtODMuMzMzMzMlOyB9XFxuICAubGFyZ2Utb2Zmc2V0LTkge1xcbiAgICBtYXJnaW4tbGVmdDogNzUlOyB9XFxuICAubGFyZ2UtMTEge1xcbiAgICB3aWR0aDogOTEuNjY2NjclOyB9XFxuICAubGFyZ2UtcHVzaC0xMSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgbGVmdDogOTEuNjY2NjclOyB9XFxuICAubGFyZ2UtcHVsbC0xMSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgbGVmdDogLTkxLjY2NjY3JTsgfVxcbiAgLmxhcmdlLW9mZnNldC0xMCB7XFxuICAgIG1hcmdpbi1sZWZ0OiA4My4zMzMzMyU7IH1cXG4gIC5sYXJnZS0xMiB7XFxuICAgIHdpZHRoOiAxMDAlOyB9XFxuICAubGFyZ2Utb2Zmc2V0LTExIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDkxLjY2NjY3JTsgfVxcbiAgLmxhcmdlLXVwLTEgPiAuY29sdW1uLCAubGFyZ2UtdXAtMSA+IC5jb2x1bW5zIHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGZsb2F0OiBsZWZ0OyB9XFxuICAgIC5sYXJnZS11cC0xID4gLmNvbHVtbjpudGgtb2YtdHlwZSgxbiksIC5sYXJnZS11cC0xID4gLmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pIHtcXG4gICAgICBjbGVhcjogbm9uZTsgfVxcbiAgICAubGFyZ2UtdXAtMSA+IC5jb2x1bW46bnRoLW9mLXR5cGUoMW4rMSksIC5sYXJnZS11cC0xID4gLmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4rMSkge1xcbiAgICAgIGNsZWFyOiBib3RoOyB9XFxuICAgIC5sYXJnZS11cC0xID4gLmNvbHVtbjpsYXN0LWNoaWxkLCAubGFyZ2UtdXAtMSA+IC5jb2x1bW5zOmxhc3QtY2hpbGQge1xcbiAgICAgIGZsb2F0OiBsZWZ0OyB9XFxuICAubGFyZ2UtdXAtMiA+IC5jb2x1bW4sIC5sYXJnZS11cC0yID4gLmNvbHVtbnMge1xcbiAgICB3aWR0aDogNTAlO1xcbiAgICBmbG9hdDogbGVmdDsgfVxcbiAgICAubGFyZ2UtdXAtMiA+IC5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLCAubGFyZ2UtdXAtMiA+IC5jb2x1bW5zOm50aC1vZi10eXBlKDFuKSB7XFxuICAgICAgY2xlYXI6IG5vbmU7IH1cXG4gICAgLmxhcmdlLXVwLTIgPiAuY29sdW1uOm50aC1vZi10eXBlKDJuKzEpLCAubGFyZ2UtdXAtMiA+IC5jb2x1bW5zOm50aC1vZi10eXBlKDJuKzEpIHtcXG4gICAgICBjbGVhcjogYm90aDsgfVxcbiAgICAubGFyZ2UtdXAtMiA+IC5jb2x1bW46bGFzdC1jaGlsZCwgLmxhcmdlLXVwLTIgPiAuY29sdW1uczpsYXN0LWNoaWxkIHtcXG4gICAgICBmbG9hdDogbGVmdDsgfVxcbiAgLmxhcmdlLXVwLTMgPiAuY29sdW1uLCAubGFyZ2UtdXAtMyA+IC5jb2x1bW5zIHtcXG4gICAgd2lkdGg6IDMzLjMzMzMzJTtcXG4gICAgZmxvYXQ6IGxlZnQ7IH1cXG4gICAgLmxhcmdlLXVwLTMgPiAuY29sdW1uOm50aC1vZi10eXBlKDFuKSwgLmxhcmdlLXVwLTMgPiAuY29sdW1uczpudGgtb2YtdHlwZSgxbikge1xcbiAgICAgIGNsZWFyOiBub25lOyB9XFxuICAgIC5sYXJnZS11cC0zID4gLmNvbHVtbjpudGgtb2YtdHlwZSgzbisxKSwgLmxhcmdlLXVwLTMgPiAuY29sdW1uczpudGgtb2YtdHlwZSgzbisxKSB7XFxuICAgICAgY2xlYXI6IGJvdGg7IH1cXG4gICAgLmxhcmdlLXVwLTMgPiAuY29sdW1uOmxhc3QtY2hpbGQsIC5sYXJnZS11cC0zID4gLmNvbHVtbnM6bGFzdC1jaGlsZCB7XFxuICAgICAgZmxvYXQ6IGxlZnQ7IH1cXG4gIC5sYXJnZS11cC00ID4gLmNvbHVtbiwgLmxhcmdlLXVwLTQgPiAuY29sdW1ucyB7XFxuICAgIHdpZHRoOiAyNSU7XFxuICAgIGZsb2F0OiBsZWZ0OyB9XFxuICAgIC5sYXJnZS11cC00ID4gLmNvbHVtbjpudGgtb2YtdHlwZSgxbiksIC5sYXJnZS11cC00ID4gLmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pIHtcXG4gICAgICBjbGVhcjogbm9uZTsgfVxcbiAgICAubGFyZ2UtdXAtNCA+IC5jb2x1bW46bnRoLW9mLXR5cGUoNG4rMSksIC5sYXJnZS11cC00ID4gLmNvbHVtbnM6bnRoLW9mLXR5cGUoNG4rMSkge1xcbiAgICAgIGNsZWFyOiBib3RoOyB9XFxuICAgIC5sYXJnZS11cC00ID4gLmNvbHVtbjpsYXN0LWNoaWxkLCAubGFyZ2UtdXAtNCA+IC5jb2x1bW5zOmxhc3QtY2hpbGQge1xcbiAgICAgIGZsb2F0OiBsZWZ0OyB9XFxuICAubGFyZ2UtdXAtNSA+IC5jb2x1bW4sIC5sYXJnZS11cC01ID4gLmNvbHVtbnMge1xcbiAgICB3aWR0aDogMjAlO1xcbiAgICBmbG9hdDogbGVmdDsgfVxcbiAgICAubGFyZ2UtdXAtNSA+IC5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLCAubGFyZ2UtdXAtNSA+IC5jb2x1bW5zOm50aC1vZi10eXBlKDFuKSB7XFxuICAgICAgY2xlYXI6IG5vbmU7IH1cXG4gICAgLmxhcmdlLXVwLTUgPiAuY29sdW1uOm50aC1vZi10eXBlKDVuKzEpLCAubGFyZ2UtdXAtNSA+IC5jb2x1bW5zOm50aC1vZi10eXBlKDVuKzEpIHtcXG4gICAgICBjbGVhcjogYm90aDsgfVxcbiAgICAubGFyZ2UtdXAtNSA+IC5jb2x1bW46bGFzdC1jaGlsZCwgLmxhcmdlLXVwLTUgPiAuY29sdW1uczpsYXN0LWNoaWxkIHtcXG4gICAgICBmbG9hdDogbGVmdDsgfVxcbiAgLmxhcmdlLXVwLTYgPiAuY29sdW1uLCAubGFyZ2UtdXAtNiA+IC5jb2x1bW5zIHtcXG4gICAgd2lkdGg6IDE2LjY2NjY3JTtcXG4gICAgZmxvYXQ6IGxlZnQ7IH1cXG4gICAgLmxhcmdlLXVwLTYgPiAuY29sdW1uOm50aC1vZi10eXBlKDFuKSwgLmxhcmdlLXVwLTYgPiAuY29sdW1uczpudGgtb2YtdHlwZSgxbikge1xcbiAgICAgIGNsZWFyOiBub25lOyB9XFxuICAgIC5sYXJnZS11cC02ID4gLmNvbHVtbjpudGgtb2YtdHlwZSg2bisxKSwgLmxhcmdlLXVwLTYgPiAuY29sdW1uczpudGgtb2YtdHlwZSg2bisxKSB7XFxuICAgICAgY2xlYXI6IGJvdGg7IH1cXG4gICAgLmxhcmdlLXVwLTYgPiAuY29sdW1uOmxhc3QtY2hpbGQsIC5sYXJnZS11cC02ID4gLmNvbHVtbnM6bGFzdC1jaGlsZCB7XFxuICAgICAgZmxvYXQ6IGxlZnQ7IH1cXG4gIC5sYXJnZS11cC03ID4gLmNvbHVtbiwgLmxhcmdlLXVwLTcgPiAuY29sdW1ucyB7XFxuICAgIHdpZHRoOiAxNC4yODU3MSU7XFxuICAgIGZsb2F0OiBsZWZ0OyB9XFxuICAgIC5sYXJnZS11cC03ID4gLmNvbHVtbjpudGgtb2YtdHlwZSgxbiksIC5sYXJnZS11cC03ID4gLmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pIHtcXG4gICAgICBjbGVhcjogbm9uZTsgfVxcbiAgICAubGFyZ2UtdXAtNyA+IC5jb2x1bW46bnRoLW9mLXR5cGUoN24rMSksIC5sYXJnZS11cC03ID4gLmNvbHVtbnM6bnRoLW9mLXR5cGUoN24rMSkge1xcbiAgICAgIGNsZWFyOiBib3RoOyB9XFxuICAgIC5sYXJnZS11cC03ID4gLmNvbHVtbjpsYXN0LWNoaWxkLCAubGFyZ2UtdXAtNyA+IC5jb2x1bW5zOmxhc3QtY2hpbGQge1xcbiAgICAgIGZsb2F0OiBsZWZ0OyB9XFxuICAubGFyZ2UtdXAtOCA+IC5jb2x1bW4sIC5sYXJnZS11cC04ID4gLmNvbHVtbnMge1xcbiAgICB3aWR0aDogMTIuNSU7XFxuICAgIGZsb2F0OiBsZWZ0OyB9XFxuICAgIC5sYXJnZS11cC04ID4gLmNvbHVtbjpudGgtb2YtdHlwZSgxbiksIC5sYXJnZS11cC04ID4gLmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pIHtcXG4gICAgICBjbGVhcjogbm9uZTsgfVxcbiAgICAubGFyZ2UtdXAtOCA+IC5jb2x1bW46bnRoLW9mLXR5cGUoOG4rMSksIC5sYXJnZS11cC04ID4gLmNvbHVtbnM6bnRoLW9mLXR5cGUoOG4rMSkge1xcbiAgICAgIGNsZWFyOiBib3RoOyB9XFxuICAgIC5sYXJnZS11cC04ID4gLmNvbHVtbjpsYXN0LWNoaWxkLCAubGFyZ2UtdXAtOCA+IC5jb2x1bW5zOmxhc3QtY2hpbGQge1xcbiAgICAgIGZsb2F0OiBsZWZ0OyB9XFxuICAubGFyZ2UtY29sbGFwc2UgPiAuY29sdW1uLCAubGFyZ2UtY29sbGFwc2UgPiAuY29sdW1ucyB7XFxuICAgIHBhZGRpbmctbGVmdDogMDtcXG4gICAgcGFkZGluZy1yaWdodDogMDsgfVxcbiAgLmxhcmdlLWNvbGxhcHNlIC5yb3csXFxuICAuZXhwYW5kZWQucm93IC5sYXJnZS1jb2xsYXBzZS5yb3cge1xcbiAgICBtYXJnaW4tbGVmdDogMDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAwOyB9XFxuICAubGFyZ2UtdW5jb2xsYXBzZSA+IC5jb2x1bW4sIC5sYXJnZS11bmNvbGxhcHNlID4gLmNvbHVtbnMge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDAuOTM3NXJlbTtcXG4gICAgcGFkZGluZy1yaWdodDogMC45Mzc1cmVtOyB9XFxuICAubGFyZ2UtY2VudGVyZWQge1xcbiAgICBmbG9hdDogbm9uZTtcXG4gICAgbWFyZ2luLWxlZnQ6IGF1dG87XFxuICAgIG1hcmdpbi1yaWdodDogYXV0bzsgfVxcbiAgLmxhcmdlLXVuY2VudGVyZWQsXFxuICAubGFyZ2UtcHVzaC0wLFxcbiAgLmxhcmdlLXB1bGwtMCB7XFxuICAgIHBvc2l0aW9uOiBzdGF0aWM7XFxuICAgIG1hcmdpbi1sZWZ0OiAwO1xcbiAgICBtYXJnaW4tcmlnaHQ6IDA7XFxuICAgIGZsb2F0OiBsZWZ0OyB9IH1cXG5cXG5kaXYsXFxuZGwsXFxuZHQsXFxuZGQsXFxudWwsXFxub2wsXFxubGksXFxuaDEsXFxuaDIsXFxuaDMsXFxuaDQsXFxuaDUsXFxuaDYsXFxucHJlLFxcbmZvcm0sXFxucCxcXG5ibG9ja3F1b3RlLFxcbnRoLFxcbnRkIHtcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDA7IH1cXG5cXG5wIHtcXG4gIGZvbnQtc2l6ZTogaW5oZXJpdDtcXG4gIGxpbmUtaGVpZ2h0OiAxLjY7XFxuICBtYXJnaW4tYm90dG9tOiAxcmVtO1xcbiAgdGV4dC1yZW5kZXJpbmc6IG9wdGltaXplTGVnaWJpbGl0eTsgfVxcblxcbmVtLFxcbmkge1xcbiAgZm9udC1zdHlsZTogaXRhbGljO1xcbiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG5cXG5zdHJvbmcsXFxuYiB7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuXFxuc21hbGwge1xcbiAgZm9udC1zaXplOiA4MCU7XFxuICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcblxcbmgxLFxcbmgyLFxcbmgzLFxcbmg0LFxcbmg1LFxcbmg2IHtcXG4gIGZvbnQtZmFtaWx5OiBcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLCBIZWx2ZXRpY2EsIFJvYm90bywgQXJpYWwsIHNhbnMtc2VyaWY7XFxuICBmb250LXdlaWdodDogbm9ybWFsO1xcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xcbiAgY29sb3I6IGluaGVyaXQ7XFxuICB0ZXh0LXJlbmRlcmluZzogb3B0aW1pemVMZWdpYmlsaXR5O1xcbiAgbWFyZ2luLXRvcDogMDtcXG4gIG1hcmdpbi1ib3R0b206IDAuNXJlbTtcXG4gIGxpbmUtaGVpZ2h0OiAxLjQ7IH1cXG4gIGgxIHNtYWxsLFxcbiAgaDIgc21hbGwsXFxuICBoMyBzbWFsbCxcXG4gIGg0IHNtYWxsLFxcbiAgaDUgc21hbGwsXFxuICBoNiBzbWFsbCB7XFxuICAgIGNvbG9yOiAjY2FjYWNhO1xcbiAgICBsaW5lLWhlaWdodDogMDsgfVxcblxcbmgxIHtcXG4gIGZvbnQtc2l6ZTogMS41cmVtOyB9XFxuXFxuaDIge1xcbiAgZm9udC1zaXplOiAxLjI1cmVtOyB9XFxuXFxuaDMge1xcbiAgZm9udC1zaXplOiAxLjE4NzVyZW07IH1cXG5cXG5oNCB7XFxuICBmb250LXNpemU6IDEuMTI1cmVtOyB9XFxuXFxuaDUge1xcbiAgZm9udC1zaXplOiAxLjA2MjVyZW07IH1cXG5cXG5oNiB7XFxuICBmb250LXNpemU6IDFyZW07IH1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA0MGVtKSB7XFxuICBoMSB7XFxuICAgIGZvbnQtc2l6ZTogM3JlbTsgfVxcbiAgaDIge1xcbiAgICBmb250LXNpemU6IDIuNXJlbTsgfVxcbiAgaDMge1xcbiAgICBmb250LXNpemU6IDEuOTM3NXJlbTsgfVxcbiAgaDQge1xcbiAgICBmb250LXNpemU6IDEuNTYyNXJlbTsgfVxcbiAgaDUge1xcbiAgICBmb250LXNpemU6IDEuMjVyZW07IH1cXG4gIGg2IHtcXG4gICAgZm9udC1zaXplOiAxcmVtOyB9IH1cXG5cXG5hIHtcXG4gIGNvbG9yOiAjMjE5OWU4O1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7XFxuICBjdXJzb3I6IHBvaW50ZXI7IH1cXG4gIGE6aG92ZXIsIGE6Zm9jdXMge1xcbiAgICBjb2xvcjogIzE1ODVjZjsgfVxcbiAgYSBpbWcge1xcbiAgICBib3JkZXI6IDA7IH1cXG5cXG5ociB7XFxuICBtYXgtd2lkdGg6IDc1cmVtO1xcbiAgaGVpZ2h0OiAwO1xcbiAgYm9yZGVyLXJpZ2h0OiAwO1xcbiAgYm9yZGVyLXRvcDogMDtcXG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjY2FjYWNhO1xcbiAgYm9yZGVyLWxlZnQ6IDA7XFxuICBtYXJnaW46IDEuMjVyZW0gYXV0bztcXG4gIGNsZWFyOiBib3RoOyB9XFxuXFxudWwsXFxub2wsXFxuZGwge1xcbiAgbGluZS1oZWlnaHQ6IDEuNjtcXG4gIG1hcmdpbi1ib3R0b206IDFyZW07XFxuICBsaXN0LXN0eWxlLXBvc2l0aW9uOiBvdXRzaWRlOyB9XFxuXFxubGkge1xcbiAgZm9udC1zaXplOiBpbmhlcml0OyB9XFxuXFxudWwge1xcbiAgbGlzdC1zdHlsZS10eXBlOiBkaXNjO1xcbiAgbWFyZ2luLWxlZnQ6IDEuMjVyZW07IH1cXG5cXG5vbCB7XFxuICBtYXJnaW4tbGVmdDogMS4yNXJlbTsgfVxcblxcbnVsIHVsLCBvbCB1bCwgdWwgb2wsIG9sIG9sIHtcXG4gIG1hcmdpbi1sZWZ0OiAxLjI1cmVtO1xcbiAgbWFyZ2luLWJvdHRvbTogMDsgfVxcblxcbmRsIHtcXG4gIG1hcmdpbi1ib3R0b206IDFyZW07IH1cXG4gIGRsIGR0IHtcXG4gICAgbWFyZ2luLWJvdHRvbTogMC4zcmVtO1xcbiAgICBmb250LXdlaWdodDogYm9sZDsgfVxcblxcbmJsb2NrcXVvdGUge1xcbiAgbWFyZ2luOiAwIDAgMXJlbTtcXG4gIHBhZGRpbmc6IDAuNTYyNXJlbSAxLjI1cmVtIDAgMS4xODc1cmVtO1xcbiAgYm9yZGVyLWxlZnQ6IDFweCBzb2xpZCAjY2FjYWNhOyB9XFxuICBibG9ja3F1b3RlLCBibG9ja3F1b3RlIHAge1xcbiAgICBsaW5lLWhlaWdodDogMS42O1xcbiAgICBjb2xvcjogIzhhOGE4YTsgfVxcblxcbmNpdGUge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBmb250LXNpemU6IDAuODEyNXJlbTtcXG4gIGNvbG9yOiAjOGE4YThhOyB9XFxuICBjaXRlOmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6ICdcXFxcMjAxNCAgICAnOyB9XFxuXFxuYWJiciB7XFxuICBjb2xvcjogIzBhMGEwYTtcXG4gIGN1cnNvcjogaGVscDtcXG4gIGJvcmRlci1ib3R0b206IDFweCBkb3R0ZWQgIzBhMGEwYTsgfVxcblxcbmNvZGUge1xcbiAgZm9udC1mYW1pbHk6IENvbnNvbGFzLCBcXFwiTGliZXJhdGlvbiBNb25vXFxcIiwgQ291cmllciwgbW9ub3NwYWNlO1xcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXG4gIGNvbG9yOiAjMGEwYTBhO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2U2ZTZlNjtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNjYWNhY2E7XFxuICBwYWRkaW5nOiAwLjEyNXJlbSAwLjMxMjVyZW0gMC4wNjI1cmVtOyB9XFxuXFxua2JkIHtcXG4gIHBhZGRpbmc6IDAuMTI1cmVtIDAuMjVyZW0gMDtcXG4gIG1hcmdpbjogMDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlNmU2ZTY7XFxuICBjb2xvcjogIzBhMGEwYTtcXG4gIGZvbnQtZmFtaWx5OiBDb25zb2xhcywgXFxcIkxpYmVyYXRpb24gTW9ub1xcXCIsIENvdXJpZXIsIG1vbm9zcGFjZTsgfVxcblxcbi5zdWJoZWFkZXIge1xcbiAgbWFyZ2luLXRvcDogMC4ycmVtO1xcbiAgbWFyZ2luLWJvdHRvbTogMC41cmVtO1xcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXG4gIGxpbmUtaGVpZ2h0OiAxLjQ7XFxuICBjb2xvcjogIzhhOGE4YTsgfVxcblxcbi5sZWFkIHtcXG4gIGZvbnQtc2l6ZTogMTI1JTtcXG4gIGxpbmUtaGVpZ2h0OiAxLjY7IH1cXG5cXG4uc3RhdCB7XFxuICBmb250LXNpemU6IDIuNXJlbTtcXG4gIGxpbmUtaGVpZ2h0OiAxOyB9XFxuICBwICsgLnN0YXQge1xcbiAgICBtYXJnaW4tdG9wOiAtMXJlbTsgfVxcblxcbi5uby1idWxsZXQge1xcbiAgbWFyZ2luLWxlZnQ6IDA7XFxuICBsaXN0LXN0eWxlOiBub25lOyB9XFxuXFxuLnRleHQtbGVmdCB7XFxuICB0ZXh0LWFsaWduOiBsZWZ0OyB9XFxuXFxuLnRleHQtcmlnaHQge1xcbiAgdGV4dC1hbGlnbjogcmlnaHQ7IH1cXG5cXG4udGV4dC1jZW50ZXIge1xcbiAgdGV4dC1hbGlnbjogY2VudGVyOyB9XFxuXFxuLnRleHQtanVzdGlmeSB7XFxuICB0ZXh0LWFsaWduOiBqdXN0aWZ5OyB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNDBlbSkge1xcbiAgLm1lZGl1bS10ZXh0LWxlZnQge1xcbiAgICB0ZXh0LWFsaWduOiBsZWZ0OyB9XFxuICAubWVkaXVtLXRleHQtcmlnaHQge1xcbiAgICB0ZXh0LWFsaWduOiByaWdodDsgfVxcbiAgLm1lZGl1bS10ZXh0LWNlbnRlciB7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjsgfVxcbiAgLm1lZGl1bS10ZXh0LWp1c3RpZnkge1xcbiAgICB0ZXh0LWFsaWduOiBqdXN0aWZ5OyB9IH1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA2NGVtKSB7XFxuICAubGFyZ2UtdGV4dC1sZWZ0IHtcXG4gICAgdGV4dC1hbGlnbjogbGVmdDsgfVxcbiAgLmxhcmdlLXRleHQtcmlnaHQge1xcbiAgICB0ZXh0LWFsaWduOiByaWdodDsgfVxcbiAgLmxhcmdlLXRleHQtY2VudGVyIHtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyOyB9XFxuICAubGFyZ2UtdGV4dC1qdXN0aWZ5IHtcXG4gICAgdGV4dC1hbGlnbjoganVzdGlmeTsgfSB9XFxuXFxuLnNob3ctZm9yLXByaW50IHtcXG4gIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDsgfVxcblxcbkBtZWRpYSBwcmludCB7XFxuICAqIHtcXG4gICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQgIWltcG9ydGFudDtcXG4gICAgY29sb3I6IGJsYWNrICFpbXBvcnRhbnQ7XFxuICAgIGJveC1zaGFkb3c6IG5vbmUgIWltcG9ydGFudDtcXG4gICAgdGV4dC1zaGFkb3c6IG5vbmUgIWltcG9ydGFudDsgfVxcbiAgLnNob3ctZm9yLXByaW50IHtcXG4gICAgZGlzcGxheTogYmxvY2sgIWltcG9ydGFudDsgfVxcbiAgLmhpZGUtZm9yLXByaW50IHtcXG4gICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50OyB9XFxuICB0YWJsZS5zaG93LWZvci1wcmludCB7XFxuICAgIGRpc3BsYXk6IHRhYmxlICFpbXBvcnRhbnQ7IH1cXG4gIHRoZWFkLnNob3ctZm9yLXByaW50IHtcXG4gICAgZGlzcGxheTogdGFibGUtaGVhZGVyLWdyb3VwICFpbXBvcnRhbnQ7IH1cXG4gIHRib2R5LnNob3ctZm9yLXByaW50IHtcXG4gICAgZGlzcGxheTogdGFibGUtcm93LWdyb3VwICFpbXBvcnRhbnQ7IH1cXG4gIHRyLnNob3ctZm9yLXByaW50IHtcXG4gICAgZGlzcGxheTogdGFibGUtcm93ICFpbXBvcnRhbnQ7IH1cXG4gIHRkLnNob3ctZm9yLXByaW50IHtcXG4gICAgZGlzcGxheTogdGFibGUtY2VsbCAhaW1wb3J0YW50OyB9XFxuICB0aC5zaG93LWZvci1wcmludCB7XFxuICAgIGRpc3BsYXk6IHRhYmxlLWNlbGwgIWltcG9ydGFudDsgfVxcbiAgYSxcXG4gIGE6dmlzaXRlZCB7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lOyB9XFxuICBhW2hyZWZdOmFmdGVyIHtcXG4gICAgY29udGVudDogXFxcIiAoXFxcIiBhdHRyKGhyZWYpIFxcXCIpXFxcIjsgfVxcbiAgLmlyIGE6YWZ0ZXIsXFxuICBhW2hyZWZePSdqYXZhc2NyaXB0OiddOmFmdGVyLFxcbiAgYVtocmVmXj0nIyddOmFmdGVyIHtcXG4gICAgY29udGVudDogJyc7IH1cXG4gIGFiYnJbdGl0bGVdOmFmdGVyIHtcXG4gICAgY29udGVudDogXFxcIiAoXFxcIiBhdHRyKHRpdGxlKSBcXFwiKVxcXCI7IH1cXG4gIHByZSxcXG4gIGJsb2NrcXVvdGUge1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjOGE4YThhO1xcbiAgICBwYWdlLWJyZWFrLWluc2lkZTogYXZvaWQ7IH1cXG4gIHRoZWFkIHtcXG4gICAgZGlzcGxheTogdGFibGUtaGVhZGVyLWdyb3VwOyB9XFxuICB0cixcXG4gIGltZyB7XFxuICAgIHBhZ2UtYnJlYWstaW5zaWRlOiBhdm9pZDsgfVxcbiAgaW1nIHtcXG4gICAgbWF4LXdpZHRoOiAxMDAlICFpbXBvcnRhbnQ7IH1cXG4gIEBwYWdlIHtcXG4gICAgbWFyZ2luOiAwLjVjbTsgfVxcbiAgcCxcXG4gIGgyLFxcbiAgaDMge1xcbiAgICBvcnBoYW5zOiAzO1xcbiAgICB3aWRvd3M6IDM7IH1cXG4gIGgyLFxcbiAgaDMge1xcbiAgICBwYWdlLWJyZWFrLWFmdGVyOiBhdm9pZDsgfSB9XFxuXFxuW3R5cGU9J3RleHQnXSwgW3R5cGU9J3Bhc3N3b3JkJ10sIFt0eXBlPSdkYXRlJ10sIFt0eXBlPSdkYXRldGltZSddLCBbdHlwZT0nZGF0ZXRpbWUtbG9jYWwnXSwgW3R5cGU9J21vbnRoJ10sIFt0eXBlPSd3ZWVrJ10sIFt0eXBlPSdlbWFpbCddLCBbdHlwZT0nbnVtYmVyJ10sIFt0eXBlPSdzZWFyY2gnXSwgW3R5cGU9J3RlbCddLCBbdHlwZT0ndGltZSddLCBbdHlwZT0ndXJsJ10sIFt0eXBlPSdjb2xvciddLFxcbnRleHRhcmVhIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAyLjQzNzVyZW07XFxuICBwYWRkaW5nOiAwLjVyZW07XFxuICBib3JkZXI6IDFweCBzb2xpZCAjY2FjYWNhO1xcbiAgbWFyZ2luOiAwIDAgMXJlbTtcXG4gIGZvbnQtZmFtaWx5OiBpbmhlcml0O1xcbiAgZm9udC1zaXplOiAxcmVtO1xcbiAgY29sb3I6ICMwYTBhMGE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmVmZWZlO1xcbiAgYm94LXNoYWRvdzogaW5zZXQgMCAxcHggMnB4IHJnYmEoMTAsIDEwLCAxMCwgMC4xKTtcXG4gIGJvcmRlci1yYWRpdXM6IDA7XFxuICB0cmFuc2l0aW9uOiBib3gtc2hhZG93IDAuNXMsIGJvcmRlci1jb2xvciAwLjI1cyBlYXNlLWluLW91dDtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG4gIC1tb3otYXBwZWFyYW5jZTogbm9uZTsgfVxcbiAgW3R5cGU9J3RleHQnXTpmb2N1cywgW3R5cGU9J3Bhc3N3b3JkJ106Zm9jdXMsIFt0eXBlPSdkYXRlJ106Zm9jdXMsIFt0eXBlPSdkYXRldGltZSddOmZvY3VzLCBbdHlwZT0nZGF0ZXRpbWUtbG9jYWwnXTpmb2N1cywgW3R5cGU9J21vbnRoJ106Zm9jdXMsIFt0eXBlPSd3ZWVrJ106Zm9jdXMsIFt0eXBlPSdlbWFpbCddOmZvY3VzLCBbdHlwZT0nbnVtYmVyJ106Zm9jdXMsIFt0eXBlPSdzZWFyY2gnXTpmb2N1cywgW3R5cGU9J3RlbCddOmZvY3VzLCBbdHlwZT0ndGltZSddOmZvY3VzLCBbdHlwZT0ndXJsJ106Zm9jdXMsIFt0eXBlPSdjb2xvciddOmZvY3VzLFxcbiAgdGV4dGFyZWE6Zm9jdXMge1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjOGE4YThhO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmVmZWZlO1xcbiAgICBvdXRsaW5lOiBub25lO1xcbiAgICBib3gtc2hhZG93OiAwIDAgNXB4ICNjYWNhY2E7XFxuICAgIHRyYW5zaXRpb246IGJveC1zaGFkb3cgMC41cywgYm9yZGVyLWNvbG9yIDAuMjVzIGVhc2UtaW4tb3V0OyB9XFxuXFxudGV4dGFyZWEge1xcbiAgbWF4LXdpZHRoOiAxMDAlOyB9XFxuICB0ZXh0YXJlYVtyb3dzXSB7XFxuICAgIGhlaWdodDogYXV0bzsgfVxcblxcbmlucHV0OjpwbGFjZWhvbGRlcixcXG50ZXh0YXJlYTo6cGxhY2Vob2xkZXIge1xcbiAgY29sb3I6ICNjYWNhY2E7IH1cXG5cXG5pbnB1dDpkaXNhYmxlZCwgaW5wdXRbcmVhZG9ubHldLFxcbnRleHRhcmVhOmRpc2FibGVkLFxcbnRleHRhcmVhW3JlYWRvbmx5XSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZTZlNmU2O1xcbiAgY3Vyc29yOiBub3QtYWxsb3dlZDsgfVxcblxcblt0eXBlPSdzdWJtaXQnXSxcXG5bdHlwZT0nYnV0dG9uJ10ge1xcbiAgYm9yZGVyLXJhZGl1czogMDtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG4gIC1tb3otYXBwZWFyYW5jZTogbm9uZTsgfVxcblxcbmlucHV0W3R5cGU9J3NlYXJjaCddIHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IH1cXG5cXG5bdHlwZT0nZmlsZSddLFxcblt0eXBlPSdjaGVja2JveCddLFxcblt0eXBlPSdyYWRpbyddIHtcXG4gIG1hcmdpbjogMCAwIDFyZW07IH1cXG5cXG5bdHlwZT0nY2hlY2tib3gnXSArIGxhYmVsLFxcblt0eXBlPSdyYWRpbyddICsgbGFiZWwge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgbWFyZ2luLWxlZnQ6IDAuNXJlbTtcXG4gIG1hcmdpbi1yaWdodDogMXJlbTtcXG4gIG1hcmdpbi1ib3R0b206IDA7XFxuICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7IH1cXG4gIFt0eXBlPSdjaGVja2JveCddICsgbGFiZWxbZm9yXSxcXG4gIFt0eXBlPSdyYWRpbyddICsgbGFiZWxbZm9yXSB7XFxuICAgIGN1cnNvcjogcG9pbnRlcjsgfVxcblxcbmxhYmVsID4gW3R5cGU9J2NoZWNrYm94J10sXFxubGFiZWwgPiBbdHlwZT0ncmFkaW8nXSB7XFxuICBtYXJnaW4tcmlnaHQ6IDAuNXJlbTsgfVxcblxcblt0eXBlPSdmaWxlJ10ge1xcbiAgd2lkdGg6IDEwMCU7IH1cXG5cXG5sYWJlbCB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIG1hcmdpbjogMDtcXG4gIGZvbnQtc2l6ZTogMC44NzVyZW07XFxuICBmb250LXdlaWdodDogbm9ybWFsO1xcbiAgbGluZS1oZWlnaHQ6IDEuODtcXG4gIGNvbG9yOiAjMGEwYTBhOyB9XFxuICBsYWJlbC5taWRkbGUge1xcbiAgICBtYXJnaW46IDAgMCAxcmVtO1xcbiAgICBwYWRkaW5nOiAwLjU2MjVyZW0gMDsgfVxcblxcbi5oZWxwLXRleHQge1xcbiAgbWFyZ2luLXRvcDogLTAuNXJlbTtcXG4gIGZvbnQtc2l6ZTogMC44MTI1cmVtO1xcbiAgZm9udC1zdHlsZTogaXRhbGljO1xcbiAgY29sb3I6ICMwYTBhMGE7IH1cXG5cXG4uaW5wdXQtZ3JvdXAge1xcbiAgZGlzcGxheTogdGFibGU7XFxuICB3aWR0aDogMTAwJTtcXG4gIG1hcmdpbi1ib3R0b206IDFyZW07IH1cXG4gIC5pbnB1dC1ncm91cCA+IDpmaXJzdC1jaGlsZCB7XFxuICAgIGJvcmRlci1yYWRpdXM6IDAgMCAwIDA7IH1cXG4gIC5pbnB1dC1ncm91cCA+IDpsYXN0LWNoaWxkID4gKiB7XFxuICAgIGJvcmRlci1yYWRpdXM6IDAgMCAwIDA7IH1cXG5cXG4uaW5wdXQtZ3JvdXAtbGFiZWwsIC5pbnB1dC1ncm91cC1maWVsZCwgLmlucHV0LWdyb3VwLWJ1dHRvbiB7XFxuICBtYXJnaW46IDA7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbiAgZGlzcGxheTogdGFibGUtY2VsbDtcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7IH1cXG5cXG4uaW5wdXQtZ3JvdXAtbGFiZWwge1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgcGFkZGluZzogMCAxcmVtO1xcbiAgYmFja2dyb3VuZDogI2U2ZTZlNjtcXG4gIGNvbG9yOiAjMGEwYTBhO1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2NhY2FjYTtcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxuICB3aWR0aDogMSU7XFxuICBoZWlnaHQ6IDEwMCU7IH1cXG4gIC5pbnB1dC1ncm91cC1sYWJlbDpmaXJzdC1jaGlsZCB7XFxuICAgIGJvcmRlci1yaWdodDogMDsgfVxcbiAgLmlucHV0LWdyb3VwLWxhYmVsOmxhc3QtY2hpbGQge1xcbiAgICBib3JkZXItbGVmdDogMDsgfVxcblxcbi5pbnB1dC1ncm91cC1maWVsZCB7XFxuICBib3JkZXItcmFkaXVzOiAwO1xcbiAgaGVpZ2h0OiAyLjVyZW07IH1cXG5cXG4uaW5wdXQtZ3JvdXAtYnV0dG9uIHtcXG4gIHBhZGRpbmctdG9wOiAwO1xcbiAgcGFkZGluZy1ib3R0b206IDA7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICB3aWR0aDogMSU7IH1cXG4gIC5pbnB1dC1ncm91cC1idXR0b24gYSxcXG4gIC5pbnB1dC1ncm91cC1idXR0b24gaW5wdXQsXFxuICAuaW5wdXQtZ3JvdXAtYnV0dG9uIGJ1dHRvbiB7XFxuICAgIG1hcmdpbjogMDsgfVxcblxcbi5pbnB1dC1ncm91cCAuaW5wdXQtZ3JvdXAtYnV0dG9uIHtcXG4gIGRpc3BsYXk6IHRhYmxlLWNlbGw7IH1cXG5cXG5maWVsZHNldCB7XFxuICBib3JkZXI6IDA7XFxuICBwYWRkaW5nOiAwO1xcbiAgbWFyZ2luOiAwOyB9XFxuXFxubGVnZW5kIHtcXG4gIG1hcmdpbi1ib3R0b206IDAuNXJlbTtcXG4gIG1heC13aWR0aDogMTAwJTsgfVxcblxcbi5maWVsZHNldCB7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjY2FjYWNhO1xcbiAgcGFkZGluZzogMS4yNXJlbTtcXG4gIG1hcmdpbjogMS4xMjVyZW0gMDsgfVxcbiAgLmZpZWxkc2V0IGxlZ2VuZCB7XFxuICAgIGJhY2tncm91bmQ6ICNmZWZlZmU7XFxuICAgIHBhZGRpbmc6IDAgMC4xODc1cmVtO1xcbiAgICBtYXJnaW46IDA7XFxuICAgIG1hcmdpbi1sZWZ0OiAtMC4xODc1cmVtOyB9XFxuXFxuc2VsZWN0IHtcXG4gIGhlaWdodDogMi40Mzc1cmVtO1xcbiAgcGFkZGluZzogMC41cmVtO1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2NhY2FjYTtcXG4gIG1hcmdpbjogMCAwIDFyZW07XFxuICBmb250LXNpemU6IDFyZW07XFxuICBmb250LWZhbWlseTogaW5oZXJpdDtcXG4gIGxpbmUtaGVpZ2h0OiBub3JtYWw7XFxuICBjb2xvcjogIzBhMGEwYTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZWZlZmU7XFxuICBib3JkZXItcmFkaXVzOiAwO1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcbiAgLW1vei1hcHBlYXJhbmNlOiBub25lO1xcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWw7dXRmOCw8c3ZnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycgdmVyc2lvbj0nMS4xJyB3aWR0aD0nMzInIGhlaWdodD0nMjQnIHZpZXdCb3g9JzAgMCAzMiAyNCc+PHBvbHlnb24gcG9pbnRzPScwLDAgMzIsMCAxNiwyNCcgc3R5bGU9J2ZpbGw6IHJnYiUyODEzOCwgMTM4LCAxMzglMjknPjwvcG9seWdvbj48L3N2Zz5cXFwiKTtcXG4gIGJhY2tncm91bmQtc2l6ZTogOXB4IDZweDtcXG4gIGJhY2tncm91bmQtcG9zaXRpb246IHJpZ2h0IC0xcmVtIGNlbnRlcjtcXG4gIGJhY2tncm91bmQtb3JpZ2luOiBjb250ZW50LWJveDtcXG4gIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICBwYWRkaW5nLXJpZ2h0OiAxLjVyZW07IH1cXG4gIEBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDBcXFxcMCkge1xcbiAgICBzZWxlY3Qge1xcbiAgICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybChcXFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDQUFBQUFZQ0FZQUFBQ2JVLzgwQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUFJcEpSRUZVZU5yRWtja05nREFNQkJmUmtFdDBPYlJCQmRzR1hVRGdtUWZLNFhoSDJtOGN6UUFBeTI3UjN0c3c0UWZlMng4dU9PNm9ZTGI2R2xPb3IzR0Yrc3dVUkFPbVVKK1J3dEVKczlXdlRHRVl4QlhxSTFNUUFaaENmVVFLUnpETVZqK1R3ckFJVjZqdlNVRWtZQXIxTFNrY3lUQmIvVitLWWZYN3hBZXVzcTNzTER0R0gza0VHQUNQV0lmbE5aZmhSUUFBQUFCSlJVNUVya0pnZ2c9PVxcXCIpOyB9IH1cXG4gIHNlbGVjdDpkaXNhYmxlZCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNlNmU2ZTY7XFxuICAgIGN1cnNvcjogbm90LWFsbG93ZWQ7IH1cXG4gIHNlbGVjdDo6LW1zLWV4cGFuZCB7XFxuICAgIGRpc3BsYXk6IG5vbmU7IH1cXG4gIHNlbGVjdFttdWx0aXBsZV0ge1xcbiAgICBoZWlnaHQ6IGF1dG87XFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IG5vbmU7IH1cXG5cXG4uaXMtaW52YWxpZC1pbnB1dDpub3QoOmZvY3VzKSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDIzNiwgODgsIDY0LCAwLjEpO1xcbiAgYm9yZGVyLWNvbG9yOiAjZWM1ODQwOyB9XFxuXFxuLmlzLWludmFsaWQtbGFiZWwge1xcbiAgY29sb3I6ICNlYzU4NDA7IH1cXG5cXG4uZm9ybS1lcnJvciB7XFxuICBkaXNwbGF5OiBub25lO1xcbiAgbWFyZ2luLXRvcDogLTAuNXJlbTtcXG4gIG1hcmdpbi1ib3R0b206IDFyZW07XFxuICBmb250LXNpemU6IDAuNzVyZW07XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIGNvbG9yOiAjZWM1ODQwOyB9XFxuICAuZm9ybS1lcnJvci5pcy12aXNpYmxlIHtcXG4gICAgZGlzcGxheTogYmxvY2s7IH1cXG5cXG4uYnV0dG9uIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGxpbmUtaGVpZ2h0OiAxO1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcbiAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAwLjI1cyBlYXNlLW91dCwgY29sb3IgMC4yNXMgZWFzZS1vdXQ7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgYm9yZGVyOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XFxuICBib3JkZXItcmFkaXVzOiAwO1xcbiAgcGFkZGluZzogMC44NWVtIDFlbTtcXG4gIG1hcmdpbjogMCAwIDFyZW0gMDtcXG4gIGZvbnQtc2l6ZTogMC45cmVtO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzIxOTllODtcXG4gIGNvbG9yOiAjZmVmZWZlOyB9XFxuICBbZGF0YS13aGF0aW5wdXQ9J21vdXNlJ10gLmJ1dHRvbiB7XFxuICAgIG91dGxpbmU6IDA7IH1cXG4gIC5idXR0b246aG92ZXIsIC5idXR0b246Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMTU4M2NjO1xcbiAgICBjb2xvcjogI2ZlZmVmZTsgfVxcbiAgLmJ1dHRvbi50aW55IHtcXG4gICAgZm9udC1zaXplOiAwLjZyZW07IH1cXG4gIC5idXR0b24uc21hbGwge1xcbiAgICBmb250LXNpemU6IDAuNzVyZW07IH1cXG4gIC5idXR0b24ubGFyZ2Uge1xcbiAgICBmb250LXNpemU6IDEuMjVyZW07IH1cXG4gIC5idXR0b24uZXhwYW5kZWQge1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIG1hcmdpbi1sZWZ0OiAwO1xcbiAgICBtYXJnaW4tcmlnaHQ6IDA7IH1cXG4gIC5idXR0b24ucHJpbWFyeSB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMyMTk5ZTg7XFxuICAgIGNvbG9yOiAjZmVmZWZlOyB9XFxuICAgIC5idXR0b24ucHJpbWFyeTpob3ZlciwgLmJ1dHRvbi5wcmltYXJ5OmZvY3VzIHtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMTQ3Y2MwO1xcbiAgICAgIGNvbG9yOiAjZmVmZWZlOyB9XFxuICAuYnV0dG9uLnNlY29uZGFyeSB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICM3Nzc7XFxuICAgIGNvbG9yOiAjZmVmZWZlOyB9XFxuICAgIC5idXR0b24uc2Vjb25kYXJ5OmhvdmVyLCAuYnV0dG9uLnNlY29uZGFyeTpmb2N1cyB7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzVmNWY1ZjtcXG4gICAgICBjb2xvcjogI2ZlZmVmZTsgfVxcbiAgLmJ1dHRvbi5zdWNjZXNzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzNhZGI3NjtcXG4gICAgY29sb3I6ICNmZWZlZmU7IH1cXG4gICAgLmJ1dHRvbi5zdWNjZXNzOmhvdmVyLCAuYnV0dG9uLnN1Y2Nlc3M6Zm9jdXMge1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICMyMmJiNWI7XFxuICAgICAgY29sb3I6ICNmZWZlZmU7IH1cXG4gIC5idXR0b24ud2FybmluZyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmFlMDA7XFxuICAgIGNvbG9yOiAjZmVmZWZlOyB9XFxuICAgIC5idXR0b24ud2FybmluZzpob3ZlciwgLmJ1dHRvbi53YXJuaW5nOmZvY3VzIHtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjY2M4YjAwO1xcbiAgICAgIGNvbG9yOiAjZmVmZWZlOyB9XFxuICAuYnV0dG9uLmFsZXJ0IHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2VjNTg0MDtcXG4gICAgY29sb3I6ICNmZWZlZmU7IH1cXG4gICAgLmJ1dHRvbi5hbGVydDpob3ZlciwgLmJ1dHRvbi5hbGVydDpmb2N1cyB7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2RhMzExNjtcXG4gICAgICBjb2xvcjogI2ZlZmVmZTsgfVxcbiAgLmJ1dHRvbi5ob2xsb3cge1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjMjE5OWU4O1xcbiAgICBjb2xvcjogIzIxOTllODsgfVxcbiAgICAuYnV0dG9uLmhvbGxvdywgLmJ1dHRvbi5ob2xsb3c6aG92ZXIsIC5idXR0b24uaG9sbG93OmZvY3VzIHtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsgfVxcbiAgICAuYnV0dG9uLmhvbGxvdzpob3ZlciwgLmJ1dHRvbi5ob2xsb3c6Zm9jdXMge1xcbiAgICAgIGJvcmRlci1jb2xvcjogIzBjNGQ3ODtcXG4gICAgICBjb2xvcjogIzBjNGQ3ODsgfVxcbiAgICAuYnV0dG9uLmhvbGxvdy5wcmltYXJ5IHtcXG4gICAgICBib3JkZXI6IDFweCBzb2xpZCAjMjE5OWU4O1xcbiAgICAgIGNvbG9yOiAjMjE5OWU4OyB9XFxuICAgICAgLmJ1dHRvbi5ob2xsb3cucHJpbWFyeTpob3ZlciwgLmJ1dHRvbi5ob2xsb3cucHJpbWFyeTpmb2N1cyB7XFxuICAgICAgICBib3JkZXItY29sb3I6ICMwYzRkNzg7XFxuICAgICAgICBjb2xvcjogIzBjNGQ3ODsgfVxcbiAgICAuYnV0dG9uLmhvbGxvdy5zZWNvbmRhcnkge1xcbiAgICAgIGJvcmRlcjogMXB4IHNvbGlkICM3Nzc7XFxuICAgICAgY29sb3I6ICM3Nzc7IH1cXG4gICAgICAuYnV0dG9uLmhvbGxvdy5zZWNvbmRhcnk6aG92ZXIsIC5idXR0b24uaG9sbG93LnNlY29uZGFyeTpmb2N1cyB7XFxuICAgICAgICBib3JkZXItY29sb3I6ICMzYzNjM2M7XFxuICAgICAgICBjb2xvcjogIzNjM2MzYzsgfVxcbiAgICAuYnV0dG9uLmhvbGxvdy5zdWNjZXNzIHtcXG4gICAgICBib3JkZXI6IDFweCBzb2xpZCAjM2FkYjc2O1xcbiAgICAgIGNvbG9yOiAjM2FkYjc2OyB9XFxuICAgICAgLmJ1dHRvbi5ob2xsb3cuc3VjY2Vzczpob3ZlciwgLmJ1dHRvbi5ob2xsb3cuc3VjY2Vzczpmb2N1cyB7XFxuICAgICAgICBib3JkZXItY29sb3I6ICMxNTc1Mzk7XFxuICAgICAgICBjb2xvcjogIzE1NzUzOTsgfVxcbiAgICAuYnV0dG9uLmhvbGxvdy53YXJuaW5nIHtcXG4gICAgICBib3JkZXI6IDFweCBzb2xpZCAjZmZhZTAwO1xcbiAgICAgIGNvbG9yOiAjZmZhZTAwOyB9XFxuICAgICAgLmJ1dHRvbi5ob2xsb3cud2FybmluZzpob3ZlciwgLmJ1dHRvbi5ob2xsb3cud2FybmluZzpmb2N1cyB7XFxuICAgICAgICBib3JkZXItY29sb3I6ICM4MDU3MDA7XFxuICAgICAgICBjb2xvcjogIzgwNTcwMDsgfVxcbiAgICAuYnV0dG9uLmhvbGxvdy5hbGVydCB7XFxuICAgICAgYm9yZGVyOiAxcHggc29saWQgI2VjNTg0MDtcXG4gICAgICBjb2xvcjogI2VjNTg0MDsgfVxcbiAgICAgIC5idXR0b24uaG9sbG93LmFsZXJ0OmhvdmVyLCAuYnV0dG9uLmhvbGxvdy5hbGVydDpmb2N1cyB7XFxuICAgICAgICBib3JkZXItY29sb3I6ICM4ODFmMGU7XFxuICAgICAgICBjb2xvcjogIzg4MWYwZTsgfVxcbiAgLmJ1dHRvbi5kaXNhYmxlZCwgLmJ1dHRvbltkaXNhYmxlZF0ge1xcbiAgICBvcGFjaXR5OiAwLjI1O1xcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkOyB9XFxuICAgIC5idXR0b24uZGlzYWJsZWQ6aG92ZXIsIC5idXR0b24uZGlzYWJsZWQ6Zm9jdXMsIC5idXR0b25bZGlzYWJsZWRdOmhvdmVyLCAuYnV0dG9uW2Rpc2FibGVkXTpmb2N1cyB7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzIxOTllODtcXG4gICAgICBjb2xvcjogI2ZlZmVmZTsgfVxcbiAgLmJ1dHRvbi5kcm9wZG93bjo6YWZ0ZXIge1xcbiAgICBjb250ZW50OiAnJztcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICAgIHdpZHRoOiAwO1xcbiAgICBoZWlnaHQ6IDA7XFxuICAgIGJvcmRlcjogaW5zZXQgMC40ZW07XFxuICAgIGJvcmRlci1jb2xvcjogI2ZlZmVmZSB0cmFuc3BhcmVudCB0cmFuc3BhcmVudDtcXG4gICAgYm9yZGVyLXRvcC1zdHlsZTogc29saWQ7XFxuICAgIGJvcmRlci1ib3R0b20td2lkdGg6IDA7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgdG9wOiAwLjRlbTtcXG4gICAgZmxvYXQ6IHJpZ2h0O1xcbiAgICBtYXJnaW4tbGVmdDogMWVtO1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IH1cXG4gIC5idXR0b24uYXJyb3ctb25seTo6YWZ0ZXIge1xcbiAgICBtYXJnaW4tbGVmdDogMDtcXG4gICAgZmxvYXQ6IG5vbmU7XFxuICAgIHRvcDogLTAuMWVtOyB9XFxuXFxuLmFjY29yZGlvbiB7XFxuICBsaXN0LXN0eWxlLXR5cGU6IG5vbmU7XFxuICBiYWNrZ3JvdW5kOiAjZmVmZWZlO1xcbiAgbWFyZ2luLWxlZnQ6IDA7IH1cXG5cXG4uYWNjb3JkaW9uLWl0ZW06Zmlyc3QtY2hpbGQgPiA6Zmlyc3QtY2hpbGQge1xcbiAgYm9yZGVyLXJhZGl1czogMCAwIDAgMDsgfVxcblxcbi5hY2NvcmRpb24taXRlbTpsYXN0LWNoaWxkID4gOmxhc3QtY2hpbGQge1xcbiAgYm9yZGVyLXJhZGl1czogMCAwIDAgMDsgfVxcblxcbi5hY2NvcmRpb24tdGl0bGUge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBwYWRkaW5nOiAxLjI1cmVtIDFyZW07XFxuICBsaW5lLWhlaWdodDogMTtcXG4gIGZvbnQtc2l6ZTogMC43NXJlbTtcXG4gIGNvbG9yOiAjMjE5OWU4O1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2U2ZTZlNjtcXG4gIGJvcmRlci1ib3R0b206IDA7IH1cXG4gIDpsYXN0LWNoaWxkOm5vdCguaXMtYWN0aXZlKSA+IC5hY2NvcmRpb24tdGl0bGUge1xcbiAgICBib3JkZXItcmFkaXVzOiAwIDAgMCAwO1xcbiAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2U2ZTZlNjsgfVxcbiAgLmFjY29yZGlvbi10aXRsZTpob3ZlciwgLmFjY29yZGlvbi10aXRsZTpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNlNmU2ZTY7IH1cXG4gIC5hY2NvcmRpb24tdGl0bGU6OmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6ICcrJztcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICByaWdodDogMXJlbTtcXG4gICAgdG9wOiA1MCU7XFxuICAgIG1hcmdpbi10b3A6IC0wLjVyZW07IH1cXG4gIC5pcy1hY3RpdmUgPiAuYWNjb3JkaW9uLXRpdGxlOjpiZWZvcmUge1xcbiAgICBjb250ZW50OiAnXFxcXDIwMTMnOyB9XFxuXFxuLmFjY29yZGlvbi1jb250ZW50IHtcXG4gIHBhZGRpbmc6IDFyZW07XFxuICBkaXNwbGF5OiBub25lO1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2U2ZTZlNjtcXG4gIGJvcmRlci1ib3R0b206IDA7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmVmZWZlO1xcbiAgY29sb3I6ICMwYTBhMGE7IH1cXG4gIDpsYXN0LWNoaWxkID4gLmFjY29yZGlvbi1jb250ZW50Omxhc3QtY2hpbGQge1xcbiAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2U2ZTZlNjsgfVxcblxcbi5pcy1hY2NvcmRpb24tc3VibWVudS1wYXJlbnQgPiBhIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTsgfVxcbiAgLmlzLWFjY29yZGlvbi1zdWJtZW51LXBhcmVudCA+IGE6OmFmdGVyIHtcXG4gICAgY29udGVudDogJyc7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICB3aWR0aDogMDtcXG4gICAgaGVpZ2h0OiAwO1xcbiAgICBib3JkZXI6IGluc2V0IDZweDtcXG4gICAgYm9yZGVyLWNvbG9yOiAjMjE5OWU4IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50O1xcbiAgICBib3JkZXItdG9wLXN0eWxlOiBzb2xpZDtcXG4gICAgYm9yZGVyLWJvdHRvbS13aWR0aDogMDtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDUwJTtcXG4gICAgbWFyZ2luLXRvcDogLTRweDtcXG4gICAgcmlnaHQ6IDFyZW07IH1cXG5cXG4uaXMtYWNjb3JkaW9uLXN1Ym1lbnUtcGFyZW50W2FyaWEtZXhwYW5kZWQ9J3RydWUnXSA+IGE6OmFmdGVyIHtcXG4gIHRyYW5zZm9ybS1vcmlnaW46IDUwJSA1MCU7XFxuICB0cmFuc2Zvcm06IHNjYWxlWSgtMSk7IH1cXG5cXG4uYmFkZ2Uge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgcGFkZGluZzogMC4zZW07XFxuICBtaW4td2lkdGg6IDIuMWVtO1xcbiAgZm9udC1zaXplOiAwLjZyZW07XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBib3JkZXItcmFkaXVzOiA1MCU7XFxuICBiYWNrZ3JvdW5kOiAjMjE5OWU4O1xcbiAgY29sb3I6ICNmZWZlZmU7IH1cXG4gIC5iYWRnZS5zZWNvbmRhcnkge1xcbiAgICBiYWNrZ3JvdW5kOiAjNzc3O1xcbiAgICBjb2xvcjogI2ZlZmVmZTsgfVxcbiAgLmJhZGdlLnN1Y2Nlc3Mge1xcbiAgICBiYWNrZ3JvdW5kOiAjM2FkYjc2O1xcbiAgICBjb2xvcjogI2ZlZmVmZTsgfVxcbiAgLmJhZGdlLndhcm5pbmcge1xcbiAgICBiYWNrZ3JvdW5kOiAjZmZhZTAwO1xcbiAgICBjb2xvcjogI2ZlZmVmZTsgfVxcbiAgLmJhZGdlLmFsZXJ0IHtcXG4gICAgYmFja2dyb3VuZDogI2VjNTg0MDtcXG4gICAgY29sb3I6ICNmZWZlZmU7IH1cXG5cXG4uYnJlYWRjcnVtYnMge1xcbiAgbGlzdC1zdHlsZTogbm9uZTtcXG4gIG1hcmdpbjogMCAwIDFyZW0gMDsgfVxcbiAgLmJyZWFkY3J1bWJzOjpiZWZvcmUsIC5icmVhZGNydW1iczo6YWZ0ZXIge1xcbiAgICBjb250ZW50OiAnICc7XFxuICAgIGRpc3BsYXk6IHRhYmxlOyB9XFxuICAuYnJlYWRjcnVtYnM6OmFmdGVyIHtcXG4gICAgY2xlYXI6IGJvdGg7IH1cXG4gIC5icmVhZGNydW1icyBsaSB7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbiAgICBjb2xvcjogIzBhMGEwYTtcXG4gICAgZm9udC1zaXplOiAwLjY4NzVyZW07XFxuICAgIGN1cnNvcjogZGVmYXVsdDtcXG4gICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTsgfVxcbiAgICAuYnJlYWRjcnVtYnMgbGk6bm90KDpsYXN0LWNoaWxkKTo6YWZ0ZXIge1xcbiAgICAgIGNvbG9yOiAjY2FjYWNhO1xcbiAgICAgIGNvbnRlbnQ6IFxcXCIvXFxcIjtcXG4gICAgICBtYXJnaW46IDAgMC43NXJlbTtcXG4gICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgICAgdG9wOiAxcHg7XFxuICAgICAgb3BhY2l0eTogMTsgfVxcbiAgLmJyZWFkY3J1bWJzIGEge1xcbiAgICBjb2xvcjogIzIxOTllODsgfVxcbiAgICAuYnJlYWRjcnVtYnMgYTpob3ZlciB7XFxuICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7IH1cXG4gIC5icmVhZGNydW1icyAuZGlzYWJsZWQge1xcbiAgICBjb2xvcjogI2NhY2FjYTtcXG4gICAgY3Vyc29yOiBub3QtYWxsb3dlZDsgfVxcblxcbi5idXR0b24tZ3JvdXAge1xcbiAgbWFyZ2luLWJvdHRvbTogMXJlbTtcXG4gIGZvbnQtc2l6ZTogMDsgfVxcbiAgLmJ1dHRvbi1ncm91cDo6YmVmb3JlLCAuYnV0dG9uLWdyb3VwOjphZnRlciB7XFxuICAgIGNvbnRlbnQ6ICcgJztcXG4gICAgZGlzcGxheTogdGFibGU7IH1cXG4gIC5idXR0b24tZ3JvdXA6OmFmdGVyIHtcXG4gICAgY2xlYXI6IGJvdGg7IH1cXG4gIC5idXR0b24tZ3JvdXAgLmJ1dHRvbiB7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAxcHg7XFxuICAgIG1hcmdpbi1ib3R0b206IDFweDtcXG4gICAgZm9udC1zaXplOiAwLjlyZW07IH1cXG4gICAgLmJ1dHRvbi1ncm91cCAuYnV0dG9uOmxhc3QtY2hpbGQge1xcbiAgICAgIG1hcmdpbi1yaWdodDogMDsgfVxcbiAgLmJ1dHRvbi1ncm91cC50aW55IC5idXR0b24ge1xcbiAgICBmb250LXNpemU6IDAuNnJlbTsgfVxcbiAgLmJ1dHRvbi1ncm91cC5zbWFsbCAuYnV0dG9uIHtcXG4gICAgZm9udC1zaXplOiAwLjc1cmVtOyB9XFxuICAuYnV0dG9uLWdyb3VwLmxhcmdlIC5idXR0b24ge1xcbiAgICBmb250LXNpemU6IDEuMjVyZW07IH1cXG4gIC5idXR0b24tZ3JvdXAuZXhwYW5kZWQge1xcbiAgICBtYXJnaW4tcmlnaHQ6IC0xcHg7IH1cXG4gICAgLmJ1dHRvbi1ncm91cC5leHBhbmRlZDo6YmVmb3JlLCAuYnV0dG9uLWdyb3VwLmV4cGFuZGVkOjphZnRlciB7XFxuICAgICAgZGlzcGxheTogbm9uZTsgfVxcbiAgICAuYnV0dG9uLWdyb3VwLmV4cGFuZGVkIC5idXR0b246Zmlyc3QtY2hpbGQ6bnRoLWxhc3QtY2hpbGQoMiksIC5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCgyKTpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCgyKSB+IC5idXR0b24ge1xcbiAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgICB3aWR0aDogY2FsYyg1MCUgLSAxcHgpO1xcbiAgICAgIG1hcmdpbi1yaWdodDogMXB4OyB9XFxuICAgICAgLmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDIpOmxhc3QtY2hpbGQsIC5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCgyKTpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCgyKSB+IC5idXR0b246bGFzdC1jaGlsZCB7XFxuICAgICAgICBtYXJnaW4tcmlnaHQ6IC02cHg7IH1cXG4gICAgLmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDMpLCAuYnV0dG9uLWdyb3VwLmV4cGFuZGVkIC5idXR0b246Zmlyc3QtY2hpbGQ6bnRoLWxhc3QtY2hpbGQoMyk6Zmlyc3QtY2hpbGQ6bnRoLWxhc3QtY2hpbGQoMykgfiAuYnV0dG9uIHtcXG4gICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgICAgd2lkdGg6IGNhbGMoMzMuMzMzMzMlIC0gMXB4KTtcXG4gICAgICBtYXJnaW4tcmlnaHQ6IDFweDsgfVxcbiAgICAgIC5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCgzKTpsYXN0LWNoaWxkLCAuYnV0dG9uLWdyb3VwLmV4cGFuZGVkIC5idXR0b246Zmlyc3QtY2hpbGQ6bnRoLWxhc3QtY2hpbGQoMyk6Zmlyc3QtY2hpbGQ6bnRoLWxhc3QtY2hpbGQoMykgfiAuYnV0dG9uOmxhc3QtY2hpbGQge1xcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAtNnB4OyB9XFxuICAgIC5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg0KSwgLmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDQpOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDQpIH4gLmJ1dHRvbiB7XFxuICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICAgIHdpZHRoOiBjYWxjKDI1JSAtIDFweCk7XFxuICAgICAgbWFyZ2luLXJpZ2h0OiAxcHg7IH1cXG4gICAgICAuYnV0dG9uLWdyb3VwLmV4cGFuZGVkIC5idXR0b246Zmlyc3QtY2hpbGQ6bnRoLWxhc3QtY2hpbGQoNCk6bGFzdC1jaGlsZCwgLmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDQpOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDQpIH4gLmJ1dHRvbjpsYXN0LWNoaWxkIHtcXG4gICAgICAgIG1hcmdpbi1yaWdodDogLTZweDsgfVxcbiAgICAuYnV0dG9uLWdyb3VwLmV4cGFuZGVkIC5idXR0b246Zmlyc3QtY2hpbGQ6bnRoLWxhc3QtY2hpbGQoNSksIC5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg1KTpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg1KSB+IC5idXR0b24ge1xcbiAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgICB3aWR0aDogY2FsYygyMCUgLSAxcHgpO1xcbiAgICAgIG1hcmdpbi1yaWdodDogMXB4OyB9XFxuICAgICAgLmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDUpOmxhc3QtY2hpbGQsIC5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg1KTpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg1KSB+IC5idXR0b246bGFzdC1jaGlsZCB7XFxuICAgICAgICBtYXJnaW4tcmlnaHQ6IC02cHg7IH1cXG4gICAgLmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDYpLCAuYnV0dG9uLWdyb3VwLmV4cGFuZGVkIC5idXR0b246Zmlyc3QtY2hpbGQ6bnRoLWxhc3QtY2hpbGQoNik6Zmlyc3QtY2hpbGQ6bnRoLWxhc3QtY2hpbGQoNikgfiAuYnV0dG9uIHtcXG4gICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgICAgd2lkdGg6IGNhbGMoMTYuNjY2NjclIC0gMXB4KTtcXG4gICAgICBtYXJnaW4tcmlnaHQ6IDFweDsgfVxcbiAgICAgIC5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg2KTpsYXN0LWNoaWxkLCAuYnV0dG9uLWdyb3VwLmV4cGFuZGVkIC5idXR0b246Zmlyc3QtY2hpbGQ6bnRoLWxhc3QtY2hpbGQoNik6Zmlyc3QtY2hpbGQ6bnRoLWxhc3QtY2hpbGQoNikgfiAuYnV0dG9uOmxhc3QtY2hpbGQge1xcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAtNnB4OyB9XFxuICAuYnV0dG9uLWdyb3VwLnByaW1hcnkgLmJ1dHRvbiB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMyMTk5ZTg7XFxuICAgIGNvbG9yOiAjZmVmZWZlOyB9XFxuICAgIC5idXR0b24tZ3JvdXAucHJpbWFyeSAuYnV0dG9uOmhvdmVyLCAuYnV0dG9uLWdyb3VwLnByaW1hcnkgLmJ1dHRvbjpmb2N1cyB7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzE0N2NjMDtcXG4gICAgICBjb2xvcjogI2ZlZmVmZTsgfVxcbiAgLmJ1dHRvbi1ncm91cC5zZWNvbmRhcnkgLmJ1dHRvbiB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICM3Nzc7XFxuICAgIGNvbG9yOiAjZmVmZWZlOyB9XFxuICAgIC5idXR0b24tZ3JvdXAuc2Vjb25kYXJ5IC5idXR0b246aG92ZXIsIC5idXR0b24tZ3JvdXAuc2Vjb25kYXJ5IC5idXR0b246Zm9jdXMge1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICM1ZjVmNWY7XFxuICAgICAgY29sb3I6ICNmZWZlZmU7IH1cXG4gIC5idXR0b24tZ3JvdXAuc3VjY2VzcyAuYnV0dG9uIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzNhZGI3NjtcXG4gICAgY29sb3I6ICNmZWZlZmU7IH1cXG4gICAgLmJ1dHRvbi1ncm91cC5zdWNjZXNzIC5idXR0b246aG92ZXIsIC5idXR0b24tZ3JvdXAuc3VjY2VzcyAuYnV0dG9uOmZvY3VzIHtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjJiYjViO1xcbiAgICAgIGNvbG9yOiAjZmVmZWZlOyB9XFxuICAuYnV0dG9uLWdyb3VwLndhcm5pbmcgLmJ1dHRvbiB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmFlMDA7XFxuICAgIGNvbG9yOiAjZmVmZWZlOyB9XFxuICAgIC5idXR0b24tZ3JvdXAud2FybmluZyAuYnV0dG9uOmhvdmVyLCAuYnV0dG9uLWdyb3VwLndhcm5pbmcgLmJ1dHRvbjpmb2N1cyB7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2NjOGIwMDtcXG4gICAgICBjb2xvcjogI2ZlZmVmZTsgfVxcbiAgLmJ1dHRvbi1ncm91cC5hbGVydCAuYnV0dG9uIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2VjNTg0MDtcXG4gICAgY29sb3I6ICNmZWZlZmU7IH1cXG4gICAgLmJ1dHRvbi1ncm91cC5hbGVydCAuYnV0dG9uOmhvdmVyLCAuYnV0dG9uLWdyb3VwLmFsZXJ0IC5idXR0b246Zm9jdXMge1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICNkYTMxMTY7XFxuICAgICAgY29sb3I6ICNmZWZlZmU7IH1cXG4gIC5idXR0b24tZ3JvdXAuc3RhY2tlZCAuYnV0dG9uLCAuYnV0dG9uLWdyb3VwLnN0YWNrZWQtZm9yLXNtYWxsIC5idXR0b24sIC5idXR0b24tZ3JvdXAuc3RhY2tlZC1mb3ItbWVkaXVtIC5idXR0b24ge1xcbiAgICB3aWR0aDogMTAwJTsgfVxcbiAgICAuYnV0dG9uLWdyb3VwLnN0YWNrZWQgLmJ1dHRvbjpsYXN0LWNoaWxkLCAuYnV0dG9uLWdyb3VwLnN0YWNrZWQtZm9yLXNtYWxsIC5idXR0b246bGFzdC1jaGlsZCwgLmJ1dHRvbi1ncm91cC5zdGFja2VkLWZvci1tZWRpdW0gLmJ1dHRvbjpsYXN0LWNoaWxkIHtcXG4gICAgICBtYXJnaW4tYm90dG9tOiAwOyB9XFxuICBAbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA0MGVtKSB7XFxuICAgIC5idXR0b24tZ3JvdXAuc3RhY2tlZC1mb3Itc21hbGwgLmJ1dHRvbiB7XFxuICAgICAgd2lkdGg6IGF1dG87XFxuICAgICAgbWFyZ2luLWJvdHRvbTogMDsgfSB9XFxuICBAbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA2NGVtKSB7XFxuICAgIC5idXR0b24tZ3JvdXAuc3RhY2tlZC1mb3ItbWVkaXVtIC5idXR0b24ge1xcbiAgICAgIHdpZHRoOiBhdXRvO1xcbiAgICAgIG1hcmdpbi1ib3R0b206IDA7IH0gfVxcbiAgQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogMzkuOTM3NWVtKSB7XFxuICAgIC5idXR0b24tZ3JvdXAuc3RhY2tlZC1mb3Itc21hbGwuZXhwYW5kZWQge1xcbiAgICAgIGRpc3BsYXk6IGJsb2NrOyB9XFxuICAgICAgLmJ1dHRvbi1ncm91cC5zdGFja2VkLWZvci1zbWFsbC5leHBhbmRlZCAuYnV0dG9uIHtcXG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAwOyB9IH1cXG5cXG4uY2FsbG91dCB7XFxuICBtYXJnaW46IDAgMCAxcmVtIDA7XFxuICBwYWRkaW5nOiAxcmVtO1xcbiAgYm9yZGVyOiAxcHggc29saWQgcmdiYSgxMCwgMTAsIDEwLCAwLjI1KTtcXG4gIGJvcmRlci1yYWRpdXM6IDA7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBjb2xvcjogIzBhMGEwYTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlOyB9XFxuICAuY2FsbG91dCA+IDpmaXJzdC1jaGlsZCB7XFxuICAgIG1hcmdpbi10b3A6IDA7IH1cXG4gIC5jYWxsb3V0ID4gOmxhc3QtY2hpbGQge1xcbiAgICBtYXJnaW4tYm90dG9tOiAwOyB9XFxuICAuY2FsbG91dC5wcmltYXJ5IHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2RlZjBmYzsgfVxcbiAgLmNhbGxvdXQuc2Vjb25kYXJ5IHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ViZWJlYjsgfVxcbiAgLmNhbGxvdXQuc3VjY2VzcyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNlMWZhZWE7IH1cXG4gIC5jYWxsb3V0Lndhcm5pbmcge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmM2Q5OyB9XFxuICAuY2FsbG91dC5hbGVydCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmY2U2ZTI7IH1cXG4gIC5jYWxsb3V0LnNtYWxsIHtcXG4gICAgcGFkZGluZy10b3A6IDAuNXJlbTtcXG4gICAgcGFkZGluZy1yaWdodDogMC41cmVtO1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMC41cmVtO1xcbiAgICBwYWRkaW5nLWxlZnQ6IDAuNXJlbTsgfVxcbiAgLmNhbGxvdXQubGFyZ2Uge1xcbiAgICBwYWRkaW5nLXRvcDogM3JlbTtcXG4gICAgcGFkZGluZy1yaWdodDogM3JlbTtcXG4gICAgcGFkZGluZy1ib3R0b206IDNyZW07XFxuICAgIHBhZGRpbmctbGVmdDogM3JlbTsgfVxcblxcbi5jbG9zZS1idXR0b24ge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgY29sb3I6ICM4YThhOGE7XFxuICByaWdodDogMXJlbTtcXG4gIHRvcDogMC41cmVtO1xcbiAgZm9udC1zaXplOiAyZW07XFxuICBsaW5lLWhlaWdodDogMTtcXG4gIGN1cnNvcjogcG9pbnRlcjsgfVxcbiAgW2RhdGEtd2hhdGlucHV0PSdtb3VzZSddIC5jbG9zZS1idXR0b24ge1xcbiAgICBvdXRsaW5lOiAwOyB9XFxuICAuY2xvc2UtYnV0dG9uOmhvdmVyLCAuY2xvc2UtYnV0dG9uOmZvY3VzIHtcXG4gICAgY29sb3I6ICMwYTBhMGE7IH1cXG5cXG4ubWVudSB7XFxuICBtYXJnaW46IDA7XFxuICBsaXN0LXN0eWxlLXR5cGU6IG5vbmU7IH1cXG4gIC5tZW51ID4gbGkge1xcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOyB9XFxuICAgIFtkYXRhLXdoYXRpbnB1dD0nbW91c2UnXSAubWVudSA+IGxpIHtcXG4gICAgICBvdXRsaW5lOiAwOyB9XFxuICAubWVudSA+IGxpID4gYSB7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICBwYWRkaW5nOiAwLjdyZW0gMXJlbTtcXG4gICAgbGluZS1oZWlnaHQ6IDE7IH1cXG4gIC5tZW51IGlucHV0LFxcbiAgLm1lbnUgYSxcXG4gIC5tZW51IGJ1dHRvbiB7XFxuICAgIG1hcmdpbi1ib3R0b206IDA7IH1cXG4gIC5tZW51ID4gbGkgPiBhIGltZyxcXG4gIC5tZW51ID4gbGkgPiBhIGksXFxuICAubWVudSA+IGxpID4gYSBzdmcge1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOyB9XFxuICAgIC5tZW51ID4gbGkgPiBhIGltZyArIHNwYW4sXFxuICAgIC5tZW51ID4gbGkgPiBhIGkgKyBzcGFuLFxcbiAgICAubWVudSA+IGxpID4gYSBzdmcgKyBzcGFuIHtcXG4gICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOyB9XFxuICAubWVudSA+IGxpID4gYSBpbWcsXFxuICAubWVudSA+IGxpID4gYSBpLFxcbiAgLm1lbnUgPiBsaSA+IGEgc3ZnIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAwLjI1cmVtO1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IH1cXG4gIC5tZW51ID4gbGkge1xcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsOyB9XFxuICAubWVudS52ZXJ0aWNhbCA+IGxpIHtcXG4gICAgZGlzcGxheTogYmxvY2s7IH1cXG4gIEBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDQwZW0pIHtcXG4gICAgLm1lbnUubWVkaXVtLWhvcml6b250YWwgPiBsaSB7XFxuICAgICAgZGlzcGxheTogdGFibGUtY2VsbDsgfVxcbiAgICAubWVudS5tZWRpdW0tdmVydGljYWwgPiBsaSB7XFxuICAgICAgZGlzcGxheTogYmxvY2s7IH0gfVxcbiAgQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNjRlbSkge1xcbiAgICAubWVudS5sYXJnZS1ob3Jpem9udGFsID4gbGkge1xcbiAgICAgIGRpc3BsYXk6IHRhYmxlLWNlbGw7IH1cXG4gICAgLm1lbnUubGFyZ2UtdmVydGljYWwgPiBsaSB7XFxuICAgICAgZGlzcGxheTogYmxvY2s7IH0gfVxcbiAgLm1lbnUuc2ltcGxlIGxpIHtcXG4gICAgbGluZS1oZWlnaHQ6IDE7XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgbWFyZ2luLXJpZ2h0OiAxcmVtOyB9XFxuICAubWVudS5zaW1wbGUgYSB7XFxuICAgIHBhZGRpbmc6IDA7IH1cXG4gIC5tZW51LmFsaWduLXJpZ2h0OjpiZWZvcmUsIC5tZW51LmFsaWduLXJpZ2h0OjphZnRlciB7XFxuICAgIGNvbnRlbnQ6ICcgJztcXG4gICAgZGlzcGxheTogdGFibGU7IH1cXG4gIC5tZW51LmFsaWduLXJpZ2h0OjphZnRlciB7XFxuICAgIGNsZWFyOiBib3RoOyB9XFxuICAubWVudS5hbGlnbi1yaWdodCA+IGxpIHtcXG4gICAgZmxvYXQ6IHJpZ2h0OyB9XFxuICAubWVudS5leHBhbmRlZCB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBkaXNwbGF5OiB0YWJsZTtcXG4gICAgdGFibGUtbGF5b3V0OiBmaXhlZDsgfVxcbiAgICAubWVudS5leHBhbmRlZCA+IGxpOmZpcnN0LWNoaWxkOmxhc3QtY2hpbGQge1xcbiAgICAgIHdpZHRoOiAxMDAlOyB9XFxuICAubWVudS5pY29uLXRvcCA+IGxpID4gYSB7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjsgfVxcbiAgICAubWVudS5pY29uLXRvcCA+IGxpID4gYSBpbWcsXFxuICAgIC5tZW51Lmljb24tdG9wID4gbGkgPiBhIGksXFxuICAgIC5tZW51Lmljb24tdG9wID4gbGkgPiBhIHN2ZyB7XFxuICAgICAgZGlzcGxheTogYmxvY2s7XFxuICAgICAgbWFyZ2luOiAwIGF1dG8gMC4yNXJlbTsgfVxcbiAgLm1lbnUubmVzdGVkIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDFyZW07IH1cXG4gIC5tZW51IC5hY3RpdmUgPiBhIHtcXG4gICAgY29sb3I6ICNmZWZlZmU7XFxuICAgIGJhY2tncm91bmQ6ICMyMTk5ZTg7IH1cXG5cXG4ubWVudS10ZXh0IHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgY29sb3I6IGluaGVyaXQ7XFxuICBsaW5lLWhlaWdodDogMTtcXG4gIHBhZGRpbmctdG9wOiAwO1xcbiAgcGFkZGluZy1ib3R0b206IDA7XFxuICBwYWRkaW5nOiAwLjdyZW0gMXJlbTsgfVxcblxcbi5tZW51LWNlbnRlcmVkIHtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjsgfVxcbiAgLm1lbnUtY2VudGVyZWQgPiAubWVudSB7XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jazsgfVxcblxcbi5uby1qcyBbZGF0YS1yZXNwb25zaXZlLW1lbnVdIHVsIHtcXG4gIGRpc3BsYXk6IG5vbmU7IH1cXG5cXG4ubWVudS1pY29uIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICB3aWR0aDogMjBweDtcXG4gIGhlaWdodDogMTZweDsgfVxcbiAgLm1lbnUtaWNvbjo6YWZ0ZXIge1xcbiAgICBjb250ZW50OiAnJztcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMnB4O1xcbiAgICBiYWNrZ3JvdW5kOiAjZmVmZWZlO1xcbiAgICB0b3A6IDA7XFxuICAgIGxlZnQ6IDA7XFxuICAgIGJveC1zaGFkb3c6IDAgN3B4IDAgI2ZlZmVmZSwgMCAxNHB4IDAgI2ZlZmVmZTsgfVxcbiAgLm1lbnUtaWNvbjpob3Zlcjo6YWZ0ZXIge1xcbiAgICBiYWNrZ3JvdW5kOiAjY2FjYWNhO1xcbiAgICBib3gtc2hhZG93OiAwIDdweCAwICNjYWNhY2EsIDAgMTRweCAwICNjYWNhY2E7IH1cXG5cXG4ubWVudS1pY29uLmRhcmsge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIHdpZHRoOiAyMHB4O1xcbiAgaGVpZ2h0OiAxNnB4OyB9XFxuICAubWVudS1pY29uLmRhcms6OmFmdGVyIHtcXG4gICAgY29udGVudDogJyc7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDJweDtcXG4gICAgYmFja2dyb3VuZDogIzBhMGEwYTtcXG4gICAgdG9wOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICBib3gtc2hhZG93OiAwIDdweCAwICMwYTBhMGEsIDAgMTRweCAwICMwYTBhMGE7IH1cXG4gIC5tZW51LWljb24uZGFyazpob3Zlcjo6YWZ0ZXIge1xcbiAgICBiYWNrZ3JvdW5kOiAjOGE4YThhO1xcbiAgICBib3gtc2hhZG93OiAwIDdweCAwICM4YThhOGEsIDAgMTRweCAwICM4YThhOGE7IH1cXG5cXG4uaXMtZHJpbGxkb3duIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIG92ZXJmbG93OiBoaWRkZW47IH1cXG4gIC5pcy1kcmlsbGRvd24gbGkge1xcbiAgICBkaXNwbGF5OiBibG9jayAhaW1wb3J0YW50OyB9XFxuXFxuLmlzLWRyaWxsZG93bi1zdWJtZW51IHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDEwMCU7XFxuICB6LWluZGV4OiAtMTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgYmFja2dyb3VuZDogI2ZlZmVmZTtcXG4gIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjE1cyBsaW5lYXI7IH1cXG4gIC5pcy1kcmlsbGRvd24tc3VibWVudS5pcy1hY3RpdmUge1xcbiAgICB6LWluZGV4OiAxO1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC0xMDAlKTsgfVxcbiAgLmlzLWRyaWxsZG93bi1zdWJtZW51LmlzLWNsb3Npbmcge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMTAwJSk7IH1cXG5cXG4uaXMtZHJpbGxkb3duLXN1Ym1lbnUtcGFyZW50ID4gYSB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7IH1cXG4gIC5pcy1kcmlsbGRvd24tc3VibWVudS1wYXJlbnQgPiBhOjphZnRlciB7XFxuICAgIGNvbnRlbnQ6ICcnO1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgd2lkdGg6IDA7XFxuICAgIGhlaWdodDogMDtcXG4gICAgYm9yZGVyOiBpbnNldCA2cHg7XFxuICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgIzIxOTllODtcXG4gICAgYm9yZGVyLWxlZnQtc3R5bGU6IHNvbGlkO1xcbiAgICBib3JkZXItcmlnaHQtd2lkdGg6IDA7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiA1MCU7XFxuICAgIG1hcmdpbi10b3A6IC02cHg7XFxuICAgIHJpZ2h0OiAxcmVtOyB9XFxuXFxuLmpzLWRyaWxsZG93bi1iYWNrID4gYTo6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6ICcnO1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICB3aWR0aDogMDtcXG4gIGhlaWdodDogMDtcXG4gIGJvcmRlcjogaW5zZXQgNnB4O1xcbiAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudCAjMjE5OWU4IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50O1xcbiAgYm9yZGVyLXJpZ2h0LXN0eWxlOiBzb2xpZDtcXG4gIGJvcmRlci1sZWZ0LXdpZHRoOiAwO1xcbiAgYm9yZGVyLWxlZnQtd2lkdGg6IDA7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgbWFyZ2luLXJpZ2h0OiAwLjc1cmVtOyB9XFxuXFxuLmRyb3Bkb3duLXBhbmUge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZlZmVmZTtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNjYWNhY2E7XFxuICBib3JkZXItcmFkaXVzOiAwO1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBmb250LXNpemU6IDFyZW07XFxuICBwYWRkaW5nOiAxcmVtO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgd2lkdGg6IDMwMHB4O1xcbiAgei1pbmRleDogMTA7IH1cXG4gIC5kcm9wZG93bi1wYW5lLmlzLW9wZW4ge1xcbiAgICB2aXNpYmlsaXR5OiB2aXNpYmxlOyB9XFxuXFxuLmRyb3Bkb3duLXBhbmUudGlueSB7XFxuICB3aWR0aDogMTAwcHg7IH1cXG5cXG4uZHJvcGRvd24tcGFuZS5zbWFsbCB7XFxuICB3aWR0aDogMjAwcHg7IH1cXG5cXG4uZHJvcGRvd24tcGFuZS5sYXJnZSB7XFxuICB3aWR0aDogNDAwcHg7IH1cXG5cXG4uZHJvcGRvd24ubWVudSA+IGxpLm9wZW5zLWxlZnQgPiAuaXMtZHJvcGRvd24tc3VibWVudSB7XFxuICBsZWZ0OiBhdXRvO1xcbiAgcmlnaHQ6IDA7XFxuICB0b3A6IDEwMCU7IH1cXG5cXG4uZHJvcGRvd24ubWVudSA+IGxpLm9wZW5zLXJpZ2h0ID4gLmlzLWRyb3Bkb3duLXN1Ym1lbnUge1xcbiAgcmlnaHQ6IGF1dG87XFxuICBsZWZ0OiAwO1xcbiAgdG9wOiAxMDAlOyB9XFxuXFxuLmRyb3Bkb3duLm1lbnUgPiBsaS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudCA+IGEge1xcbiAgcGFkZGluZy1yaWdodDogMS41cmVtO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlOyB9XFxuXFxuLmRyb3Bkb3duLm1lbnUgPiBsaS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudCA+IGE6OmFmdGVyIHtcXG4gIGNvbnRlbnQ6ICcnO1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICB3aWR0aDogMDtcXG4gIGhlaWdodDogMDtcXG4gIGJvcmRlcjogaW5zZXQgNXB4O1xcbiAgYm9yZGVyLWNvbG9yOiAjMjE5OWU4IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50O1xcbiAgYm9yZGVyLXRvcC1zdHlsZTogc29saWQ7XFxuICBib3JkZXItYm90dG9tLXdpZHRoOiAwO1xcbiAgcmlnaHQ6IDVweDtcXG4gIG1hcmdpbi10b3A6IC0ycHg7IH1cXG5cXG5bZGF0YS13aGF0aW5wdXQ9J21vdXNlJ10gLmRyb3Bkb3duLm1lbnUgYSB7XFxuICBvdXRsaW5lOiAwOyB9XFxuXFxuLm5vLWpzIC5kcm9wZG93bi5tZW51IHVsIHtcXG4gIGRpc3BsYXk6IG5vbmU7IH1cXG5cXG4uZHJvcGRvd24ubWVudS52ZXJ0aWNhbCA+IGxpIC5pcy1kcm9wZG93bi1zdWJtZW51IHtcXG4gIHRvcDogMDsgfVxcblxcbi5kcm9wZG93bi5tZW51LnZlcnRpY2FsID4gbGkub3BlbnMtbGVmdCA+IC5pcy1kcm9wZG93bi1zdWJtZW51IHtcXG4gIGxlZnQ6IGF1dG87XFxuICByaWdodDogMTAwJTsgfVxcblxcbi5kcm9wZG93bi5tZW51LnZlcnRpY2FsID4gbGkub3BlbnMtcmlnaHQgPiAuaXMtZHJvcGRvd24tc3VibWVudSB7XFxuICByaWdodDogYXV0bztcXG4gIGxlZnQ6IDEwMCU7IH1cXG5cXG4uZHJvcGRvd24ubWVudS52ZXJ0aWNhbCA+IGxpID4gYTo6YWZ0ZXIge1xcbiAgcmlnaHQ6IDE0cHg7XFxuICBtYXJnaW4tdG9wOiAtM3B4OyB9XFxuXFxuLmRyb3Bkb3duLm1lbnUudmVydGljYWwgPiBsaS5vcGVucy1sZWZ0ID4gYTo6YWZ0ZXIge1xcbiAgY29udGVudDogJyc7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHdpZHRoOiAwO1xcbiAgaGVpZ2h0OiAwO1xcbiAgYm9yZGVyOiBpbnNldCA1cHg7XFxuICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50ICMyMTk5ZTggdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQ7XFxuICBib3JkZXItcmlnaHQtc3R5bGU6IHNvbGlkO1xcbiAgYm9yZGVyLWxlZnQtd2lkdGg6IDA7IH1cXG5cXG4uZHJvcGRvd24ubWVudS52ZXJ0aWNhbCA+IGxpLm9wZW5zLXJpZ2h0ID4gYTo6YWZ0ZXIge1xcbiAgY29udGVudDogJyc7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHdpZHRoOiAwO1xcbiAgaGVpZ2h0OiAwO1xcbiAgYm9yZGVyOiBpbnNldCA1cHg7XFxuICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50ICMyMTk5ZTg7XFxuICBib3JkZXItbGVmdC1zdHlsZTogc29saWQ7XFxuICBib3JkZXItcmlnaHQtd2lkdGg6IDA7IH1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA0MGVtKSB7XFxuICAuZHJvcGRvd24ubWVudS5tZWRpdW0taG9yaXpvbnRhbCA+IGxpLm9wZW5zLWxlZnQgPiAuaXMtZHJvcGRvd24tc3VibWVudSB7XFxuICAgIGxlZnQ6IGF1dG87XFxuICAgIHJpZ2h0OiAwO1xcbiAgICB0b3A6IDEwMCU7IH1cXG4gIC5kcm9wZG93bi5tZW51Lm1lZGl1bS1ob3Jpem9udGFsID4gbGkub3BlbnMtcmlnaHQgPiAuaXMtZHJvcGRvd24tc3VibWVudSB7XFxuICAgIHJpZ2h0OiBhdXRvO1xcbiAgICBsZWZ0OiAwO1xcbiAgICB0b3A6IDEwMCU7IH1cXG4gIC5kcm9wZG93bi5tZW51Lm1lZGl1bS1ob3Jpem9udGFsID4gbGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQgPiBhIHtcXG4gICAgcGFkZGluZy1yaWdodDogMS41cmVtO1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7IH1cXG4gIC5kcm9wZG93bi5tZW51Lm1lZGl1bS1ob3Jpem9udGFsID4gbGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQgPiBhOjphZnRlciB7XFxuICAgIGNvbnRlbnQ6ICcnO1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgd2lkdGg6IDA7XFxuICAgIGhlaWdodDogMDtcXG4gICAgYm9yZGVyOiBpbnNldCA1cHg7XFxuICAgIGJvcmRlci1jb2xvcjogIzIxOTllOCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudDtcXG4gICAgYm9yZGVyLXRvcC1zdHlsZTogc29saWQ7XFxuICAgIGJvcmRlci1ib3R0b20td2lkdGg6IDA7XFxuICAgIHJpZ2h0OiA1cHg7XFxuICAgIG1hcmdpbi10b3A6IC0ycHg7IH1cXG4gIC5kcm9wZG93bi5tZW51Lm1lZGl1bS12ZXJ0aWNhbCA+IGxpIC5pcy1kcm9wZG93bi1zdWJtZW51IHtcXG4gICAgdG9wOiAwOyB9XFxuICAuZHJvcGRvd24ubWVudS5tZWRpdW0tdmVydGljYWwgPiBsaS5vcGVucy1sZWZ0ID4gLmlzLWRyb3Bkb3duLXN1Ym1lbnUge1xcbiAgICBsZWZ0OiBhdXRvO1xcbiAgICByaWdodDogMTAwJTsgfVxcbiAgLmRyb3Bkb3duLm1lbnUubWVkaXVtLXZlcnRpY2FsID4gbGkub3BlbnMtcmlnaHQgPiAuaXMtZHJvcGRvd24tc3VibWVudSB7XFxuICAgIHJpZ2h0OiBhdXRvO1xcbiAgICBsZWZ0OiAxMDAlOyB9XFxuICAuZHJvcGRvd24ubWVudS5tZWRpdW0tdmVydGljYWwgPiBsaSA+IGE6OmFmdGVyIHtcXG4gICAgcmlnaHQ6IDE0cHg7XFxuICAgIG1hcmdpbi10b3A6IC0zcHg7IH1cXG4gIC5kcm9wZG93bi5tZW51Lm1lZGl1bS12ZXJ0aWNhbCA+IGxpLm9wZW5zLWxlZnQgPiBhOjphZnRlciB7XFxuICAgIGNvbnRlbnQ6ICcnO1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgd2lkdGg6IDA7XFxuICAgIGhlaWdodDogMDtcXG4gICAgYm9yZGVyOiBpbnNldCA1cHg7XFxuICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQgIzIxOTllOCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudDtcXG4gICAgYm9yZGVyLXJpZ2h0LXN0eWxlOiBzb2xpZDtcXG4gICAgYm9yZGVyLWxlZnQtd2lkdGg6IDA7IH1cXG4gIC5kcm9wZG93bi5tZW51Lm1lZGl1bS12ZXJ0aWNhbCA+IGxpLm9wZW5zLXJpZ2h0ID4gYTo6YWZ0ZXIge1xcbiAgICBjb250ZW50OiAnJztcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICAgIHdpZHRoOiAwO1xcbiAgICBoZWlnaHQ6IDA7XFxuICAgIGJvcmRlcjogaW5zZXQgNXB4O1xcbiAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50ICMyMTk5ZTg7XFxuICAgIGJvcmRlci1sZWZ0LXN0eWxlOiBzb2xpZDtcXG4gICAgYm9yZGVyLXJpZ2h0LXdpZHRoOiAwOyB9IH1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA2NGVtKSB7XFxuICAuZHJvcGRvd24ubWVudS5sYXJnZS1ob3Jpem9udGFsID4gbGkub3BlbnMtbGVmdCA+IC5pcy1kcm9wZG93bi1zdWJtZW51IHtcXG4gICAgbGVmdDogYXV0bztcXG4gICAgcmlnaHQ6IDA7XFxuICAgIHRvcDogMTAwJTsgfVxcbiAgLmRyb3Bkb3duLm1lbnUubGFyZ2UtaG9yaXpvbnRhbCA+IGxpLm9wZW5zLXJpZ2h0ID4gLmlzLWRyb3Bkb3duLXN1Ym1lbnUge1xcbiAgICByaWdodDogYXV0bztcXG4gICAgbGVmdDogMDtcXG4gICAgdG9wOiAxMDAlOyB9XFxuICAuZHJvcGRvd24ubWVudS5sYXJnZS1ob3Jpem9udGFsID4gbGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQgPiBhIHtcXG4gICAgcGFkZGluZy1yaWdodDogMS41cmVtO1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7IH1cXG4gIC5kcm9wZG93bi5tZW51LmxhcmdlLWhvcml6b250YWwgPiBsaS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudCA+IGE6OmFmdGVyIHtcXG4gICAgY29udGVudDogJyc7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICB3aWR0aDogMDtcXG4gICAgaGVpZ2h0OiAwO1xcbiAgICBib3JkZXI6IGluc2V0IDVweDtcXG4gICAgYm9yZGVyLWNvbG9yOiAjMjE5OWU4IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50O1xcbiAgICBib3JkZXItdG9wLXN0eWxlOiBzb2xpZDtcXG4gICAgYm9yZGVyLWJvdHRvbS13aWR0aDogMDtcXG4gICAgcmlnaHQ6IDVweDtcXG4gICAgbWFyZ2luLXRvcDogLTJweDsgfVxcbiAgLmRyb3Bkb3duLm1lbnUubGFyZ2UtdmVydGljYWwgPiBsaSAuaXMtZHJvcGRvd24tc3VibWVudSB7XFxuICAgIHRvcDogMDsgfVxcbiAgLmRyb3Bkb3duLm1lbnUubGFyZ2UtdmVydGljYWwgPiBsaS5vcGVucy1sZWZ0ID4gLmlzLWRyb3Bkb3duLXN1Ym1lbnUge1xcbiAgICBsZWZ0OiBhdXRvO1xcbiAgICByaWdodDogMTAwJTsgfVxcbiAgLmRyb3Bkb3duLm1lbnUubGFyZ2UtdmVydGljYWwgPiBsaS5vcGVucy1yaWdodCA+IC5pcy1kcm9wZG93bi1zdWJtZW51IHtcXG4gICAgcmlnaHQ6IGF1dG87XFxuICAgIGxlZnQ6IDEwMCU7IH1cXG4gIC5kcm9wZG93bi5tZW51LmxhcmdlLXZlcnRpY2FsID4gbGkgPiBhOjphZnRlciB7XFxuICAgIHJpZ2h0OiAxNHB4O1xcbiAgICBtYXJnaW4tdG9wOiAtM3B4OyB9XFxuICAuZHJvcGRvd24ubWVudS5sYXJnZS12ZXJ0aWNhbCA+IGxpLm9wZW5zLWxlZnQgPiBhOjphZnRlciB7XFxuICAgIGNvbnRlbnQ6ICcnO1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgd2lkdGg6IDA7XFxuICAgIGhlaWdodDogMDtcXG4gICAgYm9yZGVyOiBpbnNldCA1cHg7XFxuICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQgIzIxOTllOCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudDtcXG4gICAgYm9yZGVyLXJpZ2h0LXN0eWxlOiBzb2xpZDtcXG4gICAgYm9yZGVyLWxlZnQtd2lkdGg6IDA7IH1cXG4gIC5kcm9wZG93bi5tZW51LmxhcmdlLXZlcnRpY2FsID4gbGkub3BlbnMtcmlnaHQgPiBhOjphZnRlciB7XFxuICAgIGNvbnRlbnQ6ICcnO1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgd2lkdGg6IDA7XFxuICAgIGhlaWdodDogMDtcXG4gICAgYm9yZGVyOiBpbnNldCA1cHg7XFxuICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgIzIxOTllODtcXG4gICAgYm9yZGVyLWxlZnQtc3R5bGU6IHNvbGlkO1xcbiAgICBib3JkZXItcmlnaHQtd2lkdGg6IDA7IH0gfVxcblxcbi5kcm9wZG93bi5tZW51LmFsaWduLXJpZ2h0IC5pcy1kcm9wZG93bi1zdWJtZW51LmZpcnN0LXN1YiB7XFxuICB0b3A6IDEwMCU7XFxuICBsZWZ0OiBhdXRvO1xcbiAgcmlnaHQ6IDA7IH1cXG5cXG4uaXMtZHJvcGRvd24tbWVudS52ZXJ0aWNhbCB7XFxuICB3aWR0aDogMTAwcHg7IH1cXG4gIC5pcy1kcm9wZG93bi1tZW51LnZlcnRpY2FsLmFsaWduLXJpZ2h0IHtcXG4gICAgZmxvYXQ6IHJpZ2h0OyB9XFxuXFxuLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50IHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTsgfVxcbiAgLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50IGE6OmFmdGVyIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDUwJTtcXG4gICAgcmlnaHQ6IDVweDtcXG4gICAgbWFyZ2luLXRvcDogLTJweDsgfVxcbiAgLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50Lm9wZW5zLWlubmVyID4gLmlzLWRyb3Bkb3duLXN1Ym1lbnUge1xcbiAgICB0b3A6IDEwMCU7XFxuICAgIGxlZnQ6IGF1dG87IH1cXG4gIC5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudC5vcGVucy1sZWZ0ID4gLmlzLWRyb3Bkb3duLXN1Ym1lbnUge1xcbiAgICBsZWZ0OiBhdXRvO1xcbiAgICByaWdodDogMTAwJTsgfVxcbiAgLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50Lm9wZW5zLXJpZ2h0ID4gLmlzLWRyb3Bkb3duLXN1Ym1lbnUge1xcbiAgICByaWdodDogYXV0bztcXG4gICAgbGVmdDogMTAwJTsgfVxcblxcbi5pcy1kcm9wZG93bi1zdWJtZW51IHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAxMDAlO1xcbiAgbWluLXdpZHRoOiAyMDBweDtcXG4gIHotaW5kZXg6IDE7XFxuICBiYWNrZ3JvdW5kOiAjZmVmZWZlO1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2NhY2FjYTsgfVxcbiAgLmlzLWRyb3Bkb3duLXN1Ym1lbnUgLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50ID4gYTo6YWZ0ZXIge1xcbiAgICByaWdodDogMTRweDtcXG4gICAgbWFyZ2luLXRvcDogLTNweDsgfVxcbiAgLmlzLWRyb3Bkb3duLXN1Ym1lbnUgLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50Lm9wZW5zLWxlZnQgPiBhOjphZnRlciB7XFxuICAgIGNvbnRlbnQ6ICcnO1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgd2lkdGg6IDA7XFxuICAgIGhlaWdodDogMDtcXG4gICAgYm9yZGVyOiBpbnNldCA1cHg7XFxuICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQgIzIxOTllOCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudDtcXG4gICAgYm9yZGVyLXJpZ2h0LXN0eWxlOiBzb2xpZDtcXG4gICAgYm9yZGVyLWxlZnQtd2lkdGg6IDA7IH1cXG4gIC5pcy1kcm9wZG93bi1zdWJtZW51IC5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudC5vcGVucy1yaWdodCA+IGE6OmFmdGVyIHtcXG4gICAgY29udGVudDogJyc7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICB3aWR0aDogMDtcXG4gICAgaGVpZ2h0OiAwO1xcbiAgICBib3JkZXI6IGluc2V0IDVweDtcXG4gICAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudCAjMjE5OWU4O1xcbiAgICBib3JkZXItbGVmdC1zdHlsZTogc29saWQ7XFxuICAgIGJvcmRlci1yaWdodC13aWR0aDogMDsgfVxcbiAgLmlzLWRyb3Bkb3duLXN1Ym1lbnUgLmlzLWRyb3Bkb3duLXN1Ym1lbnUge1xcbiAgICBtYXJnaW4tdG9wOiAtMXB4OyB9XFxuICAuaXMtZHJvcGRvd24tc3VibWVudSA+IGxpIHtcXG4gICAgd2lkdGg6IDEwMCU7IH1cXG4gIC5pcy1kcm9wZG93bi1zdWJtZW51LmpzLWRyb3Bkb3duLWFjdGl2ZSB7XFxuICAgIGRpc3BsYXk6IGJsb2NrOyB9XFxuXFxuLmZsZXgtdmlkZW8ge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgaGVpZ2h0OiAwO1xcbiAgcGFkZGluZy1ib3R0b206IDc1JTtcXG4gIG1hcmdpbi1ib3R0b206IDFyZW07XFxuICBvdmVyZmxvdzogaGlkZGVuOyB9XFxuICAuZmxleC12aWRlbyBpZnJhbWUsXFxuICAuZmxleC12aWRlbyBvYmplY3QsXFxuICAuZmxleC12aWRlbyBlbWJlZCxcXG4gIC5mbGV4LXZpZGVvIHZpZGVvIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDA7XFxuICAgIGxlZnQ6IDA7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7IH1cXG4gIC5mbGV4LXZpZGVvLndpZGVzY3JlZW4ge1xcbiAgICBwYWRkaW5nLWJvdHRvbTogNTYuMjUlOyB9XFxuICAuZmxleC12aWRlby52aW1lbyB7XFxuICAgIHBhZGRpbmctdG9wOiAwOyB9XFxuXFxuLmxhYmVsIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIHBhZGRpbmc6IDAuMzMzMzNyZW0gMC41cmVtO1xcbiAgZm9udC1zaXplOiAwLjhyZW07XFxuICBsaW5lLWhlaWdodDogMTtcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxuICBjdXJzb3I6IGRlZmF1bHQ7XFxuICBib3JkZXItcmFkaXVzOiAwO1xcbiAgYmFja2dyb3VuZDogIzIxOTllODtcXG4gIGNvbG9yOiAjZmVmZWZlOyB9XFxuICAubGFiZWwuc2Vjb25kYXJ5IHtcXG4gICAgYmFja2dyb3VuZDogIzc3NztcXG4gICAgY29sb3I6ICNmZWZlZmU7IH1cXG4gIC5sYWJlbC5zdWNjZXNzIHtcXG4gICAgYmFja2dyb3VuZDogIzNhZGI3NjtcXG4gICAgY29sb3I6ICNmZWZlZmU7IH1cXG4gIC5sYWJlbC53YXJuaW5nIHtcXG4gICAgYmFja2dyb3VuZDogI2ZmYWUwMDtcXG4gICAgY29sb3I6ICNmZWZlZmU7IH1cXG4gIC5sYWJlbC5hbGVydCB7XFxuICAgIGJhY2tncm91bmQ6ICNlYzU4NDA7XFxuICAgIGNvbG9yOiAjZmVmZWZlOyB9XFxuXFxuLm1lZGlhLW9iamVjdCB7XFxuICBtYXJnaW4tYm90dG9tOiAxcmVtO1xcbiAgZGlzcGxheTogYmxvY2s7IH1cXG4gIC5tZWRpYS1vYmplY3QgaW1nIHtcXG4gICAgbWF4LXdpZHRoOiBub25lOyB9XFxuICBAbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiAzOS45Mzc1ZW0pIHtcXG4gICAgLm1lZGlhLW9iamVjdC5zdGFjay1mb3Itc21hbGwgLm1lZGlhLW9iamVjdC1zZWN0aW9uIHtcXG4gICAgICBwYWRkaW5nOiAwO1xcbiAgICAgIHBhZGRpbmctYm90dG9tOiAxcmVtO1xcbiAgICAgIGRpc3BsYXk6IGJsb2NrOyB9XFxuICAgICAgLm1lZGlhLW9iamVjdC5zdGFjay1mb3Itc21hbGwgLm1lZGlhLW9iamVjdC1zZWN0aW9uIGltZyB7XFxuICAgICAgICB3aWR0aDogMTAwJTsgfSB9XFxuXFxuLm1lZGlhLW9iamVjdC1zZWN0aW9uIHtcXG4gIGRpc3BsYXk6IHRhYmxlLWNlbGw7XFxuICB2ZXJ0aWNhbC1hbGlnbjogdG9wOyB9XFxuICAubWVkaWEtb2JqZWN0LXNlY3Rpb246Zmlyc3QtY2hpbGQge1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAxcmVtOyB9XFxuICAubWVkaWEtb2JqZWN0LXNlY3Rpb246bGFzdC1jaGlsZDpub3QoOm50aC1jaGlsZCgyKSkge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDFyZW07IH1cXG4gIC5tZWRpYS1vYmplY3Qtc2VjdGlvbiA+IDpsYXN0LWNoaWxkIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogMDsgfVxcbiAgLm1lZGlhLW9iamVjdC1zZWN0aW9uLm1pZGRsZSB7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7IH1cXG4gIC5tZWRpYS1vYmplY3Qtc2VjdGlvbi5ib3R0b20ge1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogYm90dG9tOyB9XFxuXFxuaHRtbCxcXG5ib2R5IHtcXG4gIGhlaWdodDogMTAwJTsgfVxcblxcbi5vZmYtY2FudmFzLXdyYXBwZXIge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBvdmVyZmxvdy14OiBoaWRkZW47XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBiYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47XFxuICAtd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzogYXV0bzsgfVxcblxcbi5vZmYtY2FudmFzLXdyYXBwZXItaW5uZXIge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgd2lkdGg6IDEwMCU7XFxuICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC41cyBlYXNlOyB9XFxuICAub2ZmLWNhbnZhcy13cmFwcGVyLWlubmVyOjpiZWZvcmUsIC5vZmYtY2FudmFzLXdyYXBwZXItaW5uZXI6OmFmdGVyIHtcXG4gICAgY29udGVudDogJyAnO1xcbiAgICBkaXNwbGF5OiB0YWJsZTsgfVxcbiAgLm9mZi1jYW52YXMtd3JhcHBlci1pbm5lcjo6YWZ0ZXIge1xcbiAgICBjbGVhcjogYm90aDsgfVxcblxcbi5vZmYtY2FudmFzLWNvbnRlbnQsXFxuLm9mZi1jYW52YXMtY29udGVudCB7XFxuICBtaW4taGVpZ2h0OiAxMDAlO1xcbiAgYmFja2dyb3VuZDogI2ZlZmVmZTtcXG4gIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjVzIGVhc2U7XFxuICBiYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47XFxuICB6LWluZGV4OiAxO1xcbiAgcGFkZGluZy1ib3R0b206IDAuMXB4O1xcbiAgYm94LXNoYWRvdzogMCAwIDEwcHggcmdiYSgxMCwgMTAsIDEwLCAwLjUpOyB9XFxuXFxuLmpzLW9mZi1jYW52YXMtZXhpdCB7XFxuICBkaXNwbGF5OiBub25lO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogMDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgYmFja2dyb3VuZDogcmdiYSgyNTQsIDI1NCwgMjU0LCAwLjI1KTtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIHRyYW5zaXRpb246IGJhY2tncm91bmQgMC41cyBlYXNlOyB9XFxuXFxuLm9mZi1jYW52YXMge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgYmFja2dyb3VuZDogI2U2ZTZlNjtcXG4gIHotaW5kZXg6IC0xO1xcbiAgbWF4LWhlaWdodDogMTAwJTtcXG4gIG92ZXJmbG93LXk6IGF1dG87XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7IH1cXG4gIFtkYXRhLXdoYXRpbnB1dD0nbW91c2UnXSAub2ZmLWNhbnZhcyB7XFxuICAgIG91dGxpbmU6IDA7IH1cXG4gIC5vZmYtY2FudmFzLnBvc2l0aW9uLWxlZnQge1xcbiAgICBsZWZ0OiAtMjUwcHg7XFxuICAgIHRvcDogMDtcXG4gICAgd2lkdGg6IDI1MHB4OyB9XFxuICAgIC5pcy1vcGVuLWxlZnQge1xcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgyNTBweCk7IH1cXG4gIC5vZmYtY2FudmFzLnBvc2l0aW9uLXJpZ2h0IHtcXG4gICAgcmlnaHQ6IC0yNTBweDtcXG4gICAgdG9wOiAwO1xcbiAgICB3aWR0aDogMjUwcHg7IH1cXG4gICAgLmlzLW9wZW4tcmlnaHQge1xcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtMjUwcHgpOyB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNDBlbSkge1xcbiAgLnBvc2l0aW9uLWxlZnQucmV2ZWFsLWZvci1tZWRpdW0ge1xcbiAgICBsZWZ0OiAwO1xcbiAgICB6LWluZGV4OiBhdXRvO1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7IH1cXG4gICAgLnBvc2l0aW9uLWxlZnQucmV2ZWFsLWZvci1tZWRpdW0gfiAub2ZmLWNhbnZhcy1jb250ZW50IHtcXG4gICAgICBtYXJnaW4tbGVmdDogMjUwcHg7IH1cXG4gIC5wb3NpdGlvbi1yaWdodC5yZXZlYWwtZm9yLW1lZGl1bSB7XFxuICAgIHJpZ2h0OiAwO1xcbiAgICB6LWluZGV4OiBhdXRvO1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7IH1cXG4gICAgLnBvc2l0aW9uLXJpZ2h0LnJldmVhbC1mb3ItbWVkaXVtIH4gLm9mZi1jYW52YXMtY29udGVudCB7XFxuICAgICAgbWFyZ2luLXJpZ2h0OiAyNTBweDsgfSB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNjRlbSkge1xcbiAgLnBvc2l0aW9uLWxlZnQucmV2ZWFsLWZvci1sYXJnZSB7XFxuICAgIGxlZnQ6IDA7XFxuICAgIHotaW5kZXg6IGF1dG87XFxuICAgIHBvc2l0aW9uOiBmaXhlZDsgfVxcbiAgICAucG9zaXRpb24tbGVmdC5yZXZlYWwtZm9yLWxhcmdlIH4gLm9mZi1jYW52YXMtY29udGVudCB7XFxuICAgICAgbWFyZ2luLWxlZnQ6IDI1MHB4OyB9XFxuICAucG9zaXRpb24tcmlnaHQucmV2ZWFsLWZvci1sYXJnZSB7XFxuICAgIHJpZ2h0OiAwO1xcbiAgICB6LWluZGV4OiBhdXRvO1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7IH1cXG4gICAgLnBvc2l0aW9uLXJpZ2h0LnJldmVhbC1mb3ItbGFyZ2UgfiAub2ZmLWNhbnZhcy1jb250ZW50IHtcXG4gICAgICBtYXJnaW4tcmlnaHQ6IDI1MHB4OyB9IH1cXG5cXG4ub3JiaXQge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlOyB9XFxuXFxuLm9yYml0LWNvbnRhaW5lciB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBtYXJnaW46IDA7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgbGlzdC1zdHlsZTogbm9uZTsgfVxcblxcbi5vcmJpdC1zbGlkZSB7XFxuICB3aWR0aDogMTAwJTtcXG4gIG1heC1oZWlnaHQ6IDEwMCU7IH1cXG4gIC5vcmJpdC1zbGlkZS5uby1tb3Rpb251aS5pcy1hY3RpdmUge1xcbiAgICB0b3A6IDA7XFxuICAgIGxlZnQ6IDA7IH1cXG5cXG4ub3JiaXQtZmlndXJlIHtcXG4gIG1hcmdpbjogMDsgfVxcblxcbi5vcmJpdC1pbWFnZSB7XFxuICBtYXJnaW46IDA7XFxuICB3aWR0aDogMTAwJTtcXG4gIG1heC13aWR0aDogMTAwJTsgfVxcblxcbi5vcmJpdC1jYXB0aW9uIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGJvdHRvbTogMDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgcGFkZGluZzogMXJlbTtcXG4gIG1hcmdpbi1ib3R0b206IDA7XFxuICBjb2xvcjogI2ZlZmVmZTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTAsIDEwLCAxMCwgMC41KTsgfVxcblxcbi5vcmJpdC1wcmV2aW91cywgLm9yYml0LW5leHQge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiA1MCU7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSk7XFxuICB6LWluZGV4OiAxMDtcXG4gIHBhZGRpbmc6IDFyZW07XFxuICBjb2xvcjogI2ZlZmVmZTsgfVxcbiAgW2RhdGEtd2hhdGlucHV0PSdtb3VzZSddIC5vcmJpdC1wcmV2aW91cywgW2RhdGEtd2hhdGlucHV0PSdtb3VzZSddIC5vcmJpdC1uZXh0IHtcXG4gICAgb3V0bGluZTogMDsgfVxcbiAgLm9yYml0LXByZXZpb3VzOmhvdmVyLCAub3JiaXQtbmV4dDpob3ZlciwgLm9yYml0LXByZXZpb3VzOmFjdGl2ZSwgLm9yYml0LW5leHQ6YWN0aXZlLCAub3JiaXQtcHJldmlvdXM6Zm9jdXMsIC5vcmJpdC1uZXh0OmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxMCwgMTAsIDEwLCAwLjUpOyB9XFxuXFxuLm9yYml0LXByZXZpb3VzIHtcXG4gIGxlZnQ6IDA7IH1cXG5cXG4ub3JiaXQtbmV4dCB7XFxuICBsZWZ0OiBhdXRvO1xcbiAgcmlnaHQ6IDA7IH1cXG5cXG4ub3JiaXQtYnVsbGV0cyB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBtYXJnaW4tdG9wOiAwLjhyZW07XFxuICBtYXJnaW4tYm90dG9tOiAwLjhyZW07XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7IH1cXG4gIFtkYXRhLXdoYXRpbnB1dD0nbW91c2UnXSAub3JiaXQtYnVsbGV0cyB7XFxuICAgIG91dGxpbmU6IDA7IH1cXG4gIC5vcmJpdC1idWxsZXRzIGJ1dHRvbiB7XFxuICAgIHdpZHRoOiAxLjJyZW07XFxuICAgIGhlaWdodDogMS4ycmVtO1xcbiAgICBtYXJnaW46IDAuMXJlbTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2NhY2FjYTtcXG4gICAgYm9yZGVyLXJhZGl1czogNTAlOyB9XFxuICAgIC5vcmJpdC1idWxsZXRzIGJ1dHRvbjpob3ZlciB7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzhhOGE4YTsgfVxcbiAgICAub3JiaXQtYnVsbGV0cyBidXR0b24uaXMtYWN0aXZlIHtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjOGE4YThhOyB9XFxuXFxuLnBhZ2luYXRpb24ge1xcbiAgbWFyZ2luLWxlZnQ6IDA7XFxuICBtYXJnaW4tYm90dG9tOiAxcmVtOyB9XFxuICAucGFnaW5hdGlvbjo6YmVmb3JlLCAucGFnaW5hdGlvbjo6YWZ0ZXIge1xcbiAgICBjb250ZW50OiAnICc7XFxuICAgIGRpc3BsYXk6IHRhYmxlOyB9XFxuICAucGFnaW5hdGlvbjo6YWZ0ZXIge1xcbiAgICBjbGVhcjogYm90aDsgfVxcbiAgLnBhZ2luYXRpb24gbGkge1xcbiAgICBmb250LXNpemU6IDAuODc1cmVtO1xcbiAgICBtYXJnaW4tcmlnaHQ6IDAuMDYyNXJlbTtcXG4gICAgYm9yZGVyLXJhZGl1czogMDtcXG4gICAgZGlzcGxheTogbm9uZTsgfVxcbiAgICAucGFnaW5hdGlvbiBsaTpsYXN0LWNoaWxkLCAucGFnaW5hdGlvbiBsaTpmaXJzdC1jaGlsZCB7XFxuICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrOyB9XFxuICAgIEBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDQwZW0pIHtcXG4gICAgICAucGFnaW5hdGlvbiBsaSB7XFxuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IH0gfVxcbiAgLnBhZ2luYXRpb24gYSxcXG4gIC5wYWdpbmF0aW9uIGJ1dHRvbiB7XFxuICAgIGNvbG9yOiAjMGEwYTBhO1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgcGFkZGluZzogMC4xODc1cmVtIDAuNjI1cmVtO1xcbiAgICBib3JkZXItcmFkaXVzOiAwOyB9XFxuICAgIC5wYWdpbmF0aW9uIGE6aG92ZXIsXFxuICAgIC5wYWdpbmF0aW9uIGJ1dHRvbjpob3ZlciB7XFxuICAgICAgYmFja2dyb3VuZDogI2U2ZTZlNjsgfVxcbiAgLnBhZ2luYXRpb24gLmN1cnJlbnQge1xcbiAgICBwYWRkaW5nOiAwLjE4NzVyZW0gMC42MjVyZW07XFxuICAgIGJhY2tncm91bmQ6ICMyMTk5ZTg7XFxuICAgIGNvbG9yOiAjZmVmZWZlO1xcbiAgICBjdXJzb3I6IGRlZmF1bHQ7IH1cXG4gIC5wYWdpbmF0aW9uIC5kaXNhYmxlZCB7XFxuICAgIHBhZGRpbmc6IDAuMTg3NXJlbSAwLjYyNXJlbTtcXG4gICAgY29sb3I6ICNjYWNhY2E7XFxuICAgIGN1cnNvcjogbm90LWFsbG93ZWQ7IH1cXG4gICAgLnBhZ2luYXRpb24gLmRpc2FibGVkOmhvdmVyIHtcXG4gICAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDsgfVxcbiAgLnBhZ2luYXRpb24gLmVsbGlwc2lzOjphZnRlciB7XFxuICAgIGNvbnRlbnQ6ICdcXFxcMjAyNic7XFxuICAgIHBhZGRpbmc6IDAuMTg3NXJlbSAwLjYyNXJlbTtcXG4gICAgY29sb3I6ICMwYTBhMGE7IH1cXG5cXG4ucGFnaW5hdGlvbi1wcmV2aW91cyBhOjpiZWZvcmUsXFxuLnBhZ2luYXRpb24tcHJldmlvdXMuZGlzYWJsZWQ6OmJlZm9yZSB7XFxuICBjb250ZW50OiAnXFxcXEFCJztcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIG1hcmdpbi1yaWdodDogMC41cmVtOyB9XFxuXFxuLnBhZ2luYXRpb24tbmV4dCBhOjphZnRlcixcXG4ucGFnaW5hdGlvbi1uZXh0LmRpc2FibGVkOjphZnRlciB7XFxuICBjb250ZW50OiAnXFxcXEJCJztcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIG1hcmdpbi1sZWZ0OiAwLjVyZW07IH1cXG5cXG4ucHJvZ3Jlc3Mge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2NhY2FjYTtcXG4gIGhlaWdodDogMXJlbTtcXG4gIG1hcmdpbi1ib3R0b206IDFyZW07XFxuICBib3JkZXItcmFkaXVzOiAwOyB9XFxuICAucHJvZ3Jlc3MucHJpbWFyeSAucHJvZ3Jlc3MtbWV0ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjE5OWU4OyB9XFxuICAucHJvZ3Jlc3Muc2Vjb25kYXJ5IC5wcm9ncmVzcy1tZXRlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICM3Nzc7IH1cXG4gIC5wcm9ncmVzcy5zdWNjZXNzIC5wcm9ncmVzcy1tZXRlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMzYWRiNzY7IH1cXG4gIC5wcm9ncmVzcy53YXJuaW5nIC5wcm9ncmVzcy1tZXRlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmFlMDA7IH1cXG4gIC5wcm9ncmVzcy5hbGVydCAucHJvZ3Jlc3MtbWV0ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWM1ODQwOyB9XFxuXFxuLnByb2dyZXNzLW1ldGVyIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgd2lkdGg6IDAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzIxOTllODsgfVxcblxcbi5wcm9ncmVzcy1tZXRlci10ZXh0IHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogNTAlO1xcbiAgbGVmdDogNTAlO1xcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBtYXJnaW46IDA7XFxuICBmb250LXNpemU6IDAuNzVyZW07XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIGNvbG9yOiAjZmVmZWZlO1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDsgfVxcblxcbi5zbGlkZXIge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgaGVpZ2h0OiAwLjVyZW07XFxuICBtYXJnaW4tdG9wOiAxLjI1cmVtO1xcbiAgbWFyZ2luLWJvdHRvbTogMi4yNXJlbTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlNmU2ZTY7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXG4gIHRvdWNoLWFjdGlvbjogbm9uZTsgfVxcblxcbi5zbGlkZXItZmlsbCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAwO1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgbWF4LXdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAwLjVyZW07XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjY2FjYWNhO1xcbiAgdHJhbnNpdGlvbjogYWxsIDAuMnMgZWFzZS1pbi1vdXQ7IH1cXG4gIC5zbGlkZXItZmlsbC5pcy1kcmFnZ2luZyB7XFxuICAgIHRyYW5zaXRpb246IGFsbCAwcyBsaW5lYXI7IH1cXG5cXG4uc2xpZGVyLWhhbmRsZSB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDUwJTtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKTtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGxlZnQ6IDA7XFxuICB6LWluZGV4OiAxO1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgd2lkdGg6IDEuNHJlbTtcXG4gIGhlaWdodDogMS40cmVtO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzIxOTllODtcXG4gIHRyYW5zaXRpb246IGFsbCAwLjJzIGVhc2UtaW4tb3V0O1xcbiAgdG91Y2gtYWN0aW9uOiBtYW5pcHVsYXRpb247XFxuICBib3JkZXItcmFkaXVzOiAwOyB9XFxuICBbZGF0YS13aGF0aW5wdXQ9J21vdXNlJ10gLnNsaWRlci1oYW5kbGUge1xcbiAgICBvdXRsaW5lOiAwOyB9XFxuICAuc2xpZGVyLWhhbmRsZTpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMxNTgzY2M7IH1cXG4gIC5zbGlkZXItaGFuZGxlLmlzLWRyYWdnaW5nIHtcXG4gICAgdHJhbnNpdGlvbjogYWxsIDBzIGxpbmVhcjsgfVxcblxcbi5zbGlkZXIuZGlzYWJsZWQsXFxuLnNsaWRlcltkaXNhYmxlZF0ge1xcbiAgb3BhY2l0eTogMC4yNTtcXG4gIGN1cnNvcjogbm90LWFsbG93ZWQ7IH1cXG5cXG4uc2xpZGVyLnZlcnRpY2FsIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIHdpZHRoOiAwLjVyZW07XFxuICBoZWlnaHQ6IDEyLjVyZW07XFxuICBtYXJnaW46IDAgMS4yNXJlbTtcXG4gIHRyYW5zZm9ybTogc2NhbGUoMSwgLTEpOyB9XFxuICAuc2xpZGVyLnZlcnRpY2FsIC5zbGlkZXItZmlsbCB7XFxuICAgIHRvcDogMDtcXG4gICAgd2lkdGg6IDAuNXJlbTtcXG4gICAgbWF4LWhlaWdodDogMTAwJTsgfVxcbiAgLnNsaWRlci52ZXJ0aWNhbCAuc2xpZGVyLWhhbmRsZSB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiAwO1xcbiAgICBsZWZ0OiA1MCU7XFxuICAgIHdpZHRoOiAxLjRyZW07XFxuICAgIGhlaWdodDogMS40cmVtO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7IH1cXG5cXG4uc3RpY2t5LWNvbnRhaW5lciB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7IH1cXG5cXG4uc3RpY2t5IHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHotaW5kZXg6IDA7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDAsIDApOyB9XFxuXFxuLnN0aWNreS5pcy1zdHVjayB7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICB6LWluZGV4OiA1OyB9XFxuICAuc3RpY2t5LmlzLXN0dWNrLmlzLWF0LXRvcCB7XFxuICAgIHRvcDogMDsgfVxcbiAgLnN0aWNreS5pcy1zdHVjay5pcy1hdC1ib3R0b20ge1xcbiAgICBib3R0b206IDA7IH1cXG5cXG4uc3RpY2t5LmlzLWFuY2hvcmVkIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGxlZnQ6IGF1dG87XFxuICByaWdodDogYXV0bzsgfVxcbiAgLnN0aWNreS5pcy1hbmNob3JlZC5pcy1hdC1ib3R0b20ge1xcbiAgICBib3R0b206IDA7IH1cXG5cXG5ib2R5LmlzLXJldmVhbC1vcGVuIHtcXG4gIG92ZXJmbG93OiBoaWRkZW47IH1cXG5cXG5odG1sLmlzLXJldmVhbC1vcGVuLFxcbmh0bWwuaXMtcmV2ZWFsLW9wZW4gYm9keSB7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7IH1cXG5cXG4ucmV2ZWFsLW92ZXJsYXkge1xcbiAgZGlzcGxheTogbm9uZTtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHRvcDogMDtcXG4gIGJvdHRvbTogMDtcXG4gIGxlZnQ6IDA7XFxuICByaWdodDogMDtcXG4gIHotaW5kZXg6IDEwMDU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDEwLCAxMCwgMTAsIDAuNDUpO1xcbiAgb3ZlcmZsb3cteTogc2Nyb2xsOyB9XFxuXFxuLnJldmVhbCB7XFxuICBkaXNwbGF5OiBub25lO1xcbiAgei1pbmRleDogMTAwNjtcXG4gIHBhZGRpbmc6IDFyZW07XFxuICBib3JkZXI6IDFweCBzb2xpZCAjY2FjYWNhO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZlZmVmZTtcXG4gIGJvcmRlci1yYWRpdXM6IDA7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB0b3A6IDEwMHB4O1xcbiAgbWFyZ2luLWxlZnQ6IGF1dG87XFxuICBtYXJnaW4tcmlnaHQ6IGF1dG87XFxuICBvdmVyZmxvdy15OiBhdXRvOyB9XFxuICBbZGF0YS13aGF0aW5wdXQ9J21vdXNlJ10gLnJldmVhbCB7XFxuICAgIG91dGxpbmU6IDA7IH1cXG4gIEBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDQwZW0pIHtcXG4gICAgLnJldmVhbCB7XFxuICAgICAgbWluLWhlaWdodDogMDsgfSB9XFxuICAucmV2ZWFsIC5jb2x1bW4sIC5yZXZlYWwgLmNvbHVtbnMsXFxuICAucmV2ZWFsIC5jb2x1bW5zIHtcXG4gICAgbWluLXdpZHRoOiAwOyB9XFxuICAucmV2ZWFsID4gOmxhc3QtY2hpbGQge1xcbiAgICBtYXJnaW4tYm90dG9tOiAwOyB9XFxuICBAbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA0MGVtKSB7XFxuICAgIC5yZXZlYWwge1xcbiAgICAgIHdpZHRoOiA2MDBweDtcXG4gICAgICBtYXgtd2lkdGg6IDc1cmVtOyB9IH1cXG4gIEBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDQwZW0pIHtcXG4gICAgLnJldmVhbCAucmV2ZWFsIHtcXG4gICAgICBsZWZ0OiBhdXRvO1xcbiAgICAgIHJpZ2h0OiBhdXRvO1xcbiAgICAgIG1hcmdpbjogMCBhdXRvOyB9IH1cXG4gIC5yZXZlYWwuY29sbGFwc2Uge1xcbiAgICBwYWRkaW5nOiAwOyB9XFxuICBAbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA0MGVtKSB7XFxuICAgIC5yZXZlYWwudGlueSB7XFxuICAgICAgd2lkdGg6IDMwJTtcXG4gICAgICBtYXgtd2lkdGg6IDc1cmVtOyB9IH1cXG4gIEBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDQwZW0pIHtcXG4gICAgLnJldmVhbC5zbWFsbCB7XFxuICAgICAgd2lkdGg6IDUwJTtcXG4gICAgICBtYXgtd2lkdGg6IDc1cmVtOyB9IH1cXG4gIEBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDQwZW0pIHtcXG4gICAgLnJldmVhbC5sYXJnZSB7XFxuICAgICAgd2lkdGg6IDkwJTtcXG4gICAgICBtYXgtd2lkdGg6IDc1cmVtOyB9IH1cXG4gIC5yZXZlYWwuZnVsbCB7XFxuICAgIHRvcDogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDB2aDtcXG4gICAgbWluLWhlaWdodDogMTAwdmg7XFxuICAgIG1heC13aWR0aDogbm9uZTtcXG4gICAgbWFyZ2luLWxlZnQ6IDA7XFxuICAgIGJvcmRlcjogMDtcXG4gICAgYm9yZGVyLXJhZGl1czogMDsgfVxcbiAgQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogMzkuOTM3NWVtKSB7XFxuICAgIC5yZXZlYWwge1xcbiAgICAgIHRvcDogMDtcXG4gICAgICBsZWZ0OiAwO1xcbiAgICAgIHdpZHRoOiAxMDAlO1xcbiAgICAgIGhlaWdodDogMTAwJTtcXG4gICAgICBoZWlnaHQ6IDEwMHZoO1xcbiAgICAgIG1pbi1oZWlnaHQ6IDEwMHZoO1xcbiAgICAgIG1heC13aWR0aDogbm9uZTtcXG4gICAgICBtYXJnaW4tbGVmdDogMDtcXG4gICAgICBib3JkZXI6IDA7XFxuICAgICAgYm9yZGVyLXJhZGl1czogMDsgfSB9XFxuICAucmV2ZWFsLndpdGhvdXQtb3ZlcmxheSB7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDsgfVxcblxcbi5zd2l0Y2gge1xcbiAgbWFyZ2luLWJvdHRvbTogMXJlbTtcXG4gIG91dGxpbmU6IDA7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXG4gIGNvbG9yOiAjZmVmZWZlO1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBmb250LXNpemU6IDAuODc1cmVtOyB9XFxuXFxuLnN3aXRjaC1pbnB1dCB7XFxuICBvcGFjaXR5OiAwO1xcbiAgcG9zaXRpb246IGFic29sdXRlOyB9XFxuXFxuLnN3aXRjaC1wYWRkbGUge1xcbiAgYmFja2dyb3VuZDogI2NhY2FjYTtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgd2lkdGg6IDRyZW07XFxuICBoZWlnaHQ6IDJyZW07XFxuICB0cmFuc2l0aW9uOiBhbGwgMC4yNXMgZWFzZS1vdXQ7XFxuICBib3JkZXItcmFkaXVzOiAwO1xcbiAgY29sb3I6IGluaGVyaXQ7XFxuICBmb250LXdlaWdodDogaW5oZXJpdDsgfVxcbiAgaW5wdXQgKyAuc3dpdGNoLXBhZGRsZSB7XFxuICAgIG1hcmdpbjogMDsgfVxcbiAgLnN3aXRjaC1wYWRkbGU6OmFmdGVyIHtcXG4gICAgYmFja2dyb3VuZDogI2ZlZmVmZTtcXG4gICAgY29udGVudDogJyc7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGhlaWdodDogMS41cmVtO1xcbiAgICBsZWZ0OiAwLjI1cmVtO1xcbiAgICB0b3A6IDAuMjVyZW07XFxuICAgIHdpZHRoOiAxLjVyZW07XFxuICAgIHRyYW5zaXRpb246IGFsbCAwLjI1cyBlYXNlLW91dDtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAwLCAwKTtcXG4gICAgYm9yZGVyLXJhZGl1czogMDsgfVxcbiAgaW5wdXQ6Y2hlY2tlZCB+IC5zd2l0Y2gtcGFkZGxlIHtcXG4gICAgYmFja2dyb3VuZDogIzIxOTllODsgfVxcbiAgICBpbnB1dDpjaGVja2VkIH4gLnN3aXRjaC1wYWRkbGU6OmFmdGVyIHtcXG4gICAgICBsZWZ0OiAyLjI1cmVtOyB9XFxuICBbZGF0YS13aGF0aW5wdXQ9J21vdXNlJ10gaW5wdXQ6Zm9jdXMgfiAuc3dpdGNoLXBhZGRsZSB7XFxuICAgIG91dGxpbmU6IDA7IH1cXG5cXG4uc3dpdGNoLWFjdGl2ZSwgLnN3aXRjaC1pbmFjdGl2ZSB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDUwJTtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKTsgfVxcblxcbi5zd2l0Y2gtYWN0aXZlIHtcXG4gIGxlZnQ6IDglO1xcbiAgZGlzcGxheTogbm9uZTsgfVxcbiAgaW5wdXQ6Y2hlY2tlZCArIGxhYmVsID4gLnN3aXRjaC1hY3RpdmUge1xcbiAgICBkaXNwbGF5OiBibG9jazsgfVxcblxcbi5zd2l0Y2gtaW5hY3RpdmUge1xcbiAgcmlnaHQ6IDE1JTsgfVxcbiAgaW5wdXQ6Y2hlY2tlZCArIGxhYmVsID4gLnN3aXRjaC1pbmFjdGl2ZSB7XFxuICAgIGRpc3BsYXk6IG5vbmU7IH1cXG5cXG4uc3dpdGNoLnRpbnkgLnN3aXRjaC1wYWRkbGUge1xcbiAgd2lkdGg6IDNyZW07XFxuICBoZWlnaHQ6IDEuNXJlbTtcXG4gIGZvbnQtc2l6ZTogMC42MjVyZW07IH1cXG5cXG4uc3dpdGNoLnRpbnkgLnN3aXRjaC1wYWRkbGU6OmFmdGVyIHtcXG4gIHdpZHRoOiAxcmVtO1xcbiAgaGVpZ2h0OiAxcmVtOyB9XFxuXFxuLnN3aXRjaC50aW55IGlucHV0OmNoZWNrZWQgfiAuc3dpdGNoLXBhZGRsZTo6YWZ0ZXIge1xcbiAgbGVmdDogMS43NXJlbTsgfVxcblxcbi5zd2l0Y2guc21hbGwgLnN3aXRjaC1wYWRkbGUge1xcbiAgd2lkdGg6IDMuNXJlbTtcXG4gIGhlaWdodDogMS43NXJlbTtcXG4gIGZvbnQtc2l6ZTogMC43NXJlbTsgfVxcblxcbi5zd2l0Y2guc21hbGwgLnN3aXRjaC1wYWRkbGU6OmFmdGVyIHtcXG4gIHdpZHRoOiAxLjI1cmVtO1xcbiAgaGVpZ2h0OiAxLjI1cmVtOyB9XFxuXFxuLnN3aXRjaC5zbWFsbCBpbnB1dDpjaGVja2VkIH4gLnN3aXRjaC1wYWRkbGU6OmFmdGVyIHtcXG4gIGxlZnQ6IDJyZW07IH1cXG5cXG4uc3dpdGNoLmxhcmdlIC5zd2l0Y2gtcGFkZGxlIHtcXG4gIHdpZHRoOiA1cmVtO1xcbiAgaGVpZ2h0OiAyLjVyZW07XFxuICBmb250LXNpemU6IDFyZW07IH1cXG5cXG4uc3dpdGNoLmxhcmdlIC5zd2l0Y2gtcGFkZGxlOjphZnRlciB7XFxuICB3aWR0aDogMnJlbTtcXG4gIGhlaWdodDogMnJlbTsgfVxcblxcbi5zd2l0Y2gubGFyZ2UgaW5wdXQ6Y2hlY2tlZCB+IC5zd2l0Y2gtcGFkZGxlOjphZnRlciB7XFxuICBsZWZ0OiAyLjc1cmVtOyB9XFxuXFxudGFibGUge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBtYXJnaW4tYm90dG9tOiAxcmVtO1xcbiAgYm9yZGVyLXJhZGl1czogMDsgfVxcbiAgdGFibGUgdGhlYWQsXFxuICB0YWJsZSB0Ym9keSxcXG4gIHRhYmxlIHRmb290IHtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgI2YxZjFmMTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZlZmVmZTsgfVxcbiAgdGFibGUgY2FwdGlvbiB7XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgICBwYWRkaW5nOiAwLjVyZW0gMC42MjVyZW0gMC42MjVyZW07IH1cXG4gIHRhYmxlIHRoZWFkLFxcbiAgdGFibGUgdGZvb3Qge1xcbiAgICBiYWNrZ3JvdW5kOiAjZjhmOGY4O1xcbiAgICBjb2xvcjogIzBhMGEwYTsgfVxcbiAgICB0YWJsZSB0aGVhZCB0cixcXG4gICAgdGFibGUgdGZvb3QgdHIge1xcbiAgICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50OyB9XFxuICAgIHRhYmxlIHRoZWFkIHRoLFxcbiAgICB0YWJsZSB0aGVhZCB0ZCxcXG4gICAgdGFibGUgdGZvb3QgdGgsXFxuICAgIHRhYmxlIHRmb290IHRkIHtcXG4gICAgICBwYWRkaW5nOiAwLjVyZW0gMC42MjVyZW0gMC42MjVyZW07XFxuICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICAgICAgdGV4dC1hbGlnbjogbGVmdDsgfVxcbiAgdGFibGUgdGJvZHkgdHI6bnRoLWNoaWxkKGV2ZW4pIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2YxZjFmMTsgfVxcbiAgdGFibGUgdGJvZHkgdGgsXFxuICB0YWJsZSB0Ym9keSB0ZCB7XFxuICAgIHBhZGRpbmc6IDAuNXJlbSAwLjYyNXJlbSAwLjYyNXJlbTsgfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDYzLjkzNzVlbSkge1xcbiAgdGFibGUuc3RhY2sgdGhlYWQge1xcbiAgICBkaXNwbGF5OiBub25lOyB9XFxuICB0YWJsZS5zdGFjayB0Zm9vdCB7XFxuICAgIGRpc3BsYXk6IG5vbmU7IH1cXG4gIHRhYmxlLnN0YWNrIHRyLFxcbiAgdGFibGUuc3RhY2sgdGgsXFxuICB0YWJsZS5zdGFjayB0ZCB7XFxuICAgIGRpc3BsYXk6IGJsb2NrOyB9XFxuICB0YWJsZS5zdGFjayB0ZCB7XFxuICAgIGJvcmRlci10b3A6IDA7IH0gfVxcblxcbnRhYmxlLnNjcm9sbCB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHdpZHRoOiAxMDAlO1xcbiAgb3ZlcmZsb3cteDogYXV0bzsgfVxcblxcbnRhYmxlLmhvdmVyIHRyOmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmOWY5Zjk7IH1cXG5cXG50YWJsZS5ob3ZlciB0cjpudGgtb2YtdHlwZShldmVuKTpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWNlY2VjOyB9XFxuXFxuLnRhYmxlLXNjcm9sbCB7XFxuICBvdmVyZmxvdy14OiBhdXRvOyB9XFxuICAudGFibGUtc2Nyb2xsIHRhYmxlIHtcXG4gICAgd2lkdGg6IGF1dG87IH1cXG5cXG4udGFicyB7XFxuICBtYXJnaW46IDA7XFxuICBsaXN0LXN0eWxlLXR5cGU6IG5vbmU7XFxuICBiYWNrZ3JvdW5kOiAjZmVmZWZlO1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2U2ZTZlNjsgfVxcbiAgLnRhYnM6OmJlZm9yZSwgLnRhYnM6OmFmdGVyIHtcXG4gICAgY29udGVudDogJyAnO1xcbiAgICBkaXNwbGF5OiB0YWJsZTsgfVxcbiAgLnRhYnM6OmFmdGVyIHtcXG4gICAgY2xlYXI6IGJvdGg7IH1cXG5cXG4udGFicy52ZXJ0aWNhbCA+IGxpIHtcXG4gIHdpZHRoOiBhdXRvO1xcbiAgZmxvYXQ6IG5vbmU7XFxuICBkaXNwbGF5OiBibG9jazsgfVxcblxcbi50YWJzLnNpbXBsZSA+IGxpID4gYSB7XFxuICBwYWRkaW5nOiAwOyB9XFxuICAudGFicy5zaW1wbGUgPiBsaSA+IGE6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDsgfVxcblxcbi50YWJzLnByaW1hcnkge1xcbiAgYmFja2dyb3VuZDogIzIxOTllODsgfVxcbiAgLnRhYnMucHJpbWFyeSA+IGxpID4gYSB7XFxuICAgIGNvbG9yOiAjZmVmZWZlOyB9XFxuICAgIC50YWJzLnByaW1hcnkgPiBsaSA+IGE6aG92ZXIsIC50YWJzLnByaW1hcnkgPiBsaSA+IGE6Zm9jdXMge1xcbiAgICAgIGJhY2tncm91bmQ6ICMxODkzZTQ7IH1cXG5cXG4udGFicy10aXRsZSB7XFxuICBmbG9hdDogbGVmdDsgfVxcbiAgLnRhYnMtdGl0bGUgPiBhIHtcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICAgIHBhZGRpbmc6IDEuMjVyZW0gMS41cmVtO1xcbiAgICBsaW5lLWhlaWdodDogMTtcXG4gICAgZm9udC1zaXplOiAwLjc1cmVtOyB9XFxuICAgIC50YWJzLXRpdGxlID4gYTpob3ZlciB7XFxuICAgICAgYmFja2dyb3VuZDogI2ZlZmVmZTsgfVxcbiAgICAudGFicy10aXRsZSA+IGE6Zm9jdXMsIC50YWJzLXRpdGxlID4gYVthcmlhLXNlbGVjdGVkPSd0cnVlJ10ge1xcbiAgICAgIGJhY2tncm91bmQ6ICNlNmU2ZTY7IH1cXG5cXG4udGFicy1jb250ZW50IHtcXG4gIGJhY2tncm91bmQ6ICNmZWZlZmU7XFxuICB0cmFuc2l0aW9uOiBhbGwgMC41cyBlYXNlO1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2U2ZTZlNjtcXG4gIGJvcmRlci10b3A6IDA7IH1cXG5cXG4udGFicy1jb250ZW50LnZlcnRpY2FsIHtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNlNmU2ZTY7XFxuICBib3JkZXItbGVmdDogMDsgfVxcblxcbi50YWJzLXBhbmVsIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxuICBwYWRkaW5nOiAxcmVtOyB9XFxuICAudGFicy1wYW5lbC5pcy1hY3RpdmUge1xcbiAgICBkaXNwbGF5OiBibG9jazsgfVxcblxcbi50aHVtYm5haWwge1xcbiAgYm9yZGVyOiBzb2xpZCA0cHggI2ZlZmVmZTtcXG4gIGJveC1zaGFkb3c6IDAgMCAwIDFweCByZ2JhKDEwLCAxMCwgMTAsIDAuMik7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBsaW5lLWhlaWdodDogMDtcXG4gIG1heC13aWR0aDogMTAwJTtcXG4gIHRyYW5zaXRpb246IGJveC1zaGFkb3cgMjAwbXMgZWFzZS1vdXQ7XFxuICBib3JkZXItcmFkaXVzOiAwO1xcbiAgbWFyZ2luLWJvdHRvbTogMXJlbTsgfVxcbiAgLnRodW1ibmFpbDpob3ZlciwgLnRodW1ibmFpbDpmb2N1cyB7XFxuICAgIGJveC1zaGFkb3c6IDAgMCA2cHggMXB4IHJnYmEoMzMsIDE1MywgMjMyLCAwLjUpOyB9XFxuXFxuLnRpdGxlLWJhciB7XFxuICBiYWNrZ3JvdW5kOiAjMGEwYTBhO1xcbiAgY29sb3I6ICNmZWZlZmU7XFxuICBwYWRkaW5nOiAwLjVyZW07IH1cXG4gIC50aXRsZS1iYXI6OmJlZm9yZSwgLnRpdGxlLWJhcjo6YWZ0ZXIge1xcbiAgICBjb250ZW50OiAnICc7XFxuICAgIGRpc3BsYXk6IHRhYmxlOyB9XFxuICAudGl0bGUtYmFyOjphZnRlciB7XFxuICAgIGNsZWFyOiBib3RoOyB9XFxuICAudGl0bGUtYmFyIC5tZW51LWljb24ge1xcbiAgICBtYXJnaW4tbGVmdDogMC4yNXJlbTtcXG4gICAgbWFyZ2luLXJpZ2h0OiAwLjI1cmVtOyB9XFxuXFxuLnRpdGxlLWJhci1sZWZ0IHtcXG4gIGZsb2F0OiBsZWZ0OyB9XFxuXFxuLnRpdGxlLWJhci1yaWdodCB7XFxuICBmbG9hdDogcmlnaHQ7XFxuICB0ZXh0LWFsaWduOiByaWdodDsgfVxcblxcbi50aXRsZS1iYXItdGl0bGUge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrOyB9XFxuXFxuLm1lbnUtaWNvbi5kYXJrIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICB3aWR0aDogMjBweDtcXG4gIGhlaWdodDogMTZweDsgfVxcbiAgLm1lbnUtaWNvbi5kYXJrOjphZnRlciB7XFxuICAgIGNvbnRlbnQ6ICcnO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAycHg7XFxuICAgIGJhY2tncm91bmQ6ICMwYTBhMGE7XFxuICAgIHRvcDogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgYm94LXNoYWRvdzogMCA3cHggMCAjMGEwYTBhLCAwIDE0cHggMCAjMGEwYTBhOyB9XFxuICAubWVudS1pY29uLmRhcms6aG92ZXI6OmFmdGVyIHtcXG4gICAgYmFja2dyb3VuZDogIzhhOGE4YTtcXG4gICAgYm94LXNoYWRvdzogMCA3cHggMCAjOGE4YThhLCAwIDE0cHggMCAjOGE4YThhOyB9XFxuXFxuLmhhcy10aXAge1xcbiAgYm9yZGVyLWJvdHRvbTogZG90dGVkIDFweCAjOGE4YThhO1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBjdXJzb3I6IGhlbHA7IH1cXG5cXG4udG9vbHRpcCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMGEwYTBhO1xcbiAgY29sb3I6ICNmZWZlZmU7XFxuICBmb250LXNpemU6IDgwJTtcXG4gIHBhZGRpbmc6IDAuNzVyZW07XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB6LWluZGV4OiAxMDtcXG4gIHRvcDogY2FsYygxMDAlICsgMC42NDk1cmVtKTtcXG4gIG1heC13aWR0aDogMTByZW0gIWltcG9ydGFudDtcXG4gIGJvcmRlci1yYWRpdXM6IDA7IH1cXG4gIC50b29sdGlwOjpiZWZvcmUge1xcbiAgICBjb250ZW50OiAnJztcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICAgIHdpZHRoOiAwO1xcbiAgICBoZWlnaHQ6IDA7XFxuICAgIGJvcmRlcjogaW5zZXQgMC43NXJlbTtcXG4gICAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudCB0cmFuc3BhcmVudCAjMGEwYTBhO1xcbiAgICBib3JkZXItYm90dG9tLXN0eWxlOiBzb2xpZDtcXG4gICAgYm9yZGVyLXRvcC13aWR0aDogMDtcXG4gICAgYm90dG9tOiAxMDAlO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGxlZnQ6IDUwJTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpOyB9XFxuICAudG9vbHRpcC50b3A6OmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6ICcnO1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgd2lkdGg6IDA7XFxuICAgIGhlaWdodDogMDtcXG4gICAgYm9yZGVyOiBpbnNldCAwLjc1cmVtO1xcbiAgICBib3JkZXItY29sb3I6ICMwYTBhMGEgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQ7XFxuICAgIGJvcmRlci10b3Atc3R5bGU6IHNvbGlkO1xcbiAgICBib3JkZXItYm90dG9tLXdpZHRoOiAwO1xcbiAgICB0b3A6IDEwMCU7XFxuICAgIGJvdHRvbTogYXV0bzsgfVxcbiAgLnRvb2x0aXAubGVmdDo6YmVmb3JlIHtcXG4gICAgY29udGVudDogJyc7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICB3aWR0aDogMDtcXG4gICAgaGVpZ2h0OiAwO1xcbiAgICBib3JkZXI6IGluc2V0IDAuNzVyZW07XFxuICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgIzBhMGEwYTtcXG4gICAgYm9yZGVyLWxlZnQtc3R5bGU6IHNvbGlkO1xcbiAgICBib3JkZXItcmlnaHQtd2lkdGg6IDA7XFxuICAgIGJvdHRvbTogYXV0bztcXG4gICAgbGVmdDogMTAwJTtcXG4gICAgdG9wOiA1MCU7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKTsgfVxcbiAgLnRvb2x0aXAucmlnaHQ6OmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6ICcnO1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgd2lkdGg6IDA7XFxuICAgIGhlaWdodDogMDtcXG4gICAgYm9yZGVyOiBpbnNldCAwLjc1cmVtO1xcbiAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50ICMwYTBhMGEgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQ7XFxuICAgIGJvcmRlci1yaWdodC1zdHlsZTogc29saWQ7XFxuICAgIGJvcmRlci1sZWZ0LXdpZHRoOiAwO1xcbiAgICBib3R0b206IGF1dG87XFxuICAgIGxlZnQ6IGF1dG87XFxuICAgIHJpZ2h0OiAxMDAlO1xcbiAgICB0b3A6IDUwJTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpOyB9XFxuXFxuLnRvcC1iYXIge1xcbiAgcGFkZGluZzogMC41cmVtOyB9XFxuICAudG9wLWJhcjo6YmVmb3JlLCAudG9wLWJhcjo6YWZ0ZXIge1xcbiAgICBjb250ZW50OiAnICc7XFxuICAgIGRpc3BsYXk6IHRhYmxlOyB9XFxuICAudG9wLWJhcjo6YWZ0ZXIge1xcbiAgICBjbGVhcjogYm90aDsgfVxcbiAgLnRvcC1iYXIsXFxuICAudG9wLWJhciB1bCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNlNmU2ZTY7IH1cXG4gIC50b3AtYmFyIGlucHV0IHtcXG4gICAgbWF4LXdpZHRoOiAyMDBweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAxcmVtOyB9XFxuICAudG9wLWJhciAuaW5wdXQtZ3JvdXAtZmllbGQge1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgbWFyZ2luLXJpZ2h0OiAwOyB9XFxuICAudG9wLWJhciBpbnB1dC5idXR0b24ge1xcbiAgICB3aWR0aDogYXV0bzsgfVxcbiAgLnRvcC1iYXIgLnRvcC1iYXItbGVmdCxcXG4gIC50b3AtYmFyIC50b3AtYmFyLXJpZ2h0IHtcXG4gICAgd2lkdGg6IDEwMCU7IH1cXG4gIEBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDQwZW0pIHtcXG4gICAgLnRvcC1iYXIgLnRvcC1iYXItbGVmdCxcXG4gICAgLnRvcC1iYXIgLnRvcC1iYXItcmlnaHQge1xcbiAgICAgIHdpZHRoOiBhdXRvOyB9IH1cXG4gIEBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDYzLjkzNzVlbSkge1xcbiAgICAudG9wLWJhci5zdGFja2VkLWZvci1tZWRpdW0gLnRvcC1iYXItbGVmdCxcXG4gICAgLnRvcC1iYXIuc3RhY2tlZC1mb3ItbWVkaXVtIC50b3AtYmFyLXJpZ2h0IHtcXG4gICAgICB3aWR0aDogMTAwJTsgfSB9XFxuICBAbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA3NC45Mzc1ZW0pIHtcXG4gICAgLnRvcC1iYXIuc3RhY2tlZC1mb3ItbGFyZ2UgLnRvcC1iYXItbGVmdCxcXG4gICAgLnRvcC1iYXIuc3RhY2tlZC1mb3ItbGFyZ2UgLnRvcC1iYXItcmlnaHQge1xcbiAgICAgIHdpZHRoOiAxMDAlOyB9IH1cXG5cXG4udG9wLWJhci10aXRsZSB7XFxuICBmbG9hdDogbGVmdDtcXG4gIG1hcmdpbi1yaWdodDogMXJlbTsgfVxcblxcbi50b3AtYmFyLWxlZnQge1xcbiAgZmxvYXQ6IGxlZnQ7IH1cXG5cXG4udG9wLWJhci1yaWdodCB7XFxuICBmbG9hdDogcmlnaHQ7IH1cXG5cXG4uaGlkZSB7XFxuICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7IH1cXG5cXG4uaW52aXNpYmxlIHtcXG4gIHZpc2liaWxpdHk6IGhpZGRlbjsgfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDM5LjkzNzVlbSkge1xcbiAgLmhpZGUtZm9yLXNtYWxsLW9ubHkge1xcbiAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7IH0gfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDBlbSksIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNDBlbSkge1xcbiAgLnNob3ctZm9yLXNtYWxsLW9ubHkge1xcbiAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7IH0gfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDQwZW0pIHtcXG4gIC5oaWRlLWZvci1tZWRpdW0ge1xcbiAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7IH0gfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDM5LjkzNzVlbSkge1xcbiAgLnNob3ctZm9yLW1lZGl1bSB7XFxuICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDsgfSB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNDBlbSkgYW5kIChtYXgtd2lkdGg6IDYzLjkzNzVlbSkge1xcbiAgLmhpZGUtZm9yLW1lZGl1bS1vbmx5IHtcXG4gICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50OyB9IH1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiAzOS45Mzc1ZW0pLCBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDY0ZW0pIHtcXG4gIC5zaG93LWZvci1tZWRpdW0tb25seSB7XFxuICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDsgfSB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNjRlbSkge1xcbiAgLmhpZGUtZm9yLWxhcmdlIHtcXG4gICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50OyB9IH1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA2My45Mzc1ZW0pIHtcXG4gIC5zaG93LWZvci1sYXJnZSB7XFxuICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDsgfSB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNjRlbSkgYW5kIChtYXgtd2lkdGg6IDc0LjkzNzVlbSkge1xcbiAgLmhpZGUtZm9yLWxhcmdlLW9ubHkge1xcbiAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7IH0gfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDYzLjkzNzVlbSksIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNzVlbSkge1xcbiAgLnNob3ctZm9yLWxhcmdlLW9ubHkge1xcbiAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7IH0gfVxcblxcbi5zaG93LWZvci1zcixcXG4uc2hvdy1vbi1mb2N1cyB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGUgIWltcG9ydGFudDtcXG4gIHdpZHRoOiAxcHg7XFxuICBoZWlnaHQ6IDFweDtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICBjbGlwOiByZWN0KDAsIDAsIDAsIDApOyB9XFxuXFxuLnNob3ctb24tZm9jdXM6YWN0aXZlLCAuc2hvdy1vbi1mb2N1czpmb2N1cyB7XFxuICBwb3NpdGlvbjogc3RhdGljICFpbXBvcnRhbnQ7XFxuICBoZWlnaHQ6IGF1dG87XFxuICB3aWR0aDogYXV0bztcXG4gIG92ZXJmbG93OiB2aXNpYmxlO1xcbiAgY2xpcDogYXV0bzsgfVxcblxcbi5zaG93LWZvci1sYW5kc2NhcGUsXFxuLmhpZGUtZm9yLXBvcnRyYWl0IHtcXG4gIGRpc3BsYXk6IGJsb2NrICFpbXBvcnRhbnQ7IH1cXG4gIEBtZWRpYSBzY3JlZW4gYW5kIChvcmllbnRhdGlvbjogbGFuZHNjYXBlKSB7XFxuICAgIC5zaG93LWZvci1sYW5kc2NhcGUsXFxuICAgIC5oaWRlLWZvci1wb3J0cmFpdCB7XFxuICAgICAgZGlzcGxheTogYmxvY2sgIWltcG9ydGFudDsgfSB9XFxuICBAbWVkaWEgc2NyZWVuIGFuZCAob3JpZW50YXRpb246IHBvcnRyYWl0KSB7XFxuICAgIC5zaG93LWZvci1sYW5kc2NhcGUsXFxuICAgIC5oaWRlLWZvci1wb3J0cmFpdCB7XFxuICAgICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50OyB9IH1cXG5cXG4uaGlkZS1mb3ItbGFuZHNjYXBlLFxcbi5zaG93LWZvci1wb3J0cmFpdCB7XFxuICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7IH1cXG4gIEBtZWRpYSBzY3JlZW4gYW5kIChvcmllbnRhdGlvbjogbGFuZHNjYXBlKSB7XFxuICAgIC5oaWRlLWZvci1sYW5kc2NhcGUsXFxuICAgIC5zaG93LWZvci1wb3J0cmFpdCB7XFxuICAgICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50OyB9IH1cXG4gIEBtZWRpYSBzY3JlZW4gYW5kIChvcmllbnRhdGlvbjogcG9ydHJhaXQpIHtcXG4gICAgLmhpZGUtZm9yLWxhbmRzY2FwZSxcXG4gICAgLnNob3ctZm9yLXBvcnRyYWl0IHtcXG4gICAgICBkaXNwbGF5OiBibG9jayAhaW1wb3J0YW50OyB9IH1cXG5cXG4uZmxvYXQtbGVmdCB7XFxuICBmbG9hdDogbGVmdCAhaW1wb3J0YW50OyB9XFxuXFxuLmZsb2F0LXJpZ2h0IHtcXG4gIGZsb2F0OiByaWdodCAhaW1wb3J0YW50OyB9XFxuXFxuLmZsb2F0LWNlbnRlciB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIG1hcmdpbi1sZWZ0OiBhdXRvO1xcbiAgbWFyZ2luLXJpZ2h0OiBhdXRvOyB9XFxuXFxuLmNsZWFyZml4OjpiZWZvcmUsIC5jbGVhcmZpeDo6YWZ0ZXIge1xcbiAgY29udGVudDogJyAnO1xcbiAgZGlzcGxheTogdGFibGU7IH1cXG5cXG4uY2xlYXJmaXg6OmFmdGVyIHtcXG4gIGNsZWFyOiBib3RoOyB9XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY3NzLWxvYWRlciEuL34vc2Fzcy1sb2FkZXIhLi9hcHAvc3R5bGVzL2FwcC5zY3NzXG4gKiogbW9kdWxlIGlkID0gMjMwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBsaXN0ID0gW107XHJcblxyXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcclxuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XHJcblx0XHR2YXIgcmVzdWx0ID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IHRoaXNbaV07XHJcblx0XHRcdGlmKGl0ZW1bMl0pIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGl0ZW1bMV0gKyBcIn1cIik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2goaXRlbVsxXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiByZXN1bHQuam9pbihcIlwiKTtcclxuXHR9O1xyXG5cclxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxyXG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcclxuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxyXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XHJcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcclxuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxyXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcclxuXHRcdH1cclxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xyXG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXHJcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXHJcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXHJcblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXHJcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XHJcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xyXG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcclxuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuXHRyZXR1cm4gbGlzdDtcclxufTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXG4gKiovIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIHN0eWxlc0luRG9tID0ge30sXHJcblx0bWVtb2l6ZSA9IGZ1bmN0aW9uKGZuKSB7XHJcblx0XHR2YXIgbWVtbztcclxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0XHRcdHJldHVybiBtZW1vO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cdGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIC9tc2llIFs2LTldXFxiLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpO1xyXG5cdH0pLFxyXG5cdGdldEhlYWRFbGVtZW50ID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XHJcblx0fSksXHJcblx0c2luZ2xldG9uRWxlbWVudCA9IG51bGwsXHJcblx0c2luZ2xldG9uQ291bnRlciA9IDAsXHJcblx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AgPSBbXTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xyXG5cdGlmKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xyXG5cdFx0aWYodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XHJcblx0fVxyXG5cclxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cclxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXHJcblx0aWYgKHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XHJcblxyXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiA8aGVhZD4uXHJcblx0aWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcclxuXHJcblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0KTtcclxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcclxuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XHJcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xyXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XHJcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcclxuXHRcdH1cclxuXHRcdGlmKG5ld0xpc3QpIHtcclxuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0KTtcclxuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xyXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XHJcblx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKVxyXG5cdFx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oKTtcclxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKSB7XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XHJcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcclxuXHRcdGlmKGRvbVN0eWxlKSB7XHJcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcclxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFyIHBhcnRzID0gW107XHJcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMobGlzdCkge1xyXG5cdHZhciBzdHlsZXMgPSBbXTtcclxuXHR2YXIgbmV3U3R5bGVzID0ge307XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcclxuXHRcdHZhciBpZCA9IGl0ZW1bMF07XHJcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcclxuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XHJcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcclxuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcclxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKVxyXG5cdFx0XHRzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XHJcblx0fVxyXG5cdHJldHVybiBzdHlsZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpIHtcclxuXHR2YXIgaGVhZCA9IGdldEhlYWRFbGVtZW50KCk7XHJcblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3Bbc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XHJcblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcclxuXHRcdGlmKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xyXG5cdFx0XHRoZWFkLmluc2VydEJlZm9yZShzdHlsZUVsZW1lbnQsIGhlYWQuZmlyc3RDaGlsZCk7XHJcblx0XHR9IGVsc2UgaWYobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcclxuXHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0XHR9XHJcblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlRWxlbWVudCk7XHJcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XHJcblx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnLiBNdXN0IGJlICd0b3AnIG9yICdib3R0b20nLlwiKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcclxuXHRzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdHZhciBpZHggPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlRWxlbWVudCk7XHJcblx0aWYoaWR4ID49IDApIHtcclxuXHRcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcclxuXHR2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xyXG5cdHN0eWxlRWxlbWVudC50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xyXG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpO1xyXG5cdHJldHVybiBzdHlsZUVsZW1lbnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpIHtcclxuXHR2YXIgbGlua0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcclxuXHRsaW5rRWxlbWVudC5yZWwgPSBcInN0eWxlc2hlZXRcIjtcclxuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGlua0VsZW1lbnQpO1xyXG5cdHJldHVybiBsaW5rRWxlbWVudDtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XHJcblx0dmFyIHN0eWxlRWxlbWVudCwgdXBkYXRlLCByZW1vdmU7XHJcblxyXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xyXG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XHJcblx0XHRzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcclxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIGZhbHNlKTtcclxuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpO1xyXG5cdH0gZWxzZSBpZihvYmouc291cmNlTWFwICYmXHJcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xyXG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XHJcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XHJcblx0XHRcdGlmKHN0eWxlRWxlbWVudC5ocmVmKVxyXG5cdFx0XHRcdFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGVFbGVtZW50LmhyZWYpO1xyXG5cdFx0fTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xyXG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XHJcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0dXBkYXRlKG9iaik7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcclxuXHRcdGlmKG5ld09iaikge1xyXG5cdFx0XHRpZihuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJlbW92ZSgpO1xyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XHJcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xyXG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xyXG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XHJcblx0fTtcclxufSkoKTtcclxuXHJcbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcclxuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XHJcblxyXG5cdGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XHJcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzO1xyXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xyXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGNzc05vZGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZUVsZW1lbnQsIG9iaikge1xyXG5cdHZhciBjc3MgPSBvYmouY3NzO1xyXG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcclxuXHJcblx0aWYobWVkaWEpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcclxuXHR9XHJcblxyXG5cdGlmKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR3aGlsZShzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xyXG5cdFx0fVxyXG5cdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlTGluayhsaW5rRWxlbWVudCwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IG9iai5jc3M7XHJcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XHJcblxyXG5cdGlmKHNvdXJjZU1hcCkge1xyXG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcclxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcclxuXHR9XHJcblxyXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xyXG5cclxuXHR2YXIgb2xkU3JjID0gbGlua0VsZW1lbnQuaHJlZjtcclxuXHJcblx0bGlua0VsZW1lbnQuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcblxyXG5cdGlmKG9sZFNyYylcclxuXHRcdFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcclxufVxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXG4gKiogbW9kdWxlIGlkID0gMjMyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNvbXBvc2UgPSBleHBvcnRzLmFwcGx5TWlkZGxld2FyZSA9IGV4cG9ydHMuYmluZEFjdGlvbkNyZWF0b3JzID0gZXhwb3J0cy5jb21iaW5lUmVkdWNlcnMgPSBleHBvcnRzLmNyZWF0ZVN0b3JlID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZVN0b3JlID0gcmVxdWlyZSgnLi9jcmVhdGVTdG9yZScpO1xuXG52YXIgX2NyZWF0ZVN0b3JlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVN0b3JlKTtcblxudmFyIF9jb21iaW5lUmVkdWNlcnMgPSByZXF1aXJlKCcuL2NvbWJpbmVSZWR1Y2VycycpO1xuXG52YXIgX2NvbWJpbmVSZWR1Y2VyczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21iaW5lUmVkdWNlcnMpO1xuXG52YXIgX2JpbmRBY3Rpb25DcmVhdG9ycyA9IHJlcXVpcmUoJy4vYmluZEFjdGlvbkNyZWF0b3JzJyk7XG5cbnZhciBfYmluZEFjdGlvbkNyZWF0b3JzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JpbmRBY3Rpb25DcmVhdG9ycyk7XG5cbnZhciBfYXBwbHlNaWRkbGV3YXJlID0gcmVxdWlyZSgnLi9hcHBseU1pZGRsZXdhcmUnKTtcblxudmFyIF9hcHBseU1pZGRsZXdhcmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXBwbHlNaWRkbGV3YXJlKTtcblxudmFyIF9jb21wb3NlID0gcmVxdWlyZSgnLi9jb21wb3NlJyk7XG5cbnZhciBfY29tcG9zZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wb3NlKTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnLi91dGlscy93YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKlxuKiBUaGlzIGlzIGEgZHVtbXkgZnVuY3Rpb24gdG8gY2hlY2sgaWYgdGhlIGZ1bmN0aW9uIG5hbWUgaGFzIGJlZW4gYWx0ZXJlZCBieSBtaW5pZmljYXRpb24uXG4qIElmIHRoZSBmdW5jdGlvbiBoYXMgYmVlbiBtaW5pZmllZCBhbmQgTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJywgd2FybiB0aGUgdXNlci5cbiovXG5mdW5jdGlvbiBpc0NydXNoZWQoKSB7fVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgaXNDcnVzaGVkLm5hbWUgPT09ICdzdHJpbmcnICYmIGlzQ3J1c2hlZC5uYW1lICE9PSAnaXNDcnVzaGVkJykge1xuICAoMCwgX3dhcm5pbmcyWydkZWZhdWx0J10pKCdZb3UgYXJlIGN1cnJlbnRseSB1c2luZyBtaW5pZmllZCBjb2RlIG91dHNpZGUgb2YgTk9ERV9FTlYgPT09IFxcJ3Byb2R1Y3Rpb25cXCcuICcgKyAnVGhpcyBtZWFucyB0aGF0IHlvdSBhcmUgcnVubmluZyBhIHNsb3dlciBkZXZlbG9wbWVudCBidWlsZCBvZiBSZWR1eC4gJyArICdZb3UgY2FuIHVzZSBsb29zZS1lbnZpZnkgKGh0dHBzOi8vZ2l0aHViLmNvbS96ZXJ0b3NoL2xvb3NlLWVudmlmeSkgZm9yIGJyb3dzZXJpZnkgJyArICdvciBEZWZpbmVQbHVnaW4gZm9yIHdlYnBhY2sgKGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzAwMzAwMzEpICcgKyAndG8gZW5zdXJlIHlvdSBoYXZlIHRoZSBjb3JyZWN0IGNvZGUgZm9yIHlvdXIgcHJvZHVjdGlvbiBidWlsZC4nKTtcbn1cblxuZXhwb3J0cy5jcmVhdGVTdG9yZSA9IF9jcmVhdGVTdG9yZTJbJ2RlZmF1bHQnXTtcbmV4cG9ydHMuY29tYmluZVJlZHVjZXJzID0gX2NvbWJpbmVSZWR1Y2VyczJbJ2RlZmF1bHQnXTtcbmV4cG9ydHMuYmluZEFjdGlvbkNyZWF0b3JzID0gX2JpbmRBY3Rpb25DcmVhdG9yczJbJ2RlZmF1bHQnXTtcbmV4cG9ydHMuYXBwbHlNaWRkbGV3YXJlID0gX2FwcGx5TWlkZGxld2FyZTJbJ2RlZmF1bHQnXTtcbmV4cG9ydHMuY29tcG9zZSA9IF9jb21wb3NlMlsnZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWR1eC9saWIvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLkFjdGlvblR5cGVzID0gdW5kZWZpbmVkO1xuZXhwb3J0c1snZGVmYXVsdCddID0gY3JlYXRlU3RvcmU7XG5cbnZhciBfaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJ2xvZGFzaC9pc1BsYWluT2JqZWN0Jyk7XG5cbnZhciBfaXNQbGFpbk9iamVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc1BsYWluT2JqZWN0KTtcblxudmFyIF9zeW1ib2xPYnNlcnZhYmxlID0gcmVxdWlyZSgnc3ltYm9sLW9ic2VydmFibGUnKTtcblxudmFyIF9zeW1ib2xPYnNlcnZhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N5bWJvbE9ic2VydmFibGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbi8qKlxuICogVGhlc2UgYXJlIHByaXZhdGUgYWN0aW9uIHR5cGVzIHJlc2VydmVkIGJ5IFJlZHV4LlxuICogRm9yIGFueSB1bmtub3duIGFjdGlvbnMsIHlvdSBtdXN0IHJldHVybiB0aGUgY3VycmVudCBzdGF0ZS5cbiAqIElmIHRoZSBjdXJyZW50IHN0YXRlIGlzIHVuZGVmaW5lZCwgeW91IG11c3QgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLlxuICogRG8gbm90IHJlZmVyZW5jZSB0aGVzZSBhY3Rpb24gdHlwZXMgZGlyZWN0bHkgaW4geW91ciBjb2RlLlxuICovXG52YXIgQWN0aW9uVHlwZXMgPSBleHBvcnRzLkFjdGlvblR5cGVzID0ge1xuICBJTklUOiAnQEByZWR1eC9JTklUJ1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgUmVkdXggc3RvcmUgdGhhdCBob2xkcyB0aGUgc3RhdGUgdHJlZS5cbiAqIFRoZSBvbmx5IHdheSB0byBjaGFuZ2UgdGhlIGRhdGEgaW4gdGhlIHN0b3JlIGlzIHRvIGNhbGwgYGRpc3BhdGNoKClgIG9uIGl0LlxuICpcbiAqIFRoZXJlIHNob3VsZCBvbmx5IGJlIGEgc2luZ2xlIHN0b3JlIGluIHlvdXIgYXBwLiBUbyBzcGVjaWZ5IGhvdyBkaWZmZXJlbnRcbiAqIHBhcnRzIG9mIHRoZSBzdGF0ZSB0cmVlIHJlc3BvbmQgdG8gYWN0aW9ucywgeW91IG1heSBjb21iaW5lIHNldmVyYWwgcmVkdWNlcnNcbiAqIGludG8gYSBzaW5nbGUgcmVkdWNlciBmdW5jdGlvbiBieSB1c2luZyBgY29tYmluZVJlZHVjZXJzYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWR1Y2VyIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBuZXh0IHN0YXRlIHRyZWUsIGdpdmVuXG4gKiB0aGUgY3VycmVudCBzdGF0ZSB0cmVlIGFuZCB0aGUgYWN0aW9uIHRvIGhhbmRsZS5cbiAqXG4gKiBAcGFyYW0ge2FueX0gW3ByZWxvYWRlZFN0YXRlXSBUaGUgaW5pdGlhbCBzdGF0ZS4gWW91IG1heSBvcHRpb25hbGx5IHNwZWNpZnkgaXRcbiAqIHRvIGh5ZHJhdGUgdGhlIHN0YXRlIGZyb20gdGhlIHNlcnZlciBpbiB1bml2ZXJzYWwgYXBwcywgb3IgdG8gcmVzdG9yZSBhXG4gKiBwcmV2aW91c2x5IHNlcmlhbGl6ZWQgdXNlciBzZXNzaW9uLlxuICogSWYgeW91IHVzZSBgY29tYmluZVJlZHVjZXJzYCB0byBwcm9kdWNlIHRoZSByb290IHJlZHVjZXIgZnVuY3Rpb24sIHRoaXMgbXVzdCBiZVxuICogYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUgc2hhcGUgYXMgYGNvbWJpbmVSZWR1Y2Vyc2Aga2V5cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbmhhbmNlciBUaGUgc3RvcmUgZW5oYW5jZXIuIFlvdSBtYXkgb3B0aW9uYWxseSBzcGVjaWZ5IGl0XG4gKiB0byBlbmhhbmNlIHRoZSBzdG9yZSB3aXRoIHRoaXJkLXBhcnR5IGNhcGFiaWxpdGllcyBzdWNoIGFzIG1pZGRsZXdhcmUsXG4gKiB0aW1lIHRyYXZlbCwgcGVyc2lzdGVuY2UsIGV0Yy4gVGhlIG9ubHkgc3RvcmUgZW5oYW5jZXIgdGhhdCBzaGlwcyB3aXRoIFJlZHV4XG4gKiBpcyBgYXBwbHlNaWRkbGV3YXJlKClgLlxuICpcbiAqIEByZXR1cm5zIHtTdG9yZX0gQSBSZWR1eCBzdG9yZSB0aGF0IGxldHMgeW91IHJlYWQgdGhlIHN0YXRlLCBkaXNwYXRjaCBhY3Rpb25zXG4gKiBhbmQgc3Vic2NyaWJlIHRvIGNoYW5nZXMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBlbmhhbmNlcikge1xuICB2YXIgX3JlZjI7XG5cbiAgaWYgKHR5cGVvZiBwcmVsb2FkZWRTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZW5oYW5jZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZW5oYW5jZXIgPSBwcmVsb2FkZWRTdGF0ZTtcbiAgICBwcmVsb2FkZWRTdGF0ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBlbmhhbmNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgZW5oYW5jZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5oYW5jZXIoY3JlYXRlU3RvcmUpKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIHJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHZhciBjdXJyZW50UmVkdWNlciA9IHJlZHVjZXI7XG4gIHZhciBjdXJyZW50U3RhdGUgPSBwcmVsb2FkZWRTdGF0ZTtcbiAgdmFyIGN1cnJlbnRMaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzO1xuICB2YXIgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKG5leHRMaXN0ZW5lcnMgPT09IGN1cnJlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzLnNsaWNlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIHRoZSBzdGF0ZSB0cmVlIG1hbmFnZWQgYnkgdGhlIHN0b3JlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7YW55fSBUaGUgY3VycmVudCBzdGF0ZSB0cmVlIG9mIHlvdXIgYXBwbGljYXRpb24uXG4gICAqL1xuICBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICByZXR1cm4gY3VycmVudFN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBjaGFuZ2UgbGlzdGVuZXIuIEl0IHdpbGwgYmUgY2FsbGVkIGFueSB0aW1lIGFuIGFjdGlvbiBpcyBkaXNwYXRjaGVkLFxuICAgKiBhbmQgc29tZSBwYXJ0IG9mIHRoZSBzdGF0ZSB0cmVlIG1heSBwb3RlbnRpYWxseSBoYXZlIGNoYW5nZWQuIFlvdSBtYXkgdGhlblxuICAgKiBjYWxsIGBnZXRTdGF0ZSgpYCB0byByZWFkIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgaW5zaWRlIHRoZSBjYWxsYmFjay5cbiAgICpcbiAgICogWW91IG1heSBjYWxsIGBkaXNwYXRjaCgpYCBmcm9tIGEgY2hhbmdlIGxpc3RlbmVyLCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICogY2F2ZWF0czpcbiAgICpcbiAgICogMS4gVGhlIHN1YnNjcmlwdGlvbnMgYXJlIHNuYXBzaG90dGVkIGp1c3QgYmVmb3JlIGV2ZXJ5IGBkaXNwYXRjaCgpYCBjYWxsLlxuICAgKiBJZiB5b3Ugc3Vic2NyaWJlIG9yIHVuc3Vic2NyaWJlIHdoaWxlIHRoZSBsaXN0ZW5lcnMgYXJlIGJlaW5nIGludm9rZWQsIHRoaXNcbiAgICogd2lsbCBub3QgaGF2ZSBhbnkgZWZmZWN0IG9uIHRoZSBgZGlzcGF0Y2goKWAgdGhhdCBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3MuXG4gICAqIEhvd2V2ZXIsIHRoZSBuZXh0IGBkaXNwYXRjaCgpYCBjYWxsLCB3aGV0aGVyIG5lc3RlZCBvciBub3QsIHdpbGwgdXNlIGEgbW9yZVxuICAgKiByZWNlbnQgc25hcHNob3Qgb2YgdGhlIHN1YnNjcmlwdGlvbiBsaXN0LlxuICAgKlxuICAgKiAyLiBUaGUgbGlzdGVuZXIgc2hvdWxkIG5vdCBleHBlY3QgdG8gc2VlIGFsbCBzdGF0ZSBjaGFuZ2VzLCBhcyB0aGUgc3RhdGVcbiAgICogbWlnaHQgaGF2ZSBiZWVuIHVwZGF0ZWQgbXVsdGlwbGUgdGltZXMgZHVyaW5nIGEgbmVzdGVkIGBkaXNwYXRjaCgpYCBiZWZvcmVcbiAgICogdGhlIGxpc3RlbmVyIGlzIGNhbGxlZC4gSXQgaXMsIGhvd2V2ZXIsIGd1YXJhbnRlZWQgdGhhdCBhbGwgc3Vic2NyaWJlcnNcbiAgICogcmVnaXN0ZXJlZCBiZWZvcmUgdGhlIGBkaXNwYXRjaCgpYCBzdGFydGVkIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGxhdGVzdFxuICAgKiBzdGF0ZSBieSB0aGUgdGltZSBpdCBleGl0cy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgQSBjYWxsYmFjayB0byBiZSBpbnZva2VkIG9uIGV2ZXJ5IGRpc3BhdGNoLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdG8gcmVtb3ZlIHRoaXMgY2hhbmdlIGxpc3RlbmVyLlxuICAgKi9cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIHZhciBpc1N1YnNjcmliZWQgPSB0cnVlO1xuXG4gICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgIG5leHRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICBpZiAoIWlzU3Vic2NyaWJlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlzU3Vic2NyaWJlZCA9IGZhbHNlO1xuXG4gICAgICBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCk7XG4gICAgICB2YXIgaW5kZXggPSBuZXh0TGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgbmV4dExpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhbiBhY3Rpb24uIEl0IGlzIHRoZSBvbmx5IHdheSB0byB0cmlnZ2VyIGEgc3RhdGUgY2hhbmdlLlxuICAgKlxuICAgKiBUaGUgYHJlZHVjZXJgIGZ1bmN0aW9uLCB1c2VkIHRvIGNyZWF0ZSB0aGUgc3RvcmUsIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlXG4gICAqIGN1cnJlbnQgc3RhdGUgdHJlZSBhbmQgdGhlIGdpdmVuIGBhY3Rpb25gLiBJdHMgcmV0dXJuIHZhbHVlIHdpbGxcbiAgICogYmUgY29uc2lkZXJlZCB0aGUgKipuZXh0Kiogc3RhdGUgb2YgdGhlIHRyZWUsIGFuZCB0aGUgY2hhbmdlIGxpc3RlbmVyc1xuICAgKiB3aWxsIGJlIG5vdGlmaWVkLlxuICAgKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvbmx5IHN1cHBvcnRzIHBsYWluIG9iamVjdCBhY3Rpb25zLiBJZiB5b3Ugd2FudCB0b1xuICAgKiBkaXNwYXRjaCBhIFByb21pc2UsIGFuIE9ic2VydmFibGUsIGEgdGh1bmssIG9yIHNvbWV0aGluZyBlbHNlLCB5b3UgbmVlZCB0b1xuICAgKiB3cmFwIHlvdXIgc3RvcmUgY3JlYXRpbmcgZnVuY3Rpb24gaW50byB0aGUgY29ycmVzcG9uZGluZyBtaWRkbGV3YXJlLiBGb3JcbiAgICogZXhhbXBsZSwgc2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciB0aGUgYHJlZHV4LXRodW5rYCBwYWNrYWdlLiBFdmVuIHRoZVxuICAgKiBtaWRkbGV3YXJlIHdpbGwgZXZlbnR1YWxseSBkaXNwYXRjaCBwbGFpbiBvYmplY3QgYWN0aW9ucyB1c2luZyB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBBIHBsYWluIG9iamVjdCByZXByZXNlbnRpbmcg4oCcd2hhdCBjaGFuZ2Vk4oCdLiBJdCBpc1xuICAgKiBhIGdvb2QgaWRlYSB0byBrZWVwIGFjdGlvbnMgc2VyaWFsaXphYmxlIHNvIHlvdSBjYW4gcmVjb3JkIGFuZCByZXBsYXkgdXNlclxuICAgKiBzZXNzaW9ucywgb3IgdXNlIHRoZSB0aW1lIHRyYXZlbGxpbmcgYHJlZHV4LWRldnRvb2xzYC4gQW4gYWN0aW9uIG11c3QgaGF2ZVxuICAgKiBhIGB0eXBlYCBwcm9wZXJ0eSB3aGljaCBtYXkgbm90IGJlIGB1bmRlZmluZWRgLiBJdCBpcyBhIGdvb2QgaWRlYSB0byB1c2VcbiAgICogc3RyaW5nIGNvbnN0YW50cyBmb3IgYWN0aW9uIHR5cGVzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBGb3IgY29udmVuaWVuY2UsIHRoZSBzYW1lIGFjdGlvbiBvYmplY3QgeW91IGRpc3BhdGNoZWQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCwgaWYgeW91IHVzZSBhIGN1c3RvbSBtaWRkbGV3YXJlLCBpdCBtYXkgd3JhcCBgZGlzcGF0Y2goKWAgdG9cbiAgICogcmV0dXJuIHNvbWV0aGluZyBlbHNlIChmb3IgZXhhbXBsZSwgYSBQcm9taXNlIHlvdSBjYW4gYXdhaXQpLlxuICAgKi9cbiAgZnVuY3Rpb24gZGlzcGF0Y2goYWN0aW9uKSB7XG4gICAgaWYgKCEoMCwgX2lzUGxhaW5PYmplY3QyWydkZWZhdWx0J10pKGFjdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWN0aW9ucyBtdXN0IGJlIHBsYWluIG9iamVjdHMuICcgKyAnVXNlIGN1c3RvbSBtaWRkbGV3YXJlIGZvciBhc3luYyBhY3Rpb25zLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYWN0aW9uLnR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdGlvbnMgbWF5IG5vdCBoYXZlIGFuIHVuZGVmaW5lZCBcInR5cGVcIiBwcm9wZXJ0eS4gJyArICdIYXZlIHlvdSBtaXNzcGVsbGVkIGEgY29uc3RhbnQ/Jyk7XG4gICAgfVxuXG4gICAgaWYgKGlzRGlzcGF0Y2hpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVkdWNlcnMgbWF5IG5vdCBkaXNwYXRjaCBhY3Rpb25zLicpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpc0Rpc3BhdGNoaW5nID0gdHJ1ZTtcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnRSZWR1Y2VyKGN1cnJlbnRTdGF0ZSwgYWN0aW9uKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBsaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzID0gbmV4dExpc3RlbmVycztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgbGlzdGVuZXJzW2ldKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyB0aGUgcmVkdWNlciBjdXJyZW50bHkgdXNlZCBieSB0aGUgc3RvcmUgdG8gY2FsY3VsYXRlIHRoZSBzdGF0ZS5cbiAgICpcbiAgICogWW91IG1pZ2h0IG5lZWQgdGhpcyBpZiB5b3VyIGFwcCBpbXBsZW1lbnRzIGNvZGUgc3BsaXR0aW5nIGFuZCB5b3Ugd2FudCB0b1xuICAgKiBsb2FkIHNvbWUgb2YgdGhlIHJlZHVjZXJzIGR5bmFtaWNhbGx5LiBZb3UgbWlnaHQgYWxzbyBuZWVkIHRoaXMgaWYgeW91XG4gICAqIGltcGxlbWVudCBhIGhvdCByZWxvYWRpbmcgbWVjaGFuaXNtIGZvciBSZWR1eC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbmV4dFJlZHVjZXIgVGhlIHJlZHVjZXIgZm9yIHRoZSBzdG9yZSB0byB1c2UgaW5zdGVhZC5cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBmdW5jdGlvbiByZXBsYWNlUmVkdWNlcihuZXh0UmVkdWNlcikge1xuICAgIGlmICh0eXBlb2YgbmV4dFJlZHVjZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIG5leHRSZWR1Y2VyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgY3VycmVudFJlZHVjZXIgPSBuZXh0UmVkdWNlcjtcbiAgICBkaXNwYXRjaCh7IHR5cGU6IEFjdGlvblR5cGVzLklOSVQgfSk7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJvcGVyYWJpbGl0eSBwb2ludCBmb3Igb2JzZXJ2YWJsZS9yZWFjdGl2ZSBsaWJyYXJpZXMuXG4gICAqIEByZXR1cm5zIHtvYnNlcnZhYmxlfSBBIG1pbmltYWwgb2JzZXJ2YWJsZSBvZiBzdGF0ZSBjaGFuZ2VzLlxuICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIHRoZSBvYnNlcnZhYmxlIHByb3Bvc2FsOlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vemVucGFyc2luZy9lcy1vYnNlcnZhYmxlXG4gICAqL1xuICBmdW5jdGlvbiBvYnNlcnZhYmxlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIG91dGVyU3Vic2NyaWJlID0gc3Vic2NyaWJlO1xuICAgIHJldHVybiBfcmVmID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbWluaW1hbCBvYnNlcnZhYmxlIHN1YnNjcmlwdGlvbiBtZXRob2QuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JzZXJ2ZXIgQW55IG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGFzIGFuIG9ic2VydmVyLlxuICAgICAgICogVGhlIG9ic2VydmVyIG9iamVjdCBzaG91bGQgaGF2ZSBhIGBuZXh0YCBtZXRob2QuXG4gICAgICAgKiBAcmV0dXJucyB7c3Vic2NyaXB0aW9ufSBBbiBvYmplY3Qgd2l0aCBhbiBgdW5zdWJzY3JpYmVgIG1ldGhvZCB0aGF0IGNhblxuICAgICAgICogYmUgdXNlZCB0byB1bnN1YnNjcmliZSB0aGUgb2JzZXJ2YWJsZSBmcm9tIHRoZSBzdG9yZSwgYW5kIHByZXZlbnQgZnVydGhlclxuICAgICAgICogZW1pc3Npb24gb2YgdmFsdWVzIGZyb20gdGhlIG9ic2VydmFibGUuXG4gICAgICAgKi9cbiAgICAgIHN1YnNjcmliZTogZnVuY3Rpb24gc3Vic2NyaWJlKG9ic2VydmVyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JzZXJ2ZXIgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgdGhlIG9ic2VydmVyIHRvIGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9ic2VydmVTdGF0ZSgpIHtcbiAgICAgICAgICBpZiAob2JzZXJ2ZXIubmV4dCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChnZXRTdGF0ZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvYnNlcnZlU3RhdGUoKTtcbiAgICAgICAgdmFyIHVuc3Vic2NyaWJlID0gb3V0ZXJTdWJzY3JpYmUob2JzZXJ2ZVN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHsgdW5zdWJzY3JpYmU6IHVuc3Vic2NyaWJlIH07XG4gICAgICB9XG4gICAgfSwgX3JlZltfc3ltYm9sT2JzZXJ2YWJsZTJbJ2RlZmF1bHQnXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBfcmVmO1xuICB9XG5cbiAgLy8gV2hlbiBhIHN0b3JlIGlzIGNyZWF0ZWQsIGFuIFwiSU5JVFwiIGFjdGlvbiBpcyBkaXNwYXRjaGVkIHNvIHRoYXQgZXZlcnlcbiAgLy8gcmVkdWNlciByZXR1cm5zIHRoZWlyIGluaXRpYWwgc3RhdGUuIFRoaXMgZWZmZWN0aXZlbHkgcG9wdWxhdGVzXG4gIC8vIHRoZSBpbml0aWFsIHN0YXRlIHRyZWUuXG4gIGRpc3BhdGNoKHsgdHlwZTogQWN0aW9uVHlwZXMuSU5JVCB9KTtcblxuICByZXR1cm4gX3JlZjIgPSB7XG4gICAgZGlzcGF0Y2g6IGRpc3BhdGNoLFxuICAgIHN1YnNjcmliZTogc3Vic2NyaWJlLFxuICAgIGdldFN0YXRlOiBnZXRTdGF0ZSxcbiAgICByZXBsYWNlUmVkdWNlcjogcmVwbGFjZVJlZHVjZXJcbiAgfSwgX3JlZjJbX3N5bWJvbE9ic2VydmFibGUyWydkZWZhdWx0J11dID0gb2JzZXJ2YWJsZSwgX3JlZjI7XG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlZHV4L2xpYi9jcmVhdGVTdG9yZS5qc1xuICoqLyIsInZhciBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuOC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fCBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSAhPSBvYmplY3RUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmXG4gICAgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiYgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQbGFpbk9iamVjdDtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9sb2Rhc2gvaXNQbGFpbk9iamVjdC5qc1xuICoqLyIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRQcm90b3R5cGU7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vbG9kYXNoL19nZXRQcm90b3R5cGUuanNcbiAqKi8iLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyQXJnO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2xvZGFzaC9fb3ZlckFyZy5qc1xuICoqLyIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9pbmRleCcpO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3N5bWJvbC1vYnNlcnZhYmxlL2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3BvbnlmaWxsID0gcmVxdWlyZSgnLi9wb255ZmlsbCcpO1xuXG52YXIgX3BvbnlmaWxsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BvbnlmaWxsKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgcm9vdCA9IG1vZHVsZTsgLyogZ2xvYmFsIHdpbmRvdyAqL1xuXG5cbmlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgcm9vdCA9IHNlbGY7XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBnbG9iYWw7XG59IGVsc2Uge1xuICByb290ID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbn1cblxudmFyIHJlc3VsdCA9ICgwLCBfcG9ueWZpbGwyWydkZWZhdWx0J10pKHJvb3QpO1xuZXhwb3J0c1snZGVmYXVsdCddID0gcmVzdWx0O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9zeW1ib2wtb2JzZXJ2YWJsZS9saWIvaW5kZXguanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHN5bWJvbE9ic2VydmFibGVQb255ZmlsbDtcbmZ1bmN0aW9uIHN5bWJvbE9ic2VydmFibGVQb255ZmlsbChyb290KSB7XG5cdHZhciByZXN1bHQ7XG5cdHZhciBfU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cblx0aWYgKHR5cGVvZiBfU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0aWYgKF9TeW1ib2wub2JzZXJ2YWJsZSkge1xuXHRcdFx0cmVzdWx0ID0gX1N5bWJvbC5vYnNlcnZhYmxlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXN1bHQgPSBfU3ltYm9sKCdvYnNlcnZhYmxlJyk7XG5cdFx0XHRfU3ltYm9sLm9ic2VydmFibGUgPSByZXN1bHQ7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHJlc3VsdCA9ICdAQG9ic2VydmFibGUnO1xuXHR9XG5cblx0cmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3N5bWJvbC1vYnNlcnZhYmxlL2xpYi9wb255ZmlsbC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGNvbWJpbmVSZWR1Y2VycztcblxudmFyIF9jcmVhdGVTdG9yZSA9IHJlcXVpcmUoJy4vY3JlYXRlU3RvcmUnKTtcblxudmFyIF9pc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnbG9kYXNoL2lzUGxhaW5PYmplY3QnKTtcblxudmFyIF9pc1BsYWluT2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzUGxhaW5PYmplY3QpO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCcuL3V0aWxzL3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGdldFVuZGVmaW5lZFN0YXRlRXJyb3JNZXNzYWdlKGtleSwgYWN0aW9uKSB7XG4gIHZhciBhY3Rpb25UeXBlID0gYWN0aW9uICYmIGFjdGlvbi50eXBlO1xuICB2YXIgYWN0aW9uTmFtZSA9IGFjdGlvblR5cGUgJiYgJ1wiJyArIGFjdGlvblR5cGUudG9TdHJpbmcoKSArICdcIicgfHwgJ2FuIGFjdGlvbic7XG5cbiAgcmV0dXJuICdHaXZlbiBhY3Rpb24gJyArIGFjdGlvbk5hbWUgKyAnLCByZWR1Y2VyIFwiJyArIGtleSArICdcIiByZXR1cm5lZCB1bmRlZmluZWQuICcgKyAnVG8gaWdub3JlIGFuIGFjdGlvbiwgeW91IG11c3QgZXhwbGljaXRseSByZXR1cm4gdGhlIHByZXZpb3VzIHN0YXRlLic7XG59XG5cbmZ1bmN0aW9uIGdldFVuZXhwZWN0ZWRTdGF0ZVNoYXBlV2FybmluZ01lc3NhZ2UoaW5wdXRTdGF0ZSwgcmVkdWNlcnMsIGFjdGlvbiwgdW5leHBlY3RlZEtleUNhY2hlKSB7XG4gIHZhciByZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKTtcbiAgdmFyIGFyZ3VtZW50TmFtZSA9IGFjdGlvbiAmJiBhY3Rpb24udHlwZSA9PT0gX2NyZWF0ZVN0b3JlLkFjdGlvblR5cGVzLklOSVQgPyAncHJlbG9hZGVkU3RhdGUgYXJndW1lbnQgcGFzc2VkIHRvIGNyZWF0ZVN0b3JlJyA6ICdwcmV2aW91cyBzdGF0ZSByZWNlaXZlZCBieSB0aGUgcmVkdWNlcic7XG5cbiAgaWYgKHJlZHVjZXJLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnU3RvcmUgZG9lcyBub3QgaGF2ZSBhIHZhbGlkIHJlZHVjZXIuIE1ha2Ugc3VyZSB0aGUgYXJndW1lbnQgcGFzc2VkICcgKyAndG8gY29tYmluZVJlZHVjZXJzIGlzIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIHJlZHVjZXJzLic7XG4gIH1cblxuICBpZiAoISgwLCBfaXNQbGFpbk9iamVjdDJbJ2RlZmF1bHQnXSkoaW5wdXRTdGF0ZSkpIHtcbiAgICByZXR1cm4gJ1RoZSAnICsgYXJndW1lbnROYW1lICsgJyBoYXMgdW5leHBlY3RlZCB0eXBlIG9mIFwiJyArIHt9LnRvU3RyaW5nLmNhbGwoaW5wdXRTdGF0ZSkubWF0Y2goL1xccyhbYS16fEEtWl0rKS8pWzFdICsgJ1wiLiBFeHBlY3RlZCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nICcgKyAoJ2tleXM6IFwiJyArIHJlZHVjZXJLZXlzLmpvaW4oJ1wiLCBcIicpICsgJ1wiJyk7XG4gIH1cblxuICB2YXIgdW5leHBlY3RlZEtleXMgPSBPYmplY3Qua2V5cyhpbnB1dFN0YXRlKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAhcmVkdWNlcnMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhdW5leHBlY3RlZEtleUNhY2hlW2tleV07XG4gIH0pO1xuXG4gIHVuZXhwZWN0ZWRLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHVuZXhwZWN0ZWRLZXlDYWNoZVtrZXldID0gdHJ1ZTtcbiAgfSk7XG5cbiAgaWYgKHVuZXhwZWN0ZWRLZXlzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gJ1VuZXhwZWN0ZWQgJyArICh1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAxID8gJ2tleXMnIDogJ2tleScpICsgJyAnICsgKCdcIicgKyB1bmV4cGVjdGVkS2V5cy5qb2luKCdcIiwgXCInKSArICdcIiBmb3VuZCBpbiAnICsgYXJndW1lbnROYW1lICsgJy4gJykgKyAnRXhwZWN0ZWQgdG8gZmluZCBvbmUgb2YgdGhlIGtub3duIHJlZHVjZXIga2V5cyBpbnN0ZWFkOiAnICsgKCdcIicgKyByZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKSArICdcIi4gVW5leHBlY3RlZCBrZXlzIHdpbGwgYmUgaWdub3JlZC4nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRSZWR1Y2VyU2FuaXR5KHJlZHVjZXJzKSB7XG4gIE9iamVjdC5rZXlzKHJlZHVjZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgcmVkdWNlciA9IHJlZHVjZXJzW2tleV07XG4gICAgdmFyIGluaXRpYWxTdGF0ZSA9IHJlZHVjZXIodW5kZWZpbmVkLCB7IHR5cGU6IF9jcmVhdGVTdG9yZS5BY3Rpb25UeXBlcy5JTklUIH0pO1xuXG4gICAgaWYgKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZXIgXCInICsga2V5ICsgJ1wiIHJldHVybmVkIHVuZGVmaW5lZCBkdXJpbmcgaW5pdGlhbGl6YXRpb24uICcgKyAnSWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGUgcmVkdWNlciBpcyB1bmRlZmluZWQsIHlvdSBtdXN0ICcgKyAnZXhwbGljaXRseSByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSAnICsgJ25vdCBiZSB1bmRlZmluZWQuJyk7XG4gICAgfVxuXG4gICAgdmFyIHR5cGUgPSAnQEByZWR1eC9QUk9CRV9VTktOT1dOX0FDVElPTl8nICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDcpLnNwbGl0KCcnKS5qb2luKCcuJyk7XG4gICAgaWYgKHR5cGVvZiByZWR1Y2VyKHVuZGVmaW5lZCwgeyB0eXBlOiB0eXBlIH0pID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2VyIFwiJyArIGtleSArICdcIiByZXR1cm5lZCB1bmRlZmluZWQgd2hlbiBwcm9iZWQgd2l0aCBhIHJhbmRvbSB0eXBlLiAnICsgKCdEb25cXCd0IHRyeSB0byBoYW5kbGUgJyArIF9jcmVhdGVTdG9yZS5BY3Rpb25UeXBlcy5JTklUICsgJyBvciBvdGhlciBhY3Rpb25zIGluIFwicmVkdXgvKlwiICcpICsgJ25hbWVzcGFjZS4gVGhleSBhcmUgY29uc2lkZXJlZCBwcml2YXRlLiBJbnN0ZWFkLCB5b3UgbXVzdCByZXR1cm4gdGhlICcgKyAnY3VycmVudCBzdGF0ZSBmb3IgYW55IHVua25vd24gYWN0aW9ucywgdW5sZXNzIGl0IGlzIHVuZGVmaW5lZCwgJyArICdpbiB3aGljaCBjYXNlIHlvdSBtdXN0IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZSwgcmVnYXJkbGVzcyBvZiB0aGUgJyArICdhY3Rpb24gdHlwZS4gVGhlIGluaXRpYWwgc3RhdGUgbWF5IG5vdCBiZSB1bmRlZmluZWQuJyk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBUdXJucyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBkaWZmZXJlbnQgcmVkdWNlciBmdW5jdGlvbnMsIGludG8gYSBzaW5nbGVcbiAqIHJlZHVjZXIgZnVuY3Rpb24uIEl0IHdpbGwgY2FsbCBldmVyeSBjaGlsZCByZWR1Y2VyLCBhbmQgZ2F0aGVyIHRoZWlyIHJlc3VsdHNcbiAqIGludG8gYSBzaW5nbGUgc3RhdGUgb2JqZWN0LCB3aG9zZSBrZXlzIGNvcnJlc3BvbmQgdG8gdGhlIGtleXMgb2YgdGhlIHBhc3NlZFxuICogcmVkdWNlciBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHJlZHVjZXJzIEFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgY29ycmVzcG9uZCB0byBkaWZmZXJlbnRcbiAqIHJlZHVjZXIgZnVuY3Rpb25zIHRoYXQgbmVlZCB0byBiZSBjb21iaW5lZCBpbnRvIG9uZS4gT25lIGhhbmR5IHdheSB0byBvYnRhaW5cbiAqIGl0IGlzIHRvIHVzZSBFUzYgYGltcG9ydCAqIGFzIHJlZHVjZXJzYCBzeW50YXguIFRoZSByZWR1Y2VycyBtYXkgbmV2ZXIgcmV0dXJuXG4gKiB1bmRlZmluZWQgZm9yIGFueSBhY3Rpb24uIEluc3RlYWQsIHRoZXkgc2hvdWxkIHJldHVybiB0aGVpciBpbml0aWFsIHN0YXRlXG4gKiBpZiB0aGUgc3RhdGUgcGFzc2VkIHRvIHRoZW0gd2FzIHVuZGVmaW5lZCwgYW5kIHRoZSBjdXJyZW50IHN0YXRlIGZvciBhbnlcbiAqIHVucmVjb2duaXplZCBhY3Rpb24uXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIHJlZHVjZXIgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGV2ZXJ5IHJlZHVjZXIgaW5zaWRlIHRoZVxuICogcGFzc2VkIG9iamVjdCwgYW5kIGJ1aWxkcyBhIHN0YXRlIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNoYXBlLlxuICovXG5mdW5jdGlvbiBjb21iaW5lUmVkdWNlcnMocmVkdWNlcnMpIHtcbiAgdmFyIHJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICB2YXIgZmluYWxSZWR1Y2VycyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZHVjZXJLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IHJlZHVjZXJLZXlzW2ldO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVkdWNlcnNba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgKDAsIF93YXJuaW5nMlsnZGVmYXVsdCddKSgnTm8gcmVkdWNlciBwcm92aWRlZCBmb3Iga2V5IFwiJyArIGtleSArICdcIicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcmVkdWNlcnNba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZmluYWxSZWR1Y2Vyc1trZXldID0gcmVkdWNlcnNba2V5XTtcbiAgICB9XG4gIH1cbiAgdmFyIGZpbmFsUmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhmaW5hbFJlZHVjZXJzKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciB1bmV4cGVjdGVkS2V5Q2FjaGUgPSB7fTtcbiAgfVxuXG4gIHZhciBzYW5pdHlFcnJvcjtcbiAgdHJ5IHtcbiAgICBhc3NlcnRSZWR1Y2VyU2FuaXR5KGZpbmFsUmVkdWNlcnMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgc2FuaXR5RXJyb3IgPSBlO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbWJpbmF0aW9uKCkge1xuICAgIHZhciBzdGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuICAgIHZhciBhY3Rpb24gPSBhcmd1bWVudHNbMV07XG5cbiAgICBpZiAoc2FuaXR5RXJyb3IpIHtcbiAgICAgIHRocm93IHNhbml0eUVycm9yO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgd2FybmluZ01lc3NhZ2UgPSBnZXRVbmV4cGVjdGVkU3RhdGVTaGFwZVdhcm5pbmdNZXNzYWdlKHN0YXRlLCBmaW5hbFJlZHVjZXJzLCBhY3Rpb24sIHVuZXhwZWN0ZWRLZXlDYWNoZSk7XG4gICAgICBpZiAod2FybmluZ01lc3NhZ2UpIHtcbiAgICAgICAgKDAsIF93YXJuaW5nMlsnZGVmYXVsdCddKSh3YXJuaW5nTWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGhhc0NoYW5nZWQgPSBmYWxzZTtcbiAgICB2YXIgbmV4dFN0YXRlID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaW5hbFJlZHVjZXJLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gZmluYWxSZWR1Y2VyS2V5c1tpXTtcbiAgICAgIHZhciByZWR1Y2VyID0gZmluYWxSZWR1Y2Vyc1trZXldO1xuICAgICAgdmFyIHByZXZpb3VzU3RhdGVGb3JLZXkgPSBzdGF0ZVtrZXldO1xuICAgICAgdmFyIG5leHRTdGF0ZUZvcktleSA9IHJlZHVjZXIocHJldmlvdXNTdGF0ZUZvcktleSwgYWN0aW9uKTtcbiAgICAgIGlmICh0eXBlb2YgbmV4dFN0YXRlRm9yS2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gZ2V0VW5kZWZpbmVkU3RhdGVFcnJvck1lc3NhZ2Uoa2V5LCBhY3Rpb24pO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIG5leHRTdGF0ZVtrZXldID0gbmV4dFN0YXRlRm9yS2V5O1xuICAgICAgaGFzQ2hhbmdlZCA9IGhhc0NoYW5nZWQgfHwgbmV4dFN0YXRlRm9yS2V5ICE9PSBwcmV2aW91c1N0YXRlRm9yS2V5O1xuICAgIH1cbiAgICByZXR1cm4gaGFzQ2hhbmdlZCA/IG5leHRTdGF0ZSA6IHN0YXRlO1xuICB9O1xufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWR1eC9saWIvY29tYmluZVJlZHVjZXJzLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1snZGVmYXVsdCddID0gd2FybmluZztcbi8qKlxuICogUHJpbnRzIGEgd2FybmluZyBpbiB0aGUgY29uc29sZSBpZiBpdCBleGlzdHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIHdhcm5pbmcgbWVzc2FnZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IGlmIHlvdSBlbmFibGVcbiAgICAvLyBcImJyZWFrIG9uIGFsbCBleGNlcHRpb25zXCIgaW4geW91ciBjb25zb2xlLFxuICAgIC8vIGl0IHdvdWxkIHBhdXNlIHRoZSBleGVjdXRpb24gYXQgdGhpcyBsaW5lLlxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1lbXB0eSAqL1xuICB9IGNhdGNoIChlKSB7fVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWVtcHR5ICovXG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlZHV4L2xpYi91dGlscy93YXJuaW5nLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1snZGVmYXVsdCddID0gYmluZEFjdGlvbkNyZWF0b3JzO1xuZnVuY3Rpb24gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvciwgZGlzcGF0Y2gpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2goYWN0aW9uQ3JlYXRvci5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICB9O1xufVxuXG4vKipcbiAqIFR1cm5zIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGFjdGlvbiBjcmVhdG9ycywgaW50byBhbiBvYmplY3Qgd2l0aCB0aGVcbiAqIHNhbWUga2V5cywgYnV0IHdpdGggZXZlcnkgZnVuY3Rpb24gd3JhcHBlZCBpbnRvIGEgYGRpc3BhdGNoYCBjYWxsIHNvIHRoZXlcbiAqIG1heSBiZSBpbnZva2VkIGRpcmVjdGx5LiBUaGlzIGlzIGp1c3QgYSBjb252ZW5pZW5jZSBtZXRob2QsIGFzIHlvdSBjYW4gY2FsbFxuICogYHN0b3JlLmRpc3BhdGNoKE15QWN0aW9uQ3JlYXRvcnMuZG9Tb21ldGhpbmcoKSlgIHlvdXJzZWxmIGp1c3QgZmluZS5cbiAqXG4gKiBGb3IgY29udmVuaWVuY2UsIHlvdSBjYW4gYWxzbyBwYXNzIGEgc2luZ2xlIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudCxcbiAqIGFuZCBnZXQgYSBmdW5jdGlvbiBpbiByZXR1cm4uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IGFjdGlvbkNyZWF0b3JzIEFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGFjdGlvblxuICogY3JlYXRvciBmdW5jdGlvbnMuIE9uZSBoYW5keSB3YXkgdG8gb2J0YWluIGl0IGlzIHRvIHVzZSBFUzYgYGltcG9ydCAqIGFzYFxuICogc3ludGF4LiBZb3UgbWF5IGFsc28gcGFzcyBhIHNpbmdsZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkaXNwYXRjaCBUaGUgYGRpc3BhdGNoYCBmdW5jdGlvbiBhdmFpbGFibGUgb24geW91ciBSZWR1eFxuICogc3RvcmUuXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufE9iamVjdH0gVGhlIG9iamVjdCBtaW1pY2tpbmcgdGhlIG9yaWdpbmFsIG9iamVjdCwgYnV0IHdpdGhcbiAqIGV2ZXJ5IGFjdGlvbiBjcmVhdG9yIHdyYXBwZWQgaW50byB0aGUgYGRpc3BhdGNoYCBjYWxsLiBJZiB5b3UgcGFzc2VkIGFcbiAqIGZ1bmN0aW9uIGFzIGBhY3Rpb25DcmVhdG9yc2AsIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBhbHNvIGJlIGEgc2luZ2xlXG4gKiBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmluZEFjdGlvbkNyZWF0b3JzKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCkge1xuICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3JzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3JzICE9PSAnb2JqZWN0JyB8fCBhY3Rpb25DcmVhdG9ycyA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignYmluZEFjdGlvbkNyZWF0b3JzIGV4cGVjdGVkIGFuIG9iamVjdCBvciBhIGZ1bmN0aW9uLCBpbnN0ZWFkIHJlY2VpdmVkICcgKyAoYWN0aW9uQ3JlYXRvcnMgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgYWN0aW9uQ3JlYXRvcnMpICsgJy4gJyArICdEaWQgeW91IHdyaXRlIFwiaW1wb3J0IEFjdGlvbkNyZWF0b3JzIGZyb21cIiBpbnN0ZWFkIG9mIFwiaW1wb3J0ICogYXMgQWN0aW9uQ3JlYXRvcnMgZnJvbVwiPycpO1xuICB9XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhY3Rpb25DcmVhdG9ycyk7XG4gIHZhciBib3VuZEFjdGlvbkNyZWF0b3JzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIHZhciBhY3Rpb25DcmVhdG9yID0gYWN0aW9uQ3JlYXRvcnNba2V5XTtcbiAgICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGJvdW5kQWN0aW9uQ3JlYXRvcnNba2V5XSA9IGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3IsIGRpc3BhdGNoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJvdW5kQWN0aW9uQ3JlYXRvcnM7XG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlZHV4L2xpYi9iaW5kQWN0aW9uQ3JlYXRvcnMuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGFwcGx5TWlkZGxld2FyZTtcblxudmFyIF9jb21wb3NlID0gcmVxdWlyZSgnLi9jb21wb3NlJyk7XG5cbnZhciBfY29tcG9zZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wb3NlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzdG9yZSBlbmhhbmNlciB0aGF0IGFwcGxpZXMgbWlkZGxld2FyZSB0byB0aGUgZGlzcGF0Y2ggbWV0aG9kXG4gKiBvZiB0aGUgUmVkdXggc3RvcmUuIFRoaXMgaXMgaGFuZHkgZm9yIGEgdmFyaWV0eSBvZiB0YXNrcywgc3VjaCBhcyBleHByZXNzaW5nXG4gKiBhc3luY2hyb25vdXMgYWN0aW9ucyBpbiBhIGNvbmNpc2UgbWFubmVyLCBvciBsb2dnaW5nIGV2ZXJ5IGFjdGlvbiBwYXlsb2FkLlxuICpcbiAqIFNlZSBgcmVkdXgtdGh1bmtgIHBhY2thZ2UgYXMgYW4gZXhhbXBsZSBvZiB0aGUgUmVkdXggbWlkZGxld2FyZS5cbiAqXG4gKiBCZWNhdXNlIG1pZGRsZXdhcmUgaXMgcG90ZW50aWFsbHkgYXN5bmNocm9ub3VzLCB0aGlzIHNob3VsZCBiZSB0aGUgZmlyc3RcbiAqIHN0b3JlIGVuaGFuY2VyIGluIHRoZSBjb21wb3NpdGlvbiBjaGFpbi5cbiAqXG4gKiBOb3RlIHRoYXQgZWFjaCBtaWRkbGV3YXJlIHdpbGwgYmUgZ2l2ZW4gdGhlIGBkaXNwYXRjaGAgYW5kIGBnZXRTdGF0ZWAgZnVuY3Rpb25zXG4gKiBhcyBuYW1lZCBhcmd1bWVudHMuXG4gKlxuICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gbWlkZGxld2FyZXMgVGhlIG1pZGRsZXdhcmUgY2hhaW4gdG8gYmUgYXBwbGllZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBzdG9yZSBlbmhhbmNlciBhcHBseWluZyB0aGUgbWlkZGxld2FyZS5cbiAqL1xuZnVuY3Rpb24gYXBwbHlNaWRkbGV3YXJlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbWlkZGxld2FyZXMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBtaWRkbGV3YXJlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoY3JlYXRlU3RvcmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBlbmhhbmNlcikge1xuICAgICAgdmFyIHN0b3JlID0gY3JlYXRlU3RvcmUocmVkdWNlciwgcHJlbG9hZGVkU3RhdGUsIGVuaGFuY2VyKTtcbiAgICAgIHZhciBfZGlzcGF0Y2ggPSBzdG9yZS5kaXNwYXRjaDtcbiAgICAgIHZhciBjaGFpbiA9IFtdO1xuXG4gICAgICB2YXIgbWlkZGxld2FyZUFQSSA9IHtcbiAgICAgICAgZ2V0U3RhdGU6IHN0b3JlLmdldFN0YXRlLFxuICAgICAgICBkaXNwYXRjaDogZnVuY3Rpb24gZGlzcGF0Y2goYWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIF9kaXNwYXRjaChhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY2hhaW4gPSBtaWRkbGV3YXJlcy5tYXAoZnVuY3Rpb24gKG1pZGRsZXdhcmUpIHtcbiAgICAgICAgcmV0dXJuIG1pZGRsZXdhcmUobWlkZGxld2FyZUFQSSk7XG4gICAgICB9KTtcbiAgICAgIF9kaXNwYXRjaCA9IF9jb21wb3NlMlsnZGVmYXVsdCddLmFwcGx5KHVuZGVmaW5lZCwgY2hhaW4pKHN0b3JlLmRpc3BhdGNoKTtcblxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdG9yZSwge1xuICAgICAgICBkaXNwYXRjaDogX2Rpc3BhdGNoXG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWR1eC9saWIvYXBwbHlNaWRkbGV3YXJlLmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGNvbXBvc2U7XG4vKipcbiAqIENvbXBvc2VzIHNpbmdsZS1hcmd1bWVudCBmdW5jdGlvbnMgZnJvbSByaWdodCB0byBsZWZ0LiBUaGUgcmlnaHRtb3N0XG4gKiBmdW5jdGlvbiBjYW4gdGFrZSBtdWx0aXBsZSBhcmd1bWVudHMgYXMgaXQgcHJvdmlkZXMgdGhlIHNpZ25hdHVyZSBmb3JcbiAqIHRoZSByZXN1bHRpbmcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IGZ1bmNzIFRoZSBmdW5jdGlvbnMgdG8gY29tcG9zZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiBvYnRhaW5lZCBieSBjb21wb3NpbmcgdGhlIGFyZ3VtZW50IGZ1bmN0aW9uc1xuICogZnJvbSByaWdodCB0byBsZWZ0LiBGb3IgZXhhbXBsZSwgY29tcG9zZShmLCBnLCBoKSBpcyBpZGVudGljYWwgdG8gZG9pbmdcbiAqICguLi5hcmdzKSA9PiBmKGcoaCguLi5hcmdzKSkpLlxuICovXG5cbmZ1bmN0aW9uIGNvbXBvc2UoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBmdW5jcyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGZ1bmNzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKGZ1bmNzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICByZXR1cm4gYXJnO1xuICAgIH07XG4gIH1cblxuICBpZiAoZnVuY3MubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGZ1bmNzWzBdO1xuICB9XG5cbiAgdmFyIGxhc3QgPSBmdW5jc1tmdW5jcy5sZW5ndGggLSAxXTtcbiAgdmFyIHJlc3QgPSBmdW5jcy5zbGljZSgwLCAtMSk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJlc3QucmVkdWNlUmlnaHQoZnVuY3Rpb24gKGNvbXBvc2VkLCBmKSB7XG4gICAgICByZXR1cm4gZihjb21wb3NlZCk7XG4gICAgfSwgbGFzdC5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICB9O1xufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWR1eC9saWIvY29tcG9zZS5qc1xuICoqLyIsInZhciByZWR1eCA9IHJlcXVpcmUoJ3JlZHV4Jyk7XG5cbmNvbnNvbGUubG9nKCdzdGFydGluZyByZWR1eCB0b2RvIGV4YW1wbGUnKTtcblxudmFyIHN0YXRlRGVmYXVsdCA9IHtcbiAgc2VhcmNoVGV4dDogJycsXG4gIHNob3dDb21wbGV0ZWQ6IGZhbHNlLFxuICB0b2RvczogW11cbn07XG52YXIgcmVkdWNlciA9IChzdGF0ZSA9c3RhdGVEZWZhdWx0ICwgYWN0aW9uKSA9PiB7XG5cbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgJ0NIQU5HRV9TRUFSQ0hfVEVYVCc6XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgc2VhcmNoVGV4dDogYWN0aW9uLnNlYXJjaFRleHRcbiAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9O1xufTtcblxudmFyIHN0b3JlID0gcmVkdXguY3JlYXRlU3RvcmUocmVkdWNlciwgcmVkdXguY29tcG9zZShcbiAgd2luZG93LmRldlRvb2xzRXh0ZW5zaW9uID8gd2luZG93LmRldlRvb2xzRXh0ZW5zaW9uKCkgOiBmID0+IGZcbikpO1xuXG5zdG9yZS5zdWJzY3JpYmUoKCkgPT4ge1xuICB2YXIgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYXBwJykuaW5uZXJIVE1MID0gc3RhdGUuc2VhcmNoVGV4dDtcbn0pO1xuXG52YXIgY3VycmVudFN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbmNvbnNvbGUubG9nKCdjdXJyZW50U3RhdGUnLCBjdXJyZW50U3RhdGUpO1xuXG5zdG9yZSAuZGlzcGF0Y2goe1xuICB0eXBlOidDSEFOR0VfU0VBUkNIX1RFWFQnLFxuICBzZWFyY2hUZXh0OidtaW5jZSdcbn0pO1xuXG5zdG9yZSAuZGlzcGF0Y2goe1xuICB0eXBlOidDSEFOR0VfU0VBUkNIX1RFWFQnLFxuICBzZWFyY2hUZXh0Oidwb3RhdG9lcydcbn0pO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvcmVkdXgtdG9kby1leGFtcGxlLmpzeFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=